window.storyFormat({"name":"Engleri","version":"0.1.2","description":"A Twine story format that uses Inkle's Ink language","proofing":false,"license":"MIT","setup":"","source":"<!DOCTYPE html><html><head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta charset=\"utf-8\">\n        <title>{{STORY_NAME}}</title>\n        <style>\n/* The MIT License (MIT) Copyright (c) 2019 Chris Klimas, 2022 Dan Cox, 2025 Vincent H. */\n\n/* Give ourselves some decent defaults. */\n\nbody {\n\tfont: 1.5em \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\tcolor: hsl(0, 0%, 13%);\n    text-align: center;\n}\n\ndiv#ink_block {\n\theight: 70vh;\n\toverflow-y: scroll;\n}\n\ntw-icon {\n\tfont-size: 2em;\n\tcursor: pointer;\n}\n\ntw-story {\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tmin-height: 100%;\n\tfont-size: 1.5em;\n\tline-height: 1.5em;\n\tdisplay: flex;\n\tflex-direction: row;\n\tmargin-top: 1em;\n}\n\ntw-passage {\n\twidth: 90%;\n\tdisplay: block;\n}\n\ntw-link, a {\n\tcolor: #00a;\n\ttext-decoration-color: #00a;\n\tcursor: pointer;\n\ttext-decoration: underline;\n}\n\ntw-link:hover, tw-icon:hover, a:hover {\n\tcolor: #44f;\n\ttext-decoration-color: #44f;\n\ttext-decoration: underline;\n}\n\ntw-storydata {\n\tdisplay: none;\n}\n        </style>\n    </head>\n    <body>\n        {{STORY_DATA}}\n\t\t<tw-story>\n\t\t\t<tw-passage class=\"passage\"></tw-passage>\n\t\t</tw-story>\n        <script>\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('path'), require('fs')) :\n  typeof define === 'function' && define.amd ? define(['path', 'fs'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.require$$0, global.require$$1));\n})(this, (function (require$$0, require$$1) { 'use strict';\n\n  var passage;\n  var hasRequiredPassage;\n\n  function requirePassage () {\n  \tif (hasRequiredPassage) return passage;\n  \thasRequiredPassage = 1;\n\n\n  \tclass ParsedPassage {\n  \t\t// includes:\tstring[]\n  \t\t// contents:\t\tParsedObject[]\n  \t\tconstructor(includes, contents) {\n  \t\t\tincludes ??= [];\n  \t\t\tcontents ??= [];\n\n  \t\t\tthis.includes = includes;\n  \t\t\tthis.contents = contents;\n  \t\t\tthis.typeName = \"ParsedPassage\";\n  \t\t}\n  \t}\n\n  \tclass ParsedObject {\n  \t\t// typeName: \tstring\n  \t\t// values: \t\t(ParsedObject | string)[]\n  \t\t// reduce:\t\t(arg: (ParsedObject | string)[]) => string\n  \t\tconstructor(typeName, values, reduce) {\n  \t\t\ttypeName ??= \"\";\n  \t\t\tvalues ??= [];\n  \t\t\treduce ??= function(parsedObjects) {\n\n  \t\t\t\tlet values = parsedObjects.map(function(object) {\n  \t\t\t\t\t\treturn (typeof object === \"string\") ? object : object.render();\n  \t\t\t\t\t});\n\n  \t\t\t\treturn values.join(\"\");\n  \t\t\t};\n\n  \t\t\tthis.typeName = typeName;\n  \t\t\tthis.values = values;\n  \t\t\tthis.reduce = reduce;\n  \t\t}\n\n  \t\trender() {\n  \t\t\treturn this.reduce(this.values);\n  \t\t}\n  \t}\n\n  \tclass Link extends ParsedObject {\n  \t\tconstructor(values) {\n  \t    \tsuper(\n  \t\t\t\t\"link\", \n  \t\t\t\tvalues, \n  \t\t\t\tfunction (textValues) {\n  \t\t\t\t\t// we know these values are text objects.\n  \t\t\t\t\tlet renderedTextValues = textValues.map((value) => value.render());\n  \t\t\t\t\tlet label = renderedTextValues[0];\n  \t\t\t\t\tlet dest = renderedTextValues[1];\n\n  \t\t\t\t\treturn `<tw-link data-passage=\"${dest.trim()}\">${label.trim()}</tw-link>`;\n  \t\t\t\t});\n  \t    }\n  \t}\n\n\n  \tclass peg$SyntaxError extends SyntaxError {\n  \t  constructor(message, expected, found, location) {\n  \t    super(message);\n  \t    this.expected = expected;\n  \t    this.found = found;\n  \t    this.location = location;\n  \t    this.name = \"SyntaxError\";\n  \t  }\n\n  \t  format(sources) {\n  \t    let str = \"Error: \" + this.message;\n  \t    if (this.location) {\n  \t      let src = null;\n  \t      const st = sources.find(s => s.source === this.location.source);\n  \t      if (st) {\n  \t        src = st.text.split(/\\r\\n|\\n|\\r/g);\n  \t      }\n  \t      const s = this.location.start;\n  \t      const offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n  \t        ? this.location.source.offset(s)\n  \t        : s;\n  \t      const loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n  \t      if (src) {\n  \t        const e = this.location.end;\n  \t        const filler = \"\".padEnd(offset_s.line.toString().length, \" \");\n  \t        const line = src[s.line - 1];\n  \t        const last = s.line === e.line ? e.column : line.length + 1;\n  \t        const hatLen = (last - s.column) || 1;\n  \t        str += \"\\n --> \" + loc + \"\\n\"\n  \t            + filler + \" |\\n\"\n  \t            + offset_s.line + \" | \" + line + \"\\n\"\n  \t            + filler + \" | \" + \"\".padEnd(s.column - 1, \" \")\n  \t            + \"\".padEnd(hatLen, \"^\");\n  \t      } else {\n  \t        str += \"\\n at \" + loc;\n  \t      }\n  \t    }\n  \t    return str;\n  \t  }\n\n  \t  static buildMessage(expected, found) {\n  \t    function hex(ch) {\n  \t      return ch.codePointAt(0).toString(16).toUpperCase();\n  \t    }\n\n  \t    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \"unicode\")\n  \t      ? new RegExp(\"[\\\\p{C}\\\\p{Mn}\\\\p{Mc}]\", \"gu\")\n  \t      : null;\n  \t    function unicodeEscape(s) {\n  \t      if (nonPrintable) {\n  \t        return s.replace(nonPrintable,  ch => \"\\\\u{\" + hex(ch) + \"}\");\n  \t      }\n  \t      return s;\n  \t    }\n\n  \t    function literalEscape(s) {\n  \t      return unicodeEscape(s\n  \t        .replace(/\\\\/g, \"\\\\\\\\\")\n  \t        .replace(/\"/g,  \"\\\\\\\"\")\n  \t        .replace(/\\0/g, \"\\\\0\")\n  \t        .replace(/\\t/g, \"\\\\t\")\n  \t        .replace(/\\n/g, \"\\\\n\")\n  \t        .replace(/\\r/g, \"\\\\r\")\n  \t        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n  \t        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n  \t    }\n\n  \t    function classEscape(s) {\n  \t      return unicodeEscape(s\n  \t        .replace(/\\\\/g, \"\\\\\\\\\")\n  \t        .replace(/\\]/g, \"\\\\]\")\n  \t        .replace(/\\^/g, \"\\\\^\")\n  \t        .replace(/-/g,  \"\\\\-\")\n  \t        .replace(/\\0/g, \"\\\\0\")\n  \t        .replace(/\\t/g, \"\\\\t\")\n  \t        .replace(/\\n/g, \"\\\\n\")\n  \t        .replace(/\\r/g, \"\\\\r\")\n  \t        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n  \t        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n  \t    }\n\n  \t    const DESCRIBE_EXPECTATION_FNS = {\n  \t      literal(expectation) {\n  \t        return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n  \t      },\n\n  \t      class(expectation) {\n  \t        const escapedParts = expectation.parts.map(\n  \t          part => (Array.isArray(part)\n  \t            ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n  \t            : classEscape(part))\n  \t        );\n\n  \t        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\" + (expectation.unicode ? \"u\" : \"\");\n  \t      },\n\n  \t      any() {\n  \t        return \"any character\";\n  \t      },\n\n  \t      end() {\n  \t        return \"end of input\";\n  \t      },\n\n  \t      other(expectation) {\n  \t        return expectation.description;\n  \t      },\n  \t    };\n\n  \t    function describeExpectation(expectation) {\n  \t      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  \t    }\n\n  \t    function describeExpected(expected) {\n  \t      const descriptions = expected.map(describeExpectation);\n  \t      descriptions.sort();\n\n  \t      if (descriptions.length > 0) {\n  \t        let j = 1;\n  \t        for (let i = 1; i < descriptions.length; i++) {\n  \t          if (descriptions[i - 1] !== descriptions[i]) {\n  \t            descriptions[j] = descriptions[i];\n  \t            j++;\n  \t          }\n  \t        }\n  \t        descriptions.length = j;\n  \t      }\n\n  \t      switch (descriptions.length) {\n  \t        case 1:\n  \t          return descriptions[0];\n\n  \t        case 2:\n  \t          return descriptions[0] + \" or \" + descriptions[1];\n\n  \t        default:\n  \t          return descriptions.slice(0, -1).join(\", \")\n  \t            + \", or \"\n  \t            + descriptions[descriptions.length - 1];\n  \t      }\n  \t    }\n\n  \t    function describeFound(found) {\n  \t      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  \t    }\n\n  \t    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  \t  }\n  \t}\n\n  \tfunction peg$parse(input, options) {\n  \t  options = options !== undefined ? options : {};\n\n  \t  const peg$FAILED = {};\n  \t  const peg$source = options.grammarSource;\n\n  \t  const peg$startRuleFunctions = {\n  \t    Expression: peg$parseExpression,\n  \t  };\n  \t  let peg$startRuleFunction = peg$parseExpression;\n\n  \t  const peg$c0 = \"<==text==>\";\n  \t  const peg$c1 = \"<==text>\";\n  \t  const peg$c2 = \"<==t==>\";\n  \t  const peg$c3 = \"<==t>\";\n  \t  const peg$c4 = \"<==>\";\n  \t  const peg$c5 = \"<[[\";\n  \t  const peg$c6 = \"|\";\n  \t  const peg$c7 = \"]]>\";\n  \t  const peg$c8 = \"[[\";\n  \t  const peg$c9 = \"]]\";\n  \t  const peg$c10 = \"->\";\n  \t  const peg$c11 = \"<-\";\n  \t  const peg$c12 = \"\\\\\";\n\n  \t  const peg$r0 = /^[<>]/;\n  \t  const peg$r1 = /^[^\\n\\r]/;\n  \t  const peg$r2 = /^[<>|[\\]{}\\r\\n_\\\\]/;\n  \t  const peg$r3 = /^[\\r]/;\n  \t  const peg$r4 = /^[\\n]/;\n  \t  const peg$r5 = /^[ \\t]/;\n\n  \t  const peg$e0 = peg$anyExpectation();\n  \t  const peg$e1 = peg$literalExpectation(\"<==text==>\", false);\n  \t  const peg$e2 = peg$literalExpectation(\"<==text>\", false);\n  \t  const peg$e3 = peg$literalExpectation(\"<==t==>\", false);\n  \t  const peg$e4 = peg$literalExpectation(\"<==t>\", false);\n  \t  const peg$e5 = peg$literalExpectation(\"<==>\", false);\n  \t  const peg$e6 = peg$literalExpectation(\"<[[\", false);\n  \t  const peg$e7 = peg$literalExpectation(\"|\", false);\n  \t  const peg$e8 = peg$literalExpectation(\"]]>\", false);\n  \t  const peg$e9 = peg$literalExpectation(\"[[\", false);\n  \t  const peg$e10 = peg$literalExpectation(\"]]\", false);\n  \t  const peg$e11 = peg$otherExpectation(\"->\");\n  \t  const peg$e12 = peg$literalExpectation(\"->\", false);\n  \t  const peg$e13 = peg$otherExpectation(\"<-\");\n  \t  const peg$e14 = peg$literalExpectation(\"<-\", false);\n  \t  const peg$e15 = peg$literalExpectation(\"\\\\\", false);\n  \t  const peg$e16 = peg$classExpectation([\"<\", \">\"], false, false, false);\n  \t  const peg$e17 = peg$classExpectation([\"\\n\", \"\\r\"], true, false, false);\n  \t  const peg$e18 = peg$classExpectation([\"<\", \">\", \"|\", \"[\", \"]\", \"{\", \"}\", \"\\r\", \"\\n\", \"_\", \"\\\\\"], false, false, false);\n  \t  const peg$e19 = peg$otherExpectation(\"endOfLine\");\n  \t  const peg$e20 = peg$otherExpectation(\"newLine\");\n  \t  const peg$e21 = peg$classExpectation([\"\\r\"], false, false, false);\n  \t  const peg$e22 = peg$classExpectation([\"\\n\"], false, false, false);\n  \t  const peg$e23 = peg$otherExpectation(\"endOfFile\");\n  \t  const peg$e24 = peg$classExpectation([\" \", \"\\t\"], false, false, false);\n\n  \t  function peg$f0(chunks) {\n\n  \t    let inkTextCount = 0;\n  \t    chunks.forEach((chunk) => {\n  \t    \tif (chunk.typeName === \"InkText\") {\n  \t    \t\tinkTextCount += 1;\n  \t    \t}\n  \t    });\n\n  \t    if (inkTextCount > 1) {\n  \t    \tthrow new Error(\"There shouldn't be more than one InkText block in a passage!\");\n  \t    }\n\n  \t    return new ParsedPassage([], chunks);\n  \t  }\n  \t  function peg$f1(char) {    return char;  }\n  \t  function peg$f2(inkTextChars) {\n  \t    const toHtml = () => \"<div id='ink_block'></div>\\n\";\n  \t    return new ParsedObject(\"InkText\", inkTextChars, toHtml);\n  \t  }\n  \t  function peg$f3(contents, nls) {    \n  \t\t\tconst toHtml = function (values) {\n  \t\t\t\tlet contents = values[0];\n  \t\t\t\tlet newlines = values[1];\n\n  \t\t\t\tlet pText =  `<p>${contents.map((o)=>o.render()).join(\"\")}</p>`;\n  \t\t\t\tlet brText = `${newlines.map((o)=>o.render()).join(\"\")}`;\n\n  \t\t\t\treturn `${pText}\\n${brText}`\n  \t\t\t};\n\n  \t\t\treturn new ParsedObject(\"mixedLine\", [contents, [nls]], toHtml)\n  \t  }\n  \t  function peg$f4(label, dest) {    return dest;  }\n  \t  function peg$f5(label, destination) {\n  \t    let dest = destination ? destination : label;\n\n  \t    return new Link([label, dest]);\n  \t  }\n  \t  function peg$f6(value) {    return new Link(value);  }\n  \t  function peg$f7(labelAndDest) {    return [labelAndDest, labelAndDest];  }\n  \t  function peg$f8(label, destination) {    return [label, destination];  }\n  \t  function peg$f9(destination, label) {    return [label, destination];  }\n  \t  function peg$f10(chars) {    \n  \t\t\treturn new ParsedObject(\"text\", chars, (values) => values.join(\"\").trimStart()); \n  \t  }\n  \t  function peg$f11(char) {    return char;  }\n  \t  function peg$f12(char) {    return char;  }\n  \t  function peg$f13(lines) {    \n  \t\t\tconst toHtml = (values) => {\n  \t\t\t\tlet count = values.length - 2;\n\n  \t\t\t\tif (count > 0) {\n  \t\t\t\t\treturn \"<br> \\n\".repeat(count);\n  \t\t\t\t} else {\n  \t\t\t\t\treturn \"\";\n  \t\t\t\t}\n\n  \t\t\t};\n  \t\t\treturn new ParsedObject(\"newlines\", lines, toHtml); \n  \t  }\n  \t  let peg$currPos = options.peg$currPos | 0;\n  \t  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  \t  let peg$maxFailPos = peg$currPos;\n  \t  let peg$maxFailExpected = options.peg$maxFailExpected || [];\n  \t  let peg$silentFails = options.peg$silentFails | 0;\n\n  \t  let peg$result;\n\n  \t  if (options.startRule) {\n  \t    if (!(options.startRule in peg$startRuleFunctions)) {\n  \t      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n  \t    }\n\n  \t    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  \t  }\n\n  \t  function peg$getUnicode(pos = peg$currPos) {\n  \t    const cp = input.codePointAt(pos);\n  \t    if (cp === undefined) {\n  \t      return \"\";\n  \t    }\n  \t    return String.fromCodePoint(cp);\n  \t  }\n\n  \t  function peg$literalExpectation(text, ignoreCase) {\n  \t    return { type: \"literal\", text, ignoreCase };\n  \t  }\n\n  \t  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\n  \t    return { type: \"class\", parts, inverted, ignoreCase, unicode };\n  \t  }\n\n  \t  function peg$anyExpectation() {\n  \t    return { type: \"any\" };\n  \t  }\n\n  \t  function peg$endExpectation() {\n  \t    return { type: \"end\" };\n  \t  }\n\n  \t  function peg$otherExpectation(description) {\n  \t    return { type: \"other\", description };\n  \t  }\n\n  \t  function peg$computePosDetails(pos) {\n  \t    let details = peg$posDetailsCache[pos];\n  \t    let p;\n\n  \t    if (details) {\n  \t      return details;\n  \t    } else {\n  \t      if (pos >= peg$posDetailsCache.length) {\n  \t        p = peg$posDetailsCache.length - 1;\n  \t      } else {\n  \t        p = pos;\n  \t        while (!peg$posDetailsCache[--p]) {}\n  \t      }\n\n  \t      details = peg$posDetailsCache[p];\n  \t      details = {\n  \t        line: details.line,\n  \t        column: details.column,\n  \t      };\n\n  \t      while (p < pos) {\n  \t        if (input.charCodeAt(p) === 10) {\n  \t          details.line++;\n  \t          details.column = 1;\n  \t        } else {\n  \t          details.column++;\n  \t        }\n\n  \t        p++;\n  \t      }\n\n  \t      peg$posDetailsCache[pos] = details;\n\n  \t      return details;\n  \t    }\n  \t  }\n\n  \t  function peg$computeLocation(startPos, endPos, offset) {\n  \t    const startPosDetails = peg$computePosDetails(startPos);\n  \t    const endPosDetails = peg$computePosDetails(endPos);\n\n  \t    const res = {\n  \t      source: peg$source,\n  \t      start: {\n  \t        offset: startPos,\n  \t        line: startPosDetails.line,\n  \t        column: startPosDetails.column,\n  \t      },\n  \t      end: {\n  \t        offset: endPos,\n  \t        line: endPosDetails.line,\n  \t        column: endPosDetails.column,\n  \t      },\n  \t    };\n  \t    return res;\n  \t  }\n\n  \t  function peg$fail(expected) {\n  \t    if (peg$currPos < peg$maxFailPos) { return; }\n\n  \t    if (peg$currPos > peg$maxFailPos) {\n  \t      peg$maxFailPos = peg$currPos;\n  \t      peg$maxFailExpected = [];\n  \t    }\n\n  \t    peg$maxFailExpected.push(expected);\n  \t  }\n\n  \t  function peg$buildStructuredError(expected, found, location) {\n  \t    return new peg$SyntaxError(\n  \t      peg$SyntaxError.buildMessage(expected, found),\n  \t      expected,\n  \t      found,\n  \t      location\n  \t    );\n  \t  }\n\n  \t  function peg$parseExpression() {\n  \t    let s0, s2, s3, s4;\n\n  \t    s0 = peg$currPos;\n  \t    peg$parse_nls();\n  \t    s2 = [];\n  \t    s3 = peg$parseInkText();\n  \t    if (s3 === peg$FAILED) {\n  \t      s3 = peg$parsemixedLine();\n  \t    }\n  \t    while (s3 !== peg$FAILED) {\n  \t      s2.push(s3);\n  \t      s3 = peg$parseInkText();\n  \t      if (s3 === peg$FAILED) {\n  \t        s3 = peg$parsemixedLine();\n  \t      }\n  \t    }\n  \t    s3 = peg$parse_nls();\n  \t    s4 = peg$parse_eol();\n  \t    if (s4 !== peg$FAILED) {\n  \t      s0 = peg$f0(s2);\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parseInkText() {\n  \t    let s0, s1, s2, s3, s4, s5;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parse_inkTextStart();\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = [];\n  \t      s3 = peg$currPos;\n  \t      s4 = peg$currPos;\n  \t      peg$silentFails++;\n  \t      s5 = peg$parse_inkTextEnd();\n  \t      peg$silentFails--;\n  \t      if (s5 === peg$FAILED) {\n  \t        s4 = undefined;\n  \t      } else {\n  \t        peg$currPos = s4;\n  \t        s4 = peg$FAILED;\n  \t      }\n  \t      if (s4 !== peg$FAILED) {\n  \t        if (input.length > peg$currPos) {\n  \t          s5 = input.charAt(peg$currPos);\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s5 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n  \t        }\n  \t        if (s5 !== peg$FAILED) {\n  \t          s3 = peg$f1(s5);\n  \t        } else {\n  \t          peg$currPos = s3;\n  \t          s3 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s3;\n  \t        s3 = peg$FAILED;\n  \t      }\n  \t      while (s3 !== peg$FAILED) {\n  \t        s2.push(s3);\n  \t        s3 = peg$currPos;\n  \t        s4 = peg$currPos;\n  \t        peg$silentFails++;\n  \t        s5 = peg$parse_inkTextEnd();\n  \t        peg$silentFails--;\n  \t        if (s5 === peg$FAILED) {\n  \t          s4 = undefined;\n  \t        } else {\n  \t          peg$currPos = s4;\n  \t          s4 = peg$FAILED;\n  \t        }\n  \t        if (s4 !== peg$FAILED) {\n  \t          if (input.length > peg$currPos) {\n  \t            s5 = input.charAt(peg$currPos);\n  \t            peg$currPos++;\n  \t          } else {\n  \t            s5 = peg$FAILED;\n  \t            if (peg$silentFails === 0) { peg$fail(peg$e0); }\n  \t          }\n  \t          if (s5 !== peg$FAILED) {\n  \t            s3 = peg$f1(s5);\n  \t          } else {\n  \t            peg$currPos = s3;\n  \t            s3 = peg$FAILED;\n  \t          }\n  \t        } else {\n  \t          peg$currPos = s3;\n  \t          s3 = peg$FAILED;\n  \t        }\n  \t      }\n  \t      s3 = peg$parse_inkTextEnd();\n  \t      if (s3 !== peg$FAILED) {\n  \t        s4 = peg$parse_nls();\n  \t        s0 = peg$f2(s2);\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inkTextStart() {\n  \t    let s0;\n\n  \t    if (input.substr(peg$currPos, 10) === peg$c0) {\n  \t      s0 = peg$c0;\n  \t      peg$currPos += 10;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n  \t    }\n  \t    if (s0 === peg$FAILED) {\n  \t      if (input.substr(peg$currPos, 8) === peg$c1) {\n  \t        s0 = peg$c1;\n  \t        peg$currPos += 8;\n  \t      } else {\n  \t        s0 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n  \t      }\n  \t      if (s0 === peg$FAILED) {\n  \t        if (input.substr(peg$currPos, 7) === peg$c2) {\n  \t          s0 = peg$c2;\n  \t          peg$currPos += 7;\n  \t        } else {\n  \t          s0 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n  \t        }\n  \t        if (s0 === peg$FAILED) {\n  \t          if (input.substr(peg$currPos, 5) === peg$c3) {\n  \t            s0 = peg$c3;\n  \t            peg$currPos += 5;\n  \t          } else {\n  \t            s0 = peg$FAILED;\n  \t            if (peg$silentFails === 0) { peg$fail(peg$e4); }\n  \t          }\n  \t        }\n  \t      }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inkTextEnd() {\n  \t    let s0;\n\n  \t    if (input.substr(peg$currPos, 4) === peg$c4) {\n  \t      s0 = peg$c4;\n  \t      peg$currPos += 4;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parsemixedLine() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parsepureText();\n  \t    if (s2 === peg$FAILED) {\n  \t      s2 = peg$parselink();\n  \t    }\n  \t    if (s2 !== peg$FAILED) {\n  \t      while (s2 !== peg$FAILED) {\n  \t        s1.push(s2);\n  \t        s2 = peg$parsepureText();\n  \t        if (s2 === peg$FAILED) {\n  \t          s2 = peg$parselink();\n  \t        }\n  \t      }\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_nls();\n  \t      s0 = peg$f3(s1, s2);\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parselink() {\n  \t    let s0;\n\n  \t    s0 = peg$parse_wrappedLink();\n  \t    if (s0 === peg$FAILED) {\n  \t      s0 = peg$parse_twLink();\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_wrappedLink() {\n  \t    let s0, s1, s2, s3, s4, s5;\n\n  \t    s0 = peg$currPos;\n  \t    if (input.substr(peg$currPos, 3) === peg$c5) {\n  \t      s1 = peg$c5;\n  \t      peg$currPos += 3;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parsepureText();\n  \t      if (s2 !== peg$FAILED) {\n  \t        s3 = peg$currPos;\n  \t        if (input.charCodeAt(peg$currPos) === 124) {\n  \t          s4 = peg$c6;\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s4 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e7); }\n  \t        }\n  \t        if (s4 !== peg$FAILED) {\n  \t          s5 = peg$parsepureText();\n  \t          if (s5 !== peg$FAILED) {\n  \t            s3 = peg$f4(s2, s5);\n  \t          } else {\n  \t            peg$currPos = s3;\n  \t            s3 = peg$FAILED;\n  \t          }\n  \t        } else {\n  \t          peg$currPos = s3;\n  \t          s3 = peg$FAILED;\n  \t        }\n  \t        if (s3 === peg$FAILED) {\n  \t          s3 = null;\n  \t        }\n  \t        if (input.substr(peg$currPos, 3) === peg$c7) {\n  \t          s4 = peg$c7;\n  \t          peg$currPos += 3;\n  \t        } else {\n  \t          s4 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e8); }\n  \t        }\n  \t        if (s4 !== peg$FAILED) {\n  \t          s0 = peg$f5(s2, s3);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_twLink() {\n  \t    let s0, s1, s2, s3;\n\n  \t    s0 = peg$currPos;\n  \t    if (input.substr(peg$currPos, 2) === peg$c8) {\n  \t      s1 = peg$c8;\n  \t      peg$currPos += 2;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_inner_link_lr();\n  \t      if (s2 === peg$FAILED) {\n  \t        s2 = peg$parse_inner_link_rl();\n  \t        if (s2 === peg$FAILED) {\n  \t          s2 = peg$parse_inner_link_simple();\n  \t        }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        if (input.substr(peg$currPos, 2) === peg$c9) {\n  \t          s3 = peg$c9;\n  \t          peg$currPos += 2;\n  \t        } else {\n  \t          s3 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e10); }\n  \t        }\n  \t        if (s3 !== peg$FAILED) {\n  \t          s0 = peg$f6(s2);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inner_link_simple() {\n  \t    let s0, s1;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parsepureText();\n  \t    if (s1 !== peg$FAILED) {\n  \t      s1 = peg$f7(s1);\n  \t    }\n  \t    s0 = s1;\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inner_link_lr() {\n  \t    let s0, s1, s2, s3;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parsepureText();\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_linkArrowRight();\n  \t      if (s2 === peg$FAILED) {\n  \t        if (input.charCodeAt(peg$currPos) === 124) {\n  \t          s2 = peg$c6;\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s2 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e7); }\n  \t        }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        s3 = peg$parsepureText();\n  \t        if (s3 !== peg$FAILED) {\n  \t          s0 = peg$f8(s1, s3);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inner_link_rl() {\n  \t    let s0, s1, s2, s3;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parsepureText();\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_linkArrowLeft();\n  \t      if (s2 !== peg$FAILED) {\n  \t        s3 = peg$parsepureText();\n  \t        if (s3 !== peg$FAILED) {\n  \t          s0 = peg$f9(s1, s3);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_linkArrowRight() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    if (input.substr(peg$currPos, 2) === peg$c10) {\n  \t      s0 = peg$c10;\n  \t      peg$currPos += 2;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_linkArrowLeft() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    if (input.substr(peg$currPos, 2) === peg$c11) {\n  \t      s0 = peg$c11;\n  \t      peg$currPos += 2;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parsepureText() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parse_charUnescaped();\n  \t    if (s2 === peg$FAILED) {\n  \t      s2 = peg$parse_charEscaped();\n  \t    }\n  \t    if (s2 !== peg$FAILED) {\n  \t      while (s2 !== peg$FAILED) {\n  \t        s1.push(s2);\n  \t        s2 = peg$parse_charUnescaped();\n  \t        if (s2 === peg$FAILED) {\n  \t          s2 = peg$parse_charEscaped();\n  \t        }\n  \t      }\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s1 = peg$f10(s1);\n  \t    }\n  \t    s0 = s1;\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_charUnescaped() {\n  \t    let s0, s1, s2, s3, s4, s5;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$currPos;\n  \t    peg$silentFails++;\n  \t    s2 = peg$currPos;\n  \t    s3 = peg$currPos;\n  \t    peg$silentFails++;\n  \t    s4 = peg$parse_nonTextCharUnescaped();\n  \t    peg$silentFails--;\n  \t    if (s4 === peg$FAILED) {\n  \t      s3 = undefined;\n  \t    } else {\n  \t      peg$currPos = s3;\n  \t      s3 = peg$FAILED;\n  \t    }\n  \t    if (s3 !== peg$FAILED) {\n  \t      s4 = peg$currPos;\n  \t      peg$silentFails++;\n  \t      s5 = peg$parse_linkArrowRight();\n  \t      peg$silentFails--;\n  \t      if (s5 === peg$FAILED) {\n  \t        s4 = undefined;\n  \t      } else {\n  \t        peg$currPos = s4;\n  \t        s4 = peg$FAILED;\n  \t      }\n  \t      if (s4 !== peg$FAILED) {\n  \t        s3 = [s3, s4];\n  \t        s2 = s3;\n  \t      } else {\n  \t        peg$currPos = s2;\n  \t        s2 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s2;\n  \t      s2 = peg$FAILED;\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s2 !== peg$FAILED) {\n  \t      peg$currPos = s1;\n  \t      s1 = undefined;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      if (input.length > peg$currPos) {\n  \t        s2 = input.charAt(peg$currPos);\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s2 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        s0 = peg$f11(s2);\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_charEscaped() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    if (input.charCodeAt(peg$currPos) === 92) {\n  \t      s1 = peg$c12;\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = input.charAt(peg$currPos);\n  \t      if (peg$r0.test(s2)) {\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s2 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e16); }\n  \t      }\n  \t      if (s2 === peg$FAILED) {\n  \t        s2 = input.charAt(peg$currPos);\n  \t        if (peg$r1.test(s2)) {\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s2 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e17); }\n  \t        }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        s0 = peg$f12(s2);\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_nonTextCharUnescaped() {\n  \t    let s0;\n\n  \t    s0 = input.charAt(peg$currPos);\n  \t    if (peg$r2.test(s0)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e18); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_eol() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$parse_nl();\n  \t    if (s0 === peg$FAILED) {\n  \t      s0 = peg$parse_eof();\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_nl() {\n  \t    let s0, s1, s2, s3;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parse_();\n  \t    s2 = input.charAt(peg$currPos);\n  \t    if (peg$r3.test(s2)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s2 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n  \t    }\n  \t    if (s2 === peg$FAILED) {\n  \t      s2 = null;\n  \t    }\n  \t    s3 = input.charAt(peg$currPos);\n  \t    if (peg$r4.test(s3)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s3 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n  \t    }\n  \t    if (s3 !== peg$FAILED) {\n  \t      s1 = [s1, s2, s3];\n  \t      s0 = s1;\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_nls() {\n  \t    let s0, s1, s2;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parse_nl();\n  \t    while (s2 !== peg$FAILED) {\n  \t      s1.push(s2);\n  \t      s2 = peg$parse_nl();\n  \t    }\n  \t    s1 = peg$f13(s1);\n  \t    s0 = s1;\n  \t    peg$silentFails--;\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_eof() {\n  \t    let s0, s1, s2, s3;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parse_();\n  \t    s2 = peg$currPos;\n  \t    peg$silentFails++;\n  \t    if (input.length > peg$currPos) {\n  \t      s3 = input.charAt(peg$currPos);\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s3 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s3 === peg$FAILED) {\n  \t      s2 = undefined;\n  \t    } else {\n  \t      peg$currPos = s2;\n  \t      s2 = peg$FAILED;\n  \t    }\n  \t    if (s2 !== peg$FAILED) {\n  \t      s1 = [s1, s2];\n  \t      s0 = s1;\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_() {\n  \t    let s0, s1;\n\n  \t    peg$silentFails++;\n  \t    s0 = [];\n  \t    s1 = input.charAt(peg$currPos);\n  \t    if (peg$r5.test(s1)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n  \t    }\n  \t    while (s1 !== peg$FAILED) {\n  \t      s0.push(s1);\n  \t      s1 = input.charAt(peg$currPos);\n  \t      if (peg$r5.test(s1)) {\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s1 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e24); }\n  \t      }\n  \t    }\n  \t    peg$silentFails--;\n\n  \t    return s0;\n  \t  }\n\n  \t  peg$result = peg$startRuleFunction();\n\n  \t  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);\n  \t  function peg$throw() {\n  \t    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n  \t      peg$fail(peg$endExpectation());\n  \t    }\n\n  \t    throw peg$buildStructuredError(\n  \t      peg$maxFailExpected,\n  \t      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,\n  \t      peg$maxFailPos < input.length\n  \t        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n  \t        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n  \t    );\n  \t  }\n  \t  if (options.peg$library) {\n  \t    return /** @type {any} */ ({\n  \t      peg$result,\n  \t      peg$currPos,\n  \t      peg$FAILED,\n  \t      peg$maxFailExpected,\n  \t      peg$maxFailPos,\n  \t      peg$success,\n  \t      peg$throw: peg$success ? undefined : peg$throw,\n  \t    });\n  \t  }\n  \t  if (peg$success) {\n  \t    return peg$result;\n  \t  } else {\n  \t    peg$throw();\n  \t  }\n  \t}\n\n  \tpassage = {\n  \t  StartRules: [\"Expression\"],\n  \t  SyntaxError: peg$SyntaxError,\n  \t  parse: peg$parse,\n  \t};\n  \treturn passage;\n  }\n\n  var passageExports = requirePassage();\n\n  var Passage = (function () {\n      function Passage(name, tags, source) {\n          if (name === void 0) { name = 'Default'; }\n          if (tags === void 0) { tags = []; }\n          if (source === void 0) { source = ''; }\n          name !== null && name !== void 0 ? name : (name = 'Default');\n          tags !== null && tags !== void 0 ? tags : (tags = []);\n          source !== null && source !== void 0 ? source : (source = '');\n          this.name = name;\n          this.tags = tags;\n          this.source = source;\n          this.template = document.createElement(\"template\");\n          this.inkSource = \"\";\n          this.parsePassage();\n      }\n      Passage.prototype.parsePassage = function () {\n          this.unescapedSource = Passage.unescapeHtml(this.source);\n          this.parsedSource = passageExports.parse(this.unescapedSource);\n      };\n      Passage.prototype.renderStaticElements = function () {\n          var result = Passage.renderChunks(this.parsedSource.contents);\n          this.renderedChunks = result.chunks;\n          this.inkSource = result.inkSource;\n          this.template.innerHTML = result.chunks.join(\"\");\n          return this.template;\n      };\n      Passage.renderChunks = function (sourceChunks) {\n          var inkSource = \"\";\n          var chunks = sourceChunks.map(function (chunk) {\n              if (chunk.typeName === \"InkText\") {\n                  inkSource = chunk.values.join(\"\");\n              }\n              return chunk.render();\n          });\n          return { chunks: chunks, inkSource: inkSource };\n      };\n      Passage.unescapeHtml = function (source) {\n          var doc = new DOMParser().parseFromString(source, \"text/html\");\n          return doc.documentElement.textContent;\n      };\n      return Passage;\n  }());\n\n  var Utils = (function () {\n      function Utils() {\n      }\n      Utils.generateElements = function (html) {\n          var template = document.createElement('template');\n          template.innerHTML = html.trim();\n          return template.content.children;\n      };\n      Utils.addEventListener = function (eventName, eventHandler, selector) {\n          var wrappedHandler = function (e) {\n              if (!e.target || !(e.target instanceof Element))\n                  return;\n              var el = e.target.closest(selector);\n              if (el) {\n                  eventHandler.call(el, e);\n              }\n          };\n          document.addEventListener(eventName, wrappedHandler);\n          return wrappedHandler;\n      };\n      return Utils;\n  }());\n\n  var ink = {};\n\n  var Story$2 = {};\n\n  var Container = {};\n\n  var Value = {};\n\n  var _Object$1 = {};\n\n  var Path$1 = {};\n\n  var hasRequiredPath$1;\n\n  function requirePath$1 () {\n  \tif (hasRequiredPath$1) return Path$1;\n  \thasRequiredPath$1 = 1;\n  \tObject.defineProperty(Path$1, \"__esModule\", { value: true });\n  \tPath$1.Path = void 0;\n  \tclass Path {\n  \t    constructor() {\n  \t        this._components = [];\n  \t        this._componentsString = null;\n  \t        this._isRelative = false;\n  \t        if (typeof arguments[0] == \"string\") {\n  \t            let componentsString = arguments[0];\n  \t            this.componentsString = componentsString;\n  \t        }\n  \t        else if (arguments[0] instanceof Path.Component &&\n  \t            arguments[1] instanceof Path) {\n  \t            let head = arguments[0];\n  \t            let tail = arguments[1];\n  \t            this._components.push(head);\n  \t            this._components = this._components.concat(tail._components);\n  \t        }\n  \t        else if (arguments[0] instanceof Array) {\n  \t            let head = arguments[0];\n  \t            let relative = !!arguments[1];\n  \t            this._components = this._components.concat(head);\n  \t            this._isRelative = relative;\n  \t        }\n  \t    }\n  \t    get isRelative() {\n  \t        return this._isRelative;\n  \t    }\n  \t    get componentCount() {\n  \t        return this._components.length;\n  \t    }\n  \t    get head() {\n  \t        if (this._components.length > 0) {\n  \t            return this._components[0];\n  \t        }\n  \t        else {\n  \t            return null;\n  \t        }\n  \t    }\n  \t    get tail() {\n  \t        if (this._components.length >= 2) {\n  \t            // careful, the original code uses length-1 here. This is because the second argument of\n  \t            // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n  \t            let tailComps = this._components.slice(1, this._components.length);\n  \t            return new Path(tailComps);\n  \t        }\n  \t        else {\n  \t            return Path.self;\n  \t        }\n  \t    }\n  \t    get length() {\n  \t        return this._components.length;\n  \t    }\n  \t    get lastComponent() {\n  \t        let lastComponentIdx = this._components.length - 1;\n  \t        if (lastComponentIdx >= 0) {\n  \t            return this._components[lastComponentIdx];\n  \t        }\n  \t        else {\n  \t            return null;\n  \t        }\n  \t    }\n  \t    get containsNamedComponent() {\n  \t        for (let i = 0, l = this._components.length; i < l; i++) {\n  \t            if (!this._components[i].isIndex) {\n  \t                return true;\n  \t            }\n  \t        }\n  \t        return false;\n  \t    }\n  \t    static get self() {\n  \t        let path = new Path();\n  \t        path._isRelative = true;\n  \t        return path;\n  \t    }\n  \t    GetComponent(index) {\n  \t        return this._components[index];\n  \t    }\n  \t    PathByAppendingPath(pathToAppend) {\n  \t        let p = new Path();\n  \t        let upwardMoves = 0;\n  \t        for (let i = 0; i < pathToAppend._components.length; ++i) {\n  \t            if (pathToAppend._components[i].isParent) {\n  \t                upwardMoves++;\n  \t            }\n  \t            else {\n  \t                break;\n  \t            }\n  \t        }\n  \t        for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n  \t            p._components.push(this._components[i]);\n  \t        }\n  \t        for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n  \t            p._components.push(pathToAppend._components[i]);\n  \t        }\n  \t        return p;\n  \t    }\n  \t    get componentsString() {\n  \t        if (this._componentsString == null) {\n  \t            this._componentsString = this._components.join(\".\");\n  \t            if (this.isRelative)\n  \t                this._componentsString = \".\" + this._componentsString;\n  \t        }\n  \t        return this._componentsString;\n  \t    }\n  \t    set componentsString(value) {\n  \t        this._components.length = 0;\n  \t        this._componentsString = value;\n  \t        if (this._componentsString == null || this._componentsString == \"\")\n  \t            return;\n  \t        if (this._componentsString[0] == \".\") {\n  \t            this._isRelative = true;\n  \t            this._componentsString = this._componentsString.substring(1);\n  \t        }\n  \t        let componentStrings = this._componentsString.split(\".\");\n  \t        for (let str of componentStrings) {\n  \t            // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n  \t            // the normal parseInt won't do for the detection because it's too relaxed.\n  \t            // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n  \t            if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n  \t                this._components.push(new Path.Component(parseInt(str)));\n  \t            }\n  \t            else {\n  \t                this._components.push(new Path.Component(str));\n  \t            }\n  \t        }\n  \t    }\n  \t    toString() {\n  \t        return this.componentsString;\n  \t    }\n  \t    Equals(otherPath) {\n  \t        if (otherPath == null)\n  \t            return false;\n  \t        if (otherPath._components.length != this._components.length)\n  \t            return false;\n  \t        if (otherPath.isRelative != this.isRelative)\n  \t            return false;\n  \t        // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n  \t        for (let i = 0, l = otherPath._components.length; i < l; i++) {\n  \t            // it's not quite clear whether this test should use Equals or a simple == operator,\n  \t            // see https://github.com/y-lohse/inkjs/issues/22\n  \t            if (!otherPath._components[i].Equals(this._components[i]))\n  \t                return false;\n  \t        }\n  \t        return true;\n  \t    }\n  \t    PathByAppendingComponent(c) {\n  \t        let p = new Path();\n  \t        p._components.push(...this._components);\n  \t        p._components.push(c);\n  \t        return p;\n  \t    }\n  \t}\n  \tPath$1.Path = Path;\n  \tPath.parentId = \"^\";\n  \t(function (Path) {\n  \t    class Component {\n  \t        constructor(indexOrName) {\n  \t            this.index = -1;\n  \t            this.name = null;\n  \t            if (typeof indexOrName == \"string\") {\n  \t                this.name = indexOrName;\n  \t            }\n  \t            else {\n  \t                this.index = indexOrName;\n  \t            }\n  \t        }\n  \t        get isIndex() {\n  \t            return this.index >= 0;\n  \t        }\n  \t        get isParent() {\n  \t            return this.name == Path.parentId;\n  \t        }\n  \t        static ToParent() {\n  \t            return new Component(Path.parentId);\n  \t        }\n  \t        toString() {\n  \t            if (this.isIndex) {\n  \t                return this.index.toString();\n  \t            }\n  \t            else {\n  \t                return this.name;\n  \t            }\n  \t        }\n  \t        Equals(otherComp) {\n  \t            if (otherComp != null && otherComp.isIndex == this.isIndex) {\n  \t                if (this.isIndex) {\n  \t                    return this.index == otherComp.index;\n  \t                }\n  \t                else {\n  \t                    return this.name == otherComp.name;\n  \t                }\n  \t            }\n  \t            return false;\n  \t        }\n  \t    }\n  \t    Path.Component = Component;\n  \t})(Path || (Path$1.Path = Path = {}));\n  \t\n  \treturn Path$1;\n  }\n\n  var Debug = {};\n\n  var hasRequiredDebug;\n\n  function requireDebug () {\n  \tif (hasRequiredDebug) return Debug;\n  \thasRequiredDebug = 1;\n  \tObject.defineProperty(Debug, \"__esModule\", { value: true });\n  \tDebug.Debug = void 0;\n  \tvar Debug$1;\n  \t(function (Debug) {\n  \t    function AssertType(variable, type, message) {\n  \t        Assert(variable instanceof type, message);\n  \t    }\n  \t    Debug.AssertType = AssertType;\n  \t    function Assert(condition, message) {\n  \t        if (!condition) {\n  \t            if (typeof message !== \"undefined\") {\n  \t                console.warn(message);\n  \t            }\n  \t            if (console.trace) {\n  \t                console.trace();\n  \t            }\n  \t            throw new Error(\"\");\n  \t        }\n  \t    }\n  \t    Debug.Assert = Assert;\n  \t})(Debug$1 || (Debug.Debug = Debug$1 = {}));\n  \t\n  \treturn Debug;\n  }\n\n  var TypeAssertion = {};\n\n  var hasRequiredTypeAssertion;\n\n  function requireTypeAssertion () {\n  \tif (hasRequiredTypeAssertion) return TypeAssertion;\n  \thasRequiredTypeAssertion = 1;\n  \tObject.defineProperty(TypeAssertion, \"__esModule\", { value: true });\n  \tTypeAssertion.filterUndef = TypeAssertion.isEquatable = TypeAssertion.nullIfUndefined = TypeAssertion.asINamedContentOrNull = TypeAssertion.asBooleanOrThrows = TypeAssertion.asNumberOrThrows = TypeAssertion.asOrThrows = TypeAssertion.asOrNull = void 0;\n  \tfunction asOrNull(obj, type) {\n  \t    if (obj instanceof type) {\n  \t        return unsafeTypeAssertion(obj);\n  \t    }\n  \t    else {\n  \t        return null;\n  \t    }\n  \t}\n  \tTypeAssertion.asOrNull = asOrNull;\n  \tfunction asOrThrows(obj, type) {\n  \t    if (obj instanceof type) {\n  \t        return unsafeTypeAssertion(obj);\n  \t    }\n  \t    else {\n  \t        throw new Error(`${obj} is not of type ${type}`);\n  \t    }\n  \t}\n  \tTypeAssertion.asOrThrows = asOrThrows;\n  \tfunction asNumberOrThrows(obj) {\n  \t    if (typeof obj === \"number\") {\n  \t        return obj;\n  \t    }\n  \t    else {\n  \t        throw new Error(`${obj} is not a number`);\n  \t    }\n  \t}\n  \tTypeAssertion.asNumberOrThrows = asNumberOrThrows;\n  \tfunction asBooleanOrThrows(obj) {\n  \t    if (typeof obj === \"boolean\") {\n  \t        return obj;\n  \t    }\n  \t    else {\n  \t        throw new Error(`${obj} is not a boolean`);\n  \t    }\n  \t}\n  \tTypeAssertion.asBooleanOrThrows = asBooleanOrThrows;\n  \t// So here, in the reference implementation, contentObj is casted to an INamedContent\n  \t// but here we use js-style duck typing: if it implements the same props as the interface,\n  \t// we treat it as valid.\n  \tfunction asINamedContentOrNull(obj) {\n  \t    if (obj.hasValidName && obj.name) {\n  \t        return obj;\n  \t    }\n  \t    return null;\n  \t}\n  \tTypeAssertion.asINamedContentOrNull = asINamedContentOrNull;\n  \tfunction nullIfUndefined(obj) {\n  \t    if (typeof obj === \"undefined\") {\n  \t        return null;\n  \t    }\n  \t    return obj;\n  \t}\n  \tTypeAssertion.nullIfUndefined = nullIfUndefined;\n  \tfunction isEquatable(type) {\n  \t    return typeof type === \"object\" && typeof type.Equals === \"function\";\n  \t}\n  \tTypeAssertion.isEquatable = isEquatable;\n  \tfunction unsafeTypeAssertion(obj, \n  \t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \ttype) {\n  \t    return obj;\n  \t}\n  \tfunction filterUndef(element) {\n  \t    return element != undefined;\n  \t}\n  \tTypeAssertion.filterUndef = filterUndef;\n  \t\n  \treturn TypeAssertion;\n  }\n\n  var NullException = {};\n\n  var hasRequiredNullException;\n\n  function requireNullException () {\n  \tif (hasRequiredNullException) return NullException;\n  \thasRequiredNullException = 1;\n  \tObject.defineProperty(NullException, \"__esModule\", { value: true });\n  \tNullException.throwNullException = NullException.NullException = void 0;\n  \t/**\n  \t * In the original C# code, a SystemException would be thrown when passing\n  \t * null to methods expected a valid instance. Javascript has no such\n  \t * concept, but TypeScript will not allow `null` to be passed to methods\n  \t * explicitely requiring a valid type.\n  \t *\n  \t * Whenever TypeScript complain about the possibility of a `null` value,\n  \t * check the offending value and it it's null, throw this exception using\n  \t * `throwNullException(name: string)`.\n  \t */\n  \tlet NullException$1 = class NullException extends Error {\n  \t};\n  \tNullException.NullException = NullException$1;\n  \t/**\n  \t * Throw a NullException.\n  \t *\n  \t * @param name a short description of the offending value (often its name within the code).\n  \t */\n  \tfunction throwNullException(name) {\n  \t    throw new NullException$1(`${name} is null or undefined`);\n  \t}\n  \tNullException.throwNullException = throwNullException;\n  \t\n  \treturn NullException;\n  }\n\n  var hasRequired_Object$1;\n\n  function require_Object$1 () {\n  \tif (hasRequired_Object$1) return _Object$1;\n  \thasRequired_Object$1 = 1;\n  \tObject.defineProperty(_Object$1, \"__esModule\", { value: true });\n  \t_Object$1.InkObject = void 0;\n  \tconst Path_1 = requirePath$1();\n  \tconst Container_1 = requireContainer();\n  \tconst Debug_1 = requireDebug();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst NullException_1 = requireNullException();\n  \tclass InkObject {\n  \t    constructor() {\n  \t        this.parent = null;\n  \t        this._debugMetadata = null;\n  \t        this._path = null;\n  \t    }\n  \t    get debugMetadata() {\n  \t        if (this._debugMetadata === null) {\n  \t            if (this.parent) {\n  \t                return this.parent.debugMetadata;\n  \t            }\n  \t        }\n  \t        return this._debugMetadata;\n  \t    }\n  \t    set debugMetadata(value) {\n  \t        this._debugMetadata = value;\n  \t    }\n  \t    get ownDebugMetadata() {\n  \t        return this._debugMetadata;\n  \t    }\n  \t    DebugLineNumberOfPath(path) {\n  \t        if (path === null)\n  \t            return null;\n  \t        // Try to get a line number from debug metadata\n  \t        let root = this.rootContentContainer;\n  \t        if (root) {\n  \t            let targetContent = root.ContentAtPath(path).obj;\n  \t            if (targetContent) {\n  \t                let dm = targetContent.debugMetadata;\n  \t                if (dm !== null) {\n  \t                    return dm.startLineNumber;\n  \t                }\n  \t            }\n  \t        }\n  \t        return null;\n  \t    }\n  \t    get path() {\n  \t        if (this._path == null) {\n  \t            if (this.parent == null) {\n  \t                this._path = new Path_1.Path();\n  \t            }\n  \t            else {\n  \t                let comps = [];\n  \t                let child = this;\n  \t                let container = (0, TypeAssertion_1.asOrNull)(child.parent, Container_1.Container);\n  \t                while (container !== null) {\n  \t                    let namedChild = (0, TypeAssertion_1.asINamedContentOrNull)(child);\n  \t                    if (namedChild != null && namedChild.hasValidName) {\n  \t                        if (namedChild.name === null)\n  \t                            return (0, NullException_1.throwNullException)(\"namedChild.name\");\n  \t                        comps.unshift(new Path_1.Path.Component(namedChild.name));\n  \t                    }\n  \t                    else {\n  \t                        comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));\n  \t                    }\n  \t                    child = container;\n  \t                    container = (0, TypeAssertion_1.asOrNull)(container.parent, Container_1.Container);\n  \t                }\n  \t                this._path = new Path_1.Path(comps);\n  \t            }\n  \t        }\n  \t        return this._path;\n  \t    }\n  \t    ResolvePath(path) {\n  \t        if (path === null)\n  \t            return (0, NullException_1.throwNullException)(\"path\");\n  \t        if (path.isRelative) {\n  \t            let nearestContainer = (0, TypeAssertion_1.asOrNull)(this, Container_1.Container);\n  \t            if (nearestContainer === null) {\n  \t                Debug_1.Debug.Assert(this.parent !== null, \"Can't resolve relative path because we don't have a parent\");\n  \t                nearestContainer = (0, TypeAssertion_1.asOrNull)(this.parent, Container_1.Container);\n  \t                Debug_1.Debug.Assert(nearestContainer !== null, \"Expected parent to be a container\");\n  \t                Debug_1.Debug.Assert(path.GetComponent(0).isParent);\n  \t                path = path.tail;\n  \t            }\n  \t            if (nearestContainer === null) {\n  \t                return (0, NullException_1.throwNullException)(\"nearestContainer\");\n  \t            }\n  \t            return nearestContainer.ContentAtPath(path);\n  \t        }\n  \t        else {\n  \t            let contentContainer = this.rootContentContainer;\n  \t            if (contentContainer === null) {\n  \t                return (0, NullException_1.throwNullException)(\"contentContainer\");\n  \t            }\n  \t            return contentContainer.ContentAtPath(path);\n  \t        }\n  \t    }\n  \t    ConvertPathToRelative(globalPath) {\n  \t        let ownPath = this.path;\n  \t        let minPathLength = Math.min(globalPath.length, ownPath.length);\n  \t        let lastSharedPathCompIndex = -1;\n  \t        for (let i = 0; i < minPathLength; ++i) {\n  \t            let ownComp = ownPath.GetComponent(i);\n  \t            let otherComp = globalPath.GetComponent(i);\n  \t            if (ownComp.Equals(otherComp)) {\n  \t                lastSharedPathCompIndex = i;\n  \t            }\n  \t            else {\n  \t                break;\n  \t            }\n  \t        }\n  \t        // No shared path components, so just use global path\n  \t        if (lastSharedPathCompIndex == -1)\n  \t            return globalPath;\n  \t        let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n  \t        let newPathComps = [];\n  \t        for (let up = 0; up < numUpwardsMoves; ++up)\n  \t            newPathComps.push(Path_1.Path.Component.ToParent());\n  \t        for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)\n  \t            newPathComps.push(globalPath.GetComponent(down));\n  \t        let relativePath = new Path_1.Path(newPathComps, true);\n  \t        return relativePath;\n  \t    }\n  \t    CompactPathString(otherPath) {\n  \t        let globalPathStr = null;\n  \t        let relativePathStr = null;\n  \t        if (otherPath.isRelative) {\n  \t            relativePathStr = otherPath.componentsString;\n  \t            globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n  \t        }\n  \t        else {\n  \t            let relativePath = this.ConvertPathToRelative(otherPath);\n  \t            relativePathStr = relativePath.componentsString;\n  \t            globalPathStr = otherPath.componentsString;\n  \t        }\n  \t        if (relativePathStr.length < globalPathStr.length)\n  \t            return relativePathStr;\n  \t        else\n  \t            return globalPathStr;\n  \t    }\n  \t    get rootContentContainer() {\n  \t        let ancestor = this;\n  \t        while (ancestor.parent) {\n  \t            ancestor = ancestor.parent;\n  \t        }\n  \t        return (0, TypeAssertion_1.asOrNull)(ancestor, Container_1.Container);\n  \t    }\n  \t    Copy() {\n  \t        throw Error(\"Not Implemented: Doesn't support copying\");\n  \t    }\n  \t    // SetChild works slightly diferently in the js implementation.\n  \t    // Since we can't pass an objets property by reference, we instead pass\n  \t    // the object and the property string.\n  \t    // TODO: This method can probably be rewritten with type-safety in mind.\n  \t    SetChild(obj, prop, value) {\n  \t        if (obj[prop])\n  \t            obj[prop] = null;\n  \t        obj[prop] = value;\n  \t        if (obj[prop])\n  \t            obj[prop].parent = this;\n  \t    }\n  \t    Equals(obj) {\n  \t        return obj === this;\n  \t    }\n  \t}\n  \t_Object$1.InkObject = InkObject;\n  \t\n  \treturn _Object$1;\n  }\n\n  var InkList = {};\n\n  var StringBuilder = {};\n\n  var hasRequiredStringBuilder;\n\n  function requireStringBuilder () {\n  \tif (hasRequiredStringBuilder) return StringBuilder;\n  \thasRequiredStringBuilder = 1;\n  \tObject.defineProperty(StringBuilder, \"__esModule\", { value: true });\n  \tStringBuilder.StringBuilder = void 0;\n  \tlet StringBuilder$1 = class StringBuilder {\n  \t    constructor(str) {\n  \t        str = typeof str !== \"undefined\" ? str.toString() : \"\";\n  \t        this.string = str;\n  \t    }\n  \t    get Length() {\n  \t        return this.string.length;\n  \t    }\n  \t    Append(str) {\n  \t        if (str !== null) {\n  \t            this.string += str;\n  \t        }\n  \t    }\n  \t    AppendLine(str) {\n  \t        if (typeof str !== \"undefined\")\n  \t            this.Append(str);\n  \t        this.string += \"\\n\";\n  \t    }\n  \t    AppendFormat(format, ...args) {\n  \t        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n  \t        this.string += format.replace(/{(\\d+)}/g, (match, num) => typeof args[num] != \"undefined\" ? args[num] : match);\n  \t    }\n  \t    toString() {\n  \t        return this.string;\n  \t    }\n  \t    Clear() {\n  \t        this.string = \"\";\n  \t    }\n  \t};\n  \tStringBuilder.StringBuilder = StringBuilder$1;\n  \t\n  \treturn StringBuilder;\n  }\n\n  var hasRequiredInkList;\n\n  function requireInkList () {\n  \tif (hasRequiredInkList) return InkList;\n  \thasRequiredInkList = 1;\n  \tObject.defineProperty(InkList, \"__esModule\", { value: true });\n  \tInkList.InkList = InkList.InkListItem = void 0;\n  \tconst NullException_1 = requireNullException();\n  \tconst StringBuilder_1 = requireStringBuilder();\n  \tclass InkListItem {\n  \t    constructor() {\n  \t        // InkListItem is a struct\n  \t        this.originName = null;\n  \t        this.itemName = null;\n  \t        if (typeof arguments[1] !== \"undefined\") {\n  \t            let originName = arguments[0];\n  \t            let itemName = arguments[1];\n  \t            this.originName = originName;\n  \t            this.itemName = itemName;\n  \t        }\n  \t        else if (arguments[0]) {\n  \t            let fullName = arguments[0];\n  \t            let nameParts = fullName.toString().split(\".\");\n  \t            this.originName = nameParts[0];\n  \t            this.itemName = nameParts[1];\n  \t        }\n  \t    }\n  \t    static get Null() {\n  \t        return new InkListItem(null, null);\n  \t    }\n  \t    get isNull() {\n  \t        return this.originName == null && this.itemName == null;\n  \t    }\n  \t    get fullName() {\n  \t        return ((this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName);\n  \t    }\n  \t    toString() {\n  \t        return this.fullName;\n  \t    }\n  \t    Equals(obj) {\n  \t        if (obj instanceof InkListItem) {\n  \t            let otherItem = obj;\n  \t            return (otherItem.itemName == this.itemName &&\n  \t                otherItem.originName == this.originName);\n  \t        }\n  \t        return false;\n  \t    }\n  \t    // These methods did not exist in the original C# code. Their purpose is to\n  \t    // make `InkListItem` mimics the value-type semantics of the original\n  \t    // struct. Please refer to the end of this file, for a more in-depth\n  \t    // explanation.\n  \t    /**\n  \t     * Returns a shallow clone of the current instance.\n  \t     */\n  \t    copy() {\n  \t        return new InkListItem(this.originName, this.itemName);\n  \t    }\n  \t    /**\n  \t     * Returns a `SerializedInkListItem` representing the current\n  \t     * instance. The result is intended to be used as a key inside a Map.\n  \t     */\n  \t    serialized() {\n  \t        // We are simply using a JSON representation as a value-typed key.\n  \t        return JSON.stringify({\n  \t            originName: this.originName,\n  \t            itemName: this.itemName,\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n  \t     */\n  \t    static fromSerializedKey(key) {\n  \t        let obj = JSON.parse(key);\n  \t        if (!InkListItem.isLikeInkListItem(obj))\n  \t            return InkListItem.Null;\n  \t        let inkListItem = obj;\n  \t        return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  \t    }\n  \t    /**\n  \t     * Determines whether the given item is sufficiently `InkListItem`-like\n  \t     * to be used as a template when reconstructing the InkListItem.\n  \t     */\n  \t    static isLikeInkListItem(item) {\n  \t        if (typeof item !== \"object\")\n  \t            return false;\n  \t        if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n  \t            return false;\n  \t        if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n  \t            return false;\n  \t        if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n  \t            return false;\n  \t        return true;\n  \t    }\n  \t}\n  \tInkList.InkListItem = InkListItem;\n  \tlet InkList$1 = class InkList extends Map {\n  \t    constructor() {\n  \t        // Trying to be smart here, this emulates the constructor inheritance found\n  \t        // in the original code, but only if otherList is an InkList. IIFE FTW.\n  \t        super((() => {\n  \t            if (arguments[0] instanceof InkList) {\n  \t                return arguments[0];\n  \t            }\n  \t            else {\n  \t                return [];\n  \t            }\n  \t        })());\n  \t        this.origins = null;\n  \t        this._originNames = [];\n  \t        if (arguments[0] instanceof InkList) {\n  \t            let otherList = arguments[0];\n  \t            let otherOriginNames = otherList.originNames;\n  \t            if (otherOriginNames !== null)\n  \t                this._originNames = otherOriginNames.slice();\n  \t            if (otherList.origins !== null) {\n  \t                this.origins = otherList.origins.slice();\n  \t            }\n  \t        }\n  \t        else if (typeof arguments[0] === \"string\") {\n  \t            let singleOriginListName = arguments[0];\n  \t            let originStory = arguments[1];\n  \t            this.SetInitialOriginName(singleOriginListName);\n  \t            if (originStory.listDefinitions === null) {\n  \t                return (0, NullException_1.throwNullException)(\"originStory.listDefinitions\");\n  \t            }\n  \t            let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);\n  \t            if (def.exists) {\n  \t                // Throwing now, because if the value is `null` it will\n  \t                // eventually throw down the line.\n  \t                if (def.result === null) {\n  \t                    return (0, NullException_1.throwNullException)(\"def.result\");\n  \t                }\n  \t                this.origins = [def.result];\n  \t            }\n  \t            else {\n  \t                throw new Error(\"InkList origin could not be found in story when constructing new list: \" +\n  \t                    singleOriginListName);\n  \t            }\n  \t        }\n  \t        else if (typeof arguments[0] === \"object\" &&\n  \t            arguments[0].hasOwnProperty(\"Key\") &&\n  \t            arguments[0].hasOwnProperty(\"Value\")) {\n  \t            let singleElement = arguments[0];\n  \t            this.Add(singleElement.Key, singleElement.Value);\n  \t        }\n  \t    }\n  \t    static FromString(myListItem, originStory) {\n  \t        var _a;\n  \t        if (myListItem == null || myListItem == \"\")\n  \t            return new InkList();\n  \t        let listValue = (_a = originStory.listDefinitions) === null || _a === void 0 ? void 0 : _a.FindSingleItemListWithName(myListItem);\n  \t        if (listValue) {\n  \t            if (listValue.value === null) {\n  \t                return (0, NullException_1.throwNullException)(\"listValue.value\");\n  \t            }\n  \t            return new InkList(listValue.value);\n  \t        }\n  \t        else {\n  \t            throw new Error(\"Could not find the InkListItem from the string '\" +\n  \t                myListItem +\n  \t                \"' to create an InkList because it doesn't exist in the original list definition in ink.\");\n  \t        }\n  \t    }\n  \t    AddItem(itemOrItemName, storyObject = null) {\n  \t        if (itemOrItemName instanceof InkListItem) {\n  \t            let item = itemOrItemName;\n  \t            if (item.originName == null) {\n  \t                this.AddItem(item.itemName);\n  \t                return;\n  \t            }\n  \t            if (this.origins === null)\n  \t                return (0, NullException_1.throwNullException)(\"this.origins\");\n  \t            for (let origin of this.origins) {\n  \t                if (origin.name == item.originName) {\n  \t                    let intVal = origin.TryGetValueForItem(item, 0);\n  \t                    if (intVal.exists) {\n  \t                        this.Add(item, intVal.result);\n  \t                        return;\n  \t                    }\n  \t                    else {\n  \t                        throw new Error(\"Could not add the item \" +\n  \t                            item +\n  \t                            \" to this list because it doesn't exist in the original list definition in ink.\");\n  \t                    }\n  \t                }\n  \t            }\n  \t            throw new Error(\"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\");\n  \t        }\n  \t        else if (itemOrItemName !== null) {\n  \t            //itemOrItemName is a string\n  \t            let itemName = itemOrItemName;\n  \t            let foundListDef = null;\n  \t            if (this.origins === null)\n  \t                return (0, NullException_1.throwNullException)(\"this.origins\");\n  \t            for (let origin of this.origins) {\n  \t                if (itemName === null)\n  \t                    return (0, NullException_1.throwNullException)(\"itemName\");\n  \t                if (origin.ContainsItemWithName(itemName)) {\n  \t                    if (foundListDef != null) {\n  \t                        throw new Error(\"Could not add the item \" +\n  \t                            itemName +\n  \t                            \" to this list because it could come from either \" +\n  \t                            origin.name +\n  \t                            \" or \" +\n  \t                            foundListDef.name);\n  \t                    }\n  \t                    else {\n  \t                        foundListDef = origin;\n  \t                    }\n  \t                }\n  \t            }\n  \t            if (foundListDef == null) {\n  \t                if (storyObject == null) {\n  \t                    throw new Error(\"Could not add the item \" +\n  \t                        itemName +\n  \t                        \" to this list because it isn't known to any list definitions previously associated with this list.\");\n  \t                }\n  \t                else {\n  \t                    let newItem = InkList.FromString(itemName, storyObject)\n  \t                        .orderedItems[0];\n  \t                    this.Add(newItem.Key, newItem.Value);\n  \t                }\n  \t            }\n  \t            else {\n  \t                let item = new InkListItem(foundListDef.name, itemName);\n  \t                let itemVal = foundListDef.ValueForItem(item);\n  \t                this.Add(item, itemVal);\n  \t            }\n  \t        }\n  \t    }\n  \t    ContainsItemNamed(itemName) {\n  \t        for (let [key] of this) {\n  \t            let item = InkListItem.fromSerializedKey(key);\n  \t            if (item.itemName == itemName)\n  \t                return true;\n  \t        }\n  \t        return false;\n  \t    }\n  \t    ContainsKey(key) {\n  \t        return this.has(key.serialized());\n  \t    }\n  \t    Add(key, value) {\n  \t        let serializedKey = key.serialized();\n  \t        if (this.has(serializedKey)) {\n  \t            // Throw an exception to match the C# behavior.\n  \t            throw new Error(`The Map already contains an entry for ${key}`);\n  \t        }\n  \t        this.set(serializedKey, value);\n  \t    }\n  \t    Remove(key) {\n  \t        return this.delete(key.serialized());\n  \t    }\n  \t    get Count() {\n  \t        return this.size;\n  \t    }\n  \t    get originOfMaxItem() {\n  \t        if (this.origins == null)\n  \t            return null;\n  \t        let maxOriginName = this.maxItem.Key.originName;\n  \t        let result = null;\n  \t        this.origins.every((origin) => {\n  \t            if (origin.name == maxOriginName) {\n  \t                result = origin;\n  \t                return false;\n  \t            }\n  \t            else\n  \t                return true;\n  \t        });\n  \t        return result;\n  \t    }\n  \t    get originNames() {\n  \t        if (this.Count > 0) {\n  \t            if (this._originNames == null && this.Count > 0)\n  \t                this._originNames = [];\n  \t            else {\n  \t                if (!this._originNames)\n  \t                    this._originNames = [];\n  \t                this._originNames.length = 0;\n  \t            }\n  \t            for (let [key] of this) {\n  \t                let item = InkListItem.fromSerializedKey(key);\n  \t                if (item.originName === null)\n  \t                    return (0, NullException_1.throwNullException)(\"item.originName\");\n  \t                this._originNames.push(item.originName);\n  \t            }\n  \t        }\n  \t        return this._originNames;\n  \t    }\n  \t    SetInitialOriginName(initialOriginName) {\n  \t        this._originNames = [initialOriginName];\n  \t    }\n  \t    SetInitialOriginNames(initialOriginNames) {\n  \t        if (initialOriginNames == null)\n  \t            this._originNames = null;\n  \t        else\n  \t            this._originNames = initialOriginNames.slice(); // store a copy\n  \t    }\n  \t    get maxItem() {\n  \t        let max = {\n  \t            Key: InkListItem.Null,\n  \t            Value: 0,\n  \t        };\n  \t        for (let [key, value] of this) {\n  \t            let item = InkListItem.fromSerializedKey(key);\n  \t            if (max.Key.isNull || value > max.Value)\n  \t                max = { Key: item, Value: value };\n  \t        }\n  \t        return max;\n  \t    }\n  \t    get minItem() {\n  \t        let min = {\n  \t            Key: InkListItem.Null,\n  \t            Value: 0,\n  \t        };\n  \t        for (let [key, value] of this) {\n  \t            let item = InkListItem.fromSerializedKey(key);\n  \t            if (min.Key.isNull || value < min.Value) {\n  \t                min = { Key: item, Value: value };\n  \t            }\n  \t        }\n  \t        return min;\n  \t    }\n  \t    get inverse() {\n  \t        let list = new InkList();\n  \t        if (this.origins != null) {\n  \t            for (let origin of this.origins) {\n  \t                for (let [key, value] of origin.items) {\n  \t                    let item = InkListItem.fromSerializedKey(key);\n  \t                    if (!this.ContainsKey(item))\n  \t                        list.Add(item, value);\n  \t                }\n  \t            }\n  \t        }\n  \t        return list;\n  \t    }\n  \t    get all() {\n  \t        let list = new InkList();\n  \t        if (this.origins != null) {\n  \t            for (let origin of this.origins) {\n  \t                for (let [key, value] of origin.items) {\n  \t                    let item = InkListItem.fromSerializedKey(key);\n  \t                    list.set(item.serialized(), value);\n  \t                }\n  \t            }\n  \t        }\n  \t        return list;\n  \t    }\n  \t    Union(otherList) {\n  \t        let union = new InkList(this);\n  \t        for (let [key, value] of otherList) {\n  \t            union.set(key, value);\n  \t        }\n  \t        return union;\n  \t    }\n  \t    Intersect(otherList) {\n  \t        let intersection = new InkList();\n  \t        for (let [key, value] of this) {\n  \t            if (otherList.has(key))\n  \t                intersection.set(key, value);\n  \t        }\n  \t        return intersection;\n  \t    }\n  \t    HasIntersection(otherList) {\n  \t        for (let [key] of this) {\n  \t            if (otherList.has(key))\n  \t                return true;\n  \t        }\n  \t        return false;\n  \t    }\n  \t    Without(listToRemove) {\n  \t        let result = new InkList(this);\n  \t        for (let [key] of listToRemove) {\n  \t            result.delete(key);\n  \t        }\n  \t        return result;\n  \t    }\n  \t    Contains(what) {\n  \t        if (typeof what == \"string\")\n  \t            return this.ContainsItemNamed(what);\n  \t        const otherList = what;\n  \t        if (otherList.size == 0 || this.size == 0)\n  \t            return false;\n  \t        for (let [key] of otherList) {\n  \t            if (!this.has(key))\n  \t                return false;\n  \t        }\n  \t        return true;\n  \t    }\n  \t    GreaterThan(otherList) {\n  \t        if (this.Count == 0)\n  \t            return false;\n  \t        if (otherList.Count == 0)\n  \t            return true;\n  \t        return this.minItem.Value > otherList.maxItem.Value;\n  \t    }\n  \t    GreaterThanOrEquals(otherList) {\n  \t        if (this.Count == 0)\n  \t            return false;\n  \t        if (otherList.Count == 0)\n  \t            return true;\n  \t        return (this.minItem.Value >= otherList.minItem.Value &&\n  \t            this.maxItem.Value >= otherList.maxItem.Value);\n  \t    }\n  \t    LessThan(otherList) {\n  \t        if (otherList.Count == 0)\n  \t            return false;\n  \t        if (this.Count == 0)\n  \t            return true;\n  \t        return this.maxItem.Value < otherList.minItem.Value;\n  \t    }\n  \t    LessThanOrEquals(otherList) {\n  \t        if (otherList.Count == 0)\n  \t            return false;\n  \t        if (this.Count == 0)\n  \t            return true;\n  \t        return (this.maxItem.Value <= otherList.maxItem.Value &&\n  \t            this.minItem.Value <= otherList.minItem.Value);\n  \t    }\n  \t    MaxAsList() {\n  \t        if (this.Count > 0)\n  \t            return new InkList(this.maxItem);\n  \t        else\n  \t            return new InkList();\n  \t    }\n  \t    MinAsList() {\n  \t        if (this.Count > 0)\n  \t            return new InkList(this.minItem);\n  \t        else\n  \t            return new InkList();\n  \t    }\n  \t    ListWithSubRange(minBound, maxBound) {\n  \t        if (this.Count == 0)\n  \t            return new InkList();\n  \t        let ordered = this.orderedItems;\n  \t        let minValue = 0;\n  \t        let maxValue = Number.MAX_SAFE_INTEGER;\n  \t        if (Number.isInteger(minBound)) {\n  \t            minValue = minBound;\n  \t        }\n  \t        else {\n  \t            if (minBound instanceof InkList && minBound.Count > 0)\n  \t                minValue = minBound.minItem.Value;\n  \t        }\n  \t        if (Number.isInteger(maxBound)) {\n  \t            maxValue = maxBound;\n  \t        }\n  \t        else {\n  \t            if (maxBound instanceof InkList && maxBound.Count > 0)\n  \t                maxValue = maxBound.maxItem.Value;\n  \t        }\n  \t        let subList = new InkList();\n  \t        subList.SetInitialOriginNames(this.originNames);\n  \t        for (let item of ordered) {\n  \t            if (item.Value >= minValue && item.Value <= maxValue) {\n  \t                subList.Add(item.Key, item.Value);\n  \t            }\n  \t        }\n  \t        return subList;\n  \t    }\n  \t    Equals(otherInkList) {\n  \t        if (otherInkList instanceof InkList === false)\n  \t            return false;\n  \t        if (otherInkList.Count != this.Count)\n  \t            return false;\n  \t        for (let [key] of this) {\n  \t            if (!otherInkList.has(key))\n  \t                return false;\n  \t        }\n  \t        return true;\n  \t    }\n  \t    // GetHashCode not implemented\n  \t    get orderedItems() {\n  \t        // List<KeyValuePair<InkListItem, int>>\n  \t        let ordered = new Array();\n  \t        for (let [key, value] of this) {\n  \t            let item = InkListItem.fromSerializedKey(key);\n  \t            ordered.push({ Key: item, Value: value });\n  \t        }\n  \t        ordered.sort((x, y) => {\n  \t            if (x.Key.originName === null) {\n  \t                return (0, NullException_1.throwNullException)(\"x.Key.originName\");\n  \t            }\n  \t            if (y.Key.originName === null) {\n  \t                return (0, NullException_1.throwNullException)(\"y.Key.originName\");\n  \t            }\n  \t            if (x.Value == y.Value) {\n  \t                return x.Key.originName.localeCompare(y.Key.originName);\n  \t            }\n  \t            else {\n  \t                // TODO: refactor this bit into a numberCompareTo method?\n  \t                if (x.Value < y.Value)\n  \t                    return -1;\n  \t                return x.Value > y.Value ? 1 : 0;\n  \t            }\n  \t        });\n  \t        return ordered;\n  \t    }\n  \t    get singleItem() {\n  \t        for (let item of this.orderedItems) {\n  \t            return item.Key;\n  \t        }\n  \t        return null;\n  \t    }\n  \t    toString() {\n  \t        let ordered = this.orderedItems;\n  \t        let sb = new StringBuilder_1.StringBuilder();\n  \t        for (let i = 0; i < ordered.length; i++) {\n  \t            if (i > 0)\n  \t                sb.Append(\", \");\n  \t            let item = ordered[i].Key;\n  \t            if (item.itemName === null)\n  \t                return (0, NullException_1.throwNullException)(\"item.itemName\");\n  \t            sb.Append(item.itemName);\n  \t        }\n  \t        return sb.toString();\n  \t    }\n  \t    // casting a InkList to a Number, for somereason, actually gives a number.\n  \t    // This messes up the type detection when creating a Value from a InkList.\n  \t    // Returning NaN here prevents that.\n  \t    valueOf() {\n  \t        return NaN;\n  \t    }\n  \t};\n  \tInkList.InkList = InkList$1;\n  \t\n  \treturn InkList;\n  }\n\n  var StoryException = {};\n\n  var hasRequiredStoryException;\n\n  function requireStoryException () {\n  \tif (hasRequiredStoryException) return StoryException;\n  \thasRequiredStoryException = 1;\n  \tObject.defineProperty(StoryException, \"__esModule\", { value: true });\n  \tStoryException.StoryException = void 0;\n  \tlet StoryException$1 = class StoryException extends Error {\n  \t    constructor(message) {\n  \t        super(message);\n  \t        this.useEndLineNumber = false;\n  \t        this.message = message;\n  \t        this.name = \"StoryException\";\n  \t    }\n  \t};\n  \tStoryException.StoryException = StoryException$1;\n  \t\n  \treturn StoryException;\n  }\n\n  var TryGetResult = {};\n\n  var hasRequiredTryGetResult;\n\n  function requireTryGetResult () {\n  \tif (hasRequiredTryGetResult) return TryGetResult;\n  \thasRequiredTryGetResult = 1;\n  \tObject.defineProperty(TryGetResult, \"__esModule\", { value: true });\n  \tTryGetResult.tryParseFloat = TryGetResult.tryParseInt = TryGetResult.tryGetValueFromMap = void 0;\n  \tfunction tryGetValueFromMap(map, key, \n  \t/* out */ value) {\n  \t    if (map === null) {\n  \t        return { result: value, exists: false };\n  \t    }\n  \t    let val = map.get(key);\n  \t    if (typeof val === \"undefined\") {\n  \t        return { result: value, exists: false };\n  \t    }\n  \t    else {\n  \t        return { result: val, exists: true };\n  \t    }\n  \t}\n  \tTryGetResult.tryGetValueFromMap = tryGetValueFromMap;\n  \tfunction tryParseInt(value, \n  \t/* out */ defaultValue = 0) {\n  \t    let val = parseInt(value);\n  \t    if (!Number.isNaN(val)) {\n  \t        return { result: val, exists: true };\n  \t    }\n  \t    else {\n  \t        return { result: defaultValue, exists: false };\n  \t    }\n  \t}\n  \tTryGetResult.tryParseInt = tryParseInt;\n  \tfunction tryParseFloat(value, \n  \t/* out */ defaultValue = 0) {\n  \t    let val = parseFloat(value);\n  \t    if (!Number.isNaN(val)) {\n  \t        return { result: val, exists: true };\n  \t    }\n  \t    else {\n  \t        return { result: defaultValue, exists: false };\n  \t    }\n  \t}\n  \tTryGetResult.tryParseFloat = tryParseFloat;\n  \t\n  \treturn TryGetResult;\n  }\n\n  var hasRequiredValue;\n\n  function requireValue () {\n  \tif (hasRequiredValue) return Value;\n  \thasRequiredValue = 1;\n  \tObject.defineProperty(Value, \"__esModule\", { value: true });\n  \tValue.ValueType = Value.ListValue = Value.VariablePointerValue = Value.DivertTargetValue = Value.StringValue = Value.FloatValue = Value.IntValue = Value.BoolValue = Value.Value = Value.AbstractValue = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tconst Path_1 = requirePath$1();\n  \tconst InkList_1 = requireInkList();\n  \tconst StoryException_1 = requireStoryException();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst TryGetResult_1 = requireTryGetResult();\n  \tconst NullException_1 = requireNullException();\n  \tclass AbstractValue extends Object_1.InkObject {\n  \t    static Create(val, preferredNumberType) {\n  \t        // This code doesn't exist in upstream and is simply here to enforce\n  \t        // the creation of the proper number value.\n  \t        // If `preferredNumberType` is not provided or if value doesn't match\n  \t        // `preferredNumberType`, this conditional does nothing.\n  \t        if (preferredNumberType) {\n  \t            if (preferredNumberType === ValueType.Int &&\n  \t                Number.isInteger(Number(val))) {\n  \t                return new IntValue(Number(val));\n  \t            }\n  \t            else if (preferredNumberType === ValueType.Float &&\n  \t                !isNaN(val)) {\n  \t                return new FloatValue(Number(val));\n  \t            }\n  \t        }\n  \t        if (typeof val === \"boolean\") {\n  \t            return new BoolValue(Boolean(val));\n  \t        }\n  \t        // https://github.com/y-lohse/inkjs/issues/425\n  \t        // Changed condition sequence, because Number('') is\n  \t        // parsed to 0, which made setting string to empty\n  \t        // impossible\n  \t        if (typeof val === \"string\") {\n  \t            return new StringValue(String(val));\n  \t        }\n  \t        else if (Number.isInteger(Number(val))) {\n  \t            return new IntValue(Number(val));\n  \t        }\n  \t        else if (!isNaN(val)) {\n  \t            return new FloatValue(Number(val));\n  \t        }\n  \t        else if (val instanceof Path_1.Path) {\n  \t            return new DivertTargetValue((0, TypeAssertion_1.asOrThrows)(val, Path_1.Path));\n  \t        }\n  \t        else if (val instanceof InkList_1.InkList) {\n  \t            return new ListValue((0, TypeAssertion_1.asOrThrows)(val, InkList_1.InkList));\n  \t        }\n  \t        return null;\n  \t    }\n  \t    Copy() {\n  \t        return (0, TypeAssertion_1.asOrThrows)(AbstractValue.Create(this.valueObject), Object_1.InkObject);\n  \t    }\n  \t    BadCastException(targetType) {\n  \t        return new StoryException_1.StoryException(\"Can't cast \" +\n  \t            this.valueObject +\n  \t            \" from \" +\n  \t            this.valueType +\n  \t            \" to \" +\n  \t            targetType);\n  \t    }\n  \t}\n  \tValue.AbstractValue = AbstractValue;\n  \tlet Value$1 = class Value extends AbstractValue {\n  \t    constructor(val) {\n  \t        super();\n  \t        this.value = val;\n  \t    }\n  \t    get valueObject() {\n  \t        return this.value;\n  \t    }\n  \t    toString() {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        return this.value.toString();\n  \t    }\n  \t};\n  \tValue.Value = Value$1;\n  \tclass BoolValue extends Value$1 {\n  \t    constructor(val) {\n  \t        super(val || false);\n  \t    }\n  \t    get isTruthy() {\n  \t        return Boolean(this.value);\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.Bool;\n  \t    }\n  \t    Cast(newType) {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        if (newType == this.valueType) {\n  \t            return this;\n  \t        }\n  \t        if (newType == ValueType.Int) {\n  \t            return new IntValue(this.value ? 1 : 0);\n  \t        }\n  \t        if (newType == ValueType.Float) {\n  \t            return new FloatValue(this.value ? 1.0 : 0.0);\n  \t        }\n  \t        if (newType == ValueType.String) {\n  \t            return new StringValue(this.value ? \"true\" : \"false\");\n  \t        }\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t    toString() {\n  \t        return this.value ? \"true\" : \"false\";\n  \t    }\n  \t}\n  \tValue.BoolValue = BoolValue;\n  \tclass IntValue extends Value$1 {\n  \t    constructor(val) {\n  \t        super(val || 0);\n  \t    }\n  \t    get isTruthy() {\n  \t        return this.value != 0;\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.Int;\n  \t    }\n  \t    Cast(newType) {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        if (newType == this.valueType) {\n  \t            return this;\n  \t        }\n  \t        if (newType == ValueType.Bool) {\n  \t            return new BoolValue(this.value === 0 ? false : true);\n  \t        }\n  \t        if (newType == ValueType.Float) {\n  \t            return new FloatValue(this.value);\n  \t        }\n  \t        if (newType == ValueType.String) {\n  \t            return new StringValue(\"\" + this.value);\n  \t        }\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t}\n  \tValue.IntValue = IntValue;\n  \tclass FloatValue extends Value$1 {\n  \t    constructor(val) {\n  \t        super(val || 0.0);\n  \t    }\n  \t    get isTruthy() {\n  \t        return this.value != 0.0;\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.Float;\n  \t    }\n  \t    Cast(newType) {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        if (newType == this.valueType) {\n  \t            return this;\n  \t        }\n  \t        if (newType == ValueType.Bool) {\n  \t            return new BoolValue(this.value === 0.0 ? false : true);\n  \t        }\n  \t        if (newType == ValueType.Int) {\n  \t            return new IntValue(this.value);\n  \t        }\n  \t        if (newType == ValueType.String) {\n  \t            return new StringValue(\"\" + this.value);\n  \t        }\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t}\n  \tValue.FloatValue = FloatValue;\n  \tclass StringValue extends Value$1 {\n  \t    constructor(val) {\n  \t        super(val || \"\");\n  \t        this._isNewline = this.value == \"\\n\";\n  \t        this._isInlineWhitespace = true;\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        if (this.value.length > 0) {\n  \t            this.value.split(\"\").every((c) => {\n  \t                if (c != \" \" && c != \"\\t\") {\n  \t                    this._isInlineWhitespace = false;\n  \t                    return false;\n  \t                }\n  \t                return true;\n  \t            });\n  \t        }\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.String;\n  \t    }\n  \t    get isTruthy() {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        return this.value.length > 0;\n  \t    }\n  \t    get isNewline() {\n  \t        return this._isNewline;\n  \t    }\n  \t    get isInlineWhitespace() {\n  \t        return this._isInlineWhitespace;\n  \t    }\n  \t    get isNonWhitespace() {\n  \t        return !this.isNewline && !this.isInlineWhitespace;\n  \t    }\n  \t    Cast(newType) {\n  \t        if (newType == this.valueType) {\n  \t            return this;\n  \t        }\n  \t        if (newType == ValueType.Int) {\n  \t            let parsedInt = (0, TryGetResult_1.tryParseInt)(this.value);\n  \t            if (parsedInt.exists) {\n  \t                return new IntValue(parsedInt.result);\n  \t            }\n  \t            else {\n  \t                throw this.BadCastException(newType);\n  \t            }\n  \t        }\n  \t        if (newType == ValueType.Float) {\n  \t            let parsedFloat = (0, TryGetResult_1.tryParseFloat)(this.value);\n  \t            if (parsedFloat.exists) {\n  \t                return new FloatValue(parsedFloat.result);\n  \t            }\n  \t            else {\n  \t                throw this.BadCastException(newType);\n  \t            }\n  \t        }\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t}\n  \tValue.StringValue = StringValue;\n  \tclass DivertTargetValue extends Value$1 {\n  \t    constructor(targetPath = null) {\n  \t        super(targetPath);\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.DivertTarget;\n  \t    }\n  \t    get targetPath() {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        return this.value;\n  \t    }\n  \t    set targetPath(value) {\n  \t        this.value = value;\n  \t    }\n  \t    get isTruthy() {\n  \t        throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  \t    }\n  \t    Cast(newType) {\n  \t        if (newType == this.valueType)\n  \t            return this;\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t    toString() {\n  \t        return \"DivertTargetValue(\" + this.targetPath + \")\";\n  \t    }\n  \t}\n  \tValue.DivertTargetValue = DivertTargetValue;\n  \tclass VariablePointerValue extends Value$1 {\n  \t    constructor(variableName, contextIndex = -1) {\n  \t        super(variableName);\n  \t        this._contextIndex = contextIndex;\n  \t    }\n  \t    get contextIndex() {\n  \t        return this._contextIndex;\n  \t    }\n  \t    set contextIndex(value) {\n  \t        this._contextIndex = value;\n  \t    }\n  \t    get variableName() {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        return this.value;\n  \t    }\n  \t    set variableName(value) {\n  \t        this.value = value;\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.VariablePointer;\n  \t    }\n  \t    get isTruthy() {\n  \t        throw new Error(\"Shouldn't be checking the truthiness of a variable pointer\");\n  \t    }\n  \t    Cast(newType) {\n  \t        if (newType == this.valueType)\n  \t            return this;\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t    toString() {\n  \t        return \"VariablePointerValue(\" + this.variableName + \")\";\n  \t    }\n  \t    Copy() {\n  \t        return new VariablePointerValue(this.variableName, this.contextIndex);\n  \t    }\n  \t}\n  \tValue.VariablePointerValue = VariablePointerValue;\n  \tclass ListValue extends Value$1 {\n  \t    get isTruthy() {\n  \t        if (this.value === null) {\n  \t            return (0, NullException_1.throwNullException)(\"this.value\");\n  \t        }\n  \t        return this.value.Count > 0;\n  \t    }\n  \t    get valueType() {\n  \t        return ValueType.List;\n  \t    }\n  \t    Cast(newType) {\n  \t        if (this.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"Value.value\");\n  \t        if (newType == ValueType.Int) {\n  \t            let max = this.value.maxItem;\n  \t            if (max.Key.isNull)\n  \t                return new IntValue(0);\n  \t            else\n  \t                return new IntValue(max.Value);\n  \t        }\n  \t        else if (newType == ValueType.Float) {\n  \t            let max = this.value.maxItem;\n  \t            if (max.Key.isNull)\n  \t                return new FloatValue(0.0);\n  \t            else\n  \t                return new FloatValue(max.Value);\n  \t        }\n  \t        else if (newType == ValueType.String) {\n  \t            let max = this.value.maxItem;\n  \t            if (max.Key.isNull)\n  \t                return new StringValue(\"\");\n  \t            else {\n  \t                return new StringValue(max.Key.toString());\n  \t            }\n  \t        }\n  \t        if (newType == this.valueType)\n  \t            return this;\n  \t        throw this.BadCastException(newType);\n  \t    }\n  \t    constructor(listOrSingleItem, singleValue) {\n  \t        super(null);\n  \t        if (!listOrSingleItem && !singleValue) {\n  \t            this.value = new InkList_1.InkList();\n  \t        }\n  \t        else if (listOrSingleItem instanceof InkList_1.InkList) {\n  \t            this.value = new InkList_1.InkList(listOrSingleItem);\n  \t        }\n  \t        else if (listOrSingleItem instanceof InkList_1.InkListItem &&\n  \t            typeof singleValue === \"number\") {\n  \t            this.value = new InkList_1.InkList({\n  \t                Key: listOrSingleItem,\n  \t                Value: singleValue,\n  \t            });\n  \t        }\n  \t    }\n  \t    static RetainListOriginsForAssignment(oldValue, newValue) {\n  \t        let oldList = (0, TypeAssertion_1.asOrNull)(oldValue, ListValue);\n  \t        let newList = (0, TypeAssertion_1.asOrNull)(newValue, ListValue);\n  \t        if (newList && newList.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"newList.value\");\n  \t        if (oldList && oldList.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"oldList.value\");\n  \t        // When assigning the empty list, try to retain any initial origin names\n  \t        if (oldList && newList && newList.value.Count == 0)\n  \t            newList.value.SetInitialOriginNames(oldList.value.originNames);\n  \t    }\n  \t}\n  \tValue.ListValue = ListValue;\n  \tvar ValueType;\n  \t(function (ValueType) {\n  \t    ValueType[ValueType[\"Bool\"] = -1] = \"Bool\";\n  \t    ValueType[ValueType[\"Int\"] = 0] = \"Int\";\n  \t    ValueType[ValueType[\"Float\"] = 1] = \"Float\";\n  \t    ValueType[ValueType[\"List\"] = 2] = \"List\";\n  \t    ValueType[ValueType[\"String\"] = 3] = \"String\";\n  \t    ValueType[ValueType[\"DivertTarget\"] = 4] = \"DivertTarget\";\n  \t    ValueType[ValueType[\"VariablePointer\"] = 5] = \"VariablePointer\";\n  \t})(ValueType || (Value.ValueType = ValueType = {}));\n  \t\n  \treturn Value;\n  }\n\n  var SearchResult = {};\n\n  var hasRequiredSearchResult;\n\n  function requireSearchResult () {\n  \tif (hasRequiredSearchResult) return SearchResult;\n  \thasRequiredSearchResult = 1;\n  \tObject.defineProperty(SearchResult, \"__esModule\", { value: true });\n  \tSearchResult.SearchResult = void 0;\n  \tconst Container_1 = requireContainer();\n  \tlet SearchResult$1 = class SearchResult {\n  \t    constructor() {\n  \t        this.obj = null;\n  \t        this.approximate = false;\n  \t    }\n  \t    get correctObj() {\n  \t        return this.approximate ? null : this.obj;\n  \t    }\n  \t    get container() {\n  \t        return this.obj instanceof Container_1.Container ? this.obj : null;\n  \t    }\n  \t    copy() {\n  \t        let searchResult = new SearchResult();\n  \t        searchResult.obj = this.obj;\n  \t        searchResult.approximate = this.approximate;\n  \t        return searchResult;\n  \t    }\n  \t};\n  \tSearchResult.SearchResult = SearchResult$1;\n  \t\n  \treturn SearchResult;\n  }\n\n  var hasRequiredContainer;\n\n  function requireContainer () {\n  \tif (hasRequiredContainer) return Container;\n  \thasRequiredContainer = 1;\n  \tObject.defineProperty(Container, \"__esModule\", { value: true });\n  \tContainer.Container = void 0;\n  \tconst Value_1 = requireValue();\n  \tconst NullException_1 = requireNullException();\n  \tconst StringBuilder_1 = requireStringBuilder();\n  \tconst Object_1 = require_Object$1();\n  \tconst SearchResult_1 = requireSearchResult();\n  \tconst Path_1 = requirePath$1();\n  \tconst Debug_1 = requireDebug();\n  \tconst TryGetResult_1 = requireTryGetResult();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet Container$1 = class Container extends Object_1.InkObject {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.name = null;\n  \t        this._content = [];\n  \t        this.namedContent = new Map();\n  \t        this.visitsShouldBeCounted = false;\n  \t        this.turnIndexShouldBeCounted = false;\n  \t        this.countingAtStartOnly = false;\n  \t        this._pathToFirstLeafContent = null;\n  \t    }\n  \t    get hasValidName() {\n  \t        return this.name != null && this.name.length > 0;\n  \t    }\n  \t    get content() {\n  \t        return this._content;\n  \t    }\n  \t    set content(value) {\n  \t        this.AddContent(value);\n  \t    }\n  \t    get namedOnlyContent() {\n  \t        let namedOnlyContentDict = new Map();\n  \t        for (let [key, value] of this.namedContent) {\n  \t            let inkObject = (0, TypeAssertion_1.asOrThrows)(value, Object_1.InkObject);\n  \t            namedOnlyContentDict.set(key, inkObject);\n  \t        }\n  \t        for (let c of this.content) {\n  \t            let named = (0, TypeAssertion_1.asINamedContentOrNull)(c);\n  \t            if (named != null && named.hasValidName) {\n  \t                namedOnlyContentDict.delete(named.name);\n  \t            }\n  \t        }\n  \t        if (namedOnlyContentDict.size == 0)\n  \t            namedOnlyContentDict = null;\n  \t        return namedOnlyContentDict;\n  \t    }\n  \t    set namedOnlyContent(value) {\n  \t        let existingNamedOnly = this.namedOnlyContent;\n  \t        if (existingNamedOnly != null) {\n  \t            for (let [key] of existingNamedOnly) {\n  \t                this.namedContent.delete(key);\n  \t            }\n  \t        }\n  \t        if (value == null)\n  \t            return;\n  \t        for (let [, val] of value) {\n  \t            let named = (0, TypeAssertion_1.asINamedContentOrNull)(val);\n  \t            if (named != null)\n  \t                this.AddToNamedContentOnly(named);\n  \t        }\n  \t    }\n  \t    get countFlags() {\n  \t        let flags = 0;\n  \t        if (this.visitsShouldBeCounted)\n  \t            flags |= Container.CountFlags.Visits;\n  \t        if (this.turnIndexShouldBeCounted)\n  \t            flags |= Container.CountFlags.Turns;\n  \t        if (this.countingAtStartOnly)\n  \t            flags |= Container.CountFlags.CountStartOnly;\n  \t        if (flags == Container.CountFlags.CountStartOnly) {\n  \t            flags = 0;\n  \t        }\n  \t        return flags;\n  \t    }\n  \t    set countFlags(value) {\n  \t        let flag = value;\n  \t        if ((flag & Container.CountFlags.Visits) > 0)\n  \t            this.visitsShouldBeCounted = true;\n  \t        if ((flag & Container.CountFlags.Turns) > 0)\n  \t            this.turnIndexShouldBeCounted = true;\n  \t        if ((flag & Container.CountFlags.CountStartOnly) > 0)\n  \t            this.countingAtStartOnly = true;\n  \t    }\n  \t    get pathToFirstLeafContent() {\n  \t        if (this._pathToFirstLeafContent == null)\n  \t            this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);\n  \t        return this._pathToFirstLeafContent;\n  \t    }\n  \t    get internalPathToFirstLeafContent() {\n  \t        let components = [];\n  \t        let container = this;\n  \t        while (container instanceof Container) {\n  \t            if (container.content.length > 0) {\n  \t                components.push(new Path_1.Path.Component(0));\n  \t                container = container.content[0];\n  \t            }\n  \t        }\n  \t        return new Path_1.Path(components);\n  \t    }\n  \t    AddContent(contentObjOrList) {\n  \t        if (contentObjOrList instanceof Array) {\n  \t            let contentList = contentObjOrList;\n  \t            for (let c of contentList) {\n  \t                this.AddContent(c);\n  \t            }\n  \t        }\n  \t        else {\n  \t            let contentObj = contentObjOrList;\n  \t            this._content.push(contentObj);\n  \t            if (contentObj.parent) {\n  \t                throw new Error(\"content is already in \" + contentObj.parent);\n  \t            }\n  \t            contentObj.parent = this;\n  \t            this.TryAddNamedContent(contentObj);\n  \t        }\n  \t    }\n  \t    TryAddNamedContent(contentObj) {\n  \t        let namedContentObj = (0, TypeAssertion_1.asINamedContentOrNull)(contentObj);\n  \t        if (namedContentObj != null && namedContentObj.hasValidName) {\n  \t            this.AddToNamedContentOnly(namedContentObj);\n  \t        }\n  \t    }\n  \t    AddToNamedContentOnly(namedContentObj) {\n  \t        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, \"Can only add Runtime.Objects to a Runtime.Container\");\n  \t        let runtimeObj = (0, TypeAssertion_1.asOrThrows)(namedContentObj, Object_1.InkObject);\n  \t        runtimeObj.parent = this;\n  \t        if (namedContentObj.name === null)\n  \t            return (0, NullException_1.throwNullException)(\"namedContentObj.name\");\n  \t        this.namedContent.set(namedContentObj.name, namedContentObj);\n  \t    }\n  \t    ContentAtPath(path, partialPathStart = 0, partialPathLength = -1) {\n  \t        if (partialPathLength == -1)\n  \t            partialPathLength = path.length;\n  \t        let result = new SearchResult_1.SearchResult();\n  \t        result.approximate = false;\n  \t        let currentContainer = this;\n  \t        let currentObj = this;\n  \t        for (let i = partialPathStart; i < partialPathLength; ++i) {\n  \t            let comp = path.GetComponent(i);\n  \t            if (currentContainer == null) {\n  \t                result.approximate = true;\n  \t                break;\n  \t            }\n  \t            let foundObj = currentContainer.ContentWithPathComponent(comp);\n  \t            // Couldn't resolve entire path?\n  \t            if (foundObj == null) {\n  \t                result.approximate = true;\n  \t                break;\n  \t            }\n  \t            // Are we about to loop into another container?\n  \t            // Is the object a container as expected? It might\n  \t            // no longer be if the content has shuffled around, so what\n  \t            // was originally a container no longer is.\n  \t            const nextContainer = (0, TypeAssertion_1.asOrNull)(foundObj, Container);\n  \t            if (i < partialPathLength - 1 && nextContainer == null) {\n  \t                result.approximate = true;\n  \t                break;\n  \t            }\n  \t            currentObj = foundObj;\n  \t            currentContainer = nextContainer;\n  \t        }\n  \t        result.obj = currentObj;\n  \t        return result;\n  \t    }\n  \t    InsertContent(contentObj, index) {\n  \t        this.content.splice(index, 0, contentObj);\n  \t        if (contentObj.parent) {\n  \t            throw new Error(\"content is already in \" + contentObj.parent);\n  \t        }\n  \t        contentObj.parent = this;\n  \t        this.TryAddNamedContent(contentObj);\n  \t    }\n  \t    AddContentsOfContainer(otherContainer) {\n  \t        this.content.push(...otherContainer.content);\n  \t        for (let obj of otherContainer.content) {\n  \t            obj.parent = this;\n  \t            this.TryAddNamedContent(obj);\n  \t        }\n  \t    }\n  \t    ContentWithPathComponent(component) {\n  \t        if (component.isIndex) {\n  \t            if (component.index >= 0 && component.index < this.content.length) {\n  \t                return this.content[component.index];\n  \t            }\n  \t            else {\n  \t                return null;\n  \t            }\n  \t        }\n  \t        else if (component.isParent) {\n  \t            return this.parent;\n  \t        }\n  \t        else {\n  \t            if (component.name === null) {\n  \t                return (0, NullException_1.throwNullException)(\"component.name\");\n  \t            }\n  \t            let foundContent = (0, TryGetResult_1.tryGetValueFromMap)(this.namedContent, component.name, null);\n  \t            if (foundContent.exists) {\n  \t                return (0, TypeAssertion_1.asOrThrows)(foundContent.result, Object_1.InkObject);\n  \t            }\n  \t            else {\n  \t                return null;\n  \t            }\n  \t        }\n  \t    }\n  \t    BuildStringOfHierarchy() {\n  \t        let sb;\n  \t        if (arguments.length == 0) {\n  \t            sb = new StringBuilder_1.StringBuilder();\n  \t            this.BuildStringOfHierarchy(sb, 0, null);\n  \t            return sb.toString();\n  \t        }\n  \t        sb = arguments[0];\n  \t        let indentation = arguments[1];\n  \t        let pointedObj = arguments[2];\n  \t        function appendIndentation() {\n  \t            const spacesPerIndent = 4; // Truly const in the original code\n  \t            for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n  \t                sb.Append(\" \");\n  \t            }\n  \t        }\n  \t        appendIndentation();\n  \t        sb.Append(\"[\");\n  \t        if (this.hasValidName) {\n  \t            sb.AppendFormat(\" ({0})\", this.name);\n  \t        }\n  \t        if (this == pointedObj) {\n  \t            sb.Append(\"  <---\");\n  \t        }\n  \t        sb.AppendLine();\n  \t        indentation++;\n  \t        for (let i = 0; i < this.content.length; ++i) {\n  \t            let obj = this.content[i];\n  \t            if (obj instanceof Container) {\n  \t                let container = obj;\n  \t                container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n  \t            }\n  \t            else {\n  \t                appendIndentation();\n  \t                if (obj instanceof Value_1.StringValue) {\n  \t                    sb.Append('\"');\n  \t                    sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n  \t                    sb.Append('\"');\n  \t                }\n  \t                else {\n  \t                    sb.Append(obj.toString());\n  \t                }\n  \t            }\n  \t            if (i != this.content.length - 1) {\n  \t                sb.Append(\",\");\n  \t            }\n  \t            if (!(obj instanceof Container) && obj == pointedObj) {\n  \t                sb.Append(\"  <---\");\n  \t            }\n  \t            sb.AppendLine();\n  \t        }\n  \t        let onlyNamed = new Map();\n  \t        for (let [key, value] of this.namedContent) {\n  \t            if (this.content.indexOf((0, TypeAssertion_1.asOrThrows)(value, Object_1.InkObject)) >= 0) {\n  \t                continue;\n  \t            }\n  \t            else {\n  \t                onlyNamed.set(key, value);\n  \t            }\n  \t        }\n  \t        if (onlyNamed.size > 0) {\n  \t            appendIndentation();\n  \t            sb.AppendLine(\"-- named: --\");\n  \t            for (let [, value] of onlyNamed) {\n  \t                Debug_1.Debug.AssertType(value, Container, \"Can only print out named Containers\");\n  \t                let container = value;\n  \t                container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n  \t                sb.AppendLine();\n  \t            }\n  \t        }\n  \t        indentation--;\n  \t        appendIndentation();\n  \t        sb.Append(\"]\");\n  \t    }\n  \t};\n  \tContainer.Container = Container$1;\n  \t(function (Container) {\n  \t    (function (CountFlags) {\n  \t        CountFlags[CountFlags[\"Start\"] = 0] = \"Start\";\n  \t        CountFlags[CountFlags[\"Visits\"] = 1] = \"Visits\";\n  \t        CountFlags[CountFlags[\"Turns\"] = 2] = \"Turns\";\n  \t        CountFlags[CountFlags[\"CountStartOnly\"] = 4] = \"CountStartOnly\";\n  \t    })(Container.CountFlags || (Container.CountFlags = {}));\n  \t})(Container$1 || (Container.Container = Container$1 = {}));\n  \t\n  \treturn Container;\n  }\n\n  var JsonSerialisation = {};\n\n  var Glue$1 = {};\n\n  var hasRequiredGlue$1;\n\n  function requireGlue$1 () {\n  \tif (hasRequiredGlue$1) return Glue$1;\n  \thasRequiredGlue$1 = 1;\n  \tObject.defineProperty(Glue$1, \"__esModule\", { value: true });\n  \tGlue$1.Glue = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tclass Glue extends Object_1.InkObject {\n  \t    toString() {\n  \t        return \"Glue\";\n  \t    }\n  \t}\n  \tGlue$1.Glue = Glue;\n  \t\n  \treturn Glue$1;\n  }\n\n  var ControlCommand = {};\n\n  var hasRequiredControlCommand;\n\n  function requireControlCommand () {\n  \tif (hasRequiredControlCommand) return ControlCommand;\n  \thasRequiredControlCommand = 1;\n  \tObject.defineProperty(ControlCommand, \"__esModule\", { value: true });\n  \tControlCommand.ControlCommand = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tlet ControlCommand$1 = class ControlCommand extends Object_1.InkObject {\n  \t    get commandType() {\n  \t        return this._commandType;\n  \t    }\n  \t    constructor(commandType = ControlCommand.CommandType.NotSet) {\n  \t        super();\n  \t        this._commandType = commandType;\n  \t    }\n  \t    Copy() {\n  \t        return new ControlCommand(this.commandType);\n  \t    }\n  \t    static EvalStart() {\n  \t        return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  \t    }\n  \t    static EvalOutput() {\n  \t        return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  \t    }\n  \t    static EvalEnd() {\n  \t        return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  \t    }\n  \t    static Duplicate() {\n  \t        return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  \t    }\n  \t    static PopEvaluatedValue() {\n  \t        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  \t    }\n  \t    static PopFunction() {\n  \t        return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  \t    }\n  \t    static PopTunnel() {\n  \t        return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  \t    }\n  \t    static BeginString() {\n  \t        return new ControlCommand(ControlCommand.CommandType.BeginString);\n  \t    }\n  \t    static EndString() {\n  \t        return new ControlCommand(ControlCommand.CommandType.EndString);\n  \t    }\n  \t    static NoOp() {\n  \t        return new ControlCommand(ControlCommand.CommandType.NoOp);\n  \t    }\n  \t    static ChoiceCount() {\n  \t        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  \t    }\n  \t    static Turns() {\n  \t        return new ControlCommand(ControlCommand.CommandType.Turns);\n  \t    }\n  \t    static TurnsSince() {\n  \t        return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  \t    }\n  \t    static ReadCount() {\n  \t        return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  \t    }\n  \t    static Random() {\n  \t        return new ControlCommand(ControlCommand.CommandType.Random);\n  \t    }\n  \t    static SeedRandom() {\n  \t        return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  \t    }\n  \t    static VisitIndex() {\n  \t        return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  \t    }\n  \t    static SequenceShuffleIndex() {\n  \t        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  \t    }\n  \t    static StartThread() {\n  \t        return new ControlCommand(ControlCommand.CommandType.StartThread);\n  \t    }\n  \t    static Done() {\n  \t        return new ControlCommand(ControlCommand.CommandType.Done);\n  \t    }\n  \t    static End() {\n  \t        return new ControlCommand(ControlCommand.CommandType.End);\n  \t    }\n  \t    static ListFromInt() {\n  \t        return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  \t    }\n  \t    static ListRange() {\n  \t        return new ControlCommand(ControlCommand.CommandType.ListRange);\n  \t    }\n  \t    static ListRandom() {\n  \t        return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  \t    }\n  \t    static BeginTag() {\n  \t        return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  \t    }\n  \t    static EndTag() {\n  \t        return new ControlCommand(ControlCommand.CommandType.EndTag);\n  \t    }\n  \t    toString() {\n  \t        return \"ControlCommand \" + this.commandType.toString();\n  \t    }\n  \t};\n  \tControlCommand.ControlCommand = ControlCommand$1;\n  \t(function (ControlCommand) {\n  \t    (function (CommandType) {\n  \t        CommandType[CommandType[\"NotSet\"] = -1] = \"NotSet\";\n  \t        CommandType[CommandType[\"EvalStart\"] = 0] = \"EvalStart\";\n  \t        CommandType[CommandType[\"EvalOutput\"] = 1] = \"EvalOutput\";\n  \t        CommandType[CommandType[\"EvalEnd\"] = 2] = \"EvalEnd\";\n  \t        CommandType[CommandType[\"Duplicate\"] = 3] = \"Duplicate\";\n  \t        CommandType[CommandType[\"PopEvaluatedValue\"] = 4] = \"PopEvaluatedValue\";\n  \t        CommandType[CommandType[\"PopFunction\"] = 5] = \"PopFunction\";\n  \t        CommandType[CommandType[\"PopTunnel\"] = 6] = \"PopTunnel\";\n  \t        CommandType[CommandType[\"BeginString\"] = 7] = \"BeginString\";\n  \t        CommandType[CommandType[\"EndString\"] = 8] = \"EndString\";\n  \t        CommandType[CommandType[\"NoOp\"] = 9] = \"NoOp\";\n  \t        CommandType[CommandType[\"ChoiceCount\"] = 10] = \"ChoiceCount\";\n  \t        CommandType[CommandType[\"Turns\"] = 11] = \"Turns\";\n  \t        CommandType[CommandType[\"TurnsSince\"] = 12] = \"TurnsSince\";\n  \t        CommandType[CommandType[\"ReadCount\"] = 13] = \"ReadCount\";\n  \t        CommandType[CommandType[\"Random\"] = 14] = \"Random\";\n  \t        CommandType[CommandType[\"SeedRandom\"] = 15] = \"SeedRandom\";\n  \t        CommandType[CommandType[\"VisitIndex\"] = 16] = \"VisitIndex\";\n  \t        CommandType[CommandType[\"SequenceShuffleIndex\"] = 17] = \"SequenceShuffleIndex\";\n  \t        CommandType[CommandType[\"StartThread\"] = 18] = \"StartThread\";\n  \t        CommandType[CommandType[\"Done\"] = 19] = \"Done\";\n  \t        CommandType[CommandType[\"End\"] = 20] = \"End\";\n  \t        CommandType[CommandType[\"ListFromInt\"] = 21] = \"ListFromInt\";\n  \t        CommandType[CommandType[\"ListRange\"] = 22] = \"ListRange\";\n  \t        CommandType[CommandType[\"ListRandom\"] = 23] = \"ListRandom\";\n  \t        CommandType[CommandType[\"BeginTag\"] = 24] = \"BeginTag\";\n  \t        CommandType[CommandType[\"EndTag\"] = 25] = \"EndTag\";\n  \t        CommandType[CommandType[\"TOTAL_VALUES\"] = 26] = \"TOTAL_VALUES\";\n  \t    })(ControlCommand.CommandType || (ControlCommand.CommandType = {}));\n  \t})(ControlCommand$1 || (ControlCommand.ControlCommand = ControlCommand$1 = {}));\n  \t\n  \treturn ControlCommand;\n  }\n\n  var PushPop = {};\n\n  var hasRequiredPushPop;\n\n  function requirePushPop () {\n  \tif (hasRequiredPushPop) return PushPop;\n  \thasRequiredPushPop = 1;\n  \tObject.defineProperty(PushPop, \"__esModule\", { value: true });\n  \tPushPop.PushPopType = void 0;\n  \tvar PushPopType;\n  \t(function (PushPopType) {\n  \t    PushPopType[PushPopType[\"Tunnel\"] = 0] = \"Tunnel\";\n  \t    PushPopType[PushPopType[\"Function\"] = 1] = \"Function\";\n  \t    PushPopType[PushPopType[\"FunctionEvaluationFromGame\"] = 2] = \"FunctionEvaluationFromGame\";\n  \t})(PushPopType || (PushPop.PushPopType = PushPopType = {}));\n  \t\n  \treturn PushPop;\n  }\n\n  var Divert$1 = {};\n\n  var Pointer = {};\n\n  var hasRequiredPointer;\n\n  function requirePointer () {\n  \tif (hasRequiredPointer) return Pointer;\n  \thasRequiredPointer = 1;\n  \tObject.defineProperty(Pointer, \"__esModule\", { value: true });\n  \tPointer.Pointer = void 0;\n  \tconst Path_1 = requirePath$1();\n  \tlet Pointer$1 = class Pointer {\n  \t    constructor() {\n  \t        this.container = null;\n  \t        this.index = -1;\n  \t        if (arguments.length === 2) {\n  \t            this.container = arguments[0];\n  \t            this.index = arguments[1];\n  \t        }\n  \t    }\n  \t    Resolve() {\n  \t        if (this.index < 0)\n  \t            return this.container;\n  \t        if (this.container == null)\n  \t            return null;\n  \t        if (this.container.content.length == 0)\n  \t            return this.container;\n  \t        if (this.index >= this.container.content.length)\n  \t            return null;\n  \t        return this.container.content[this.index];\n  \t    }\n  \t    get isNull() {\n  \t        return this.container == null;\n  \t    }\n  \t    get path() {\n  \t        if (this.isNull)\n  \t            return null;\n  \t        if (this.index >= 0)\n  \t            return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));\n  \t        else\n  \t            return this.container.path;\n  \t    }\n  \t    toString() {\n  \t        if (!this.container)\n  \t            return \"Ink Pointer (null)\";\n  \t        return (\"Ink Pointer -> \" +\n  \t            this.container.path.toString() +\n  \t            \" -- index \" +\n  \t            this.index);\n  \t    }\n  \t    // This method does not exist in the original C# code, but is here to maintain the\n  \t    // value semantics of Pointer.\n  \t    copy() {\n  \t        return new Pointer(this.container, this.index);\n  \t    }\n  \t    static StartOf(container) {\n  \t        return new Pointer(container, 0);\n  \t    }\n  \t    static get Null() {\n  \t        return new Pointer(null, -1);\n  \t    }\n  \t};\n  \tPointer.Pointer = Pointer$1;\n  \t\n  \treturn Pointer;\n  }\n\n  var hasRequiredDivert$1;\n\n  function requireDivert$1 () {\n  \tif (hasRequiredDivert$1) return Divert$1;\n  \thasRequiredDivert$1 = 1;\n  \tObject.defineProperty(Divert$1, \"__esModule\", { value: true });\n  \tDivert$1.Divert = void 0;\n  \tconst Path_1 = requirePath$1();\n  \tconst PushPop_1 = requirePushPop();\n  \tconst StringBuilder_1 = requireStringBuilder();\n  \tconst Object_1 = require_Object$1();\n  \tconst Pointer_1 = requirePointer();\n  \tconst Container_1 = requireContainer();\n  \tconst NullException_1 = requireNullException();\n  \tclass Divert extends Object_1.InkObject {\n  \t    get targetPath() {\n  \t        if (this._targetPath != null && this._targetPath.isRelative) {\n  \t            let targetObj = this.targetPointer.Resolve();\n  \t            if (targetObj) {\n  \t                this._targetPath = targetObj.path;\n  \t            }\n  \t        }\n  \t        return this._targetPath;\n  \t    }\n  \t    set targetPath(value) {\n  \t        this._targetPath = value;\n  \t        this._targetPointer = Pointer_1.Pointer.Null;\n  \t    }\n  \t    get targetPointer() {\n  \t        if (this._targetPointer.isNull) {\n  \t            let targetObj = this.ResolvePath(this._targetPath).obj;\n  \t            if (this._targetPath === null)\n  \t                return (0, NullException_1.throwNullException)(\"this._targetPath\");\n  \t            if (this._targetPath.lastComponent === null)\n  \t                return (0, NullException_1.throwNullException)(\"this._targetPath.lastComponent\");\n  \t            if (this._targetPath.lastComponent.isIndex) {\n  \t                if (targetObj === null)\n  \t                    return (0, NullException_1.throwNullException)(\"targetObj\");\n  \t                this._targetPointer.container =\n  \t                    targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;\n  \t                this._targetPointer.index = this._targetPath.lastComponent.index;\n  \t            }\n  \t            else {\n  \t                this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);\n  \t            }\n  \t        }\n  \t        return this._targetPointer.copy();\n  \t    }\n  \t    get targetPathString() {\n  \t        if (this.targetPath == null)\n  \t            return null;\n  \t        return this.CompactPathString(this.targetPath);\n  \t    }\n  \t    set targetPathString(value) {\n  \t        if (value == null) {\n  \t            this.targetPath = null;\n  \t        }\n  \t        else {\n  \t            this.targetPath = new Path_1.Path(value);\n  \t        }\n  \t    }\n  \t    get hasVariableTarget() {\n  \t        return this.variableDivertName != null;\n  \t    }\n  \t    constructor(stackPushType) {\n  \t        super();\n  \t        this._targetPath = null;\n  \t        this._targetPointer = Pointer_1.Pointer.Null;\n  \t        this.variableDivertName = null;\n  \t        this.pushesToStack = false;\n  \t        this.stackPushType = 0;\n  \t        this.isExternal = false;\n  \t        this.externalArgs = 0;\n  \t        this.isConditional = false;\n  \t        this.pushesToStack = false;\n  \t        if (typeof stackPushType !== \"undefined\") {\n  \t            this.pushesToStack = true;\n  \t            this.stackPushType = stackPushType;\n  \t        }\n  \t    }\n  \t    Equals(obj) {\n  \t        let otherDivert = obj;\n  \t        if (otherDivert instanceof Divert) {\n  \t            if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n  \t                if (this.hasVariableTarget) {\n  \t                    return this.variableDivertName == otherDivert.variableDivertName;\n  \t                }\n  \t                else {\n  \t                    if (this.targetPath === null)\n  \t                        return (0, NullException_1.throwNullException)(\"this.targetPath\");\n  \t                    return this.targetPath.Equals(otherDivert.targetPath);\n  \t                }\n  \t            }\n  \t        }\n  \t        return false;\n  \t    }\n  \t    toString() {\n  \t        if (this.hasVariableTarget) {\n  \t            return \"Divert(variable: \" + this.variableDivertName + \")\";\n  \t        }\n  \t        else if (this.targetPath == null) {\n  \t            return \"Divert(null)\";\n  \t        }\n  \t        else {\n  \t            let sb = new StringBuilder_1.StringBuilder();\n  \t            let targetStr = this.targetPath.toString();\n  \t            sb.Append(\"Divert\");\n  \t            if (this.isConditional)\n  \t                sb.Append(\"?\");\n  \t            if (this.pushesToStack) {\n  \t                if (this.stackPushType == PushPop_1.PushPopType.Function) {\n  \t                    sb.Append(\" function\");\n  \t                }\n  \t                else {\n  \t                    sb.Append(\" tunnel\");\n  \t                }\n  \t            }\n  \t            sb.Append(\" -> \");\n  \t            sb.Append(this.targetPathString);\n  \t            sb.Append(\" (\");\n  \t            sb.Append(targetStr);\n  \t            sb.Append(\")\");\n  \t            return sb.toString();\n  \t        }\n  \t    }\n  \t}\n  \tDivert$1.Divert = Divert;\n  \t\n  \treturn Divert$1;\n  }\n\n  var ChoicePoint = {};\n\n  var hasRequiredChoicePoint;\n\n  function requireChoicePoint () {\n  \tif (hasRequiredChoicePoint) return ChoicePoint;\n  \thasRequiredChoicePoint = 1;\n  \tObject.defineProperty(ChoicePoint, \"__esModule\", { value: true });\n  \tChoicePoint.ChoicePoint = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tconst Path_1 = requirePath$1();\n  \tconst NullException_1 = requireNullException();\n  \tlet ChoicePoint$1 = class ChoicePoint extends Object_1.InkObject {\n  \t    constructor(onceOnly = true) {\n  \t        super();\n  \t        this._pathOnChoice = null;\n  \t        this.hasCondition = false;\n  \t        this.hasStartContent = false;\n  \t        this.hasChoiceOnlyContent = false;\n  \t        this.isInvisibleDefault = false;\n  \t        this.onceOnly = true;\n  \t        this.onceOnly = onceOnly;\n  \t    }\n  \t    get pathOnChoice() {\n  \t        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n  \t            let choiceTargetObj = this.choiceTarget;\n  \t            if (choiceTargetObj) {\n  \t                this._pathOnChoice = choiceTargetObj.path;\n  \t            }\n  \t        }\n  \t        return this._pathOnChoice;\n  \t    }\n  \t    set pathOnChoice(value) {\n  \t        this._pathOnChoice = value;\n  \t    }\n  \t    get choiceTarget() {\n  \t        if (this._pathOnChoice === null)\n  \t            return (0, NullException_1.throwNullException)(\"ChoicePoint._pathOnChoice\");\n  \t        return this.ResolvePath(this._pathOnChoice).container;\n  \t    }\n  \t    get pathStringOnChoice() {\n  \t        if (this.pathOnChoice === null)\n  \t            return (0, NullException_1.throwNullException)(\"ChoicePoint.pathOnChoice\");\n  \t        return this.CompactPathString(this.pathOnChoice);\n  \t    }\n  \t    set pathStringOnChoice(value) {\n  \t        this.pathOnChoice = new Path_1.Path(value);\n  \t    }\n  \t    get flags() {\n  \t        let flags = 0;\n  \t        if (this.hasCondition)\n  \t            flags |= 1;\n  \t        if (this.hasStartContent)\n  \t            flags |= 2;\n  \t        if (this.hasChoiceOnlyContent)\n  \t            flags |= 4;\n  \t        if (this.isInvisibleDefault)\n  \t            flags |= 8;\n  \t        if (this.onceOnly)\n  \t            flags |= 16;\n  \t        return flags;\n  \t    }\n  \t    set flags(value) {\n  \t        this.hasCondition = (value & 1) > 0;\n  \t        this.hasStartContent = (value & 2) > 0;\n  \t        this.hasChoiceOnlyContent = (value & 4) > 0;\n  \t        this.isInvisibleDefault = (value & 8) > 0;\n  \t        this.onceOnly = (value & 16) > 0;\n  \t    }\n  \t    toString() {\n  \t        if (this.pathOnChoice === null)\n  \t            return (0, NullException_1.throwNullException)(\"ChoicePoint.pathOnChoice\");\n  \t        let targetString = this.pathOnChoice.toString();\n  \t        return \"Choice: -> \" + targetString;\n  \t    }\n  \t};\n  \tChoicePoint.ChoicePoint = ChoicePoint$1;\n  \t\n  \treturn ChoicePoint;\n  }\n\n  var VariableReference$1 = {};\n\n  var hasRequiredVariableReference$1;\n\n  function requireVariableReference$1 () {\n  \tif (hasRequiredVariableReference$1) return VariableReference$1;\n  \thasRequiredVariableReference$1 = 1;\n  \tObject.defineProperty(VariableReference$1, \"__esModule\", { value: true });\n  \tVariableReference$1.VariableReference = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tconst Path_1 = requirePath$1();\n  \tclass VariableReference extends Object_1.InkObject {\n  \t    get containerForCount() {\n  \t        if (this.pathForCount === null)\n  \t            return null;\n  \t        return this.ResolvePath(this.pathForCount).container;\n  \t    }\n  \t    get pathStringForCount() {\n  \t        if (this.pathForCount === null)\n  \t            return null;\n  \t        return this.CompactPathString(this.pathForCount);\n  \t    }\n  \t    set pathStringForCount(value) {\n  \t        if (value === null)\n  \t            this.pathForCount = null;\n  \t        else\n  \t            this.pathForCount = new Path_1.Path(value);\n  \t    }\n  \t    constructor(name = null) {\n  \t        super();\n  \t        this.pathForCount = null;\n  \t        this.name = name;\n  \t    }\n  \t    toString() {\n  \t        if (this.name != null) {\n  \t            return \"var(\" + this.name + \")\";\n  \t        }\n  \t        else {\n  \t            let pathStr = this.pathStringForCount;\n  \t            return \"read_count(\" + pathStr + \")\";\n  \t        }\n  \t    }\n  \t}\n  \tVariableReference$1.VariableReference = VariableReference;\n  \t\n  \treturn VariableReference$1;\n  }\n\n  var VariableAssignment$1 = {};\n\n  var hasRequiredVariableAssignment$1;\n\n  function requireVariableAssignment$1 () {\n  \tif (hasRequiredVariableAssignment$1) return VariableAssignment$1;\n  \thasRequiredVariableAssignment$1 = 1;\n  \tObject.defineProperty(VariableAssignment$1, \"__esModule\", { value: true });\n  \tVariableAssignment$1.VariableAssignment = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tclass VariableAssignment extends Object_1.InkObject {\n  \t    constructor(variableName, isNewDeclaration) {\n  \t        super();\n  \t        this.variableName = variableName || null;\n  \t        this.isNewDeclaration = !!isNewDeclaration;\n  \t        this.isGlobal = false;\n  \t    }\n  \t    toString() {\n  \t        return \"VarAssign to \" + this.variableName;\n  \t    }\n  \t}\n  \tVariableAssignment$1.VariableAssignment = VariableAssignment;\n  \t\n  \treturn VariableAssignment$1;\n  }\n\n  var NativeFunctionCall = {};\n\n  var Void = {};\n\n  var hasRequiredVoid;\n\n  function requireVoid () {\n  \tif (hasRequiredVoid) return Void;\n  \thasRequiredVoid = 1;\n  \tObject.defineProperty(Void, \"__esModule\", { value: true });\n  \tVoid.Void = void 0;\n  \tconst Object_1 = require_Object$1();\n  \tlet Void$1 = class Void extends Object_1.InkObject {\n  \t    toString() {\n  \t        return \"Void\";\n  \t    }\n  \t};\n  \tVoid.Void = Void$1;\n  \t\n  \treturn Void;\n  }\n\n  var hasRequiredNativeFunctionCall;\n\n  function requireNativeFunctionCall () {\n  \tif (hasRequiredNativeFunctionCall) return NativeFunctionCall;\n  \thasRequiredNativeFunctionCall = 1;\n  \tObject.defineProperty(NativeFunctionCall, \"__esModule\", { value: true });\n  \tNativeFunctionCall.NativeFunctionCall = void 0;\n  \tconst Value_1 = requireValue();\n  \tconst StoryException_1 = requireStoryException();\n  \tconst Void_1 = requireVoid();\n  \tconst InkList_1 = requireInkList();\n  \tconst Object_1 = require_Object$1();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst NullException_1 = requireNullException();\n  \tlet NativeFunctionCall$1 = class NativeFunctionCall extends Object_1.InkObject {\n  \t    static CallWithName(functionName) {\n  \t        return new NativeFunctionCall(functionName);\n  \t    }\n  \t    static CallExistsWithName(functionName) {\n  \t        this.GenerateNativeFunctionsIfNecessary();\n  \t        return this._nativeFunctions.get(functionName);\n  \t    }\n  \t    get name() {\n  \t        if (this._name === null)\n  \t            return (0, NullException_1.throwNullException)(\"NativeFunctionCall._name\");\n  \t        return this._name;\n  \t    }\n  \t    set name(value) {\n  \t        this._name = value;\n  \t        if (!this._isPrototype) {\n  \t            if (NativeFunctionCall._nativeFunctions === null)\n  \t                (0, NullException_1.throwNullException)(\"NativeFunctionCall._nativeFunctions\");\n  \t            else\n  \t                this._prototype =\n  \t                    NativeFunctionCall._nativeFunctions.get(this._name) || null;\n  \t        }\n  \t    }\n  \t    get numberOfParameters() {\n  \t        if (this._prototype) {\n  \t            return this._prototype.numberOfParameters;\n  \t        }\n  \t        else {\n  \t            return this._numberOfParameters;\n  \t        }\n  \t    }\n  \t    set numberOfParameters(value) {\n  \t        this._numberOfParameters = value;\n  \t    }\n  \t    Call(parameters) {\n  \t        if (this._prototype) {\n  \t            return this._prototype.Call(parameters);\n  \t        }\n  \t        if (this.numberOfParameters != parameters.length) {\n  \t            throw new Error(\"Unexpected number of parameters\");\n  \t        }\n  \t        let hasList = false;\n  \t        for (let p of parameters) {\n  \t            if (p instanceof Void_1.Void)\n  \t                throw new StoryException_1.StoryException(\"Attempting to perform \" +\n  \t                    this.name +\n  \t                    ' on a void value. Did you forget to \"return\" a value from a function you called here?');\n  \t            if (p instanceof Value_1.ListValue)\n  \t                hasList = true;\n  \t        }\n  \t        if (parameters.length == 2 && hasList) {\n  \t            return this.CallBinaryListOperation(parameters);\n  \t        }\n  \t        let coercedParams = this.CoerceValuesToSingleType(parameters);\n  \t        let coercedType = coercedParams[0].valueType;\n  \t        if (coercedType == Value_1.ValueType.Int) {\n  \t            return this.CallType(coercedParams);\n  \t        }\n  \t        else if (coercedType == Value_1.ValueType.Float) {\n  \t            return this.CallType(coercedParams);\n  \t        }\n  \t        else if (coercedType == Value_1.ValueType.String) {\n  \t            return this.CallType(coercedParams);\n  \t        }\n  \t        else if (coercedType == Value_1.ValueType.DivertTarget) {\n  \t            return this.CallType(coercedParams);\n  \t        }\n  \t        else if (coercedType == Value_1.ValueType.List) {\n  \t            return this.CallType(coercedParams);\n  \t        }\n  \t        return null;\n  \t    }\n  \t    CallType(parametersOfSingleType) {\n  \t        let param1 = (0, TypeAssertion_1.asOrThrows)(parametersOfSingleType[0], Value_1.Value);\n  \t        let valType = param1.valueType;\n  \t        let val1 = param1;\n  \t        let paramCount = parametersOfSingleType.length;\n  \t        if (paramCount == 2 || paramCount == 1) {\n  \t            if (this._operationFuncs === null)\n  \t                return (0, NullException_1.throwNullException)(\"NativeFunctionCall._operationFuncs\");\n  \t            let opForTypeObj = this._operationFuncs.get(valType);\n  \t            if (!opForTypeObj) {\n  \t                const key = Value_1.ValueType[valType];\n  \t                throw new StoryException_1.StoryException(\"Cannot perform operation \" + this.name + \" on \" + key);\n  \t            }\n  \t            if (paramCount == 2) {\n  \t                let param2 = (0, TypeAssertion_1.asOrThrows)(parametersOfSingleType[1], Value_1.Value);\n  \t                let val2 = param2;\n  \t                let opForType = opForTypeObj;\n  \t                if (val1.value === null || val2.value === null)\n  \t                    return (0, NullException_1.throwNullException)(\"NativeFunctionCall.Call BinaryOp values\");\n  \t                let resultVal = opForType(val1.value, val2.value);\n  \t                return Value_1.Value.Create(resultVal);\n  \t            }\n  \t            else {\n  \t                let opForType = opForTypeObj;\n  \t                if (val1.value === null)\n  \t                    return (0, NullException_1.throwNullException)(\"NativeFunctionCall.Call UnaryOp value\");\n  \t                let resultVal = opForType(val1.value);\n  \t                // This code is different from upstream. Since JavaScript treats\n  \t                // integers and floats as the same numbers, it's impossible\n  \t                // to force an number to be either an integer or a float.\n  \t                //\n  \t                // It can be useful to force a specific number type\n  \t                // (especially for divisions), so the result of INT() & FLOAT()\n  \t                // is coerced to the the proper value type.\n  \t                //\n  \t                // Note that we also force all other unary operation to\n  \t                // return the same value type, although this is only\n  \t                // meaningful for numbers. See `Value.Create`.\n  \t                if (this.name === NativeFunctionCall.Int) {\n  \t                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Int);\n  \t                }\n  \t                else if (this.name === NativeFunctionCall.Float) {\n  \t                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Float);\n  \t                }\n  \t                else {\n  \t                    return Value_1.Value.Create(resultVal, param1.valueType);\n  \t                }\n  \t            }\n  \t        }\n  \t        else {\n  \t            throw new Error(\"Unexpected number of parameters to NativeFunctionCall: \" +\n  \t                parametersOfSingleType.length);\n  \t        }\n  \t    }\n  \t    CallBinaryListOperation(parameters) {\n  \t        if ((this.name == \"+\" || this.name == \"-\") &&\n  \t            parameters[0] instanceof Value_1.ListValue &&\n  \t            parameters[1] instanceof Value_1.IntValue)\n  \t            return this.CallListIncrementOperation(parameters);\n  \t        let v1 = (0, TypeAssertion_1.asOrThrows)(parameters[0], Value_1.Value);\n  \t        let v2 = (0, TypeAssertion_1.asOrThrows)(parameters[1], Value_1.Value);\n  \t        if ((this.name == \"&&\" || this.name == \"||\") &&\n  \t            (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {\n  \t            if (this._operationFuncs === null)\n  \t                return (0, NullException_1.throwNullException)(\"NativeFunctionCall._operationFuncs\");\n  \t            let op = this._operationFuncs.get(Value_1.ValueType.Int);\n  \t            if (op === null)\n  \t                return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallBinaryListOperation op\");\n  \t            let result = (0, TypeAssertion_1.asBooleanOrThrows)(op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0));\n  \t            return new Value_1.BoolValue(result);\n  \t        }\n  \t        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List)\n  \t            return this.CallType([v1, v2]);\n  \t        throw new StoryException_1.StoryException(\"Can not call use \" +\n  \t            this.name +\n  \t            \" operation on \" +\n  \t            Value_1.ValueType[v1.valueType] +\n  \t            \" and \" +\n  \t            Value_1.ValueType[v2.valueType]);\n  \t    }\n  \t    CallListIncrementOperation(listIntParams) {\n  \t        let listVal = (0, TypeAssertion_1.asOrThrows)(listIntParams[0], Value_1.ListValue);\n  \t        let intVal = (0, TypeAssertion_1.asOrThrows)(listIntParams[1], Value_1.IntValue);\n  \t        let resultInkList = new InkList_1.InkList();\n  \t        if (listVal.value === null)\n  \t            return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallListIncrementOperation listVal.value\");\n  \t        for (let [listItemKey, listItemValue] of listVal.value) {\n  \t            let listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);\n  \t            if (this._operationFuncs === null)\n  \t                return (0, NullException_1.throwNullException)(\"NativeFunctionCall._operationFuncs\");\n  \t            let intOp = this._operationFuncs.get(Value_1.ValueType.Int);\n  \t            if (intVal.value === null)\n  \t                return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallListIncrementOperation intVal.value\");\n  \t            let targetInt = intOp(listItemValue, intVal.value);\n  \t            let itemOrigin = null;\n  \t            if (listVal.value.origins === null)\n  \t                return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\");\n  \t            for (let origin of listVal.value.origins) {\n  \t                if (origin.name == listItem.originName) {\n  \t                    itemOrigin = origin;\n  \t                    break;\n  \t                }\n  \t            }\n  \t            if (itemOrigin != null) {\n  \t                let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);\n  \t                if (incrementedItem.exists)\n  \t                    resultInkList.Add(incrementedItem.result, targetInt);\n  \t            }\n  \t        }\n  \t        return new Value_1.ListValue(resultInkList);\n  \t    }\n  \t    CoerceValuesToSingleType(parametersIn) {\n  \t        let valType = Value_1.ValueType.Int;\n  \t        let specialCaseList = null;\n  \t        for (let obj of parametersIn) {\n  \t            let val = (0, TypeAssertion_1.asOrThrows)(obj, Value_1.Value);\n  \t            if (val.valueType > valType) {\n  \t                valType = val.valueType;\n  \t            }\n  \t            if (val.valueType == Value_1.ValueType.List) {\n  \t                specialCaseList = (0, TypeAssertion_1.asOrNull)(val, Value_1.ListValue);\n  \t            }\n  \t        }\n  \t        let parametersOut = [];\n  \t        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {\n  \t            for (let inkObjectVal of parametersIn) {\n  \t                let val = (0, TypeAssertion_1.asOrThrows)(inkObjectVal, Value_1.Value);\n  \t                if (val.valueType == Value_1.ValueType.List) {\n  \t                    parametersOut.push(val);\n  \t                }\n  \t                else if (val.valueType == Value_1.ValueType.Int) {\n  \t                    let intVal = parseInt(val.valueObject);\n  \t                    specialCaseList = (0, TypeAssertion_1.asOrThrows)(specialCaseList, Value_1.ListValue);\n  \t                    if (specialCaseList.value === null)\n  \t                        return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\");\n  \t                    let list = specialCaseList.value.originOfMaxItem;\n  \t                    if (list === null)\n  \t                        return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CoerceValuesToSingleType list\");\n  \t                    let item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);\n  \t                    if (item.exists) {\n  \t                        let castedValue = new Value_1.ListValue(item.result, intVal);\n  \t                        parametersOut.push(castedValue);\n  \t                    }\n  \t                    else\n  \t                        throw new StoryException_1.StoryException(\"Could not find List item with the value \" +\n  \t                            intVal +\n  \t                            \" in \" +\n  \t                            list.name);\n  \t                }\n  \t                else {\n  \t                    const key = Value_1.ValueType[val.valueType];\n  \t                    throw new StoryException_1.StoryException(\"Cannot mix Lists and \" + key + \" values in this operation\");\n  \t                }\n  \t            }\n  \t        }\n  \t        else {\n  \t            for (let inkObjectVal of parametersIn) {\n  \t                let val = (0, TypeAssertion_1.asOrThrows)(inkObjectVal, Value_1.Value);\n  \t                let castedValue = val.Cast(valType);\n  \t                parametersOut.push(castedValue);\n  \t            }\n  \t        }\n  \t        return parametersOut;\n  \t    }\n  \t    constructor() {\n  \t        super();\n  \t        this._name = null;\n  \t        this._numberOfParameters = 0;\n  \t        this._prototype = null;\n  \t        this._isPrototype = false;\n  \t        this._operationFuncs = null;\n  \t        if (arguments.length === 0) {\n  \t            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n  \t        }\n  \t        else if (arguments.length === 1) {\n  \t            let name = arguments[0];\n  \t            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n  \t            this.name = name;\n  \t        }\n  \t        else if (arguments.length === 2) {\n  \t            let name = arguments[0];\n  \t            let numberOfParameters = arguments[1];\n  \t            this._isPrototype = true;\n  \t            this.name = name;\n  \t            this.numberOfParameters = numberOfParameters;\n  \t        }\n  \t    }\n  \t    static Identity(t) {\n  \t        return t;\n  \t    }\n  \t    static GenerateNativeFunctionsIfNecessary() {\n  \t        if (this._nativeFunctions == null) {\n  \t            this._nativeFunctions = new Map();\n  \t            // Int operations\n  \t            this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n  \t            this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n  \t            this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n  \t            this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n  \t            this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n  \t            this.AddIntUnaryOp(this.Negate, (x) => -x);\n  \t            this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n  \t            this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n  \t            this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n  \t            this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n  \t            this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n  \t            this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n  \t            this.AddIntUnaryOp(this.Not, (x) => x == 0);\n  \t            this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n  \t            this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n  \t            this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n  \t            this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n  \t            this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n  \t            this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n  \t            this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n  \t            this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n  \t            this.AddIntUnaryOp(this.Float, (x) => x);\n  \t            // Float operations\n  \t            this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n  \t            this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n  \t            this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n  \t            this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n  \t            this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n  \t            this.AddFloatUnaryOp(this.Negate, (x) => -x);\n  \t            this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n  \t            this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n  \t            this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n  \t            this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n  \t            this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n  \t            this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n  \t            this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n  \t            this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n  \t            this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n  \t            this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n  \t            this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n  \t            this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n  \t            this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n  \t            this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n  \t            this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n  \t            this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n  \t            // String operations\n  \t            this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n  \t            this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n  \t            this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n  \t            this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n  \t            this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n  \t            this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n  \t            this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n  \t            this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n  \t            this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n  \t            this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n  \t            this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n  \t            this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n  \t            this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n  \t            this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y));\n  \t            this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y));\n  \t            this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n  \t            this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n  \t            this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n  \t            this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n  \t            this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n  \t            this.AddListUnaryOp(this.All, (x) => x.all);\n  \t            this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n  \t            this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n  \t            this.AddListUnaryOp(this.Count, (x) => x.Count);\n  \t            this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n  \t            let divertTargetsEqual = (d1, d2) => d1.Equals(d2);\n  \t            let divertTargetsNotEqual = (d1, d2) => !d1.Equals(d2);\n  \t            this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);\n  \t            this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);\n  \t        }\n  \t    }\n  \t    AddOpFuncForType(valType, op) {\n  \t        if (this._operationFuncs == null) {\n  \t            this._operationFuncs = new Map();\n  \t        }\n  \t        this._operationFuncs.set(valType, op);\n  \t    }\n  \t    static AddOpToNativeFunc(name, args, valType, op) {\n  \t        if (this._nativeFunctions === null)\n  \t            return (0, NullException_1.throwNullException)(\"NativeFunctionCall._nativeFunctions\");\n  \t        let nativeFunc = this._nativeFunctions.get(name);\n  \t        if (!nativeFunc) {\n  \t            nativeFunc = new NativeFunctionCall(name, args);\n  \t            this._nativeFunctions.set(name, nativeFunc);\n  \t        }\n  \t        nativeFunc.AddOpFuncForType(valType, op);\n  \t    }\n  \t    static AddIntBinaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);\n  \t    }\n  \t    static AddIntUnaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);\n  \t    }\n  \t    static AddFloatBinaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);\n  \t    }\n  \t    static AddFloatUnaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);\n  \t    }\n  \t    static AddStringBinaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);\n  \t    }\n  \t    static AddListBinaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);\n  \t    }\n  \t    static AddListUnaryOp(name, op) {\n  \t        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);\n  \t    }\n  \t    toString() {\n  \t        return 'Native \"' + this.name + '\"';\n  \t    }\n  \t};\n  \tNativeFunctionCall.NativeFunctionCall = NativeFunctionCall$1;\n  \tNativeFunctionCall$1.Add = \"+\";\n  \tNativeFunctionCall$1.Subtract = \"-\";\n  \tNativeFunctionCall$1.Divide = \"/\";\n  \tNativeFunctionCall$1.Multiply = \"*\";\n  \tNativeFunctionCall$1.Mod = \"%\";\n  \tNativeFunctionCall$1.Negate = \"_\";\n  \tNativeFunctionCall$1.Equal = \"==\";\n  \tNativeFunctionCall$1.Greater = \">\";\n  \tNativeFunctionCall$1.Less = \"<\";\n  \tNativeFunctionCall$1.GreaterThanOrEquals = \">=\";\n  \tNativeFunctionCall$1.LessThanOrEquals = \"<=\";\n  \tNativeFunctionCall$1.NotEquals = \"!=\";\n  \tNativeFunctionCall$1.Not = \"!\";\n  \tNativeFunctionCall$1.And = \"&&\";\n  \tNativeFunctionCall$1.Or = \"||\";\n  \tNativeFunctionCall$1.Min = \"MIN\";\n  \tNativeFunctionCall$1.Max = \"MAX\";\n  \tNativeFunctionCall$1.Pow = \"POW\";\n  \tNativeFunctionCall$1.Floor = \"FLOOR\";\n  \tNativeFunctionCall$1.Ceiling = \"CEILING\";\n  \tNativeFunctionCall$1.Int = \"INT\";\n  \tNativeFunctionCall$1.Float = \"FLOAT\";\n  \tNativeFunctionCall$1.Has = \"?\";\n  \tNativeFunctionCall$1.Hasnt = \"!?\";\n  \tNativeFunctionCall$1.Intersect = \"^\";\n  \tNativeFunctionCall$1.ListMin = \"LIST_MIN\";\n  \tNativeFunctionCall$1.ListMax = \"LIST_MAX\";\n  \tNativeFunctionCall$1.All = \"LIST_ALL\";\n  \tNativeFunctionCall$1.Count = \"LIST_COUNT\";\n  \tNativeFunctionCall$1.ValueOfList = \"LIST_VALUE\";\n  \tNativeFunctionCall$1.Invert = \"LIST_INVERT\";\n  \tNativeFunctionCall$1._nativeFunctions = null;\n  \t\n  \treturn NativeFunctionCall;\n  }\n\n  var Tag$1 = {};\n\n  var hasRequiredTag$1;\n\n  function requireTag$1 () {\n  \tif (hasRequiredTag$1) return Tag$1;\n  \thasRequiredTag$1 = 1;\n  \tObject.defineProperty(Tag$1, \"__esModule\", { value: true });\n  \tTag$1.Tag = void 0;\n  \tconst Object_1 = require_Object$1();\n  \t// New version of tags is dynamic - it constructs the tags\n  \t// at runtime based on BeginTag and EndTag control commands.\n  \t// Plain text that's in the output stream is turned into tags\n  \t// when you do story.currentTags.\n  \t// The only place this is used is when flattening tags down\n  \t// to string in advance, during dynamic string generation if\n  \t// there's a tag embedded in it. See how ControlCommand.EndString\n  \t// is implemented in Story.cs for more details + comment\n  \tclass Tag extends Object_1.InkObject {\n  \t    constructor(tagText) {\n  \t        super();\n  \t        this.text = tagText.toString() || \"\";\n  \t    }\n  \t    toString() {\n  \t        return \"# \" + this.text;\n  \t    }\n  \t}\n  \tTag$1.Tag = Tag;\n  \t\n  \treturn Tag$1;\n  }\n\n  var Choice$1 = {};\n\n  var hasRequiredChoice$1;\n\n  function requireChoice$1 () {\n  \tif (hasRequiredChoice$1) return Choice$1;\n  \thasRequiredChoice$1 = 1;\n  \tObject.defineProperty(Choice$1, \"__esModule\", { value: true });\n  \tChoice$1.Choice = void 0;\n  \tconst Path_1 = requirePath$1();\n  \tconst NullException_1 = requireNullException();\n  \tconst Object_1 = require_Object$1();\n  \tclass Choice extends Object_1.InkObject {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.text = \"\";\n  \t        this.index = 0;\n  \t        this.threadAtGeneration = null;\n  \t        this.sourcePath = \"\";\n  \t        this.targetPath = null;\n  \t        this.isInvisibleDefault = false;\n  \t        this.tags = null;\n  \t        this.originalThreadIndex = 0;\n  \t    }\n  \t    get pathStringOnChoice() {\n  \t        if (this.targetPath === null)\n  \t            return (0, NullException_1.throwNullException)(\"Choice.targetPath\");\n  \t        return this.targetPath.toString();\n  \t    }\n  \t    set pathStringOnChoice(value) {\n  \t        this.targetPath = new Path_1.Path(value);\n  \t    }\n  \t    Clone() {\n  \t        let copy = new Choice();\n  \t        copy.text = this.text;\n  \t        copy.sourcePath = this.sourcePath;\n  \t        copy.index = this.index;\n  \t        copy.targetPath = this.targetPath;\n  \t        copy.originalThreadIndex = this.originalThreadIndex;\n  \t        copy.isInvisibleDefault = this.isInvisibleDefault;\n  \t        if (this.threadAtGeneration !== null)\n  \t            copy.threadAtGeneration = this.threadAtGeneration.Copy();\n  \t        return copy;\n  \t    }\n  \t}\n  \tChoice$1.Choice = Choice;\n  \t\n  \treturn Choice$1;\n  }\n\n  var ListDefinition$1 = {};\n\n  var hasRequiredListDefinition$1;\n\n  function requireListDefinition$1 () {\n  \tif (hasRequiredListDefinition$1) return ListDefinition$1;\n  \thasRequiredListDefinition$1 = 1;\n  \tObject.defineProperty(ListDefinition$1, \"__esModule\", { value: true });\n  \tListDefinition$1.ListDefinition = void 0;\n  \tconst InkList_1 = requireInkList();\n  \tclass ListDefinition {\n  \t    constructor(name, items) {\n  \t        this._name = name || \"\";\n  \t        this._items = null;\n  \t        this._itemNameToValues = items || new Map();\n  \t    }\n  \t    get name() {\n  \t        return this._name;\n  \t    }\n  \t    get items() {\n  \t        if (this._items == null) {\n  \t            this._items = new Map();\n  \t            for (let [key, value] of this._itemNameToValues) {\n  \t                let item = new InkList_1.InkListItem(this.name, key);\n  \t                this._items.set(item.serialized(), value);\n  \t            }\n  \t        }\n  \t        return this._items;\n  \t    }\n  \t    ValueForItem(item) {\n  \t        if (!item.itemName)\n  \t            return 0;\n  \t        let intVal = this._itemNameToValues.get(item.itemName);\n  \t        if (typeof intVal !== \"undefined\")\n  \t            return intVal;\n  \t        else\n  \t            return 0;\n  \t    }\n  \t    ContainsItem(item) {\n  \t        if (!item.itemName)\n  \t            return false;\n  \t        if (item.originName != this.name)\n  \t            return false;\n  \t        return this._itemNameToValues.has(item.itemName);\n  \t    }\n  \t    ContainsItemWithName(itemName) {\n  \t        return this._itemNameToValues.has(itemName);\n  \t    }\n  \t    TryGetItemWithValue(val, \n  \t    /* out */ item) {\n  \t        for (let [key, value] of this._itemNameToValues) {\n  \t            if (value == val) {\n  \t                item = new InkList_1.InkListItem(this.name, key);\n  \t                return { result: item, exists: true };\n  \t            }\n  \t        }\n  \t        item = InkList_1.InkListItem.Null;\n  \t        return { result: item, exists: false };\n  \t    }\n  \t    TryGetValueForItem(item, \n  \t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t    /* out */ intVal) {\n  \t        if (!item.itemName)\n  \t            return { result: 0, exists: false };\n  \t        let value = this._itemNameToValues.get(item.itemName);\n  \t        if (!value)\n  \t            return { result: 0, exists: false };\n  \t        return { result: value, exists: true };\n  \t    }\n  \t}\n  \tListDefinition$1.ListDefinition = ListDefinition;\n  \t\n  \treturn ListDefinition$1;\n  }\n\n  var ListDefinitionsOrigin = {};\n\n  var hasRequiredListDefinitionsOrigin;\n\n  function requireListDefinitionsOrigin () {\n  \tif (hasRequiredListDefinitionsOrigin) return ListDefinitionsOrigin;\n  \thasRequiredListDefinitionsOrigin = 1;\n  \tObject.defineProperty(ListDefinitionsOrigin, \"__esModule\", { value: true });\n  \tListDefinitionsOrigin.ListDefinitionsOrigin = void 0;\n  \tconst InkList_1 = requireInkList();\n  \tconst Value_1 = requireValue();\n  \tconst NullException_1 = requireNullException();\n  \tlet ListDefinitionsOrigin$1 = class ListDefinitionsOrigin {\n  \t    constructor(lists) {\n  \t        this._lists = new Map();\n  \t        this._allUnambiguousListValueCache = new Map();\n  \t        for (let list of lists) {\n  \t            this._lists.set(list.name, list);\n  \t            for (let [key, val] of list.items) {\n  \t                let item = InkList_1.InkListItem.fromSerializedKey(key);\n  \t                let listValue = new Value_1.ListValue(item, val);\n  \t                if (!item.itemName) {\n  \t                    throw new Error(\"item.itemName is null or undefined.\");\n  \t                }\n  \t                this._allUnambiguousListValueCache.set(item.itemName, listValue);\n  \t                this._allUnambiguousListValueCache.set(item.fullName, listValue);\n  \t            }\n  \t        }\n  \t    }\n  \t    get lists() {\n  \t        let listOfLists = [];\n  \t        for (let [, value] of this._lists) {\n  \t            listOfLists.push(value);\n  \t        }\n  \t        return listOfLists;\n  \t    }\n  \t    TryListGetDefinition(name, \n  \t    /* out */ def) {\n  \t        if (name === null) {\n  \t            return { result: def, exists: false };\n  \t        }\n  \t        // initially, this function returns a boolean and the second parameter is an out.\n  \t        let definition = this._lists.get(name);\n  \t        if (!definition)\n  \t            return { result: def, exists: false };\n  \t        return { result: definition, exists: true };\n  \t    }\n  \t    FindSingleItemListWithName(name) {\n  \t        if (name === null) {\n  \t            return (0, NullException_1.throwNullException)(\"name\");\n  \t        }\n  \t        let val = this._allUnambiguousListValueCache.get(name);\n  \t        if (typeof val !== \"undefined\") {\n  \t            return val;\n  \t        }\n  \t        return null;\n  \t    }\n  \t};\n  \tListDefinitionsOrigin.ListDefinitionsOrigin = ListDefinitionsOrigin$1;\n  \t\n  \treturn ListDefinitionsOrigin;\n  }\n\n  var hasRequiredJsonSerialisation;\n\n  function requireJsonSerialisation () {\n  \tif (hasRequiredJsonSerialisation) return JsonSerialisation;\n  \thasRequiredJsonSerialisation = 1;\n  \tObject.defineProperty(JsonSerialisation, \"__esModule\", { value: true });\n  \tJsonSerialisation.JsonSerialisation = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst Value_1 = requireValue();\n  \tconst Glue_1 = requireGlue$1();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst PushPop_1 = requirePushPop();\n  \tconst Divert_1 = requireDivert$1();\n  \tconst ChoicePoint_1 = requireChoicePoint();\n  \tconst VariableReference_1 = requireVariableReference$1();\n  \tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst Void_1 = requireVoid();\n  \tconst Tag_1 = requireTag$1();\n  \tconst Path_1 = requirePath$1();\n  \tconst Choice_1 = requireChoice$1();\n  \tconst ListDefinition_1 = requireListDefinition$1();\n  \tconst ListDefinitionsOrigin_1 = requireListDefinitionsOrigin();\n  \tconst InkList_1 = requireInkList();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst NullException_1 = requireNullException();\n  \tlet JsonSerialisation$1 = class JsonSerialisation {\n  \t    static JArrayToRuntimeObjList(jArray, skipLast = false) {\n  \t        let count = jArray.length;\n  \t        if (skipLast)\n  \t            count--;\n  \t        let list = [];\n  \t        for (let i = 0; i < count; i++) {\n  \t            let jTok = jArray[i];\n  \t            let runtimeObj = this.JTokenToRuntimeObject(jTok);\n  \t            if (runtimeObj === null) {\n  \t                return (0, NullException_1.throwNullException)(\"runtimeObj\");\n  \t            }\n  \t            list.push(runtimeObj);\n  \t        }\n  \t        return list;\n  \t    }\n  \t    static WriteDictionaryRuntimeObjs(writer, dictionary) {\n  \t        writer.WriteObjectStart();\n  \t        for (let [key, value] of dictionary) {\n  \t            writer.WritePropertyStart(key);\n  \t            this.WriteRuntimeObject(writer, value);\n  \t            writer.WritePropertyEnd();\n  \t        }\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    static WriteListRuntimeObjs(writer, list) {\n  \t        writer.WriteArrayStart();\n  \t        for (let value of list) {\n  \t            this.WriteRuntimeObject(writer, value);\n  \t        }\n  \t        writer.WriteArrayEnd();\n  \t    }\n  \t    static WriteIntDictionary(writer, dict) {\n  \t        writer.WriteObjectStart();\n  \t        for (let [key, value] of dict) {\n  \t            writer.WriteIntProperty(key, value);\n  \t        }\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    static WriteRuntimeObject(writer, obj) {\n  \t        let container = (0, TypeAssertion_1.asOrNull)(obj, Container_1.Container);\n  \t        if (container) {\n  \t            this.WriteRuntimeContainer(writer, container);\n  \t            return;\n  \t        }\n  \t        let divert = (0, TypeAssertion_1.asOrNull)(obj, Divert_1.Divert);\n  \t        if (divert) {\n  \t            let divTypeKey = \"->\";\n  \t            if (divert.isExternal) {\n  \t                divTypeKey = \"x()\";\n  \t            }\n  \t            else if (divert.pushesToStack) {\n  \t                if (divert.stackPushType == PushPop_1.PushPopType.Function) {\n  \t                    divTypeKey = \"f()\";\n  \t                }\n  \t                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {\n  \t                    divTypeKey = \"->t->\";\n  \t                }\n  \t            }\n  \t            let targetStr;\n  \t            if (divert.hasVariableTarget) {\n  \t                targetStr = divert.variableDivertName;\n  \t            }\n  \t            else {\n  \t                targetStr = divert.targetPathString;\n  \t            }\n  \t            writer.WriteObjectStart();\n  \t            writer.WriteProperty(divTypeKey, targetStr);\n  \t            if (divert.hasVariableTarget) {\n  \t                writer.WriteProperty(\"var\", true);\n  \t            }\n  \t            if (divert.isConditional) {\n  \t                writer.WriteProperty(\"c\", true);\n  \t            }\n  \t            if (divert.externalArgs > 0) {\n  \t                writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n  \t            }\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let choicePoint = (0, TypeAssertion_1.asOrNull)(obj, ChoicePoint_1.ChoicePoint);\n  \t        if (choicePoint) {\n  \t            writer.WriteObjectStart();\n  \t            writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n  \t            writer.WriteIntProperty(\"flg\", choicePoint.flags);\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let boolVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.BoolValue);\n  \t        if (boolVal) {\n  \t            writer.WriteBool(boolVal.value);\n  \t            return;\n  \t        }\n  \t        let intVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.IntValue);\n  \t        if (intVal) {\n  \t            writer.WriteInt(intVal.value);\n  \t            return;\n  \t        }\n  \t        let floatVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.FloatValue);\n  \t        if (floatVal) {\n  \t            writer.WriteFloat(floatVal.value);\n  \t            return;\n  \t        }\n  \t        let strVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n  \t        if (strVal) {\n  \t            if (strVal.isNewline) {\n  \t                writer.Write(\"\\n\", false);\n  \t            }\n  \t            else {\n  \t                writer.WriteStringStart();\n  \t                writer.WriteStringInner(\"^\");\n  \t                writer.WriteStringInner(strVal.value);\n  \t                writer.WriteStringEnd();\n  \t            }\n  \t            return;\n  \t        }\n  \t        let listVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.ListValue);\n  \t        if (listVal) {\n  \t            this.WriteInkList(writer, listVal);\n  \t            return;\n  \t        }\n  \t        let divTargetVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.DivertTargetValue);\n  \t        if (divTargetVal) {\n  \t            writer.WriteObjectStart();\n  \t            if (divTargetVal.value === null) {\n  \t                return (0, NullException_1.throwNullException)(\"divTargetVal.value\");\n  \t            }\n  \t            writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let varPtrVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.VariablePointerValue);\n  \t        if (varPtrVal) {\n  \t            writer.WriteObjectStart();\n  \t            writer.WriteProperty(\"^var\", varPtrVal.value);\n  \t            writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let glue = (0, TypeAssertion_1.asOrNull)(obj, Glue_1.Glue);\n  \t        if (glue) {\n  \t            writer.Write(\"<>\");\n  \t            return;\n  \t        }\n  \t        let controlCmd = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n  \t        if (controlCmd) {\n  \t            writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);\n  \t            return;\n  \t        }\n  \t        let nativeFunc = (0, TypeAssertion_1.asOrNull)(obj, NativeFunctionCall_1.NativeFunctionCall);\n  \t        if (nativeFunc) {\n  \t            let name = nativeFunc.name;\n  \t            if (name == \"^\")\n  \t                name = \"L^\";\n  \t            writer.Write(name);\n  \t            return;\n  \t        }\n  \t        let varRef = (0, TypeAssertion_1.asOrNull)(obj, VariableReference_1.VariableReference);\n  \t        if (varRef) {\n  \t            writer.WriteObjectStart();\n  \t            let readCountPath = varRef.pathStringForCount;\n  \t            if (readCountPath != null) {\n  \t                writer.WriteProperty(\"CNT?\", readCountPath);\n  \t            }\n  \t            else {\n  \t                writer.WriteProperty(\"VAR?\", varRef.name);\n  \t            }\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let varAss = (0, TypeAssertion_1.asOrNull)(obj, VariableAssignment_1.VariableAssignment);\n  \t        if (varAss) {\n  \t            writer.WriteObjectStart();\n  \t            let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n  \t            writer.WriteProperty(key, varAss.variableName);\n  \t            // Reassignment?\n  \t            if (!varAss.isNewDeclaration)\n  \t                writer.WriteProperty(\"re\", true);\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let voidObj = (0, TypeAssertion_1.asOrNull)(obj, Void_1.Void);\n  \t        if (voidObj) {\n  \t            writer.Write(\"void\");\n  \t            return;\n  \t        }\n  \t        let tag = (0, TypeAssertion_1.asOrNull)(obj, Tag_1.Tag);\n  \t        if (tag) {\n  \t            writer.WriteObjectStart();\n  \t            writer.WriteProperty(\"#\", tag.text);\n  \t            writer.WriteObjectEnd();\n  \t            return;\n  \t        }\n  \t        let choice = (0, TypeAssertion_1.asOrNull)(obj, Choice_1.Choice);\n  \t        if (choice) {\n  \t            this.WriteChoice(writer, choice);\n  \t            return;\n  \t        }\n  \t        throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  \t    }\n  \t    static JObjectToDictionaryRuntimeObjs(jObject) {\n  \t        let dict = new Map();\n  \t        for (let key in jObject) {\n  \t            if (jObject.hasOwnProperty(key)) {\n  \t                let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n  \t                if (inkObject === null) {\n  \t                    return (0, NullException_1.throwNullException)(\"inkObject\");\n  \t                }\n  \t                dict.set(key, inkObject);\n  \t            }\n  \t        }\n  \t        return dict;\n  \t    }\n  \t    static JObjectToIntDictionary(jObject) {\n  \t        let dict = new Map();\n  \t        for (let key in jObject) {\n  \t            if (jObject.hasOwnProperty(key)) {\n  \t                dict.set(key, parseInt(jObject[key]));\n  \t            }\n  \t        }\n  \t        return dict;\n  \t    }\n  \t    static JTokenToRuntimeObject(token) {\n  \t        if ((typeof token === \"number\" && !isNaN(token)) ||\n  \t            typeof token === \"boolean\") {\n  \t            return Value_1.Value.Create(token);\n  \t        }\n  \t        if (typeof token === \"string\") {\n  \t            let str = token.toString();\n  \t            //Explicit float value of the form \"123.00f\"\n  \t            const floatRepresentation = /^([0-9]+.[0-9]+f)$/.exec(str);\n  \t            if (floatRepresentation) {\n  \t                return new Value_1.FloatValue(parseFloat(floatRepresentation[0]));\n  \t            }\n  \t            // String value\n  \t            let firstChar = str[0];\n  \t            if (firstChar == \"^\")\n  \t                return new Value_1.StringValue(str.substring(1));\n  \t            else if (firstChar == \"\\n\" && str.length == 1)\n  \t                return new Value_1.StringValue(\"\\n\");\n  \t            // Glue\n  \t            if (str == \"<>\")\n  \t                return new Glue_1.Glue();\n  \t            // Control commands (would looking up in a hash set be faster?)\n  \t            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n  \t                let cmdName = JsonSerialisation._controlCommandNames[i];\n  \t                if (str == cmdName) {\n  \t                    return new ControlCommand_1.ControlCommand(i);\n  \t                }\n  \t            }\n  \t            // Native functions\n  \t            if (str == \"L^\")\n  \t                str = \"^\";\n  \t            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))\n  \t                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);\n  \t            // Pop\n  \t            if (str == \"->->\")\n  \t                return ControlCommand_1.ControlCommand.PopTunnel();\n  \t            else if (str == \"~ret\")\n  \t                return ControlCommand_1.ControlCommand.PopFunction();\n  \t            // Void\n  \t            if (str == \"void\")\n  \t                return new Void_1.Void();\n  \t        }\n  \t        if (typeof token === \"object\" && !Array.isArray(token)) {\n  \t            let obj = token;\n  \t            let propValue;\n  \t            // Divert target value to path\n  \t            if (obj[\"^->\"]) {\n  \t                propValue = obj[\"^->\"];\n  \t                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));\n  \t            }\n  \t            // VariablePointerValue\n  \t            if (obj[\"^var\"]) {\n  \t                propValue = obj[\"^var\"];\n  \t                let varPtr = new Value_1.VariablePointerValue(propValue.toString());\n  \t                if (\"ci\" in obj) {\n  \t                    propValue = obj[\"ci\"];\n  \t                    varPtr.contextIndex = parseInt(propValue);\n  \t                }\n  \t                return varPtr;\n  \t            }\n  \t            // Divert\n  \t            let isDivert = false;\n  \t            let pushesToStack = false;\n  \t            let divPushType = PushPop_1.PushPopType.Function;\n  \t            let external = false;\n  \t            if ((propValue = obj[\"->\"])) {\n  \t                isDivert = true;\n  \t            }\n  \t            else if ((propValue = obj[\"f()\"])) {\n  \t                isDivert = true;\n  \t                pushesToStack = true;\n  \t                divPushType = PushPop_1.PushPopType.Function;\n  \t            }\n  \t            else if ((propValue = obj[\"->t->\"])) {\n  \t                isDivert = true;\n  \t                pushesToStack = true;\n  \t                divPushType = PushPop_1.PushPopType.Tunnel;\n  \t            }\n  \t            else if ((propValue = obj[\"x()\"])) {\n  \t                isDivert = true;\n  \t                external = true;\n  \t                pushesToStack = false;\n  \t                divPushType = PushPop_1.PushPopType.Function;\n  \t            }\n  \t            if (isDivert) {\n  \t                let divert = new Divert_1.Divert();\n  \t                divert.pushesToStack = pushesToStack;\n  \t                divert.stackPushType = divPushType;\n  \t                divert.isExternal = external;\n  \t                let target = propValue.toString();\n  \t                if ((propValue = obj[\"var\"]))\n  \t                    divert.variableDivertName = target;\n  \t                else\n  \t                    divert.targetPathString = target;\n  \t                divert.isConditional = !!obj[\"c\"];\n  \t                if (external) {\n  \t                    if ((propValue = obj[\"exArgs\"]))\n  \t                        divert.externalArgs = parseInt(propValue);\n  \t                }\n  \t                return divert;\n  \t            }\n  \t            // Choice\n  \t            if ((propValue = obj[\"*\"])) {\n  \t                let choice = new ChoicePoint_1.ChoicePoint();\n  \t                choice.pathStringOnChoice = propValue.toString();\n  \t                if ((propValue = obj[\"flg\"]))\n  \t                    choice.flags = parseInt(propValue);\n  \t                return choice;\n  \t            }\n  \t            // Variable reference\n  \t            if ((propValue = obj[\"VAR?\"])) {\n  \t                return new VariableReference_1.VariableReference(propValue.toString());\n  \t            }\n  \t            else if ((propValue = obj[\"CNT?\"])) {\n  \t                let readCountVarRef = new VariableReference_1.VariableReference();\n  \t                readCountVarRef.pathStringForCount = propValue.toString();\n  \t                return readCountVarRef;\n  \t            }\n  \t            // Variable assignment\n  \t            let isVarAss = false;\n  \t            let isGlobalVar = false;\n  \t            if ((propValue = obj[\"VAR=\"])) {\n  \t                isVarAss = true;\n  \t                isGlobalVar = true;\n  \t            }\n  \t            else if ((propValue = obj[\"temp=\"])) {\n  \t                isVarAss = true;\n  \t                isGlobalVar = false;\n  \t            }\n  \t            if (isVarAss) {\n  \t                let varName = propValue.toString();\n  \t                let isNewDecl = !obj[\"re\"];\n  \t                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);\n  \t                varAss.isGlobal = isGlobalVar;\n  \t                return varAss;\n  \t            }\n  \t            if (obj[\"#\"] !== undefined) {\n  \t                propValue = obj[\"#\"];\n  \t                return new Tag_1.Tag(propValue.toString());\n  \t            }\n  \t            // List value\n  \t            if ((propValue = obj[\"list\"])) {\n  \t                // var listContent = (Dictionary<string, object>)propValue;\n  \t                let listContent = propValue;\n  \t                let rawList = new InkList_1.InkList();\n  \t                if ((propValue = obj[\"origins\"])) {\n  \t                    // var namesAsObjs = (List<object>)propValue;\n  \t                    let namesAsObjs = propValue;\n  \t                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n  \t                    rawList.SetInitialOriginNames(namesAsObjs);\n  \t                }\n  \t                for (let key in listContent) {\n  \t                    if (listContent.hasOwnProperty(key)) {\n  \t                        let nameToVal = listContent[key];\n  \t                        let item = new InkList_1.InkListItem(key);\n  \t                        let val = parseInt(nameToVal);\n  \t                        rawList.Add(item, val);\n  \t                    }\n  \t                }\n  \t                return new Value_1.ListValue(rawList);\n  \t            }\n  \t            if (obj[\"originalChoicePath\"] != null)\n  \t                return this.JObjectToChoice(obj);\n  \t        }\n  \t        // Array is always a Runtime.Container\n  \t        if (Array.isArray(token)) {\n  \t            return this.JArrayToContainer(token);\n  \t        }\n  \t        if (token === null || token === undefined)\n  \t            return null;\n  \t        throw new Error(\"Failed to convert token to runtime object: \" +\n  \t            this.toJson(token, [\"parent\"]));\n  \t    }\n  \t    static toJson(me, removes, space) {\n  \t        return JSON.stringify(me, (k, v) => ((removes === null || removes === void 0 ? void 0 : removes.some((r) => r === k)) ? undefined : v), space);\n  \t    }\n  \t    static WriteRuntimeContainer(writer, container, withoutName = false) {\n  \t        writer.WriteArrayStart();\n  \t        if (container === null) {\n  \t            return (0, NullException_1.throwNullException)(\"container\");\n  \t        }\n  \t        for (let c of container.content)\n  \t            this.WriteRuntimeObject(writer, c);\n  \t        let namedOnlyContent = container.namedOnlyContent;\n  \t        let countFlags = container.countFlags;\n  \t        let hasNameProperty = container.name != null && !withoutName;\n  \t        let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n  \t        if (hasTerminator) {\n  \t            writer.WriteObjectStart();\n  \t        }\n  \t        if (namedOnlyContent != null) {\n  \t            for (let [key, value] of namedOnlyContent) {\n  \t                let name = key;\n  \t                let namedContainer = (0, TypeAssertion_1.asOrNull)(value, Container_1.Container);\n  \t                writer.WritePropertyStart(name);\n  \t                this.WriteRuntimeContainer(writer, namedContainer, true);\n  \t                writer.WritePropertyEnd();\n  \t            }\n  \t        }\n  \t        if (countFlags > 0)\n  \t            writer.WriteIntProperty(\"#f\", countFlags);\n  \t        if (hasNameProperty)\n  \t            writer.WriteProperty(\"#n\", container.name);\n  \t        if (hasTerminator)\n  \t            writer.WriteObjectEnd();\n  \t        else\n  \t            writer.WriteNull();\n  \t        writer.WriteArrayEnd();\n  \t    }\n  \t    static JArrayToContainer(jArray) {\n  \t        let container = new Container_1.Container();\n  \t        container.content = this.JArrayToRuntimeObjList(jArray, true);\n  \t        let terminatingObj = jArray[jArray.length - 1];\n  \t        if (terminatingObj != null) {\n  \t            let namedOnlyContent = new Map();\n  \t            for (let key in terminatingObj) {\n  \t                if (key == \"#f\") {\n  \t                    container.countFlags = parseInt(terminatingObj[key]);\n  \t                }\n  \t                else if (key == \"#n\") {\n  \t                    container.name = terminatingObj[key].toString();\n  \t                }\n  \t                else {\n  \t                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);\n  \t                    // var namedSubContainer = namedContentItem as Container;\n  \t                    let namedSubContainer = (0, TypeAssertion_1.asOrNull)(namedContentItem, Container_1.Container);\n  \t                    if (namedSubContainer)\n  \t                        namedSubContainer.name = key;\n  \t                    namedOnlyContent.set(key, namedContentItem);\n  \t                }\n  \t            }\n  \t            container.namedOnlyContent = namedOnlyContent;\n  \t        }\n  \t        return container;\n  \t    }\n  \t    static JObjectToChoice(jObj) {\n  \t        let choice = new Choice_1.Choice();\n  \t        choice.text = jObj[\"text\"].toString();\n  \t        choice.index = parseInt(jObj[\"index\"]);\n  \t        choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n  \t        choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n  \t        choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n  \t        choice.tags = this.JArrayToTags(jObj);\n  \t        return choice;\n  \t    }\n  \t    static JArrayToTags(jObj) {\n  \t        if (jObj[\"tags\"]) {\n  \t            return jObj[\"tags\"];\n  \t        }\n  \t        else {\n  \t            return null;\n  \t        }\n  \t    }\n  \t    static WriteChoice(writer, choice) {\n  \t        writer.WriteObjectStart();\n  \t        writer.WriteProperty(\"text\", choice.text);\n  \t        writer.WriteIntProperty(\"index\", choice.index);\n  \t        writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n  \t        writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n  \t        writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n  \t        this.WriteChoiceTags(writer, choice);\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    static WriteChoiceTags(writer, choice) {\n  \t        if (choice.tags && choice.tags.length > 0) {\n  \t            writer.WritePropertyStart(\"tags\");\n  \t            writer.WriteArrayStart();\n  \t            for (const tag of choice.tags) {\n  \t                writer.Write(tag);\n  \t            }\n  \t            writer.WriteArrayEnd();\n  \t            writer.WritePropertyEnd();\n  \t        }\n  \t    }\n  \t    static WriteInkList(writer, listVal) {\n  \t        let rawList = listVal.value;\n  \t        if (rawList === null) {\n  \t            return (0, NullException_1.throwNullException)(\"rawList\");\n  \t        }\n  \t        writer.WriteObjectStart();\n  \t        writer.WritePropertyStart(\"list\");\n  \t        writer.WriteObjectStart();\n  \t        for (let [key, val] of rawList) {\n  \t            let item = InkList_1.InkListItem.fromSerializedKey(key);\n  \t            let itemVal = val;\n  \t            if (item.itemName === null) {\n  \t                return (0, NullException_1.throwNullException)(\"item.itemName\");\n  \t            }\n  \t            writer.WritePropertyNameStart();\n  \t            writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n  \t            writer.WritePropertyNameInner(\".\");\n  \t            writer.WritePropertyNameInner(item.itemName);\n  \t            writer.WritePropertyNameEnd();\n  \t            writer.Write(itemVal);\n  \t            writer.WritePropertyEnd();\n  \t        }\n  \t        writer.WriteObjectEnd();\n  \t        writer.WritePropertyEnd();\n  \t        if (rawList.Count == 0 &&\n  \t            rawList.originNames != null &&\n  \t            rawList.originNames.length > 0) {\n  \t            writer.WritePropertyStart(\"origins\");\n  \t            writer.WriteArrayStart();\n  \t            for (let name of rawList.originNames)\n  \t                writer.Write(name);\n  \t            writer.WriteArrayEnd();\n  \t            writer.WritePropertyEnd();\n  \t        }\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    static ListDefinitionsToJToken(origin) {\n  \t        let result = {};\n  \t        for (let def of origin.lists) {\n  \t            let listDefJson = {};\n  \t            for (let [key, val] of def.items) {\n  \t                let item = InkList_1.InkListItem.fromSerializedKey(key);\n  \t                if (item.itemName === null) {\n  \t                    return (0, NullException_1.throwNullException)(\"item.itemName\");\n  \t                }\n  \t                listDefJson[item.itemName] = val;\n  \t            }\n  \t            result[def.name] = listDefJson;\n  \t        }\n  \t        return result;\n  \t    }\n  \t    static JTokenToListDefinitions(obj) {\n  \t        // var defsObj = (Dictionary<string, object>)obj;\n  \t        let defsObj = obj;\n  \t        let allDefs = [];\n  \t        for (let key in defsObj) {\n  \t            if (defsObj.hasOwnProperty(key)) {\n  \t                let name = key.toString();\n  \t                // var listDefJson = (Dictionary<string, object>)kv.Value;\n  \t                let listDefJson = defsObj[key];\n  \t                // Cast (string, object) to (string, int) for items\n  \t                let items = new Map();\n  \t                for (let nameValueKey in listDefJson) {\n  \t                    if (defsObj.hasOwnProperty(key)) {\n  \t                        let nameValue = listDefJson[nameValueKey];\n  \t                        items.set(nameValueKey, parseInt(nameValue));\n  \t                    }\n  \t                }\n  \t                let def = new ListDefinition_1.ListDefinition(name, items);\n  \t                allDefs.push(def);\n  \t            }\n  \t        }\n  \t        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);\n  \t    }\n  \t};\n  \tJsonSerialisation.JsonSerialisation = JsonSerialisation$1;\n  \tJsonSerialisation$1._controlCommandNames = (() => {\n  \t    let _controlCommandNames = [];\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = \"ev\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = \"out\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = \"/ev\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = \"du\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = \"~ret\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = \"->->\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = \"str\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = \"/str\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = \"nop\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = \"turn\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = \"turns\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = \"readc\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = \"rnd\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = \"srnd\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = \"visit\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] =\n  \t        \"seq\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = \"thread\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = \"done\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = \"end\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = \"listInt\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = \"range\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = \"lrnd\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginTag] = \"#\";\n  \t    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndTag] = \"/#\";\n  \t    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n  \t        if (_controlCommandNames[i] == null)\n  \t            throw new Error(\"Control command not accounted for in serialisation\");\n  \t    }\n  \t    return _controlCommandNames;\n  \t})();\n  \t\n  \treturn JsonSerialisation;\n  }\n\n  var StoryState = {};\n\n  var CallStack = {};\n\n  var hasRequiredCallStack;\n\n  function requireCallStack () {\n  \tif (hasRequiredCallStack) return CallStack;\n  \thasRequiredCallStack = 1;\n  \tObject.defineProperty(CallStack, \"__esModule\", { value: true });\n  \tCallStack.CallStack = void 0;\n  \tconst PushPop_1 = requirePushPop();\n  \tconst Path_1 = requirePath$1();\n  \tconst Story_1 = requireStory$1();\n  \tconst JsonSerialisation_1 = requireJsonSerialisation();\n  \tconst Value_1 = requireValue();\n  \tconst StringBuilder_1 = requireStringBuilder();\n  \tconst Pointer_1 = requirePointer();\n  \tconst Debug_1 = requireDebug();\n  \tconst TryGetResult_1 = requireTryGetResult();\n  \tconst NullException_1 = requireNullException();\n  \tlet CallStack$1 = class CallStack {\n  \t    get elements() {\n  \t        return this.callStack;\n  \t    }\n  \t    get depth() {\n  \t        return this.elements.length;\n  \t    }\n  \t    get currentElement() {\n  \t        let thread = this._threads[this._threads.length - 1];\n  \t        let cs = thread.callstack;\n  \t        return cs[cs.length - 1];\n  \t    }\n  \t    get currentElementIndex() {\n  \t        return this.callStack.length - 1;\n  \t    }\n  \t    get currentThread() {\n  \t        return this._threads[this._threads.length - 1];\n  \t    }\n  \t    set currentThread(value) {\n  \t        Debug_1.Debug.Assert(this._threads.length == 1, \"Shouldn't be directly setting the current thread when we have a stack of them\");\n  \t        this._threads.length = 0;\n  \t        this._threads.push(value);\n  \t    }\n  \t    get canPop() {\n  \t        return this.callStack.length > 1;\n  \t    }\n  \t    constructor() {\n  \t        this._threadCounter = 0;\n  \t        this._startOfRoot = Pointer_1.Pointer.Null;\n  \t        if (arguments[0] instanceof Story_1.Story) {\n  \t            let storyContext = arguments[0];\n  \t            this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);\n  \t            this.Reset();\n  \t        }\n  \t        else {\n  \t            let toCopy = arguments[0];\n  \t            this._threads = [];\n  \t            for (let otherThread of toCopy._threads) {\n  \t                this._threads.push(otherThread.Copy());\n  \t            }\n  \t            this._threadCounter = toCopy._threadCounter;\n  \t            this._startOfRoot = toCopy._startOfRoot.copy();\n  \t        }\n  \t    }\n  \t    Reset() {\n  \t        this._threads = [];\n  \t        this._threads.push(new CallStack.Thread());\n  \t        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));\n  \t    }\n  \t    SetJsonToken(jObject, storyContext) {\n  \t        this._threads.length = 0;\n  \t        // TODO: (List<object>) jObject [\"threads\"];\n  \t        let jThreads = jObject[\"threads\"];\n  \t        for (let jThreadTok of jThreads) {\n  \t            // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n  \t            let jThreadObj = jThreadTok;\n  \t            let thread = new CallStack.Thread(jThreadObj, storyContext);\n  \t            this._threads.push(thread);\n  \t        }\n  \t        // TODO: (int)jObject [\"threadCounter\"];\n  \t        this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n  \t        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);\n  \t    }\n  \t    WriteJson(w) {\n  \t        w.WriteObject((writer) => {\n  \t            writer.WritePropertyStart(\"threads\");\n  \t            writer.WriteArrayStart();\n  \t            for (let thread of this._threads) {\n  \t                thread.WriteJson(writer);\n  \t            }\n  \t            writer.WriteArrayEnd();\n  \t            writer.WritePropertyEnd();\n  \t            writer.WritePropertyStart(\"threadCounter\");\n  \t            writer.WriteInt(this._threadCounter);\n  \t            writer.WritePropertyEnd();\n  \t        });\n  \t    }\n  \t    PushThread() {\n  \t        let newThread = this.currentThread.Copy();\n  \t        this._threadCounter++;\n  \t        newThread.threadIndex = this._threadCounter;\n  \t        this._threads.push(newThread);\n  \t    }\n  \t    ForkThread() {\n  \t        let forkedThread = this.currentThread.Copy();\n  \t        this._threadCounter++;\n  \t        forkedThread.threadIndex = this._threadCounter;\n  \t        return forkedThread;\n  \t    }\n  \t    PopThread() {\n  \t        if (this.canPopThread) {\n  \t            this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n  \t        }\n  \t        else {\n  \t            throw new Error(\"Can't pop thread\");\n  \t        }\n  \t    }\n  \t    get canPopThread() {\n  \t        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  \t    }\n  \t    get elementIsEvaluateFromGame() {\n  \t        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;\n  \t    }\n  \t    Push(type, externalEvaluationStackHeight = 0, outputStreamLengthWithPushed = 0) {\n  \t        let element = new CallStack.Element(type, this.currentElement.currentPointer, false);\n  \t        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n  \t        element.functionStartInOutputStream = outputStreamLengthWithPushed;\n  \t        this.callStack.push(element);\n  \t    }\n  \t    CanPop(type = null) {\n  \t        if (!this.canPop)\n  \t            return false;\n  \t        if (type == null)\n  \t            return true;\n  \t        return this.currentElement.type == type;\n  \t    }\n  \t    Pop(type = null) {\n  \t        if (this.CanPop(type)) {\n  \t            this.callStack.pop();\n  \t            return;\n  \t        }\n  \t        else {\n  \t            throw new Error(\"Mismatched push/pop in Callstack\");\n  \t        }\n  \t    }\n  \t    GetTemporaryVariableWithName(name, contextIndex = -1) {\n  \t        // contextIndex 0 means global, so index is actually 1-based\n  \t        if (contextIndex == -1)\n  \t            contextIndex = this.currentElementIndex + 1;\n  \t        let contextElement = this.callStack[contextIndex - 1];\n  \t        let varValue = (0, TryGetResult_1.tryGetValueFromMap)(contextElement.temporaryVariables, name, null);\n  \t        if (varValue.exists) {\n  \t            return varValue.result;\n  \t        }\n  \t        else {\n  \t            return null;\n  \t        }\n  \t    }\n  \t    SetTemporaryVariable(name, value, declareNew, contextIndex = -1) {\n  \t        if (contextIndex == -1)\n  \t            contextIndex = this.currentElementIndex + 1;\n  \t        let contextElement = this.callStack[contextIndex - 1];\n  \t        if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n  \t            throw new Error(\"Could not find temporary variable to set: \" + name);\n  \t        }\n  \t        let oldValue = (0, TryGetResult_1.tryGetValueFromMap)(contextElement.temporaryVariables, name, null);\n  \t        if (oldValue.exists)\n  \t            Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n  \t        contextElement.temporaryVariables.set(name, value);\n  \t    }\n  \t    ContextForVariableNamed(name) {\n  \t        if (this.currentElement.temporaryVariables.get(name)) {\n  \t            return this.currentElementIndex + 1;\n  \t        }\n  \t        else {\n  \t            return 0;\n  \t        }\n  \t    }\n  \t    ThreadWithIndex(index) {\n  \t        let filtered = this._threads.filter((t) => {\n  \t            if (t.threadIndex == index)\n  \t                return t;\n  \t        });\n  \t        return filtered.length > 0 ? filtered[0] : null;\n  \t    }\n  \t    get callStack() {\n  \t        return this.currentThread.callstack;\n  \t    }\n  \t    get callStackTrace() {\n  \t        let sb = new StringBuilder_1.StringBuilder();\n  \t        for (let t = 0; t < this._threads.length; t++) {\n  \t            let thread = this._threads[t];\n  \t            let isCurrent = t == this._threads.length - 1;\n  \t            sb.AppendFormat(\"=== THREAD {0}/{1} {2}===\\n\", t + 1, this._threads.length, isCurrent ? \"(current) \" : \"\");\n  \t            for (let i = 0; i < thread.callstack.length; i++) {\n  \t                if (thread.callstack[i].type == PushPop_1.PushPopType.Function)\n  \t                    sb.Append(\"  [FUNCTION] \");\n  \t                else\n  \t                    sb.Append(\"  [TUNNEL] \");\n  \t                let pointer = thread.callstack[i].currentPointer;\n  \t                if (!pointer.isNull) {\n  \t                    sb.Append(\"<SOMEWHERE IN \");\n  \t                    if (pointer.container === null) {\n  \t                        return (0, NullException_1.throwNullException)(\"pointer.container\");\n  \t                    }\n  \t                    sb.Append(pointer.container.path.toString());\n  \t                    sb.AppendLine(\">\");\n  \t                }\n  \t            }\n  \t        }\n  \t        return sb.toString();\n  \t    }\n  \t};\n  \tCallStack.CallStack = CallStack$1;\n  \t(function (CallStack) {\n  \t    class Element {\n  \t        constructor(type, pointer, inExpressionEvaluation = false) {\n  \t            this.evaluationStackHeightWhenPushed = 0;\n  \t            this.functionStartInOutputStream = 0;\n  \t            this.currentPointer = pointer.copy();\n  \t            this.inExpressionEvaluation = inExpressionEvaluation;\n  \t            this.temporaryVariables = new Map();\n  \t            this.type = type;\n  \t        }\n  \t        Copy() {\n  \t            let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);\n  \t            copy.temporaryVariables = new Map(this.temporaryVariables);\n  \t            copy.evaluationStackHeightWhenPushed =\n  \t                this.evaluationStackHeightWhenPushed;\n  \t            copy.functionStartInOutputStream = this.functionStartInOutputStream;\n  \t            return copy;\n  \t        }\n  \t    }\n  \t    CallStack.Element = Element;\n  \t    class Thread {\n  \t        constructor() {\n  \t            this.threadIndex = 0;\n  \t            this.previousPointer = Pointer_1.Pointer.Null;\n  \t            this.callstack = [];\n  \t            if (arguments[0] && arguments[1]) {\n  \t                let jThreadObj = arguments[0];\n  \t                let storyContext = arguments[1];\n  \t                // TODO: (int) jThreadObj['threadIndex'] can raise;\n  \t                this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n  \t                let jThreadCallstack = jThreadObj[\"callstack\"];\n  \t                for (let jElTok of jThreadCallstack) {\n  \t                    let jElementObj = jElTok;\n  \t                    // TODO: (int) jElementObj['type'] can raise;\n  \t                    let pushPopType = parseInt(jElementObj[\"type\"]);\n  \t                    let pointer = Pointer_1.Pointer.Null;\n  \t                    let currentContainerPathStr;\n  \t                    // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n  \t                    let currentContainerPathStrToken = jElementObj[\"cPath\"];\n  \t                    if (typeof currentContainerPathStrToken !== \"undefined\") {\n  \t                        currentContainerPathStr = currentContainerPathStrToken.toString();\n  \t                        let threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));\n  \t                        pointer.container = threadPointerResult.container;\n  \t                        pointer.index = parseInt(jElementObj[\"idx\"]);\n  \t                        if (threadPointerResult.obj == null)\n  \t                            throw new Error(\"When loading state, internal story location couldn't be found: \" +\n  \t                                currentContainerPathStr +\n  \t                                \". Has the story changed since this save data was created?\");\n  \t                        else if (threadPointerResult.approximate) {\n  \t                            if (pointer.container !== null) {\n  \t                                storyContext.Warning(\"When loading state, exact internal story location couldn't be found: '\" +\n  \t                                    currentContainerPathStr +\n  \t                                    \"', so it was approximated to '\" +\n  \t                                    pointer.container.path.toString() +\n  \t                                    \"' to recover. Has the story changed since this save data was created?\");\n  \t                            }\n  \t                            else {\n  \t                                storyContext.Warning(\"When loading state, exact internal story location couldn't be found: '\" +\n  \t                                    currentContainerPathStr +\n  \t                                    \"' and it may not be recoverable. Has the story changed since this save data was created?\");\n  \t                            }\n  \t                        }\n  \t                    }\n  \t                    let inExpressionEvaluation = !!jElementObj[\"exp\"];\n  \t                    let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n  \t                    let temps = jElementObj[\"temp\"];\n  \t                    if (typeof temps !== \"undefined\") {\n  \t                        el.temporaryVariables =\n  \t                            JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n  \t                    }\n  \t                    else {\n  \t                        el.temporaryVariables.clear();\n  \t                    }\n  \t                    this.callstack.push(el);\n  \t                }\n  \t                let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n  \t                if (typeof prevContentObjPath !== \"undefined\") {\n  \t                    let prevPath = new Path_1.Path(prevContentObjPath.toString());\n  \t                    this.previousPointer = storyContext.PointerAtPath(prevPath);\n  \t                }\n  \t            }\n  \t        }\n  \t        Copy() {\n  \t            let copy = new Thread();\n  \t            copy.threadIndex = this.threadIndex;\n  \t            for (let e of this.callstack) {\n  \t                copy.callstack.push(e.Copy());\n  \t            }\n  \t            copy.previousPointer = this.previousPointer.copy();\n  \t            return copy;\n  \t        }\n  \t        WriteJson(writer) {\n  \t            writer.WriteObjectStart();\n  \t            writer.WritePropertyStart(\"callstack\");\n  \t            writer.WriteArrayStart();\n  \t            for (let el of this.callstack) {\n  \t                writer.WriteObjectStart();\n  \t                if (!el.currentPointer.isNull) {\n  \t                    if (el.currentPointer.container === null) {\n  \t                        return (0, NullException_1.throwNullException)(\"el.currentPointer.container\");\n  \t                    }\n  \t                    writer.WriteProperty(\"cPath\", el.currentPointer.container.path.componentsString);\n  \t                    writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n  \t                }\n  \t                writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n  \t                writer.WriteIntProperty(\"type\", el.type);\n  \t                if (el.temporaryVariables.size > 0) {\n  \t                    writer.WritePropertyStart(\"temp\");\n  \t                    JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);\n  \t                    writer.WritePropertyEnd();\n  \t                }\n  \t                writer.WriteObjectEnd();\n  \t            }\n  \t            writer.WriteArrayEnd();\n  \t            writer.WritePropertyEnd();\n  \t            writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n  \t            if (!this.previousPointer.isNull) {\n  \t                let resolvedPointer = this.previousPointer.Resolve();\n  \t                if (resolvedPointer === null) {\n  \t                    return (0, NullException_1.throwNullException)(\"this.previousPointer.Resolve()\");\n  \t                }\n  \t                writer.WriteProperty(\"previousContentObject\", resolvedPointer.path.toString());\n  \t            }\n  \t            writer.WriteObjectEnd();\n  \t        }\n  \t    }\n  \t    CallStack.Thread = Thread;\n  \t})(CallStack$1 || (CallStack.CallStack = CallStack$1 = {}));\n  \t\n  \treturn CallStack;\n  }\n\n  var VariablesState = {};\n\n  var hasRequiredVariablesState;\n\n  function requireVariablesState () {\n  \tif (hasRequiredVariablesState) return VariablesState;\n  \thasRequiredVariablesState = 1;\n  \tObject.defineProperty(VariablesState, \"__esModule\", { value: true });\n  \tVariablesState.VariablesState = void 0;\n  \tconst Value_1 = requireValue();\n  \tconst StoryException_1 = requireStoryException();\n  \tconst JsonSerialisation_1 = requireJsonSerialisation();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst TryGetResult_1 = requireTryGetResult();\n  \tconst NullException_1 = requireNullException();\n  \t// Fake class wrapper around VariableState to have correct typing\n  \t// when using the Proxy syntax in typescript\n  \tfunction VariablesStateAccessor() {\n  \t    return class {\n  \t    };\n  \t}\n  \tlet VariablesState$1 = class VariablesState extends VariablesStateAccessor() {\n  \t    variableChangedEvent(variableName, newValue) {\n  \t        for (let callback of this.variableChangedEventCallbacks) {\n  \t            callback(variableName, newValue);\n  \t        }\n  \t    }\n  \t    StartVariableObservation() {\n  \t        this._batchObservingVariableChanges = true;\n  \t        this._changedVariablesForBatchObs = new Set();\n  \t    }\n  \t    CompleteVariableObservation() {\n  \t        this._batchObservingVariableChanges = false;\n  \t        let changedVars = new Map();\n  \t        if (this._changedVariablesForBatchObs != null) {\n  \t            for (let variableName of this._changedVariablesForBatchObs) {\n  \t                let currentValue = this._globalVariables.get(variableName);\n  \t                this.variableChangedEvent(variableName, currentValue);\n  \t            }\n  \t        }\n  \t        // Patch may still be active - e.g. if we were in the middle of a background save\n  \t        if (this.patch != null) {\n  \t            for (let variableName of this.patch.changedVariables) {\n  \t                let patchedVal = this.patch.TryGetGlobal(variableName, null);\n  \t                if (patchedVal.exists)\n  \t                    changedVars.set(variableName, patchedVal);\n  \t            }\n  \t        }\n  \t        this._changedVariablesForBatchObs = null;\n  \t        return changedVars;\n  \t    }\n  \t    NotifyObservers(changedVars) {\n  \t        for (const [key, value] of changedVars) {\n  \t            this.variableChangedEvent(key, value);\n  \t        }\n  \t    }\n  \t    get callStack() {\n  \t        return this._callStack;\n  \t    }\n  \t    set callStack(callStack) {\n  \t        this._callStack = callStack;\n  \t    }\n  \t    $(variableName, value) {\n  \t        if (typeof value === \"undefined\") {\n  \t            let varContents = null;\n  \t            if (this.patch !== null) {\n  \t                varContents = this.patch.TryGetGlobal(variableName, null);\n  \t                if (varContents.exists)\n  \t                    return varContents.result.valueObject;\n  \t            }\n  \t            varContents = this._globalVariables.get(variableName);\n  \t            if (typeof varContents === \"undefined\") {\n  \t                varContents = this._defaultGlobalVariables.get(variableName);\n  \t            }\n  \t            if (typeof varContents !== \"undefined\")\n  \t                return varContents.valueObject;\n  \t            else\n  \t                return null;\n  \t        }\n  \t        else {\n  \t            if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n  \t                throw new StoryException_1.StoryException(\"Cannot assign to a variable (\" +\n  \t                    variableName +\n  \t                    \") that hasn't been declared in the story\");\n  \t            let val = Value_1.Value.Create(value);\n  \t            if (val == null) {\n  \t                if (value == null) {\n  \t                    throw new Error(\"Cannot pass null to VariableState\");\n  \t                }\n  \t                else {\n  \t                    throw new Error(\"Invalid value passed to VariableState: \" + value.toString());\n  \t                }\n  \t            }\n  \t            this.SetGlobal(variableName, val);\n  \t        }\n  \t    }\n  \t    constructor(callStack, listDefsOrigin) {\n  \t        super();\n  \t        // The way variableChangedEvent is a bit different than the reference implementation.\n  \t        // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  \t        // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  \t        // special ObserveVariableChange method below.\n  \t        this.variableChangedEventCallbacks = [];\n  \t        this.patch = null;\n  \t        this._defaultGlobalVariables = new Map();\n  \t        this._changedVariablesForBatchObs = new Set();\n  \t        this._batchObservingVariableChanges = false;\n  \t        this._globalVariables = new Map();\n  \t        this._callStack = callStack;\n  \t        this._listDefsOrigin = listDefsOrigin;\n  \t        // if es6 proxies are available, use them.\n  \t        try {\n  \t            // the proxy is used to allow direct manipulation of global variables.\n  \t            // It first tries to access the objects own property, and if none is\n  \t            // found it delegates the call to the $ method, defined below\n  \t            let p = new Proxy(this, {\n  \t                get(target, name) {\n  \t                    return name in target ? target[name] : target.$(name);\n  \t                },\n  \t                set(target, name, value) {\n  \t                    if (name in target)\n  \t                        target[name] = value;\n  \t                    else\n  \t                        target.$(name, value);\n  \t                    return true; // returning a falsy value make the trap fail\n  \t                },\n  \t                ownKeys(target) {\n  \t                    return [\n  \t                        ...new Set([\n  \t                            ...target._defaultGlobalVariables.keys(),\n  \t                            ...target._globalVariables.keys(),\n  \t                        ]),\n  \t                    ];\n  \t                },\n  \t                getOwnPropertyDescriptor(target, name) {\n  \t                    // called for every property\n  \t                    return {\n  \t                        enumerable: true,\n  \t                        configurable: true,\n  \t                        value: target.$(name),\n  \t                    };\n  \t                },\n  \t            });\n  \t            return p;\n  \t        }\n  \t        catch (e) {\n  \t            // the proxy object is not available in this context. we should warn the\n  \t            // dev but writing to the console feels a bit intrusive.\n  \t            // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n  \t        }\n  \t    }\n  \t    ApplyPatch() {\n  \t        if (this.patch === null) {\n  \t            return (0, NullException_1.throwNullException)(\"this.patch\");\n  \t        }\n  \t        for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n  \t            this._globalVariables.set(namedVarKey, namedVarValue);\n  \t        }\n  \t        if (this._changedVariablesForBatchObs !== null) {\n  \t            for (let name of this.patch.changedVariables) {\n  \t                this._changedVariablesForBatchObs.add(name);\n  \t            }\n  \t        }\n  \t        this.patch = null;\n  \t    }\n  \t    SetJsonToken(jToken) {\n  \t        this._globalVariables.clear();\n  \t        for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n  \t            let loadedToken = jToken[varValKey];\n  \t            if (typeof loadedToken !== \"undefined\") {\n  \t                let tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n  \t                if (tokenInkObject === null) {\n  \t                    return (0, NullException_1.throwNullException)(\"tokenInkObject\");\n  \t                }\n  \t                this._globalVariables.set(varValKey, tokenInkObject);\n  \t            }\n  \t            else {\n  \t                this._globalVariables.set(varValKey, varValValue);\n  \t            }\n  \t        }\n  \t    }\n  \t    WriteJson(writer) {\n  \t        writer.WriteObjectStart();\n  \t        for (let [keyValKey, keyValValue] of this._globalVariables) {\n  \t            let name = keyValKey;\n  \t            let val = keyValValue;\n  \t            if (VariablesState.dontSaveDefaultValues) {\n  \t                if (this._defaultGlobalVariables.has(name)) {\n  \t                    let defaultVal = this._defaultGlobalVariables.get(name);\n  \t                    if (this.RuntimeObjectsEqual(val, defaultVal))\n  \t                        continue;\n  \t                }\n  \t            }\n  \t            writer.WritePropertyStart(name);\n  \t            JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);\n  \t            writer.WritePropertyEnd();\n  \t        }\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    RuntimeObjectsEqual(obj1, obj2) {\n  \t        if (obj1 === null) {\n  \t            return (0, NullException_1.throwNullException)(\"obj1\");\n  \t        }\n  \t        if (obj2 === null) {\n  \t            return (0, NullException_1.throwNullException)(\"obj2\");\n  \t        }\n  \t        if (obj1.constructor !== obj2.constructor)\n  \t            return false;\n  \t        let boolVal = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.BoolValue);\n  \t        if (boolVal !== null) {\n  \t            return boolVal.value === (0, TypeAssertion_1.asOrThrows)(obj2, Value_1.BoolValue).value;\n  \t        }\n  \t        let intVal = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.IntValue);\n  \t        if (intVal !== null) {\n  \t            return intVal.value === (0, TypeAssertion_1.asOrThrows)(obj2, Value_1.IntValue).value;\n  \t        }\n  \t        let floatVal = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.FloatValue);\n  \t        if (floatVal !== null) {\n  \t            return floatVal.value === (0, TypeAssertion_1.asOrThrows)(obj2, Value_1.FloatValue).value;\n  \t        }\n  \t        let val1 = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.Value);\n  \t        let val2 = (0, TypeAssertion_1.asOrNull)(obj2, Value_1.Value);\n  \t        if (val1 !== null && val2 !== null) {\n  \t            if ((0, TypeAssertion_1.isEquatable)(val1.valueObject) && (0, TypeAssertion_1.isEquatable)(val2.valueObject)) {\n  \t                return val1.valueObject.Equals(val2.valueObject);\n  \t            }\n  \t            else {\n  \t                return val1.valueObject === val2.valueObject;\n  \t            }\n  \t        }\n  \t        throw new Error(\"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n  \t            obj1.constructor.name);\n  \t    }\n  \t    GetVariableWithName(name, contextIndex = -1) {\n  \t        let varValue = this.GetRawVariableWithName(name, contextIndex);\n  \t        // var varPointer = varValue as VariablePointerValue;\n  \t        let varPointer = (0, TypeAssertion_1.asOrNull)(varValue, Value_1.VariablePointerValue);\n  \t        if (varPointer !== null) {\n  \t            varValue = this.ValueAtVariablePointer(varPointer);\n  \t        }\n  \t        return varValue;\n  \t    }\n  \t    TryGetDefaultVariableValue(name) {\n  \t        let val = (0, TryGetResult_1.tryGetValueFromMap)(this._defaultGlobalVariables, name, null);\n  \t        return val.exists ? val.result : null;\n  \t    }\n  \t    GlobalVariableExistsWithName(name) {\n  \t        return (this._globalVariables.has(name) ||\n  \t            (this._defaultGlobalVariables !== null &&\n  \t                this._defaultGlobalVariables.has(name)));\n  \t    }\n  \t    GetRawVariableWithName(name, contextIndex) {\n  \t        let varValue = null;\n  \t        if (contextIndex == 0 || contextIndex == -1) {\n  \t            let variableValue = null;\n  \t            if (this.patch !== null) {\n  \t                variableValue = this.patch.TryGetGlobal(name, null);\n  \t                if (variableValue.exists)\n  \t                    return variableValue.result;\n  \t            }\n  \t            // this is a conditional assignment\n  \t            variableValue = (0, TryGetResult_1.tryGetValueFromMap)(this._globalVariables, name, null);\n  \t            if (variableValue.exists)\n  \t                return variableValue.result;\n  \t            if (this._defaultGlobalVariables !== null) {\n  \t                variableValue = (0, TryGetResult_1.tryGetValueFromMap)(this._defaultGlobalVariables, name, null);\n  \t                if (variableValue.exists)\n  \t                    return variableValue.result;\n  \t            }\n  \t            if (this._listDefsOrigin === null)\n  \t                return (0, NullException_1.throwNullException)(\"VariablesState._listDefsOrigin\");\n  \t            let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n  \t            if (listItemValue)\n  \t                return listItemValue;\n  \t        }\n  \t        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n  \t        return varValue;\n  \t    }\n  \t    ValueAtVariablePointer(pointer) {\n  \t        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  \t    }\n  \t    Assign(varAss, value) {\n  \t        let name = varAss.variableName;\n  \t        if (name === null) {\n  \t            return (0, NullException_1.throwNullException)(\"name\");\n  \t        }\n  \t        let contextIndex = -1;\n  \t        let setGlobal = false;\n  \t        if (varAss.isNewDeclaration) {\n  \t            setGlobal = varAss.isGlobal;\n  \t        }\n  \t        else {\n  \t            setGlobal = this.GlobalVariableExistsWithName(name);\n  \t        }\n  \t        if (varAss.isNewDeclaration) {\n  \t            // var varPointer = value as VariablePointerValue;\n  \t            let varPointer = (0, TypeAssertion_1.asOrNull)(value, Value_1.VariablePointerValue);\n  \t            if (varPointer !== null) {\n  \t                let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);\n  \t                value = fullyResolvedVariablePointer;\n  \t            }\n  \t        }\n  \t        else {\n  \t            let existingPointer = null;\n  \t            do {\n  \t                // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n  \t                existingPointer = (0, TypeAssertion_1.asOrNull)(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);\n  \t                if (existingPointer != null) {\n  \t                    name = existingPointer.variableName;\n  \t                    contextIndex = existingPointer.contextIndex;\n  \t                    setGlobal = contextIndex == 0;\n  \t                }\n  \t            } while (existingPointer != null);\n  \t        }\n  \t        if (setGlobal) {\n  \t            this.SetGlobal(name, value);\n  \t        }\n  \t        else {\n  \t            this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);\n  \t        }\n  \t    }\n  \t    SnapshotDefaultGlobals() {\n  \t        this._defaultGlobalVariables = new Map(this._globalVariables);\n  \t    }\n  \t    RetainListOriginsForAssignment(oldValue, newValue) {\n  \t        let oldList = (0, TypeAssertion_1.asOrThrows)(oldValue, Value_1.ListValue);\n  \t        let newList = (0, TypeAssertion_1.asOrThrows)(newValue, Value_1.ListValue);\n  \t        if (oldList.value && newList.value && newList.value.Count == 0) {\n  \t            newList.value.SetInitialOriginNames(oldList.value.originNames);\n  \t        }\n  \t    }\n  \t    SetGlobal(variableName, value) {\n  \t        let oldValue = null;\n  \t        if (this.patch === null) {\n  \t            oldValue = (0, TryGetResult_1.tryGetValueFromMap)(this._globalVariables, variableName, null);\n  \t        }\n  \t        if (this.patch !== null) {\n  \t            oldValue = this.patch.TryGetGlobal(variableName, null);\n  \t            if (!oldValue.exists) {\n  \t                oldValue = (0, TryGetResult_1.tryGetValueFromMap)(this._globalVariables, variableName, null);\n  \t            }\n  \t        }\n  \t        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n  \t        if (variableName === null) {\n  \t            return (0, NullException_1.throwNullException)(\"variableName\");\n  \t        }\n  \t        if (this.patch !== null) {\n  \t            this.patch.SetGlobal(variableName, value);\n  \t        }\n  \t        else {\n  \t            this._globalVariables.set(variableName, value);\n  \t        }\n  \t        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n  \t        if (this.variableChangedEvent !== null &&\n  \t            oldValue !== null &&\n  \t            value !== oldValue.result) {\n  \t            if (this._batchObservingVariableChanges) {\n  \t                if (this._changedVariablesForBatchObs === null) {\n  \t                    return (0, NullException_1.throwNullException)(\"this._changedVariablesForBatchObs\");\n  \t                }\n  \t                if (this.patch !== null) {\n  \t                    this.patch.AddChangedVariable(variableName);\n  \t                }\n  \t                else if (this._changedVariablesForBatchObs !== null) {\n  \t                    this._changedVariablesForBatchObs.add(variableName);\n  \t                }\n  \t            }\n  \t            else {\n  \t                this.variableChangedEvent(variableName, value);\n  \t            }\n  \t        }\n  \t    }\n  \t    ResolveVariablePointer(varPointer) {\n  \t        let contextIndex = varPointer.contextIndex;\n  \t        if (contextIndex == -1)\n  \t            contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);\n  \t        let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);\n  \t        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n  \t        let doubleRedirectionPointer = (0, TypeAssertion_1.asOrNull)(valueOfVariablePointedTo, Value_1.VariablePointerValue);\n  \t        if (doubleRedirectionPointer != null) {\n  \t            return doubleRedirectionPointer;\n  \t        }\n  \t        else {\n  \t            return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);\n  \t        }\n  \t    }\n  \t    GetContextIndexOfVariableNamed(varName) {\n  \t        if (this.GlobalVariableExistsWithName(varName))\n  \t            return 0;\n  \t        return this._callStack.currentElementIndex;\n  \t    }\n  \t    /**\n  \t     * This function is specific to the js version of ink. It allows to register a\n  \t     * callback that will be called when a variable changes. The original code uses\n  \t     * `state.variableChangedEvent += callback` instead.\n  \t     *\n  \t     * @param {function} callback\n  \t     */\n  \t    ObserveVariableChange(callback) {\n  \t        this.variableChangedEventCallbacks.push(callback);\n  \t    }\n  \t};\n  \tVariablesState.VariablesState = VariablesState$1;\n  \tVariablesState$1.dontSaveDefaultValues = true;\n  \t\n  \treturn VariablesState;\n  }\n\n  var PRNG = {};\n\n  var hasRequiredPRNG;\n\n  function requirePRNG () {\n  \tif (hasRequiredPRNG) return PRNG;\n  \thasRequiredPRNG = 1;\n  \tObject.defineProperty(PRNG, \"__esModule\", { value: true });\n  \tPRNG.PRNG = void 0;\n  \t// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n  \t// Ink uses a seedable PRNG of which there is none in native javascript.\n  \tlet PRNG$1 = class PRNG {\n  \t    constructor(seed) {\n  \t        this.seed = seed % 2147483647;\n  \t        if (this.seed <= 0)\n  \t            this.seed += 2147483646;\n  \t    }\n  \t    next() {\n  \t        return (this.seed = (this.seed * 48271) % 2147483647);\n  \t    }\n  \t    nextFloat() {\n  \t        return (this.next() - 1) / 2147483646;\n  \t    }\n  \t};\n  \tPRNG.PRNG = PRNG$1;\n  \t\n  \treturn PRNG;\n  }\n\n  var StatePatch = {};\n\n  var hasRequiredStatePatch;\n\n  function requireStatePatch () {\n  \tif (hasRequiredStatePatch) return StatePatch;\n  \thasRequiredStatePatch = 1;\n  \tObject.defineProperty(StatePatch, \"__esModule\", { value: true });\n  \tStatePatch.StatePatch = void 0;\n  \tlet StatePatch$1 = class StatePatch {\n  \t    get globals() {\n  \t        return this._globals;\n  \t    }\n  \t    get changedVariables() {\n  \t        return this._changedVariables;\n  \t    }\n  \t    get visitCounts() {\n  \t        return this._visitCounts;\n  \t    }\n  \t    get turnIndices() {\n  \t        return this._turnIndices;\n  \t    }\n  \t    constructor() {\n  \t        this._changedVariables = new Set();\n  \t        this._visitCounts = new Map();\n  \t        this._turnIndices = new Map();\n  \t        if (arguments.length === 1 && arguments[0] !== null) {\n  \t            let toCopy = arguments[0];\n  \t            this._globals = new Map(toCopy._globals);\n  \t            this._changedVariables = new Set(toCopy._changedVariables);\n  \t            this._visitCounts = new Map(toCopy._visitCounts);\n  \t            this._turnIndices = new Map(toCopy._turnIndices);\n  \t        }\n  \t        else {\n  \t            this._globals = new Map();\n  \t            this._changedVariables = new Set();\n  \t            this._visitCounts = new Map();\n  \t            this._turnIndices = new Map();\n  \t        }\n  \t    }\n  \t    TryGetGlobal(name, /* out */ value) {\n  \t        if (name !== null && this._globals.has(name)) {\n  \t            return { result: this._globals.get(name), exists: true };\n  \t        }\n  \t        return { result: value, exists: false };\n  \t    }\n  \t    SetGlobal(name, value) {\n  \t        this._globals.set(name, value);\n  \t    }\n  \t    AddChangedVariable(name) {\n  \t        return this._changedVariables.add(name);\n  \t    }\n  \t    TryGetVisitCount(container, /* out */ count) {\n  \t        if (this._visitCounts.has(container)) {\n  \t            return { result: this._visitCounts.get(container), exists: true };\n  \t        }\n  \t        return { result: count, exists: false };\n  \t    }\n  \t    SetVisitCount(container, count) {\n  \t        this._visitCounts.set(container, count);\n  \t    }\n  \t    SetTurnIndex(container, index) {\n  \t        this._turnIndices.set(container, index);\n  \t    }\n  \t    TryGetTurnIndex(container, /* out */ index) {\n  \t        if (this._turnIndices.has(container)) {\n  \t            return { result: this._turnIndices.get(container), exists: true };\n  \t        }\n  \t        return { result: index, exists: false };\n  \t    }\n  \t};\n  \tStatePatch.StatePatch = StatePatch$1;\n  \t\n  \treturn StatePatch;\n  }\n\n  var SimpleJson = {};\n\n  var hasRequiredSimpleJson;\n\n  function requireSimpleJson () {\n  \tif (hasRequiredSimpleJson) return SimpleJson;\n  \thasRequiredSimpleJson = 1;\n  \tObject.defineProperty(SimpleJson, \"__esModule\", { value: true });\n  \tSimpleJson.SimpleJson = void 0;\n  \tlet SimpleJson$1 = class SimpleJson {\n  \t    static TextToDictionary(text) {\n  \t        return new SimpleJson.Reader(text).ToDictionary();\n  \t    }\n  \t    static TextToArray(text) {\n  \t        return new SimpleJson.Reader(text).ToArray();\n  \t    }\n  \t};\n  \tSimpleJson.SimpleJson = SimpleJson$1;\n  \t(function (SimpleJson) {\n  \t    class Reader {\n  \t        constructor(text) {\n  \t            // Before parsing the JSON, all floats of the form \"123.0\" are transformed into \"123.0f\"\n  \t            // so that they are recognized as FLOAT in the ink runtime\n  \t            const nativeFloatParsing = JSON.parse(\"0\", \n  \t            // @ts-expect-error : typing\n  \t            (_, __, context) => context != null);\n  \t            if (!nativeFloatParsing) {\n  \t                // When the nativeFloatParsing argument is false,\n  \t                // we aggressively replace using a regexp\n  \t                // At time of writing : only happen for Safari iOS and Mac\n  \t                const jsonWithExplicitFloat = text.replace(/(,\\s*)([0-9]+\\.[0]+)([,]*)/g, '$1\"$2f\"$3');\n  \t                this._rootObject = JSON.parse(jsonWithExplicitFloat);\n  \t            }\n  \t            else {\n  \t                // @ts-expect-error : typing\n  \t                const explicitFloatReviver = (_, value, context) => {\n  \t                    // When the nativeFloatParsing argument is true,\n  \t                    // we use a custom reviver function\n  \t                    //see https://github.com/y-lohse/inkjs/pull/1100#issuecomment-2733148441\n  \t                    if (Number.isInteger(value) && context.source.endsWith(\".0\")) {\n  \t                        return context.source + \"f\";\n  \t                    }\n  \t                    return value;\n  \t                };\n  \t                // @ts-expect-error : typing\n  \t                this._rootObject = JSON.parse(text, explicitFloatReviver);\n  \t            }\n  \t        }\n  \t        ToDictionary() {\n  \t            return this._rootObject;\n  \t        }\n  \t        ToArray() {\n  \t            return this._rootObject;\n  \t        }\n  \t    }\n  \t    SimpleJson.Reader = Reader;\n  \t    // In C#, this class writes json tokens directly to a StringWriter or\n  \t    // another stream. Here, a temporary hierarchy is created in the form\n  \t    // of a javascript object, which is serialised in the `toString` method.\n  \t    // See individual methods and properties for more information.\n  \t    class Writer {\n  \t        constructor() {\n  \t            // In addition to `_stateStack` present in the original code,\n  \t            // this implementation of SimpleJson use two other stacks and two\n  \t            // temporary variables holding the current context.\n  \t            // Used to keep track of the current property name being built\n  \t            // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n  \t            // `WritePropertyNameEnd`.\n  \t            this._currentPropertyName = null;\n  \t            // Used to keep track of the current string value being built\n  \t            // with `WriteStringStart`, `WriteStringInner` and\n  \t            // `WriteStringEnd`.\n  \t            this._currentString = null;\n  \t            this._stateStack = [];\n  \t            // Keep track of the current collection being built (either an array\n  \t            // or an object). For instance, at the '?' step during the hiarchy\n  \t            // creation, this hierarchy:\n  \t            // [3, {a: [b, ?]}] will have this corresponding stack:\n  \t            // (bottom) [Array, Object, Array] (top)\n  \t            this._collectionStack = [];\n  \t            // Keep track of the current property being assigned. For instance, at\n  \t            // the '?' step during the hiarchy creation, this hierarchy:\n  \t            // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n  \t            // (bottom) [a, c] (top)\n  \t            this._propertyNameStack = [];\n  \t            // Object containing the entire hiearchy.\n  \t            this._jsonObject = null;\n  \t        }\n  \t        WriteObject(inner) {\n  \t            this.WriteObjectStart();\n  \t            inner(this);\n  \t            this.WriteObjectEnd();\n  \t        }\n  \t        // Add a new object.\n  \t        WriteObjectStart() {\n  \t            this.StartNewObject(true);\n  \t            let newObject = {};\n  \t            if (this.state === SimpleJson.Writer.State.Property) {\n  \t                // This object is created as the value of a property,\n  \t                // inside an other object.\n  \t                this.Assert(this.currentCollection !== null);\n  \t                this.Assert(this.currentPropertyName !== null);\n  \t                let propertyName = this._propertyNameStack.pop();\n  \t                this.currentCollection[propertyName] = newObject;\n  \t                this._collectionStack.push(newObject);\n  \t            }\n  \t            else if (this.state === SimpleJson.Writer.State.Array) {\n  \t                // This object is created as the child of an array.\n  \t                this.Assert(this.currentCollection !== null);\n  \t                this.currentCollection.push(newObject);\n  \t                this._collectionStack.push(newObject);\n  \t            }\n  \t            else {\n  \t                // This object is the root object.\n  \t                this.Assert(this.state === SimpleJson.Writer.State.None);\n  \t                this._jsonObject = newObject;\n  \t                this._collectionStack.push(newObject);\n  \t            }\n  \t            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));\n  \t        }\n  \t        WriteObjectEnd() {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.Object);\n  \t            this._collectionStack.pop();\n  \t            this._stateStack.pop();\n  \t        }\n  \t        // Write a property name / value pair to the current object.\n  \t        WriteProperty(name, \n  \t        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t        innerOrContent) {\n  \t            this.WritePropertyStart(name);\n  \t            if (arguments[1] instanceof Function) {\n  \t                let inner = arguments[1];\n  \t                inner(this);\n  \t            }\n  \t            else {\n  \t                let content = arguments[1];\n  \t                this.Write(content);\n  \t            }\n  \t            this.WritePropertyEnd();\n  \t        }\n  \t        // Int and Float are separate calls, since there both are\n  \t        // numbers in JavaScript, but need to be handled differently.\n  \t        WriteIntProperty(name, content) {\n  \t            this.WritePropertyStart(name);\n  \t            this.WriteInt(content);\n  \t            this.WritePropertyEnd();\n  \t        }\n  \t        WriteFloatProperty(name, content) {\n  \t            this.WritePropertyStart(name);\n  \t            this.WriteFloat(content);\n  \t            this.WritePropertyEnd();\n  \t        }\n  \t        // Prepare a new property name, which will be use to add the\n  \t        // new object when calling _addToCurrentObject() from a Write\n  \t        // method.\n  \t        WritePropertyStart(name) {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.Object);\n  \t            this._propertyNameStack.push(name);\n  \t            this.IncrementChildCount();\n  \t            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));\n  \t        }\n  \t        WritePropertyEnd() {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.Property);\n  \t            this.Assert(this.childCount === 1);\n  \t            this._stateStack.pop();\n  \t        }\n  \t        // Prepare a new property name, except this time, the property name\n  \t        // will be created by concatenating all the strings passed to\n  \t        // WritePropertyNameInner.\n  \t        WritePropertyNameStart() {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.Object);\n  \t            this.IncrementChildCount();\n  \t            this._currentPropertyName = \"\";\n  \t            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));\n  \t            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));\n  \t        }\n  \t        WritePropertyNameEnd() {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n  \t            this.Assert(this._currentPropertyName !== null);\n  \t            this._propertyNameStack.push(this._currentPropertyName);\n  \t            this._currentPropertyName = null;\n  \t            this._stateStack.pop();\n  \t        }\n  \t        WritePropertyNameInner(str) {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n  \t            this.Assert(this._currentPropertyName !== null);\n  \t            this._currentPropertyName += str;\n  \t        }\n  \t        // Add a new array.\n  \t        WriteArrayStart() {\n  \t            this.StartNewObject(true);\n  \t            let newObject = [];\n  \t            if (this.state === SimpleJson.Writer.State.Property) {\n  \t                // This array is created as the value of a property,\n  \t                // inside an object.\n  \t                this.Assert(this.currentCollection !== null);\n  \t                this.Assert(this.currentPropertyName !== null);\n  \t                let propertyName = this._propertyNameStack.pop();\n  \t                this.currentCollection[propertyName] = newObject;\n  \t                this._collectionStack.push(newObject);\n  \t            }\n  \t            else if (this.state === SimpleJson.Writer.State.Array) {\n  \t                // This array is created as the child of another array.\n  \t                this.Assert(this.currentCollection !== null);\n  \t                this.currentCollection.push(newObject);\n  \t                this._collectionStack.push(newObject);\n  \t            }\n  \t            else {\n  \t                // This array is the root object.\n  \t                this.Assert(this.state === SimpleJson.Writer.State.None);\n  \t                this._jsonObject = newObject;\n  \t                this._collectionStack.push(newObject);\n  \t            }\n  \t            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));\n  \t        }\n  \t        WriteArrayEnd() {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.Array);\n  \t            this._collectionStack.pop();\n  \t            this._stateStack.pop();\n  \t        }\n  \t        // Add the value to the appropriate collection (array / object), given the current\n  \t        // context.\n  \t        Write(value, \n  \t        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t        escape = true) {\n  \t            if (value === null) {\n  \t                console.error(\"Warning: trying to write a null value\");\n  \t                return;\n  \t            }\n  \t            this.StartNewObject(false);\n  \t            this._addToCurrentObject(value);\n  \t        }\n  \t        WriteBool(value) {\n  \t            if (value === null) {\n  \t                return;\n  \t            }\n  \t            this.StartNewObject(false);\n  \t            this._addToCurrentObject(value);\n  \t        }\n  \t        WriteInt(value) {\n  \t            if (value === null) {\n  \t                return;\n  \t            }\n  \t            this.StartNewObject(false);\n  \t            // Math.floor is used as a precaution:\n  \t            //     1. to ensure that the value is written as an integer\n  \t            //        (without a fractional part -> 1 instead of 1.0), even\n  \t            //        though it should be the default behaviour of\n  \t            //        JSON.serialize;\n  \t            //     2. to ensure that if a floating number is passed\n  \t            //        accidentally, it's converted to an integer.\n  \t            //\n  \t            // This guarantees savegame compatibility with the reference\n  \t            // implementation.\n  \t            this._addToCurrentObject(Math.floor(value));\n  \t        }\n  \t        // Since JSON doesn't support NaN and Infinity, these values\n  \t        // are converted here.\n  \t        WriteFloat(value) {\n  \t            if (value === null) {\n  \t                return;\n  \t            }\n  \t            this.StartNewObject(false);\n  \t            if (value == Number.POSITIVE_INFINITY) {\n  \t                this._addToCurrentObject(3.4e38);\n  \t            }\n  \t            else if (value == Number.NEGATIVE_INFINITY) {\n  \t                this._addToCurrentObject(-34e37);\n  \t            }\n  \t            else if (isNaN(value)) {\n  \t                this._addToCurrentObject(0.0);\n  \t            }\n  \t            else {\n  \t                this._addToCurrentObject(value);\n  \t            }\n  \t        }\n  \t        WriteNull() {\n  \t            this.StartNewObject(false);\n  \t            this._addToCurrentObject(null);\n  \t        }\n  \t        // Prepare a string before adding it to the current collection in\n  \t        // WriteStringEnd(). The string will be a concatenation of all the\n  \t        // strings passed to WriteStringInner.\n  \t        WriteStringStart() {\n  \t            this.StartNewObject(false);\n  \t            this._currentString = \"\";\n  \t            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));\n  \t        }\n  \t        WriteStringEnd() {\n  \t            this.Assert(this.state == SimpleJson.Writer.State.String);\n  \t            this._stateStack.pop();\n  \t            this._addToCurrentObject(this._currentString);\n  \t            this._currentString = null;\n  \t        }\n  \t        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t        WriteStringInner(str, escape = true) {\n  \t            this.Assert(this.state === SimpleJson.Writer.State.String);\n  \t            if (str === null) {\n  \t                console.error(\"Warning: trying to write a null string\");\n  \t                return;\n  \t            }\n  \t            this._currentString += str;\n  \t        }\n  \t        // Serialise the root object into a JSON string.\n  \t        toString() {\n  \t            if (this._jsonObject === null) {\n  \t                return \"\";\n  \t            }\n  \t            return JSON.stringify(this._jsonObject);\n  \t        }\n  \t        // Prepare the state stack when adding new objects / values.\n  \t        StartNewObject(container) {\n  \t            if (container) {\n  \t                this.Assert(this.state === SimpleJson.Writer.State.None ||\n  \t                    this.state === SimpleJson.Writer.State.Property ||\n  \t                    this.state === SimpleJson.Writer.State.Array);\n  \t            }\n  \t            else {\n  \t                this.Assert(this.state === SimpleJson.Writer.State.Property ||\n  \t                    this.state === SimpleJson.Writer.State.Array);\n  \t            }\n  \t            if (this.state === SimpleJson.Writer.State.Property) {\n  \t                this.Assert(this.childCount === 0);\n  \t            }\n  \t            if (this.state === SimpleJson.Writer.State.Array ||\n  \t                this.state === SimpleJson.Writer.State.Property) {\n  \t                this.IncrementChildCount();\n  \t            }\n  \t        }\n  \t        // These getters peek all the different stacks.\n  \t        get state() {\n  \t            if (this._stateStack.length > 0) {\n  \t                return this._stateStack[this._stateStack.length - 1].type;\n  \t            }\n  \t            else {\n  \t                return SimpleJson.Writer.State.None;\n  \t            }\n  \t        }\n  \t        get childCount() {\n  \t            if (this._stateStack.length > 0) {\n  \t                return this._stateStack[this._stateStack.length - 1].childCount;\n  \t            }\n  \t            else {\n  \t                return 0;\n  \t            }\n  \t        }\n  \t        get currentCollection() {\n  \t            if (this._collectionStack.length > 0) {\n  \t                return this._collectionStack[this._collectionStack.length - 1];\n  \t            }\n  \t            else {\n  \t                return null;\n  \t            }\n  \t        }\n  \t        get currentPropertyName() {\n  \t            if (this._propertyNameStack.length > 0) {\n  \t                return this._propertyNameStack[this._propertyNameStack.length - 1];\n  \t            }\n  \t            else {\n  \t                return null;\n  \t            }\n  \t        }\n  \t        IncrementChildCount() {\n  \t            this.Assert(this._stateStack.length > 0);\n  \t            let currEl = this._stateStack.pop();\n  \t            currEl.childCount++;\n  \t            this._stateStack.push(currEl);\n  \t        }\n  \t        Assert(condition) {\n  \t            if (!condition)\n  \t                throw Error(\"Assert failed while writing JSON\");\n  \t        }\n  \t        // This method did not exist in the original C# code. It adds\n  \t        // the given value to the current collection (used by Write methods).\n  \t        _addToCurrentObject(value) {\n  \t            this.Assert(this.currentCollection !== null);\n  \t            if (this.state === SimpleJson.Writer.State.Array) {\n  \t                this.Assert(Array.isArray(this.currentCollection));\n  \t                this.currentCollection.push(value);\n  \t            }\n  \t            else if (this.state === SimpleJson.Writer.State.Property) {\n  \t                this.Assert(!Array.isArray(this.currentCollection));\n  \t                this.Assert(this.currentPropertyName !== null);\n  \t                this.currentCollection[this.currentPropertyName] = value;\n  \t                this._propertyNameStack.pop();\n  \t            }\n  \t        }\n  \t    }\n  \t    SimpleJson.Writer = Writer;\n  \t    (function (Writer) {\n  \t        (function (State) {\n  \t            State[State[\"None\"] = 0] = \"None\";\n  \t            State[State[\"Object\"] = 1] = \"Object\";\n  \t            State[State[\"Array\"] = 2] = \"Array\";\n  \t            State[State[\"Property\"] = 3] = \"Property\";\n  \t            State[State[\"PropertyName\"] = 4] = \"PropertyName\";\n  \t            State[State[\"String\"] = 5] = \"String\";\n  \t        })(Writer.State || (Writer.State = {}));\n  \t        class StateElement {\n  \t            constructor(type) {\n  \t                this.type = SimpleJson.Writer.State.None;\n  \t                this.childCount = 0;\n  \t                this.type = type;\n  \t            }\n  \t        }\n  \t        Writer.StateElement = StateElement;\n  \t    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));\n  \t})(SimpleJson$1 || (SimpleJson.SimpleJson = SimpleJson$1 = {}));\n  \t\n  \treturn SimpleJson;\n  }\n\n  var Flow = {};\n\n  var hasRequiredFlow;\n\n  function requireFlow () {\n  \tif (hasRequiredFlow) return Flow;\n  \thasRequiredFlow = 1;\n  \tObject.defineProperty(Flow, \"__esModule\", { value: true });\n  \tFlow.Flow = void 0;\n  \tconst CallStack_1 = requireCallStack();\n  \tconst JsonSerialisation_1 = requireJsonSerialisation();\n  \tconst NullException_1 = requireNullException();\n  \tlet Flow$1 = class Flow {\n  \t    constructor() {\n  \t        let name = arguments[0];\n  \t        let story = arguments[1];\n  \t        this.name = name;\n  \t        this.callStack = new CallStack_1.CallStack(story);\n  \t        if (arguments[2]) {\n  \t            let jObject = arguments[2];\n  \t            this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n  \t            this.outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"outputStream\"]);\n  \t            this.currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"currentChoices\"]);\n  \t            let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n  \t            if (typeof jChoiceThreadsObj !== \"undefined\") {\n  \t                this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n  \t            }\n  \t        }\n  \t        else {\n  \t            this.outputStream = [];\n  \t            this.currentChoices = [];\n  \t        }\n  \t    }\n  \t    WriteJson(writer) {\n  \t        writer.WriteObjectStart();\n  \t        writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n  \t        writer.WriteProperty(\"outputStream\", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream));\n  \t        let hasChoiceThreads = false;\n  \t        for (let c of this.currentChoices) {\n  \t            if (c.threadAtGeneration === null)\n  \t                return (0, NullException_1.throwNullException)(\"c.threadAtGeneration\");\n  \t            c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n  \t            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n  \t                if (!hasChoiceThreads) {\n  \t                    hasChoiceThreads = true;\n  \t                    writer.WritePropertyStart(\"choiceThreads\");\n  \t                    writer.WriteObjectStart();\n  \t                }\n  \t                writer.WritePropertyStart(c.originalThreadIndex);\n  \t                c.threadAtGeneration.WriteJson(writer);\n  \t                writer.WritePropertyEnd();\n  \t            }\n  \t        }\n  \t        if (hasChoiceThreads) {\n  \t            writer.WriteObjectEnd();\n  \t            writer.WritePropertyEnd();\n  \t        }\n  \t        writer.WriteProperty(\"currentChoices\", (w) => {\n  \t            w.WriteArrayStart();\n  \t            for (let c of this.currentChoices) {\n  \t                JsonSerialisation_1.JsonSerialisation.WriteChoice(w, c);\n  \t            }\n  \t            w.WriteArrayEnd();\n  \t        });\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    LoadFlowChoiceThreads(jChoiceThreads, story) {\n  \t        for (let choice of this.currentChoices) {\n  \t            let foundActiveThread = this.callStack.ThreadWithIndex(choice.originalThreadIndex);\n  \t            if (foundActiveThread !== null) {\n  \t                choice.threadAtGeneration = foundActiveThread.Copy();\n  \t            }\n  \t            else {\n  \t                let jSavedChoiceThread = jChoiceThreads[`${choice.originalThreadIndex}`];\n  \t                choice.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, story);\n  \t            }\n  \t        }\n  \t    }\n  \t};\n  \tFlow.Flow = Flow$1;\n  \t\n  \treturn Flow;\n  }\n\n  var hasRequiredStoryState;\n\n  function requireStoryState () {\n  \tif (hasRequiredStoryState) return StoryState;\n  \thasRequiredStoryState = 1;\n  \tObject.defineProperty(StoryState, \"__esModule\", { value: true });\n  \tStoryState.StoryState = void 0;\n  \tconst CallStack_1 = requireCallStack();\n  \tconst VariablesState_1 = requireVariablesState();\n  \tconst Value_1 = requireValue();\n  \tconst PushPop_1 = requirePushPop();\n  \tconst Tag_1 = requireTag$1();\n  \tconst Glue_1 = requireGlue$1();\n  \tconst Path_1 = requirePath$1();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst StringBuilder_1 = requireStringBuilder();\n  \tconst JsonSerialisation_1 = requireJsonSerialisation();\n  \tconst PRNG_1 = requirePRNG();\n  \tconst Void_1 = requireVoid();\n  \tconst Pointer_1 = requirePointer();\n  \tconst TryGetResult_1 = requireTryGetResult();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst Debug_1 = requireDebug();\n  \tconst NullException_1 = requireNullException();\n  \tconst Story_1 = requireStory$1();\n  \tconst StatePatch_1 = requireStatePatch();\n  \tconst SimpleJson_1 = requireSimpleJson();\n  \tconst Flow_1 = requireFlow();\n  \tconst InkList_1 = requireInkList();\n  \tlet StoryState$1 = class StoryState {\n  \t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t    ToJson(indented = false) {\n  \t        let writer = new SimpleJson_1.SimpleJson.Writer();\n  \t        this.WriteJson(writer);\n  \t        return writer.toString();\n  \t    }\n  \t    toJson(indented = false) {\n  \t        return this.ToJson(indented);\n  \t    }\n  \t    LoadJson(json) {\n  \t        let jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);\n  \t        this.LoadJsonObj(jObject);\n  \t        if (this.onDidLoadState !== null)\n  \t            this.onDidLoadState();\n  \t    }\n  \t    VisitCountAtPathString(pathString) {\n  \t        let visitCountOut;\n  \t        if (this._patch !== null) {\n  \t            let container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;\n  \t            if (container === null)\n  \t                throw new Error(\"Content at path not found: \" + pathString);\n  \t            visitCountOut = this._patch.TryGetVisitCount(container, 0);\n  \t            if (visitCountOut.exists)\n  \t                return visitCountOut.result;\n  \t        }\n  \t        visitCountOut = (0, TryGetResult_1.tryGetValueFromMap)(this._visitCounts, pathString, null);\n  \t        if (visitCountOut.exists)\n  \t            return visitCountOut.result;\n  \t        return 0;\n  \t    }\n  \t    VisitCountForContainer(container) {\n  \t        if (container === null) {\n  \t            return (0, NullException_1.throwNullException)(\"container\");\n  \t        }\n  \t        if (!container.visitsShouldBeCounted) {\n  \t            this.story.Error(\"Read count for target (\" +\n  \t                container.name +\n  \t                \" - on \" +\n  \t                container.debugMetadata +\n  \t                \") unknown. The story may need to be compiled with countAllVisits flag (-c).\");\n  \t            return 0;\n  \t        }\n  \t        if (this._patch !== null) {\n  \t            let count = this._patch.TryGetVisitCount(container, 0);\n  \t            if (count.exists) {\n  \t                return count.result;\n  \t            }\n  \t        }\n  \t        let containerPathStr = container.path.toString();\n  \t        let count2 = (0, TryGetResult_1.tryGetValueFromMap)(this._visitCounts, containerPathStr, null);\n  \t        if (count2.exists) {\n  \t            return count2.result;\n  \t        }\n  \t        return 0;\n  \t    }\n  \t    IncrementVisitCountForContainer(container) {\n  \t        if (this._patch !== null) {\n  \t            let currCount = this.VisitCountForContainer(container);\n  \t            currCount++;\n  \t            this._patch.SetVisitCount(container, currCount);\n  \t            return;\n  \t        }\n  \t        let containerPathStr = container.path.toString();\n  \t        let count = (0, TryGetResult_1.tryGetValueFromMap)(this._visitCounts, containerPathStr, null);\n  \t        if (count.exists) {\n  \t            this._visitCounts.set(containerPathStr, count.result + 1);\n  \t        }\n  \t        else {\n  \t            this._visitCounts.set(containerPathStr, 1);\n  \t        }\n  \t    }\n  \t    RecordTurnIndexVisitToContainer(container) {\n  \t        if (this._patch !== null) {\n  \t            this._patch.SetTurnIndex(container, this.currentTurnIndex);\n  \t            return;\n  \t        }\n  \t        let containerPathStr = container.path.toString();\n  \t        this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  \t    }\n  \t    TurnsSinceForContainer(container) {\n  \t        if (!container.turnIndexShouldBeCounted) {\n  \t            this.story.Error(\"TURNS_SINCE() for target (\" +\n  \t                container.name +\n  \t                \" - on \" +\n  \t                container.debugMetadata +\n  \t                \") unknown. The story may need to be compiled with countAllVisits flag (-c).\");\n  \t        }\n  \t        if (this._patch !== null) {\n  \t            let index = this._patch.TryGetTurnIndex(container, 0);\n  \t            if (index.exists) {\n  \t                return this.currentTurnIndex - index.result;\n  \t            }\n  \t        }\n  \t        let containerPathStr = container.path.toString();\n  \t        let index2 = (0, TryGetResult_1.tryGetValueFromMap)(this._turnIndices, containerPathStr, 0);\n  \t        if (index2.exists) {\n  \t            return this.currentTurnIndex - index2.result;\n  \t        }\n  \t        else {\n  \t            return -1;\n  \t        }\n  \t    }\n  \t    get callstackDepth() {\n  \t        return this.callStack.depth;\n  \t    }\n  \t    get outputStream() {\n  \t        return this._currentFlow.outputStream;\n  \t    }\n  \t    get currentChoices() {\n  \t        // If we can continue generating text content rather than choices,\n  \t        // then we reflect the choice list as being empty, since choices\n  \t        // should always come at the end.\n  \t        if (this.canContinue)\n  \t            return [];\n  \t        return this._currentFlow.currentChoices;\n  \t    }\n  \t    get generatedChoices() {\n  \t        return this._currentFlow.currentChoices;\n  \t    }\n  \t    get currentErrors() {\n  \t        return this._currentErrors;\n  \t    }\n  \t    get currentWarnings() {\n  \t        return this._currentWarnings;\n  \t    }\n  \t    get variablesState() {\n  \t        return this._variablesState;\n  \t    }\n  \t    set variablesState(value) {\n  \t        this._variablesState = value;\n  \t    }\n  \t    get callStack() {\n  \t        return this._currentFlow.callStack;\n  \t    }\n  \t    get evaluationStack() {\n  \t        return this._evaluationStack;\n  \t    }\n  \t    get currentTurnIndex() {\n  \t        return this._currentTurnIndex;\n  \t    }\n  \t    set currentTurnIndex(value) {\n  \t        this._currentTurnIndex = value;\n  \t    }\n  \t    get currentPathString() {\n  \t        let pointer = this.currentPointer;\n  \t        if (pointer.isNull) {\n  \t            return null;\n  \t        }\n  \t        else {\n  \t            if (pointer.path === null) {\n  \t                return (0, NullException_1.throwNullException)(\"pointer.path\");\n  \t            }\n  \t            return pointer.path.toString();\n  \t        }\n  \t    }\n  \t    get previousPathString() {\n  \t        let pointer = this.previousPointer;\n  \t        if (pointer.isNull) {\n  \t            return null;\n  \t        }\n  \t        else {\n  \t            if (pointer.path === null) {\n  \t                return (0, NullException_1.throwNullException)(\"previousPointer.path\");\n  \t            }\n  \t            return pointer.path.toString();\n  \t        }\n  \t    }\n  \t    get currentPointer() {\n  \t        return this.callStack.currentElement.currentPointer.copy();\n  \t    }\n  \t    set currentPointer(value) {\n  \t        this.callStack.currentElement.currentPointer = value.copy();\n  \t    }\n  \t    get previousPointer() {\n  \t        return this.callStack.currentThread.previousPointer.copy();\n  \t    }\n  \t    set previousPointer(value) {\n  \t        this.callStack.currentThread.previousPointer = value.copy();\n  \t    }\n  \t    get canContinue() {\n  \t        return !this.currentPointer.isNull && !this.hasError;\n  \t    }\n  \t    get hasError() {\n  \t        return this.currentErrors != null && this.currentErrors.length > 0;\n  \t    }\n  \t    get hasWarning() {\n  \t        return this.currentWarnings != null && this.currentWarnings.length > 0;\n  \t    }\n  \t    get currentText() {\n  \t        if (this._outputStreamTextDirty) {\n  \t            let sb = new StringBuilder_1.StringBuilder();\n  \t            let inTag = false;\n  \t            for (let outputObj of this.outputStream) {\n  \t                // var textContent = outputObj as StringValue;\n  \t                let textContent = (0, TypeAssertion_1.asOrNull)(outputObj, Value_1.StringValue);\n  \t                if (!inTag && textContent !== null) {\n  \t                    sb.Append(textContent.value);\n  \t                }\n  \t                else {\n  \t                    let controlCommand = (0, TypeAssertion_1.asOrNull)(outputObj, ControlCommand_1.ControlCommand);\n  \t                    if (controlCommand !== null) {\n  \t                        if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n  \t                            inTag = true;\n  \t                        }\n  \t                        else if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.EndTag) {\n  \t                            inTag = false;\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t            this._currentText = this.CleanOutputWhitespace(sb.toString());\n  \t            this._outputStreamTextDirty = false;\n  \t        }\n  \t        return this._currentText;\n  \t    }\n  \t    CleanOutputWhitespace(str) {\n  \t        let sb = new StringBuilder_1.StringBuilder();\n  \t        let currentWhitespaceStart = -1;\n  \t        let startOfLine = 0;\n  \t        for (let i = 0; i < str.length; i++) {\n  \t            let c = str.charAt(i);\n  \t            let isInlineWhitespace = c == \" \" || c == \"\\t\";\n  \t            if (isInlineWhitespace && currentWhitespaceStart == -1)\n  \t                currentWhitespaceStart = i;\n  \t            if (!isInlineWhitespace) {\n  \t                if (c != \"\\n\" &&\n  \t                    currentWhitespaceStart > 0 &&\n  \t                    currentWhitespaceStart != startOfLine) {\n  \t                    sb.Append(\" \");\n  \t                }\n  \t                currentWhitespaceStart = -1;\n  \t            }\n  \t            if (c == \"\\n\")\n  \t                startOfLine = i + 1;\n  \t            if (!isInlineWhitespace)\n  \t                sb.Append(c);\n  \t        }\n  \t        return sb.toString();\n  \t    }\n  \t    get currentTags() {\n  \t        if (this._outputStreamTagsDirty) {\n  \t            this._currentTags = [];\n  \t            let inTag = false;\n  \t            let sb = new StringBuilder_1.StringBuilder();\n  \t            for (let outputObj of this.outputStream) {\n  \t                let controlCommand = (0, TypeAssertion_1.asOrNull)(outputObj, ControlCommand_1.ControlCommand);\n  \t                if (controlCommand != null) {\n  \t                    if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n  \t                        if (inTag && sb.Length > 0) {\n  \t                            let txt = this.CleanOutputWhitespace(sb.toString());\n  \t                            this._currentTags.push(txt);\n  \t                            sb.Clear();\n  \t                        }\n  \t                        inTag = true;\n  \t                    }\n  \t                    else if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.EndTag) {\n  \t                        if (sb.Length > 0) {\n  \t                            let txt = this.CleanOutputWhitespace(sb.toString());\n  \t                            this._currentTags.push(txt);\n  \t                            sb.Clear();\n  \t                        }\n  \t                        inTag = false;\n  \t                    }\n  \t                }\n  \t                else if (inTag) {\n  \t                    let strVal = (0, TypeAssertion_1.asOrNull)(outputObj, Value_1.StringValue);\n  \t                    if (strVal !== null) {\n  \t                        sb.Append(strVal.value);\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    let tag = (0, TypeAssertion_1.asOrNull)(outputObj, Tag_1.Tag);\n  \t                    if (tag != null && tag.text != null && tag.text.length > 0) {\n  \t                        this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n  \t                    }\n  \t                }\n  \t            }\n  \t            if (sb.Length > 0) {\n  \t                let txt = this.CleanOutputWhitespace(sb.toString());\n  \t                this._currentTags.push(txt);\n  \t                sb.Clear();\n  \t            }\n  \t            this._outputStreamTagsDirty = false;\n  \t        }\n  \t        return this._currentTags;\n  \t    }\n  \t    get currentFlowName() {\n  \t        return this._currentFlow.name;\n  \t    }\n  \t    get currentFlowIsDefaultFlow() {\n  \t        return this._currentFlow.name == this.kDefaultFlowName;\n  \t    }\n  \t    get aliveFlowNames() {\n  \t        if (this._aliveFlowNamesDirty) {\n  \t            this._aliveFlowNames = [];\n  \t            if (this._namedFlows != null) {\n  \t                for (let flowName of this._namedFlows.keys()) {\n  \t                    if (flowName != this.kDefaultFlowName) {\n  \t                        this._aliveFlowNames.push(flowName);\n  \t                    }\n  \t                }\n  \t            }\n  \t            this._aliveFlowNamesDirty = false;\n  \t        }\n  \t        return this._aliveFlowNames;\n  \t    }\n  \t    get inExpressionEvaluation() {\n  \t        return this.callStack.currentElement.inExpressionEvaluation;\n  \t    }\n  \t    set inExpressionEvaluation(value) {\n  \t        this.callStack.currentElement.inExpressionEvaluation = value;\n  \t    }\n  \t    constructor(story) {\n  \t        // Backward compatible changes since v8:\n  \t        // v10: dynamic tags\n  \t        // v9:  multi-flows\n  \t        this.kInkSaveStateVersion = 10;\n  \t        this.kMinCompatibleLoadVersion = 8;\n  \t        this.onDidLoadState = null;\n  \t        this._currentErrors = null;\n  \t        this._currentWarnings = null;\n  \t        this.divertedPointer = Pointer_1.Pointer.Null;\n  \t        this._currentTurnIndex = 0;\n  \t        this.storySeed = 0;\n  \t        this.previousRandom = 0;\n  \t        this.didSafeExit = false;\n  \t        this._currentText = null;\n  \t        this._currentTags = null;\n  \t        this._outputStreamTextDirty = true;\n  \t        this._outputStreamTagsDirty = true;\n  \t        this._patch = null;\n  \t        this._aliveFlowNames = null;\n  \t        this._namedFlows = null;\n  \t        this.kDefaultFlowName = \"DEFAULT_FLOW\";\n  \t        this._aliveFlowNamesDirty = true;\n  \t        this.story = story;\n  \t        this._currentFlow = new Flow_1.Flow(this.kDefaultFlowName, story);\n  \t        this.OutputStreamDirty();\n  \t        this._aliveFlowNamesDirty = true;\n  \t        this._evaluationStack = [];\n  \t        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);\n  \t        this._visitCounts = new Map();\n  \t        this._turnIndices = new Map();\n  \t        this.currentTurnIndex = -1;\n  \t        let timeSeed = new Date().getTime();\n  \t        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;\n  \t        this.previousRandom = 0;\n  \t        this.GoToStart();\n  \t    }\n  \t    GoToStart() {\n  \t        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);\n  \t    }\n  \t    SwitchFlow_Internal(flowName) {\n  \t        if (flowName === null)\n  \t            throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n  \t        if (this._namedFlows === null) {\n  \t            this._namedFlows = new Map();\n  \t            this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n  \t        }\n  \t        if (flowName === this._currentFlow.name) {\n  \t            return;\n  \t        }\n  \t        let flow;\n  \t        let content = (0, TryGetResult_1.tryGetValueFromMap)(this._namedFlows, flowName, null);\n  \t        if (content.exists) {\n  \t            flow = content.result;\n  \t        }\n  \t        else {\n  \t            flow = new Flow_1.Flow(flowName, this.story);\n  \t            this._namedFlows.set(flowName, flow);\n  \t            this._aliveFlowNamesDirty = true;\n  \t        }\n  \t        this._currentFlow = flow;\n  \t        this.variablesState.callStack = this._currentFlow.callStack;\n  \t        this.OutputStreamDirty();\n  \t    }\n  \t    SwitchToDefaultFlow_Internal() {\n  \t        if (this._namedFlows === null)\n  \t            return;\n  \t        this.SwitchFlow_Internal(this.kDefaultFlowName);\n  \t    }\n  \t    RemoveFlow_Internal(flowName) {\n  \t        if (flowName === null)\n  \t            throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n  \t        if (flowName === this.kDefaultFlowName)\n  \t            throw new Error(\"Cannot destroy default flow\");\n  \t        if (this._currentFlow.name === flowName) {\n  \t            this.SwitchToDefaultFlow_Internal();\n  \t        }\n  \t        if (this._namedFlows === null)\n  \t            return (0, NullException_1.throwNullException)(\"this._namedFlows\");\n  \t        this._namedFlows.delete(flowName);\n  \t        this._aliveFlowNamesDirty = true;\n  \t    }\n  \t    CopyAndStartPatching(forBackgroundSave) {\n  \t        let copy = new StoryState(this.story);\n  \t        copy._patch = new StatePatch_1.StatePatch(this._patch);\n  \t        copy._currentFlow.name = this._currentFlow.name;\n  \t        copy._currentFlow.callStack = new CallStack_1.CallStack(this._currentFlow.callStack);\n  \t        copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n  \t        copy.OutputStreamDirty();\n  \t        // When background saving we need to make copies of choices since they each have\n  \t        // a snapshot of the thread at the time of generation since the game could progress\n  \t        // significantly and threads modified during the save process.\n  \t        // However, when doing internal saving and restoring of snapshots this isn't an issue,\n  \t        // and we can simply ref-copy the choices with their existing threads.\n  \t        if (forBackgroundSave) {\n  \t            for (let choice of this._currentFlow.currentChoices) {\n  \t                copy._currentFlow.currentChoices.push(choice.Clone());\n  \t            }\n  \t        }\n  \t        else {\n  \t            copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n  \t        }\n  \t        if (this._namedFlows !== null) {\n  \t            copy._namedFlows = new Map();\n  \t            for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n  \t                copy._namedFlows.set(namedFlowKey, namedFlowValue);\n  \t                copy._aliveFlowNamesDirty = true;\n  \t            }\n  \t            copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n  \t        }\n  \t        if (this.hasError) {\n  \t            copy._currentErrors = [];\n  \t            copy._currentErrors.push(...(this.currentErrors || []));\n  \t        }\n  \t        if (this.hasWarning) {\n  \t            copy._currentWarnings = [];\n  \t            copy._currentWarnings.push(...(this.currentWarnings || []));\n  \t        }\n  \t        copy.variablesState = this.variablesState;\n  \t        copy.variablesState.callStack = copy.callStack;\n  \t        copy.variablesState.patch = copy._patch;\n  \t        copy.evaluationStack.push(...this.evaluationStack);\n  \t        if (!this.divertedPointer.isNull)\n  \t            copy.divertedPointer = this.divertedPointer.copy();\n  \t        copy.previousPointer = this.previousPointer.copy();\n  \t        copy._visitCounts = this._visitCounts;\n  \t        copy._turnIndices = this._turnIndices;\n  \t        copy.currentTurnIndex = this.currentTurnIndex;\n  \t        copy.storySeed = this.storySeed;\n  \t        copy.previousRandom = this.previousRandom;\n  \t        copy.didSafeExit = this.didSafeExit;\n  \t        return copy;\n  \t    }\n  \t    RestoreAfterPatch() {\n  \t        this.variablesState.callStack = this.callStack;\n  \t        this.variablesState.patch = this._patch;\n  \t    }\n  \t    ApplyAnyPatch() {\n  \t        if (this._patch === null)\n  \t            return;\n  \t        this.variablesState.ApplyPatch();\n  \t        for (let [key, value] of this._patch.visitCounts)\n  \t            this.ApplyCountChanges(key, value, true);\n  \t        for (let [key, value] of this._patch.turnIndices)\n  \t            this.ApplyCountChanges(key, value, false);\n  \t        this._patch = null;\n  \t    }\n  \t    ApplyCountChanges(container, newCount, isVisit) {\n  \t        let counts = isVisit ? this._visitCounts : this._turnIndices;\n  \t        counts.set(container.path.toString(), newCount);\n  \t    }\n  \t    WriteJson(writer) {\n  \t        writer.WriteObjectStart();\n  \t        writer.WritePropertyStart(\"flows\");\n  \t        writer.WriteObjectStart();\n  \t        // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n  \t        // Call it inside a function to make sure `this` is correctly bound\n  \t        // and passed down the call hierarchy.\n  \t        if (this._namedFlows !== null) {\n  \t            for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n  \t                writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n  \t            }\n  \t        }\n  \t        else {\n  \t            writer.WriteProperty(this._currentFlow.name, (w) => this._currentFlow.WriteJson(w));\n  \t        }\n  \t        writer.WriteObjectEnd();\n  \t        writer.WritePropertyEnd();\n  \t        writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n  \t        writer.WriteProperty(\"variablesState\", (w) => this.variablesState.WriteJson(w));\n  \t        writer.WriteProperty(\"evalStack\", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));\n  \t        if (!this.divertedPointer.isNull) {\n  \t            if (this.divertedPointer.path === null) {\n  \t                return (0, NullException_1.throwNullException)(\"divertedPointer\");\n  \t            }\n  \t            writer.WriteProperty(\"currentDivertTarget\", this.divertedPointer.path.componentsString);\n  \t        }\n  \t        writer.WriteProperty(\"visitCounts\", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));\n  \t        writer.WriteProperty(\"turnIndices\", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));\n  \t        writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n  \t        writer.WriteIntProperty(\"storySeed\", this.storySeed);\n  \t        writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n  \t        writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n  \t        writer.WriteIntProperty(\"inkFormatVersion\", Story_1.Story.inkVersionCurrent);\n  \t        writer.WriteObjectEnd();\n  \t    }\n  \t    LoadJsonObj(value) {\n  \t        let jObject = value;\n  \t        let jSaveVersion = jObject[\"inkSaveVersion\"];\n  \t        if (jSaveVersion == null) {\n  \t            throw new Error(\"ink save format incorrect, can't load.\");\n  \t        }\n  \t        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n  \t            throw new Error(\"Ink save format isn't compatible with the current version (saw '\" +\n  \t                jSaveVersion +\n  \t                \"', but minimum is \" +\n  \t                this.kMinCompatibleLoadVersion +\n  \t                \"), so can't load.\");\n  \t        }\n  \t        let flowsObj = jObject[\"flows\"];\n  \t        if (flowsObj != null) {\n  \t            let flowsObjDict = flowsObj;\n  \t            // Single default flow\n  \t            if (Object.keys(flowsObjDict).length === 1) {\n  \t                this._namedFlows = null;\n  \t            }\n  \t            else if (this._namedFlows === null) {\n  \t                this._namedFlows = new Map();\n  \t            }\n  \t            else {\n  \t                this._namedFlows.clear();\n  \t            }\n  \t            let flowsObjDictEntries = Object.entries(flowsObjDict);\n  \t            for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n  \t                let name = namedFlowObjKey;\n  \t                let flowObj = namedFlowObjValue;\n  \t                let flow = new Flow_1.Flow(name, this.story, flowObj);\n  \t                if (Object.keys(flowsObjDict).length === 1) {\n  \t                    this._currentFlow = new Flow_1.Flow(name, this.story, flowObj);\n  \t                }\n  \t                else {\n  \t                    if (this._namedFlows === null)\n  \t                        return (0, NullException_1.throwNullException)(\"this._namedFlows\");\n  \t                    this._namedFlows.set(name, flow);\n  \t                }\n  \t            }\n  \t            if (this._namedFlows != null && this._namedFlows.size > 1) {\n  \t                let currFlowName = jObject[\"currentFlowName\"];\n  \t                // Adding a bang at the end, because we're trusting the save, as\n  \t                // done in upstream.  If the save is corrupted, the execution\n  \t                // is undefined.\n  \t                this._currentFlow = this._namedFlows.get(currFlowName);\n  \t            }\n  \t        }\n  \t        else {\n  \t            this._namedFlows = null;\n  \t            this._currentFlow.name = this.kDefaultFlowName;\n  \t            this._currentFlow.callStack.SetJsonToken(jObject[\"callstackThreads\"], this.story);\n  \t            this._currentFlow.outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"outputStream\"]);\n  \t            this._currentFlow.currentChoices =\n  \t                JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"currentChoices\"]);\n  \t            let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n  \t            this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n  \t        }\n  \t        this.OutputStreamDirty();\n  \t        this._aliveFlowNamesDirty = true;\n  \t        this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n  \t        this.variablesState.callStack = this._currentFlow.callStack;\n  \t        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"evalStack\"]);\n  \t        let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n  \t        if (currentDivertTargetPath != null) {\n  \t            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());\n  \t            this.divertedPointer = this.story.PointerAtPath(divertPath);\n  \t        }\n  \t        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject[\"visitCounts\"]);\n  \t        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject[\"turnIndices\"]);\n  \t        this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n  \t        this.storySeed = parseInt(jObject[\"storySeed\"]);\n  \t        this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  \t    }\n  \t    ResetErrors() {\n  \t        this._currentErrors = null;\n  \t        this._currentWarnings = null;\n  \t    }\n  \t    ResetOutput(objs = null) {\n  \t        this.outputStream.length = 0;\n  \t        if (objs !== null)\n  \t            this.outputStream.push(...objs);\n  \t        this.OutputStreamDirty();\n  \t    }\n  \t    PushToOutputStream(obj) {\n  \t        // var text = obj as StringValue;\n  \t        let text = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n  \t        if (text !== null) {\n  \t            let listText = this.TrySplittingHeadTailWhitespace(text);\n  \t            if (listText !== null) {\n  \t                for (let textObj of listText) {\n  \t                    this.PushToOutputStreamIndividual(textObj);\n  \t                }\n  \t                this.OutputStreamDirty();\n  \t                return;\n  \t            }\n  \t        }\n  \t        this.PushToOutputStreamIndividual(obj);\n  \t        this.OutputStreamDirty();\n  \t    }\n  \t    PopFromOutputStream(count) {\n  \t        this.outputStream.splice(this.outputStream.length - count, count);\n  \t        this.OutputStreamDirty();\n  \t    }\n  \t    TrySplittingHeadTailWhitespace(single) {\n  \t        let str = single.value;\n  \t        if (str === null) {\n  \t            return (0, NullException_1.throwNullException)(\"single.value\");\n  \t        }\n  \t        let headFirstNewlineIdx = -1;\n  \t        let headLastNewlineIdx = -1;\n  \t        for (let i = 0; i < str.length; i++) {\n  \t            let c = str[i];\n  \t            if (c == \"\\n\") {\n  \t                if (headFirstNewlineIdx == -1)\n  \t                    headFirstNewlineIdx = i;\n  \t                headLastNewlineIdx = i;\n  \t            }\n  \t            else if (c == \" \" || c == \"\\t\")\n  \t                continue;\n  \t            else\n  \t                break;\n  \t        }\n  \t        let tailLastNewlineIdx = -1;\n  \t        let tailFirstNewlineIdx = -1;\n  \t        for (let i = str.length - 1; i >= 0; i--) {\n  \t            let c = str[i];\n  \t            if (c == \"\\n\") {\n  \t                if (tailLastNewlineIdx == -1)\n  \t                    tailLastNewlineIdx = i;\n  \t                tailFirstNewlineIdx = i;\n  \t            }\n  \t            else if (c == \" \" || c == \"\\t\")\n  \t                continue;\n  \t            else\n  \t                break;\n  \t        }\n  \t        // No splitting to be done?\n  \t        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)\n  \t            return null;\n  \t        let listTexts = [];\n  \t        let innerStrStart = 0;\n  \t        let innerStrEnd = str.length;\n  \t        if (headFirstNewlineIdx != -1) {\n  \t            if (headFirstNewlineIdx > 0) {\n  \t                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));\n  \t                listTexts.push(leadingSpaces);\n  \t            }\n  \t            listTexts.push(new Value_1.StringValue(\"\\n\"));\n  \t            innerStrStart = headLastNewlineIdx + 1;\n  \t        }\n  \t        if (tailLastNewlineIdx != -1) {\n  \t            innerStrEnd = tailFirstNewlineIdx;\n  \t        }\n  \t        if (innerStrEnd > innerStrStart) {\n  \t            let innerStrText = str.substring(innerStrStart, innerStrEnd);\n  \t            listTexts.push(new Value_1.StringValue(innerStrText));\n  \t        }\n  \t        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n  \t            listTexts.push(new Value_1.StringValue(\"\\n\"));\n  \t            if (tailLastNewlineIdx < str.length - 1) {\n  \t                let numSpaces = str.length - tailLastNewlineIdx - 1;\n  \t                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, tailLastNewlineIdx + 1 + numSpaces));\n  \t                listTexts.push(trailingSpaces);\n  \t            }\n  \t        }\n  \t        return listTexts;\n  \t    }\n  \t    PushToOutputStreamIndividual(obj) {\n  \t        let glue = (0, TypeAssertion_1.asOrNull)(obj, Glue_1.Glue);\n  \t        let text = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n  \t        let includeInOutput = true;\n  \t        if (glue) {\n  \t            this.TrimNewlinesFromOutputStream();\n  \t            includeInOutput = true;\n  \t        }\n  \t        else if (text) {\n  \t            let functionTrimIndex = -1;\n  \t            let currEl = this.callStack.currentElement;\n  \t            if (currEl.type == PushPop_1.PushPopType.Function) {\n  \t                functionTrimIndex = currEl.functionStartInOutputStream;\n  \t            }\n  \t            let glueTrimIndex = -1;\n  \t            for (let i = this.outputStream.length - 1; i >= 0; i--) {\n  \t                let o = this.outputStream[i];\n  \t                let c = o instanceof ControlCommand_1.ControlCommand ? o : null;\n  \t                let g = o instanceof Glue_1.Glue ? o : null;\n  \t                if (g != null) {\n  \t                    glueTrimIndex = i;\n  \t                    break;\n  \t                }\n  \t                else if (c != null &&\n  \t                    c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {\n  \t                    if (i >= functionTrimIndex) {\n  \t                        functionTrimIndex = -1;\n  \t                    }\n  \t                    break;\n  \t                }\n  \t            }\n  \t            let trimIndex = -1;\n  \t            if (glueTrimIndex != -1 && functionTrimIndex != -1)\n  \t                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n  \t            else if (glueTrimIndex != -1)\n  \t                trimIndex = glueTrimIndex;\n  \t            else\n  \t                trimIndex = functionTrimIndex;\n  \t            if (trimIndex != -1) {\n  \t                if (text.isNewline) {\n  \t                    includeInOutput = false;\n  \t                }\n  \t                else if (text.isNonWhitespace) {\n  \t                    if (glueTrimIndex > -1)\n  \t                        this.RemoveExistingGlue();\n  \t                    if (functionTrimIndex > -1) {\n  \t                        let callStackElements = this.callStack.elements;\n  \t                        for (let i = callStackElements.length - 1; i >= 0; i--) {\n  \t                            let el = callStackElements[i];\n  \t                            if (el.type == PushPop_1.PushPopType.Function) {\n  \t                                el.functionStartInOutputStream = -1;\n  \t                            }\n  \t                            else {\n  \t                                break;\n  \t                            }\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t            else if (text.isNewline) {\n  \t                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n  \t                    includeInOutput = false;\n  \t            }\n  \t        }\n  \t        if (includeInOutput) {\n  \t            if (obj === null) {\n  \t                return (0, NullException_1.throwNullException)(\"obj\");\n  \t            }\n  \t            this.outputStream.push(obj);\n  \t            this.OutputStreamDirty();\n  \t        }\n  \t    }\n  \t    TrimNewlinesFromOutputStream() {\n  \t        let removeWhitespaceFrom = -1;\n  \t        let i = this.outputStream.length - 1;\n  \t        while (i >= 0) {\n  \t            let obj = this.outputStream[i];\n  \t            let cmd = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n  \t            let txt = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n  \t            if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n  \t                break;\n  \t            }\n  \t            else if (txt != null && txt.isNewline) {\n  \t                removeWhitespaceFrom = i;\n  \t            }\n  \t            i--;\n  \t        }\n  \t        // Remove the whitespace\n  \t        if (removeWhitespaceFrom >= 0) {\n  \t            i = removeWhitespaceFrom;\n  \t            while (i < this.outputStream.length) {\n  \t                let text = (0, TypeAssertion_1.asOrNull)(this.outputStream[i], Value_1.StringValue);\n  \t                if (text) {\n  \t                    this.outputStream.splice(i, 1);\n  \t                }\n  \t                else {\n  \t                    i++;\n  \t                }\n  \t            }\n  \t        }\n  \t        this.OutputStreamDirty();\n  \t    }\n  \t    RemoveExistingGlue() {\n  \t        for (let i = this.outputStream.length - 1; i >= 0; i--) {\n  \t            let c = this.outputStream[i];\n  \t            if (c instanceof Glue_1.Glue) {\n  \t                this.outputStream.splice(i, 1);\n  \t            }\n  \t            else if (c instanceof ControlCommand_1.ControlCommand) {\n  \t                break;\n  \t            }\n  \t        }\n  \t        this.OutputStreamDirty();\n  \t    }\n  \t    get outputStreamEndsInNewline() {\n  \t        if (this.outputStream.length > 0) {\n  \t            for (let i = this.outputStream.length - 1; i >= 0; i--) {\n  \t                let obj = this.outputStream[i];\n  \t                if (obj instanceof ControlCommand_1.ControlCommand)\n  \t                    break;\n  \t                let text = this.outputStream[i];\n  \t                if (text instanceof Value_1.StringValue) {\n  \t                    if (text.isNewline)\n  \t                        return true;\n  \t                    else if (text.isNonWhitespace)\n  \t                        break;\n  \t                }\n  \t            }\n  \t        }\n  \t        return false;\n  \t    }\n  \t    get outputStreamContainsContent() {\n  \t        for (let content of this.outputStream) {\n  \t            if (content instanceof Value_1.StringValue)\n  \t                return true;\n  \t        }\n  \t        return false;\n  \t    }\n  \t    get inStringEvaluation() {\n  \t        for (let i = this.outputStream.length - 1; i >= 0; i--) {\n  \t            let cmd = (0, TypeAssertion_1.asOrNull)(this.outputStream[i], ControlCommand_1.ControlCommand);\n  \t            if (cmd instanceof ControlCommand_1.ControlCommand &&\n  \t                cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {\n  \t                return true;\n  \t            }\n  \t        }\n  \t        return false;\n  \t    }\n  \t    PushEvaluationStack(obj) {\n  \t        // var listValue = obj as ListValue;\n  \t        let listValue = (0, TypeAssertion_1.asOrNull)(obj, Value_1.ListValue);\n  \t        if (listValue) {\n  \t            // Update origin when list is has something to indicate the list origin\n  \t            let rawList = listValue.value;\n  \t            if (rawList === null) {\n  \t                return (0, NullException_1.throwNullException)(\"rawList\");\n  \t            }\n  \t            if (rawList.originNames != null) {\n  \t                if (!rawList.origins)\n  \t                    rawList.origins = [];\n  \t                rawList.origins.length = 0;\n  \t                for (let n of rawList.originNames) {\n  \t                    if (this.story.listDefinitions === null)\n  \t                        return (0, NullException_1.throwNullException)(\"StoryState.story.listDefinitions\");\n  \t                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n  \t                    if (def.result === null)\n  \t                        return (0, NullException_1.throwNullException)(\"StoryState def.result\");\n  \t                    if (rawList.origins.indexOf(def.result) < 0)\n  \t                        rawList.origins.push(def.result);\n  \t                }\n  \t            }\n  \t        }\n  \t        if (obj === null) {\n  \t            return (0, NullException_1.throwNullException)(\"obj\");\n  \t        }\n  \t        this.evaluationStack.push(obj);\n  \t    }\n  \t    PopEvaluationStack(numberOfObjects) {\n  \t        if (typeof numberOfObjects === \"undefined\") {\n  \t            let obj = this.evaluationStack.pop();\n  \t            return (0, TypeAssertion_1.nullIfUndefined)(obj);\n  \t        }\n  \t        else {\n  \t            if (numberOfObjects > this.evaluationStack.length) {\n  \t                throw new Error(\"trying to pop too many objects\");\n  \t            }\n  \t            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);\n  \t            return (0, TypeAssertion_1.nullIfUndefined)(popped);\n  \t        }\n  \t    }\n  \t    PeekEvaluationStack() {\n  \t        return this.evaluationStack[this.evaluationStack.length - 1];\n  \t    }\n  \t    ForceEnd() {\n  \t        this.callStack.Reset();\n  \t        this._currentFlow.currentChoices.length = 0;\n  \t        this.currentPointer = Pointer_1.Pointer.Null;\n  \t        this.previousPointer = Pointer_1.Pointer.Null;\n  \t        this.didSafeExit = true;\n  \t    }\n  \t    TrimWhitespaceFromFunctionEnd() {\n  \t        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);\n  \t        let functionStartPoint = this.callStack.currentElement.functionStartInOutputStream;\n  \t        if (functionStartPoint == -1) {\n  \t            functionStartPoint = 0;\n  \t        }\n  \t        for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n  \t            let obj = this.outputStream[i];\n  \t            let txt = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n  \t            let cmd = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n  \t            if (txt == null)\n  \t                continue;\n  \t            if (cmd)\n  \t                break;\n  \t            if (txt.isNewline || txt.isInlineWhitespace) {\n  \t                this.outputStream.splice(i, 1);\n  \t                this.OutputStreamDirty();\n  \t            }\n  \t            else {\n  \t                break;\n  \t            }\n  \t        }\n  \t    }\n  \t    PopCallStack(popType = null) {\n  \t        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)\n  \t            this.TrimWhitespaceFromFunctionEnd();\n  \t        this.callStack.Pop(popType);\n  \t    }\n  \t    SetChosenPath(path, incrementingTurnIndex) {\n  \t        // Changing direction, assume we need to clear current set of choices\n  \t        this._currentFlow.currentChoices.length = 0;\n  \t        let newPointer = this.story.PointerAtPath(path);\n  \t        if (!newPointer.isNull && newPointer.index == -1)\n  \t            newPointer.index = 0;\n  \t        this.currentPointer = newPointer;\n  \t        if (incrementingTurnIndex) {\n  \t            this.currentTurnIndex++;\n  \t        }\n  \t    }\n  \t    StartFunctionEvaluationFromGame(funcContainer, args) {\n  \t        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);\n  \t        this.callStack.currentElement.currentPointer =\n  \t            Pointer_1.Pointer.StartOf(funcContainer);\n  \t        this.PassArgumentsToEvaluationStack(args);\n  \t    }\n  \t    PassArgumentsToEvaluationStack(args) {\n  \t        if (args !== null) {\n  \t            for (let i = 0; i < args.length; i++) {\n  \t                if (!(typeof args[i] === \"number\" ||\n  \t                    typeof args[i] === \"string\" ||\n  \t                    typeof args[i] === \"boolean\" ||\n  \t                    args[i] instanceof InkList_1.InkList)) {\n  \t                    throw new Error(\"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n  \t                        \"number, string, bool or InkList. Argument was \" +\n  \t                        ((0, TypeAssertion_1.nullIfUndefined)(args[i]) === null\n  \t                            ? \"null\"\n  \t                            : args[i].constructor.name));\n  \t                }\n  \t                this.PushEvaluationStack(Value_1.Value.Create(args[i]));\n  \t            }\n  \t        }\n  \t    }\n  \t    TryExitFunctionEvaluationFromGame() {\n  \t        if (this.callStack.currentElement.type ==\n  \t            PushPop_1.PushPopType.FunctionEvaluationFromGame) {\n  \t            this.currentPointer = Pointer_1.Pointer.Null;\n  \t            this.didSafeExit = true;\n  \t            return true;\n  \t        }\n  \t        return false;\n  \t    }\n  \t    CompleteFunctionEvaluationFromGame() {\n  \t        if (this.callStack.currentElement.type !=\n  \t            PushPop_1.PushPopType.FunctionEvaluationFromGame) {\n  \t            throw new Error(\"Expected external function evaluation to be complete. Stack trace: \" +\n  \t                this.callStack.callStackTrace);\n  \t        }\n  \t        let originalEvaluationStackHeight = this.callStack.currentElement.evaluationStackHeightWhenPushed;\n  \t        let returnedObj = null;\n  \t        while (this.evaluationStack.length > originalEvaluationStackHeight) {\n  \t            let poppedObj = this.PopEvaluationStack();\n  \t            if (returnedObj === null)\n  \t                returnedObj = poppedObj;\n  \t        }\n  \t        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);\n  \t        if (returnedObj) {\n  \t            if (returnedObj instanceof Void_1.Void)\n  \t                return null;\n  \t            // Some kind of value, if not void\n  \t            // var returnVal = returnedObj as Runtime.Value;\n  \t            let returnVal = (0, TypeAssertion_1.asOrThrows)(returnedObj, Value_1.Value);\n  \t            // DivertTargets get returned as the string of components\n  \t            // (rather than a Path, which isn't public)\n  \t            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {\n  \t                return \"-> \" + returnVal.valueObject.toString();\n  \t            }\n  \t            // Other types can just have their exact object type:\n  \t            // int, float, string. VariablePointers get returned as strings.\n  \t            return returnVal.valueObject;\n  \t        }\n  \t        return null;\n  \t    }\n  \t    AddError(message, isWarning) {\n  \t        if (!isWarning) {\n  \t            if (this._currentErrors == null)\n  \t                this._currentErrors = [];\n  \t            this._currentErrors.push(message);\n  \t        }\n  \t        else {\n  \t            if (this._currentWarnings == null)\n  \t                this._currentWarnings = [];\n  \t            this._currentWarnings.push(message);\n  \t        }\n  \t    }\n  \t    OutputStreamDirty() {\n  \t        this._outputStreamTextDirty = true;\n  \t        this._outputStreamTagsDirty = true;\n  \t    }\n  \t};\n  \tStoryState.StoryState = StoryState$1;\n  \t\n  \treturn StoryState;\n  }\n\n  var StopWatch = {};\n\n  var hasRequiredStopWatch;\n\n  function requireStopWatch () {\n  \tif (hasRequiredStopWatch) return StopWatch;\n  \thasRequiredStopWatch = 1;\n  \tObject.defineProperty(StopWatch, \"__esModule\", { value: true });\n  \tStopWatch.Stopwatch = void 0;\n  \t// This is simple replacement of the Stopwatch class from the .NET Framework.\n  \t// The original class can count time with much more accuracy than the Javascript version.\n  \t// It might be worth considering using `window.performance` in the browser\n  \t// or `process.hrtime()` in node.\n  \tclass Stopwatch {\n  \t    constructor() {\n  \t        this.startTime = undefined;\n  \t    }\n  \t    get ElapsedMilliseconds() {\n  \t        if (typeof this.startTime === \"undefined\") {\n  \t            return 0;\n  \t        }\n  \t        return new Date().getTime() - this.startTime;\n  \t    }\n  \t    Start() {\n  \t        this.startTime = new Date().getTime();\n  \t    }\n  \t    Stop() {\n  \t        this.startTime = undefined;\n  \t    }\n  \t}\n  \tStopWatch.Stopwatch = Stopwatch;\n  \t\n  \treturn StopWatch;\n  }\n\n  var _Error = {};\n\n  var hasRequired_Error;\n\n  function require_Error () {\n  \tif (hasRequired_Error) return _Error;\n  \thasRequired_Error = 1;\n  \t// TODO: Unify with Compiler.\n  \tObject.defineProperty(_Error, \"__esModule\", { value: true });\n  \t_Error.ErrorType = void 0;\n  \tvar ErrorType;\n  \t(function (ErrorType) {\n  \t    ErrorType[ErrorType[\"Author\"] = 0] = \"Author\";\n  \t    ErrorType[ErrorType[\"Warning\"] = 1] = \"Warning\";\n  \t    ErrorType[ErrorType[\"Error\"] = 2] = \"Error\";\n  \t})(ErrorType || (_Error.ErrorType = ErrorType = {}));\n  \t\n  \treturn _Error;\n  }\n\n  var hasRequiredStory$1;\n\n  function requireStory$1 () {\n  \tif (hasRequiredStory$1) return Story$2;\n  \thasRequiredStory$1 = 1;\n  \t(function (exports) {\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.Story = exports.InkList = void 0;\n  \t\tconst Container_1 = requireContainer();\n  \t\tconst Object_1 = require_Object$1();\n  \t\tconst JsonSerialisation_1 = requireJsonSerialisation();\n  \t\tconst StoryState_1 = requireStoryState();\n  \t\tconst ControlCommand_1 = requireControlCommand();\n  \t\tconst PushPop_1 = requirePushPop();\n  \t\tconst ChoicePoint_1 = requireChoicePoint();\n  \t\tconst Choice_1 = requireChoice$1();\n  \t\tconst Divert_1 = requireDivert$1();\n  \t\tconst Value_1 = requireValue();\n  \t\tconst Path_1 = requirePath$1();\n  \t\tconst Void_1 = requireVoid();\n  \t\tconst Tag_1 = requireTag$1();\n  \t\tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \t\tconst VariableReference_1 = requireVariableReference$1();\n  \t\tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \t\tconst StoryException_1 = requireStoryException();\n  \t\tconst PRNG_1 = requirePRNG();\n  \t\tconst StringBuilder_1 = requireStringBuilder();\n  \t\tconst ListDefinitionsOrigin_1 = requireListDefinitionsOrigin();\n  \t\tconst StopWatch_1 = requireStopWatch();\n  \t\tconst Pointer_1 = requirePointer();\n  \t\tconst InkList_1 = requireInkList();\n  \t\tconst TypeAssertion_1 = requireTypeAssertion();\n  \t\tconst NullException_1 = requireNullException();\n  \t\tconst SimpleJson_1 = requireSimpleJson();\n  \t\tconst Error_1 = require_Error();\n  \t\tvar InkList_2 = requireInkList();\n  \t\tObject.defineProperty(exports, \"InkList\", { enumerable: true, get: function () { return InkList_2.InkList; } });\n  \t\tif (!Number.isInteger) {\n  \t\t    Number.isInteger = function isInteger(nVal) {\n  \t\t        return (typeof nVal === \"number\" &&\n  \t\t            isFinite(nVal) &&\n  \t\t            nVal > -9007199254740992 &&\n  \t\t            nVal < 9007199254740992 &&\n  \t\t            Math.floor(nVal) === nVal);\n  \t\t    };\n  \t\t}\n  \t\tclass Story extends Object_1.InkObject {\n  \t\t    get currentChoices() {\n  \t\t        let choices = [];\n  \t\t        if (this._state === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"this._state\");\n  \t\t        }\n  \t\t        for (let c of this._state.currentChoices) {\n  \t\t            if (!c.isInvisibleDefault) {\n  \t\t                c.index = choices.length;\n  \t\t                choices.push(c);\n  \t\t            }\n  \t\t        }\n  \t\t        return choices;\n  \t\t    }\n  \t\t    get currentText() {\n  \t\t        this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n  \t\t        return this.state.currentText;\n  \t\t    }\n  \t\t    get currentTags() {\n  \t\t        this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n  \t\t        return this.state.currentTags;\n  \t\t    }\n  \t\t    get currentErrors() {\n  \t\t        return this.state.currentErrors;\n  \t\t    }\n  \t\t    get currentWarnings() {\n  \t\t        return this.state.currentWarnings;\n  \t\t    }\n  \t\t    get currentFlowName() {\n  \t\t        return this.state.currentFlowName;\n  \t\t    }\n  \t\t    get currentFlowIsDefaultFlow() {\n  \t\t        return this.state.currentFlowIsDefaultFlow;\n  \t\t    }\n  \t\t    get aliveFlowNames() {\n  \t\t        return this.state.aliveFlowNames;\n  \t\t    }\n  \t\t    get hasError() {\n  \t\t        return this.state.hasError;\n  \t\t    }\n  \t\t    get hasWarning() {\n  \t\t        return this.state.hasWarning;\n  \t\t    }\n  \t\t    get variablesState() {\n  \t\t        return this.state.variablesState;\n  \t\t    }\n  \t\t    get listDefinitions() {\n  \t\t        return this._listDefinitions;\n  \t\t    }\n  \t\t    get state() {\n  \t\t        return this._state;\n  \t\t    }\n  \t\t    // TODO: Implement Profiler\n  \t\t    StartProfiling() {\n  \t\t        /* */\n  \t\t    }\n  \t\t    EndProfiling() {\n  \t\t        /* */\n  \t\t    }\n  \t\t    constructor() {\n  \t\t        super();\n  \t\t        this.inkVersionMinimumCompatible = 18;\n  \t\t        this.onError = null;\n  \t\t        this.onDidContinue = null;\n  \t\t        this.onMakeChoice = null;\n  \t\t        this.onEvaluateFunction = null;\n  \t\t        this.onCompleteEvaluateFunction = null;\n  \t\t        this.onChoosePathString = null;\n  \t\t        this._prevContainers = [];\n  \t\t        this.allowExternalFunctionFallbacks = false;\n  \t\t        this._listDefinitions = null;\n  \t\t        this._variableObservers = null;\n  \t\t        this._hasValidatedExternals = false;\n  \t\t        this._temporaryEvaluationContainer = null;\n  \t\t        this._asyncContinueActive = false;\n  \t\t        this._stateSnapshotAtLastNewline = null;\n  \t\t        this._sawLookaheadUnsafeFunctionAfterNewline = false;\n  \t\t        this._recursiveContinueCount = 0;\n  \t\t        this._asyncSaving = false;\n  \t\t        this._profiler = null; // TODO: Profiler\n  \t\t        // Discrimination between constructors\n  \t\t        let contentContainer;\n  \t\t        let lists = null;\n  \t\t        let json = null;\n  \t\t        if (arguments[0] instanceof Container_1.Container) {\n  \t\t            contentContainer = arguments[0];\n  \t\t            if (typeof arguments[1] !== \"undefined\") {\n  \t\t                lists = arguments[1];\n  \t\t            }\n  \t\t            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n  \t\t            this._mainContentContainer = contentContainer;\n  \t\t            // ------\n  \t\t        }\n  \t\t        else {\n  \t\t            if (typeof arguments[0] === \"string\") {\n  \t\t                let jsonString = arguments[0];\n  \t\t                json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);\n  \t\t            }\n  \t\t            else {\n  \t\t                json = arguments[0];\n  \t\t            }\n  \t\t        }\n  \t\t        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n  \t\t        if (lists != null)\n  \t\t            this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);\n  \t\t        this._externals = new Map();\n  \t\t        // ------\n  \t\t        // ------ Story(string jsonString) : this((Container)null)\n  \t\t        if (json !== null) {\n  \t\t            let rootObject = json;\n  \t\t            let versionObj = rootObject[\"inkVersion\"];\n  \t\t            if (versionObj == null)\n  \t\t                throw new Error(\"ink version number not found. Are you sure it's a valid .ink.json file?\");\n  \t\t            let formatFromFile = parseInt(versionObj);\n  \t\t            if (formatFromFile > Story.inkVersionCurrent) {\n  \t\t                throw new Error(\"Version of ink used to build story was newer than the current version of the engine\");\n  \t\t            }\n  \t\t            else if (formatFromFile < this.inkVersionMinimumCompatible) {\n  \t\t                throw new Error(\"Version of ink used to build story is too old to be loaded by this version of the engine\");\n  \t\t            }\n  \t\t            else if (formatFromFile != Story.inkVersionCurrent) {\n  \t\t                console.warn(`WARNING: Version of ink ${Story.inkVersionCurrent} used to build story doesn't match current version of engine (${formatFromFile}). Non-critical, but recommend synchronising.`);\n  \t\t            }\n  \t\t            let rootToken = rootObject[\"root\"];\n  \t\t            if (rootToken == null)\n  \t\t                throw new Error(\"Root node for ink not found. Are you sure it's a valid .ink.json file?\");\n  \t\t            let listDefsObj;\n  \t\t            if ((listDefsObj = rootObject[\"listDefs\"])) {\n  \t\t                this._listDefinitions =\n  \t\t                    JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n  \t\t            }\n  \t\t            this._mainContentContainer = (0, TypeAssertion_1.asOrThrows)(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);\n  \t\t            this.ResetState();\n  \t\t        }\n  \t\t        // ------\n  \t\t    }\n  \t\t    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  \t\t    // Will only return a value if writer was not provided.\n  \t\t    ToJson(writer) {\n  \t\t        let shouldReturn = false;\n  \t\t        if (!writer) {\n  \t\t            shouldReturn = true;\n  \t\t            writer = new SimpleJson_1.SimpleJson.Writer();\n  \t\t        }\n  \t\t        writer.WriteObjectStart();\n  \t\t        writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n  \t\t        writer.WriteProperty(\"root\", (w) => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));\n  \t\t        if (this._listDefinitions != null) {\n  \t\t            writer.WritePropertyStart(\"listDefs\");\n  \t\t            writer.WriteObjectStart();\n  \t\t            for (let def of this._listDefinitions.lists) {\n  \t\t                writer.WritePropertyStart(def.name);\n  \t\t                writer.WriteObjectStart();\n  \t\t                for (let [key, value] of def.items) {\n  \t\t                    let item = InkList_1.InkListItem.fromSerializedKey(key);\n  \t\t                    let val = value;\n  \t\t                    writer.WriteIntProperty(item.itemName, val);\n  \t\t                }\n  \t\t                writer.WriteObjectEnd();\n  \t\t                writer.WritePropertyEnd();\n  \t\t            }\n  \t\t            writer.WriteObjectEnd();\n  \t\t            writer.WritePropertyEnd();\n  \t\t        }\n  \t\t        writer.WriteObjectEnd();\n  \t\t        if (shouldReturn)\n  \t\t            return writer.toString();\n  \t\t    }\n  \t\t    ResetState() {\n  \t\t        this.IfAsyncWeCant(\"ResetState\");\n  \t\t        this._state = new StoryState_1.StoryState(this);\n  \t\t        this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));\n  \t\t        this.ResetGlobals();\n  \t\t    }\n  \t\t    ResetErrors() {\n  \t\t        if (this._state === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"this._state\");\n  \t\t        }\n  \t\t        this._state.ResetErrors();\n  \t\t    }\n  \t\t    ResetCallstack() {\n  \t\t        this.IfAsyncWeCant(\"ResetCallstack\");\n  \t\t        if (this._state === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"this._state\");\n  \t\t        }\n  \t\t        this._state.ForceEnd();\n  \t\t    }\n  \t\t    ResetGlobals() {\n  \t\t        if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n  \t\t            let originalPointer = this.state.currentPointer.copy();\n  \t\t            this.ChoosePath(new Path_1.Path(\"global decl\"), false);\n  \t\t            this.ContinueInternal();\n  \t\t            this.state.currentPointer = originalPointer;\n  \t\t        }\n  \t\t        this.state.variablesState.SnapshotDefaultGlobals();\n  \t\t    }\n  \t\t    SwitchFlow(flowName) {\n  \t\t        this.IfAsyncWeCant(\"switch flow\");\n  \t\t        if (this._asyncSaving) {\n  \t\t            throw new Error(\"Story is already in background saving mode, can't switch flow to \" +\n  \t\t                flowName);\n  \t\t        }\n  \t\t        this.state.SwitchFlow_Internal(flowName);\n  \t\t    }\n  \t\t    RemoveFlow(flowName) {\n  \t\t        this.state.RemoveFlow_Internal(flowName);\n  \t\t    }\n  \t\t    SwitchToDefaultFlow() {\n  \t\t        this.state.SwitchToDefaultFlow_Internal();\n  \t\t    }\n  \t\t    Continue() {\n  \t\t        this.ContinueAsync(0);\n  \t\t        return this.currentText;\n  \t\t    }\n  \t\t    get canContinue() {\n  \t\t        return this.state.canContinue;\n  \t\t    }\n  \t\t    get asyncContinueComplete() {\n  \t\t        return !this._asyncContinueActive;\n  \t\t    }\n  \t\t    ContinueAsync(millisecsLimitAsync) {\n  \t\t        if (!this._hasValidatedExternals)\n  \t\t            this.ValidateExternalBindings();\n  \t\t        this.ContinueInternal(millisecsLimitAsync);\n  \t\t    }\n  \t\t    ContinueInternal(millisecsLimitAsync = 0) {\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.PreContinue();\n  \t\t        let isAsyncTimeLimited = millisecsLimitAsync > 0;\n  \t\t        this._recursiveContinueCount++;\n  \t\t        if (!this._asyncContinueActive) {\n  \t\t            this._asyncContinueActive = isAsyncTimeLimited;\n  \t\t            if (!this.canContinue) {\n  \t\t                throw new Error(\"Can't continue - should check canContinue before calling Continue\");\n  \t\t            }\n  \t\t            this._state.didSafeExit = false;\n  \t\t            this._state.ResetOutput();\n  \t\t            if (this._recursiveContinueCount == 1)\n  \t\t                this._state.variablesState.StartVariableObservation();\n  \t\t        }\n  \t\t        else if (this._asyncContinueActive && !isAsyncTimeLimited) {\n  \t\t            this._asyncContinueActive = false;\n  \t\t        }\n  \t\t        let durationStopwatch = new StopWatch_1.Stopwatch();\n  \t\t        durationStopwatch.Start();\n  \t\t        let outputStreamEndsInNewline = false;\n  \t\t        this._sawLookaheadUnsafeFunctionAfterNewline = false;\n  \t\t        do {\n  \t\t            try {\n  \t\t                outputStreamEndsInNewline = this.ContinueSingleStep();\n  \t\t            }\n  \t\t            catch (e) {\n  \t\t                if (!(e instanceof StoryException_1.StoryException))\n  \t\t                    throw e;\n  \t\t                this.AddError(e.message, undefined, e.useEndLineNumber);\n  \t\t                break;\n  \t\t            }\n  \t\t            if (outputStreamEndsInNewline)\n  \t\t                break;\n  \t\t            if (this._asyncContinueActive &&\n  \t\t                durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {\n  \t\t                break;\n  \t\t            }\n  \t\t        } while (this.canContinue);\n  \t\t        durationStopwatch.Stop();\n  \t\t        let changedVariablesToObserve = null;\n  \t\t        if (outputStreamEndsInNewline || !this.canContinue) {\n  \t\t            if (this._stateSnapshotAtLastNewline !== null) {\n  \t\t                this.RestoreStateSnapshot();\n  \t\t            }\n  \t\t            if (!this.canContinue) {\n  \t\t                if (this.state.callStack.canPopThread)\n  \t\t                    this.AddError(\"Thread available to pop, threads should always be flat by the end of evaluation?\");\n  \t\t                if (this.state.generatedChoices.length == 0 &&\n  \t\t                    !this.state.didSafeExit &&\n  \t\t                    this._temporaryEvaluationContainer == null) {\n  \t\t                    if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel))\n  \t\t                        this.AddError(\"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\");\n  \t\t                    else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function))\n  \t\t                        this.AddError(\"unexpectedly reached end of content. Do you need a '~ return'?\");\n  \t\t                    else if (!this.state.callStack.canPop)\n  \t\t                        this.AddError(\"ran out of content. Do you need a '-> DONE' or '-> END'?\");\n  \t\t                    else\n  \t\t                        this.AddError(\"unexpectedly reached end of content for unknown reason. Please debug compiler!\");\n  \t\t                }\n  \t\t            }\n  \t\t            this.state.didSafeExit = false;\n  \t\t            this._sawLookaheadUnsafeFunctionAfterNewline = false;\n  \t\t            if (this._recursiveContinueCount == 1)\n  \t\t                changedVariablesToObserve =\n  \t\t                    this._state.variablesState.CompleteVariableObservation();\n  \t\t            this._asyncContinueActive = false;\n  \t\t            if (this.onDidContinue !== null)\n  \t\t                this.onDidContinue();\n  \t\t        }\n  \t\t        this._recursiveContinueCount--;\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.PostContinue();\n  \t\t        // In the following code, we're masking a lot of non-null assertion,\n  \t\t        // because testing for against `hasError` or `hasWarning` makes sure\n  \t\t        // the arrays are present and contain at least one element.\n  \t\t        if (this.state.hasError || this.state.hasWarning) {\n  \t\t            if (this.onError !== null) {\n  \t\t                if (this.state.hasError) {\n  \t\t                    for (let err of this.state.currentErrors) {\n  \t\t                        this.onError(err, Error_1.ErrorType.Error);\n  \t\t                    }\n  \t\t                }\n  \t\t                if (this.state.hasWarning) {\n  \t\t                    for (let err of this.state.currentWarnings) {\n  \t\t                        this.onError(err, Error_1.ErrorType.Warning);\n  \t\t                    }\n  \t\t                }\n  \t\t                this.ResetErrors();\n  \t\t            }\n  \t\t            else {\n  \t\t                let sb = new StringBuilder_1.StringBuilder();\n  \t\t                sb.Append(\"Ink had \");\n  \t\t                if (this.state.hasError) {\n  \t\t                    sb.Append(`${this.state.currentErrors.length}`);\n  \t\t                    sb.Append(this.state.currentErrors.length == 1 ? \" error\" : \" errors\");\n  \t\t                    if (this.state.hasWarning)\n  \t\t                        sb.Append(\" and \");\n  \t\t                }\n  \t\t                if (this.state.hasWarning) {\n  \t\t                    sb.Append(`${this.state.currentWarnings.length}`);\n  \t\t                    sb.Append(this.state.currentWarnings.length == 1 ? \" warning\" : \" warnings\");\n  \t\t                    if (this.state.hasWarning)\n  \t\t                        sb.Append(\" and \");\n  \t\t                }\n  \t\t                sb.Append(\". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \");\n  \t\t                sb.Append(this.state.hasError\n  \t\t                    ? this.state.currentErrors[0]\n  \t\t                    : this.state.currentWarnings[0]);\n  \t\t                throw new StoryException_1.StoryException(sb.toString());\n  \t\t            }\n  \t\t        }\n  \t\t        if (changedVariablesToObserve != null &&\n  \t\t            Object.keys(changedVariablesToObserve).length > 0) {\n  \t\t            this._state.variablesState.NotifyObservers(changedVariablesToObserve);\n  \t\t        }\n  \t\t    }\n  \t\t    ContinueSingleStep() {\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.PreStep();\n  \t\t        this.Step();\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.PostStep();\n  \t\t        if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n  \t\t            this.TryFollowDefaultInvisibleChoice();\n  \t\t        }\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.PreSnapshot();\n  \t\t        if (!this.state.inStringEvaluation) {\n  \t\t            if (this._stateSnapshotAtLastNewline !== null) {\n  \t\t                if (this._stateSnapshotAtLastNewline.currentTags === null) {\n  \t\t                    return (0, NullException_1.throwNullException)(\"this._stateAtLastNewline.currentTags\");\n  \t\t                }\n  \t\t                if (this.state.currentTags === null) {\n  \t\t                    return (0, NullException_1.throwNullException)(\"this.state.currentTags\");\n  \t\t                }\n  \t\t                let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);\n  \t\t                if (change == Story.OutputStateChange.ExtendedBeyondNewline ||\n  \t\t                    this._sawLookaheadUnsafeFunctionAfterNewline) {\n  \t\t                    this.RestoreStateSnapshot();\n  \t\t                    return true;\n  \t\t                }\n  \t\t                else if (change == Story.OutputStateChange.NewlineRemoved) {\n  \t\t                    this.DiscardSnapshot();\n  \t\t                }\n  \t\t            }\n  \t\t            if (this.state.outputStreamEndsInNewline) {\n  \t\t                if (this.canContinue) {\n  \t\t                    if (this._stateSnapshotAtLastNewline == null)\n  \t\t                        this.StateSnapshot();\n  \t\t                }\n  \t\t                else {\n  \t\t                    this.DiscardSnapshot();\n  \t\t                }\n  \t\t            }\n  \t\t        }\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.PostSnapshot();\n  \t\t        return false;\n  \t\t    }\n  \t\t    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {\n  \t\t        if (prevText === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"prevText\");\n  \t\t        }\n  \t\t        if (currText === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"currText\");\n  \t\t        }\n  \t\t        let newlineStillExists = currText.length >= prevText.length &&\n  \t\t            prevText.length > 0 &&\n  \t\t            currText.charAt(prevText.length - 1) == \"\\n\";\n  \t\t        if (prevTagCount == currTagCount &&\n  \t\t            prevText.length == currText.length &&\n  \t\t            newlineStillExists)\n  \t\t            return Story.OutputStateChange.NoChange;\n  \t\t        if (!newlineStillExists) {\n  \t\t            return Story.OutputStateChange.NewlineRemoved;\n  \t\t        }\n  \t\t        if (currTagCount > prevTagCount)\n  \t\t            return Story.OutputStateChange.ExtendedBeyondNewline;\n  \t\t        for (let i = prevText.length; i < currText.length; i++) {\n  \t\t            let c = currText.charAt(i);\n  \t\t            if (c != \" \" && c != \"\\t\") {\n  \t\t                return Story.OutputStateChange.ExtendedBeyondNewline;\n  \t\t            }\n  \t\t        }\n  \t\t        return Story.OutputStateChange.NoChange;\n  \t\t    }\n  \t\t    ContinueMaximally() {\n  \t\t        this.IfAsyncWeCant(\"ContinueMaximally\");\n  \t\t        let sb = new StringBuilder_1.StringBuilder();\n  \t\t        while (this.canContinue) {\n  \t\t            sb.Append(this.Continue());\n  \t\t        }\n  \t\t        return sb.toString();\n  \t\t    }\n  \t\t    ContentAtPath(path) {\n  \t\t        return this.mainContentContainer.ContentAtPath(path);\n  \t\t    }\n  \t\t    KnotContainerWithName(name) {\n  \t\t        let namedContainer = this.mainContentContainer.namedContent.get(name);\n  \t\t        if (namedContainer instanceof Container_1.Container)\n  \t\t            return namedContainer;\n  \t\t        else\n  \t\t            return null;\n  \t\t    }\n  \t\t    PointerAtPath(path) {\n  \t\t        if (path.length == 0)\n  \t\t            return Pointer_1.Pointer.Null;\n  \t\t        let p = new Pointer_1.Pointer();\n  \t\t        let pathLengthToUse = path.length;\n  \t\t        let result = null;\n  \t\t        if (path.lastComponent === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"path.lastComponent\");\n  \t\t        }\n  \t\t        if (path.lastComponent.isIndex) {\n  \t\t            pathLengthToUse = path.length - 1;\n  \t\t            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);\n  \t\t            p.container = result.container;\n  \t\t            p.index = path.lastComponent.index;\n  \t\t        }\n  \t\t        else {\n  \t\t            result = this.mainContentContainer.ContentAtPath(path);\n  \t\t            p.container = result.container;\n  \t\t            p.index = -1;\n  \t\t        }\n  \t\t        if (result.obj == null ||\n  \t\t            (result.obj == this.mainContentContainer && pathLengthToUse > 0)) {\n  \t\t            this.Error(\"Failed to find content at path '\" +\n  \t\t                path +\n  \t\t                \"', and no approximation of it was possible.\");\n  \t\t        }\n  \t\t        else if (result.approximate)\n  \t\t            this.Warning(\"Failed to find content at path '\" +\n  \t\t                path +\n  \t\t                \"', so it was approximated to: '\" +\n  \t\t                result.obj.path +\n  \t\t                \"'.\");\n  \t\t        return p;\n  \t\t    }\n  \t\t    StateSnapshot() {\n  \t\t        this._stateSnapshotAtLastNewline = this._state;\n  \t\t        this._state = this._state.CopyAndStartPatching(false);\n  \t\t    }\n  \t\t    RestoreStateSnapshot() {\n  \t\t        if (this._stateSnapshotAtLastNewline === null) {\n  \t\t            (0, NullException_1.throwNullException)(\"_stateSnapshotAtLastNewline\");\n  \t\t        }\n  \t\t        this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n  \t\t        this._state = this._stateSnapshotAtLastNewline;\n  \t\t        this._stateSnapshotAtLastNewline = null;\n  \t\t        if (!this._asyncSaving) {\n  \t\t            this._state.ApplyAnyPatch();\n  \t\t        }\n  \t\t    }\n  \t\t    DiscardSnapshot() {\n  \t\t        if (!this._asyncSaving)\n  \t\t            this._state.ApplyAnyPatch();\n  \t\t        this._stateSnapshotAtLastNewline = null;\n  \t\t    }\n  \t\t    CopyStateForBackgroundThreadSave() {\n  \t\t        this.IfAsyncWeCant(\"start saving on a background thread\");\n  \t\t        if (this._asyncSaving)\n  \t\t            throw new Error(\"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\");\n  \t\t        let stateToSave = this._state;\n  \t\t        this._state = this._state.CopyAndStartPatching(true);\n  \t\t        this._asyncSaving = true;\n  \t\t        return stateToSave;\n  \t\t    }\n  \t\t    BackgroundSaveComplete() {\n  \t\t        if (this._stateSnapshotAtLastNewline === null) {\n  \t\t            this._state.ApplyAnyPatch();\n  \t\t        }\n  \t\t        this._asyncSaving = false;\n  \t\t    }\n  \t\t    Step() {\n  \t\t        let shouldAddToStream = true;\n  \t\t        let pointer = this.state.currentPointer.copy();\n  \t\t        if (pointer.isNull) {\n  \t\t            return;\n  \t\t        }\n  \t\t        // Container containerToEnter = pointer.Resolve () as Container;\n  \t\t        let containerToEnter = (0, TypeAssertion_1.asOrNull)(pointer.Resolve(), Container_1.Container);\n  \t\t        while (containerToEnter) {\n  \t\t            this.VisitContainer(containerToEnter, true);\n  \t\t            // No content? the most we can do is step past it\n  \t\t            if (containerToEnter.content.length == 0) {\n  \t\t                break;\n  \t\t            }\n  \t\t            pointer = Pointer_1.Pointer.StartOf(containerToEnter);\n  \t\t            // containerToEnter = pointer.Resolve() as Container;\n  \t\t            containerToEnter = (0, TypeAssertion_1.asOrNull)(pointer.Resolve(), Container_1.Container);\n  \t\t        }\n  \t\t        this.state.currentPointer = pointer.copy();\n  \t\t        if (this._profiler != null)\n  \t\t            this._profiler.Step(this.state.callStack);\n  \t\t        // Is the current content object:\n  \t\t        //  - Normal content\n  \t\t        //  - Or a logic/flow statement - if so, do it\n  \t\t        // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n  \t\t        // that was diverted to rather than called as a function)\n  \t\t        let currentContentObj = pointer.Resolve();\n  \t\t        let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);\n  \t\t        // Has flow been forced to end by flow control above?\n  \t\t        if (this.state.currentPointer.isNull) {\n  \t\t            return;\n  \t\t        }\n  \t\t        if (isLogicOrFlowControl) {\n  \t\t            shouldAddToStream = false;\n  \t\t        }\n  \t\t        // Choice with condition?\n  \t\t        // var choicePoint = currentContentObj as ChoicePoint;\n  \t\t        let choicePoint = (0, TypeAssertion_1.asOrNull)(currentContentObj, ChoicePoint_1.ChoicePoint);\n  \t\t        if (choicePoint) {\n  \t\t            let choice = this.ProcessChoice(choicePoint);\n  \t\t            if (choice) {\n  \t\t                this.state.generatedChoices.push(choice);\n  \t\t            }\n  \t\t            currentContentObj = null;\n  \t\t            shouldAddToStream = false;\n  \t\t        }\n  \t\t        // If the container has no content, then it will be\n  \t\t        // the \"content\" itself, but we skip over it.\n  \t\t        if (currentContentObj instanceof Container_1.Container) {\n  \t\t            shouldAddToStream = false;\n  \t\t        }\n  \t\t        // Content to add to evaluation stack or the output stream\n  \t\t        if (shouldAddToStream) {\n  \t\t            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n  \t\t            // to our current (possibly temporary) context index. And make a copy of the pointer\n  \t\t            // so that we're not editing the original runtime object.\n  \t\t            // var varPointer = currentContentObj as VariablePointerValue;\n  \t\t            let varPointer = (0, TypeAssertion_1.asOrNull)(currentContentObj, Value_1.VariablePointerValue);\n  \t\t            if (varPointer && varPointer.contextIndex == -1) {\n  \t\t                // Create new object so we're not overwriting the story's own data\n  \t\t                let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);\n  \t\t                currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);\n  \t\t            }\n  \t\t            // Expression evaluation content\n  \t\t            if (this.state.inExpressionEvaluation) {\n  \t\t                this.state.PushEvaluationStack(currentContentObj);\n  \t\t            }\n  \t\t            // Output stream content (i.e. not expression evaluation)\n  \t\t            else {\n  \t\t                this.state.PushToOutputStream(currentContentObj);\n  \t\t            }\n  \t\t        }\n  \t\t        // Increment the content pointer, following diverts if necessary\n  \t\t        this.NextContent();\n  \t\t        // Starting a thread should be done after the increment to the content pointer,\n  \t\t        // so that when returning from the thread, it returns to the content after this instruction.\n  \t\t        // var controlCmd = currentContentObj as ;\n  \t\t        let controlCmd = (0, TypeAssertion_1.asOrNull)(currentContentObj, ControlCommand_1.ControlCommand);\n  \t\t        if (controlCmd &&\n  \t\t            controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {\n  \t\t            this.state.callStack.PushThread();\n  \t\t        }\n  \t\t    }\n  \t\t    VisitContainer(container, atStart) {\n  \t\t        if (!container.countingAtStartOnly || atStart) {\n  \t\t            if (container.visitsShouldBeCounted)\n  \t\t                this.state.IncrementVisitCountForContainer(container);\n  \t\t            if (container.turnIndexShouldBeCounted)\n  \t\t                this.state.RecordTurnIndexVisitToContainer(container);\n  \t\t        }\n  \t\t    }\n  \t\t    VisitChangedContainersDueToDivert() {\n  \t\t        let previousPointer = this.state.previousPointer.copy();\n  \t\t        let pointer = this.state.currentPointer.copy();\n  \t\t        if (pointer.isNull || pointer.index == -1)\n  \t\t            return;\n  \t\t        this._prevContainers.length = 0;\n  \t\t        if (!previousPointer.isNull) {\n  \t\t            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n  \t\t            let resolvedPreviousAncestor = previousPointer.Resolve();\n  \t\t            let prevAncestor = (0, TypeAssertion_1.asOrNull)(resolvedPreviousAncestor, Container_1.Container) ||\n  \t\t                (0, TypeAssertion_1.asOrNull)(previousPointer.container, Container_1.Container);\n  \t\t            while (prevAncestor) {\n  \t\t                this._prevContainers.push(prevAncestor);\n  \t\t                // prevAncestor = prevAncestor.parent as Container;\n  \t\t                prevAncestor = (0, TypeAssertion_1.asOrNull)(prevAncestor.parent, Container_1.Container);\n  \t\t            }\n  \t\t        }\n  \t\t        let currentChildOfContainer = pointer.Resolve();\n  \t\t        if (currentChildOfContainer == null)\n  \t\t            return;\n  \t\t        // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n  \t\t        let currentContainerAncestor = (0, TypeAssertion_1.asOrNull)(currentChildOfContainer.parent, Container_1.Container);\n  \t\t        let allChildrenEnteredAtStart = true;\n  \t\t        while (currentContainerAncestor &&\n  \t\t            (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n  \t\t                currentContainerAncestor.countingAtStartOnly)) {\n  \t\t            // Check whether this ancestor container is being entered at the start,\n  \t\t            // by checking whether the child object is the first.\n  \t\t            let enteringAtStart = currentContainerAncestor.content.length > 0 &&\n  \t\t                currentChildOfContainer == currentContainerAncestor.content[0] &&\n  \t\t                allChildrenEnteredAtStart;\n  \t\t            if (!enteringAtStart)\n  \t\t                allChildrenEnteredAtStart = false;\n  \t\t            // Mark a visit to this container\n  \t\t            this.VisitContainer(currentContainerAncestor, enteringAtStart);\n  \t\t            currentChildOfContainer = currentContainerAncestor;\n  \t\t            // currentContainerAncestor = currentContainerAncestor.parent as Container;\n  \t\t            currentContainerAncestor = (0, TypeAssertion_1.asOrNull)(currentContainerAncestor.parent, Container_1.Container);\n  \t\t        }\n  \t\t    }\n  \t\t    PopChoiceStringAndTags(tags) {\n  \t\t        let choiceOnlyStrVal = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.StringValue);\n  \t\t        while (this.state.evaluationStack.length > 0 &&\n  \t\t            (0, TypeAssertion_1.asOrNull)(this.state.PeekEvaluationStack(), Tag_1.Tag) != null) {\n  \t\t            let tag = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Tag_1.Tag);\n  \t\t            if (tag)\n  \t\t                tags.push(tag.text);\n  \t\t        }\n  \t\t        return choiceOnlyStrVal.value;\n  \t\t    }\n  \t\t    ProcessChoice(choicePoint) {\n  \t\t        let showChoice = true;\n  \t\t        // Don't create choice if choice point doesn't pass conditional\n  \t\t        if (choicePoint.hasCondition) {\n  \t\t            let conditionValue = this.state.PopEvaluationStack();\n  \t\t            if (!this.IsTruthy(conditionValue)) {\n  \t\t                showChoice = false;\n  \t\t            }\n  \t\t        }\n  \t\t        let startText = \"\";\n  \t\t        let choiceOnlyText = \"\";\n  \t\t        let tags = [];\n  \t\t        if (choicePoint.hasChoiceOnlyContent) {\n  \t\t            choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n  \t\t        }\n  \t\t        if (choicePoint.hasStartContent) {\n  \t\t            startText = this.PopChoiceStringAndTags(tags) || \"\";\n  \t\t        }\n  \t\t        // Don't create choice if player has already read this content\n  \t\t        if (choicePoint.onceOnly) {\n  \t\t            let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);\n  \t\t            if (visitCount > 0) {\n  \t\t                showChoice = false;\n  \t\t            }\n  \t\t        }\n  \t\t        // We go through the full process of creating the choice above so\n  \t\t        // that we consume the content for it, since otherwise it'll\n  \t\t        // be shown on the output stream.\n  \t\t        if (!showChoice) {\n  \t\t            return null;\n  \t\t        }\n  \t\t        let choice = new Choice_1.Choice();\n  \t\t        choice.targetPath = choicePoint.pathOnChoice;\n  \t\t        choice.sourcePath = choicePoint.path.toString();\n  \t\t        choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n  \t\t        choice.threadAtGeneration = this.state.callStack.ForkThread();\n  \t\t        choice.tags = tags.reverse(); //C# is a stack\n  \t\t        choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n  \t\t        return choice;\n  \t\t    }\n  \t\t    IsTruthy(obj) {\n  \t\t        let truthy = false;\n  \t\t        if (obj instanceof Value_1.Value) {\n  \t\t            let val = obj;\n  \t\t            if (val instanceof Value_1.DivertTargetValue) {\n  \t\t                let divTarget = val;\n  \t\t                this.Error(\"Shouldn't use a divert target (to \" +\n  \t\t                    divTarget.targetPath +\n  \t\t                    \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\");\n  \t\t                return false;\n  \t\t            }\n  \t\t            return val.isTruthy;\n  \t\t        }\n  \t\t        return truthy;\n  \t\t    }\n  \t\t    PerformLogicAndFlowControl(contentObj) {\n  \t\t        if (contentObj == null) {\n  \t\t            return false;\n  \t\t        }\n  \t\t        // Divert\n  \t\t        if (contentObj instanceof Divert_1.Divert) {\n  \t\t            let currentDivert = contentObj;\n  \t\t            if (currentDivert.isConditional) {\n  \t\t                let conditionValue = this.state.PopEvaluationStack();\n  \t\t                // False conditional? Cancel divert\n  \t\t                if (!this.IsTruthy(conditionValue))\n  \t\t                    return true;\n  \t\t            }\n  \t\t            if (currentDivert.hasVariableTarget) {\n  \t\t                let varName = currentDivert.variableDivertName;\n  \t\t                let varContents = this.state.variablesState.GetVariableWithName(varName);\n  \t\t                if (varContents == null) {\n  \t\t                    this.Error(\"Tried to divert using a target from a variable that could not be found (\" +\n  \t\t                        varName +\n  \t\t                        \")\");\n  \t\t                }\n  \t\t                else if (!(varContents instanceof Value_1.DivertTargetValue)) {\n  \t\t                    // var intContent = varContents as IntValue;\n  \t\t                    let intContent = (0, TypeAssertion_1.asOrNull)(varContents, Value_1.IntValue);\n  \t\t                    let errorMessage = \"Tried to divert to a target from a variable, but the variable (\" +\n  \t\t                        varName +\n  \t\t                        \") didn't contain a divert target, it \";\n  \t\t                    if (intContent instanceof Value_1.IntValue && intContent.value == 0) {\n  \t\t                        errorMessage += \"was empty/null (the value 0).\";\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        errorMessage += \"contained '\" + varContents + \"'.\";\n  \t\t                    }\n  \t\t                    this.Error(errorMessage);\n  \t\t                }\n  \t\t                let target = (0, TypeAssertion_1.asOrThrows)(varContents, Value_1.DivertTargetValue);\n  \t\t                this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n  \t\t            }\n  \t\t            else if (currentDivert.isExternal) {\n  \t\t                this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);\n  \t\t                return true;\n  \t\t            }\n  \t\t            else {\n  \t\t                this.state.divertedPointer = currentDivert.targetPointer.copy();\n  \t\t            }\n  \t\t            if (currentDivert.pushesToStack) {\n  \t\t                this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);\n  \t\t            }\n  \t\t            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n  \t\t                if (currentDivert &&\n  \t\t                    currentDivert.debugMetadata &&\n  \t\t                    currentDivert.debugMetadata.sourceName != null) {\n  \t\t                    this.Error(\"Divert target doesn't exist: \" +\n  \t\t                        currentDivert.debugMetadata.sourceName);\n  \t\t                }\n  \t\t                else {\n  \t\t                    this.Error(\"Divert resolution failed: \" + currentDivert);\n  \t\t                }\n  \t\t            }\n  \t\t            return true;\n  \t\t        }\n  \t\t        // Start/end an expression evaluation? Or print out the result?\n  \t\t        else if (contentObj instanceof ControlCommand_1.ControlCommand) {\n  \t\t            let evalCommand = contentObj;\n  \t\t            switch (evalCommand.commandType) {\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.EvalStart:\n  \t\t                    this.Assert(this.state.inExpressionEvaluation === false, \"Already in expression evaluation?\");\n  \t\t                    this.state.inExpressionEvaluation = true;\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.EvalEnd:\n  \t\t                    this.Assert(this.state.inExpressionEvaluation === true, \"Not in expression evaluation mode\");\n  \t\t                    this.state.inExpressionEvaluation = false;\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.EvalOutput:\n  \t\t                    // If the expression turned out to be empty, there may not be anything on the stack\n  \t\t                    if (this.state.evaluationStack.length > 0) {\n  \t\t                        let output = this.state.PopEvaluationStack();\n  \t\t                        // Functions may evaluate to Void, in which case we skip output\n  \t\t                        if (!(output instanceof Void_1.Void)) {\n  \t\t                            // TODO: Should we really always blanket convert to string?\n  \t\t                            // It would be okay to have numbers in the output stream the\n  \t\t                            // only problem is when exporting text for viewing, it skips over numbers etc.\n  \t\t                            let text = new Value_1.StringValue(output.toString());\n  \t\t                            this.state.PushToOutputStream(text);\n  \t\t                        }\n  \t\t                    }\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.NoOp:\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.Duplicate:\n  \t\t                    this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:\n  \t\t                    this.state.PopEvaluationStack();\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.PopFunction:\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.PopTunnel:\n  \t\t                    let popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction\n  \t\t                        ? PushPop_1.PushPopType.Function\n  \t\t                        : PushPop_1.PushPopType.Tunnel;\n  \t\t                    let overrideTunnelReturnTarget = null;\n  \t\t                    if (popType == PushPop_1.PushPopType.Tunnel) {\n  \t\t                        let popped = this.state.PopEvaluationStack();\n  \t\t                        // overrideTunnelReturnTarget = popped as DivertTargetValue;\n  \t\t                        overrideTunnelReturnTarget = (0, TypeAssertion_1.asOrNull)(popped, Value_1.DivertTargetValue);\n  \t\t                        if (overrideTunnelReturnTarget === null) {\n  \t\t                            this.Assert(popped instanceof Void_1.Void, \"Expected void if ->-> doesn't override target\");\n  \t\t                        }\n  \t\t                    }\n  \t\t                    if (this.state.TryExitFunctionEvaluationFromGame()) {\n  \t\t                        break;\n  \t\t                    }\n  \t\t                    else if (this.state.callStack.currentElement.type != popType ||\n  \t\t                        !this.state.callStack.canPop) {\n  \t\t                        let names = new Map();\n  \t\t                        names.set(PushPop_1.PushPopType.Function, \"function return statement (~ return)\");\n  \t\t                        names.set(PushPop_1.PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n  \t\t                        let expected = names.get(this.state.callStack.currentElement.type);\n  \t\t                        if (!this.state.callStack.canPop) {\n  \t\t                            expected = \"end of flow (-> END or choice)\";\n  \t\t                        }\n  \t\t                        let errorMsg = \"Found \" + names.get(popType) + \", when expected \" + expected;\n  \t\t                        this.Error(errorMsg);\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        this.state.PopCallStack();\n  \t\t                        if (overrideTunnelReturnTarget)\n  \t\t                            this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);\n  \t\t                    }\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.BeginString:\n  \t\t                    this.state.PushToOutputStream(evalCommand);\n  \t\t                    this.Assert(this.state.inExpressionEvaluation === true, \"Expected to be in an expression when evaluating a string\");\n  \t\t                    this.state.inExpressionEvaluation = false;\n  \t\t                    break;\n  \t\t                // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n  \t\t                // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n  \t\t                // to try and flatten dynamic tags to strings every time \\n is pushed to output\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.BeginTag:\n  \t\t                    this.state.PushToOutputStream(evalCommand);\n  \t\t                    break;\n  \t\t                // EndTag has 2 modes:\n  \t\t                //  - When in string evaluation (for choices)\n  \t\t                //  - Normal\n  \t\t                //\n  \t\t                // The only way you could have an EndTag in the middle of\n  \t\t                // string evaluation is if we're currently generating text for a\n  \t\t                // choice, such as:\n  \t\t                //\n  \t\t                //   + choice # tag\n  \t\t                //\n  \t\t                // In the above case, the ink will be run twice:\n  \t\t                //  - First, to generate the choice text. String evaluation\n  \t\t                //    will be on, and the final string will be pushed to the\n  \t\t                //    evaluation stack, ready to be popped to make a Choice\n  \t\t                //    object.\n  \t\t                //  - Second, when ink generates text after choosing the choice.\n  \t\t                //    On this ocassion, it's not in string evaluation mode.\n  \t\t                //\n  \t\t                // On the writing side, we disallow manually putting tags within\n  \t\t                // strings like this:\n  \t\t                //\n  \t\t                //   {\"hello # world\"}\n  \t\t                //\n  \t\t                // So we know that the tag must be being generated as part of\n  \t\t                // choice content. Therefore, when the tag has been generated,\n  \t\t                // we push it onto the evaluation stack in the exact same way\n  \t\t                // as the string for the choice content.\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.EndTag: {\n  \t\t                    if (this.state.inStringEvaluation) {\n  \t\t                        let contentStackForTag = [];\n  \t\t                        let outputCountConsumed = 0;\n  \t\t                        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n  \t\t                            let obj = this.state.outputStream[i];\n  \t\t                            outputCountConsumed++;\n  \t\t                            // var command = obj as ControlCommand;\n  \t\t                            let command = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n  \t\t                            if (command != null) {\n  \t\t                                if (command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n  \t\t                                    break;\n  \t\t                                }\n  \t\t                                else {\n  \t\t                                    this.Error(\"Unexpected ControlCommand while extracting tag from choice\");\n  \t\t                                    break;\n  \t\t                                }\n  \t\t                            }\n  \t\t                            if (obj instanceof Value_1.StringValue) {\n  \t\t                                contentStackForTag.push(obj);\n  \t\t                            }\n  \t\t                        }\n  \t\t                        // Consume the content that was produced for this string\n  \t\t                        this.state.PopFromOutputStream(outputCountConsumed);\n  \t\t                        // Build string out of the content we collected\n  \t\t                        let sb = new StringBuilder_1.StringBuilder();\n  \t\t                        for (let strVal of contentStackForTag.reverse()) {\n  \t\t                            sb.Append(strVal.toString());\n  \t\t                        }\n  \t\t                        let choiceTag = new Tag_1.Tag(this.state.CleanOutputWhitespace(sb.toString()));\n  \t\t                        // Pushing to the evaluation stack means it gets picked up\n  \t\t                        // when a Choice is generated from the next Choice Point.\n  \t\t                        this.state.PushEvaluationStack(choiceTag);\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        // Otherwise! Simply push EndTag, so that in the output stream we\n  \t\t                        // have a structure of: [BeginTag, \"the tag content\", EndTag]\n  \t\t                        this.state.PushToOutputStream(evalCommand);\n  \t\t                    }\n  \t\t                    break;\n  \t\t                }\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.EndString: {\n  \t\t                    let contentStackForString = [];\n  \t\t                    let contentToRetain = [];\n  \t\t                    let outputCountConsumed = 0;\n  \t\t                    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n  \t\t                        let obj = this.state.outputStream[i];\n  \t\t                        outputCountConsumed++;\n  \t\t                        // var command = obj as ControlCommand;\n  \t\t                        let command = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n  \t\t                        if (command &&\n  \t\t                            command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {\n  \t\t                            break;\n  \t\t                        }\n  \t\t                        if (obj instanceof Tag_1.Tag) {\n  \t\t                            contentToRetain.push(obj);\n  \t\t                        }\n  \t\t                        if (obj instanceof Value_1.StringValue) {\n  \t\t                            contentStackForString.push(obj);\n  \t\t                        }\n  \t\t                    }\n  \t\t                    // Consume the content that was produced for this string\n  \t\t                    this.state.PopFromOutputStream(outputCountConsumed);\n  \t\t                    // Rescue the tags that we want actually to keep on the output stack\n  \t\t                    // rather than consume as part of the string we're building.\n  \t\t                    // At the time of writing, this only applies to Tag objects generated\n  \t\t                    // by choices, which are pushed to the stack during string generation.\n  \t\t                    for (let rescuedTag of contentToRetain)\n  \t\t                        this.state.PushToOutputStream(rescuedTag);\n  \t\t                    // The C# version uses a Stack for contentStackForString, but we're\n  \t\t                    // using a simple array, so we need to reverse it before using it\n  \t\t                    contentStackForString = contentStackForString.reverse();\n  \t\t                    // Build string out of the content we collected\n  \t\t                    let sb = new StringBuilder_1.StringBuilder();\n  \t\t                    for (let c of contentStackForString) {\n  \t\t                        sb.Append(c.toString());\n  \t\t                    }\n  \t\t                    // Return to expression evaluation (from content mode)\n  \t\t                    this.state.inExpressionEvaluation = true;\n  \t\t                    this.state.PushEvaluationStack(new Value_1.StringValue(sb.toString()));\n  \t\t                    break;\n  \t\t                }\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:\n  \t\t                    let choiceCount = this.state.generatedChoices.length;\n  \t\t                    this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.Turns:\n  \t\t                    this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.TurnsSince:\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.ReadCount:\n  \t\t                    let target = this.state.PopEvaluationStack();\n  \t\t                    if (!(target instanceof Value_1.DivertTargetValue)) {\n  \t\t                        let extraNote = \"\";\n  \t\t                        if (target instanceof Value_1.IntValue)\n  \t\t                            extraNote =\n  \t\t                                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n  \t\t                        this.Error(\"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n  \t\t                            target +\n  \t\t                            extraNote);\n  \t\t                        break;\n  \t\t                    }\n  \t\t                    // var divertTarget = target as DivertTargetValue;\n  \t\t                    let divertTarget = (0, TypeAssertion_1.asOrThrows)(target, Value_1.DivertTargetValue);\n  \t\t                    // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n  \t\t                    let container = (0, TypeAssertion_1.asOrNull)(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);\n  \t\t                    let eitherCount;\n  \t\t                    if (container != null) {\n  \t\t                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)\n  \t\t                            eitherCount = this.state.TurnsSinceForContainer(container);\n  \t\t                        else\n  \t\t                            eitherCount = this.state.VisitCountForContainer(container);\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)\n  \t\t                            eitherCount = -1;\n  \t\t                        else\n  \t\t                            eitherCount = 0;\n  \t\t                        this.Warning(\"Failed to find container for \" +\n  \t\t                            evalCommand.toString() +\n  \t\t                            \" lookup at \" +\n  \t\t                            divertTarget.targetPath.toString());\n  \t\t                    }\n  \t\t                    this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.Random: {\n  \t\t                    let maxInt = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n  \t\t                    let minInt = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n  \t\t                    if (minInt == null || minInt instanceof Value_1.IntValue === false)\n  \t\t                        return this.Error(\"Invalid value for minimum parameter of RANDOM(min, max)\");\n  \t\t                    if (maxInt == null || maxInt instanceof Value_1.IntValue === false)\n  \t\t                        return this.Error(\"Invalid value for maximum parameter of RANDOM(min, max)\");\n  \t\t                    // Originally a primitive type, but here, can be null.\n  \t\t                    // TODO: Replace by default value?\n  \t\t                    if (maxInt.value === null) {\n  \t\t                        return (0, NullException_1.throwNullException)(\"maxInt.value\");\n  \t\t                    }\n  \t\t                    if (minInt.value === null) {\n  \t\t                        return (0, NullException_1.throwNullException)(\"minInt.value\");\n  \t\t                    }\n  \t\t                    // This code is differs a bit from the reference implementation, since\n  \t\t                    // JavaScript has no true integers. Hence integer arithmetics and\n  \t\t                    // interger overflows don't apply here. A loss of precision can\n  \t\t                    // happen with big numbers however.\n  \t\t                    //\n  \t\t                    // The case where 'randomRange' is lower than zero is handled below,\n  \t\t                    // so there's no need to test against Number.MIN_SAFE_INTEGER.\n  \t\t                    let randomRange = maxInt.value - minInt.value + 1;\n  \t\t                    if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n  \t\t                        randomRange = Number.MAX_SAFE_INTEGER;\n  \t\t                        this.Error(\"RANDOM was called with a range that exceeds the size that ink numbers can use.\");\n  \t\t                    }\n  \t\t                    if (randomRange <= 0)\n  \t\t                        this.Error(\"RANDOM was called with minimum as \" +\n  \t\t                            minInt.value +\n  \t\t                            \" and maximum as \" +\n  \t\t                            maxInt.value +\n  \t\t                            \". The maximum must be larger\");\n  \t\t                    let resultSeed = this.state.storySeed + this.state.previousRandom;\n  \t\t                    let random = new PRNG_1.PRNG(resultSeed);\n  \t\t                    let nextRandom = random.next();\n  \t\t                    let chosenValue = (nextRandom % randomRange) + minInt.value;\n  \t\t                    this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));\n  \t\t                    // Next random number (rather than keeping the Random object around)\n  \t\t                    this.state.previousRandom = nextRandom;\n  \t\t                    break;\n  \t\t                }\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.SeedRandom:\n  \t\t                    let seed = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n  \t\t                    if (seed == null || seed instanceof Value_1.IntValue === false)\n  \t\t                        return this.Error(\"Invalid value passed to SEED_RANDOM\");\n  \t\t                    // Originally a primitive type, but here, can be null.\n  \t\t                    // TODO: Replace by default value?\n  \t\t                    if (seed.value === null) {\n  \t\t                        return (0, NullException_1.throwNullException)(\"minInt.value\");\n  \t\t                    }\n  \t\t                    this.state.storySeed = seed.value;\n  \t\t                    this.state.previousRandom = 0;\n  \t\t                    this.state.PushEvaluationStack(new Void_1.Void());\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.VisitIndex:\n  \t\t                    let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count\n  \t\t                    this.state.PushEvaluationStack(new Value_1.IntValue(count));\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:\n  \t\t                    let shuffleIndex = this.NextSequenceShuffleIndex();\n  \t\t                    this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.StartThread:\n  \t\t                    // Handled in main step function\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.Done:\n  \t\t                    // We may exist in the context of the initial\n  \t\t                    // act of creating the thread, or in the context of\n  \t\t                    // evaluating the content.\n  \t\t                    if (this.state.callStack.canPopThread) {\n  \t\t                        this.state.callStack.PopThread();\n  \t\t                    }\n  \t\t                    // In normal flow - allow safe exit without warning\n  \t\t                    else {\n  \t\t                        this.state.didSafeExit = true;\n  \t\t                        // Stop flow in current thread\n  \t\t                        this.state.currentPointer = Pointer_1.Pointer.Null;\n  \t\t                    }\n  \t\t                    break;\n  \t\t                // Force flow to end completely\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.End:\n  \t\t                    this.state.ForceEnd();\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.ListFromInt:\n  \t\t                    // var intVal = state.PopEvaluationStack () as IntValue;\n  \t\t                    let intVal = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n  \t\t                    // var listNameVal = state.PopEvaluationStack () as StringValue;\n  \t\t                    let listNameVal = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.StringValue);\n  \t\t                    if (intVal === null) {\n  \t\t                        throw new StoryException_1.StoryException(\"Passed non-integer when creating a list element from a numerical value.\");\n  \t\t                    }\n  \t\t                    let generatedListValue = null;\n  \t\t                    if (this.listDefinitions === null) {\n  \t\t                        return (0, NullException_1.throwNullException)(\"this.listDefinitions\");\n  \t\t                    }\n  \t\t                    let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);\n  \t\t                    if (foundListDef.exists) {\n  \t\t                        // Originally a primitive type, but here, can be null.\n  \t\t                        // TODO: Replace by default value?\n  \t\t                        if (intVal.value === null) {\n  \t\t                            return (0, NullException_1.throwNullException)(\"minInt.value\");\n  \t\t                        }\n  \t\t                        let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);\n  \t\t                        if (foundItem.exists) {\n  \t\t                            generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);\n  \t\t                        }\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        throw new StoryException_1.StoryException(\"Failed to find LIST called \" + listNameVal.value);\n  \t\t                    }\n  \t\t                    if (generatedListValue == null)\n  \t\t                        generatedListValue = new Value_1.ListValue();\n  \t\t                    this.state.PushEvaluationStack(generatedListValue);\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.ListRange:\n  \t\t                    let max = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.Value);\n  \t\t                    let min = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.Value);\n  \t\t                    // var targetList = state.PopEvaluationStack () as ListValue;\n  \t\t                    let targetList = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.ListValue);\n  \t\t                    if (targetList === null || min === null || max === null)\n  \t\t                        throw new StoryException_1.StoryException(\"Expected list, minimum and maximum for LIST_RANGE\");\n  \t\t                    if (targetList.value === null) {\n  \t\t                        return (0, NullException_1.throwNullException)(\"targetList.value\");\n  \t\t                    }\n  \t\t                    let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);\n  \t\t                    this.state.PushEvaluationStack(new Value_1.ListValue(result));\n  \t\t                    break;\n  \t\t                case ControlCommand_1.ControlCommand.CommandType.ListRandom: {\n  \t\t                    let listVal = this.state.PopEvaluationStack();\n  \t\t                    if (listVal === null)\n  \t\t                        throw new StoryException_1.StoryException(\"Expected list for LIST_RANDOM\");\n  \t\t                    let list = listVal.value;\n  \t\t                    let newList = null;\n  \t\t                    if (list === null) {\n  \t\t                        throw (0, NullException_1.throwNullException)(\"list\");\n  \t\t                    }\n  \t\t                    if (list.Count == 0) {\n  \t\t                        newList = new InkList_1.InkList();\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        // Generate a random index for the element to take\n  \t\t                        let resultSeed = this.state.storySeed + this.state.previousRandom;\n  \t\t                        let random = new PRNG_1.PRNG(resultSeed);\n  \t\t                        let nextRandom = random.next();\n  \t\t                        let listItemIndex = nextRandom % list.Count;\n  \t\t                        // This bit is a little different from the original\n  \t\t                        // C# code, since iterators do not work in the same way.\n  \t\t                        // First, we iterate listItemIndex - 1 times, calling next().\n  \t\t                        // The listItemIndex-th time is made outside of the loop,\n  \t\t                        // in order to retrieve the value.\n  \t\t                        let listEnumerator = list.entries();\n  \t\t                        for (let i = 0; i <= listItemIndex - 1; i++) {\n  \t\t                            listEnumerator.next();\n  \t\t                        }\n  \t\t                        let value = listEnumerator.next().value;\n  \t\t                        let randomItem = {\n  \t\t                            Key: InkList_1.InkListItem.fromSerializedKey(value[0]),\n  \t\t                            Value: value[1],\n  \t\t                        };\n  \t\t                        // Origin list is simply the origin of the one element\n  \t\t                        if (randomItem.Key.originName === null) {\n  \t\t                            return (0, NullException_1.throwNullException)(\"randomItem.Key.originName\");\n  \t\t                        }\n  \t\t                        newList = new InkList_1.InkList(randomItem.Key.originName, this);\n  \t\t                        newList.Add(randomItem.Key, randomItem.Value);\n  \t\t                        this.state.previousRandom = nextRandom;\n  \t\t                    }\n  \t\t                    this.state.PushEvaluationStack(new Value_1.ListValue(newList));\n  \t\t                    break;\n  \t\t                }\n  \t\t                default:\n  \t\t                    this.Error(\"unhandled ControlCommand: \" + evalCommand);\n  \t\t                    break;\n  \t\t            }\n  \t\t            return true;\n  \t\t        }\n  \t\t        // Variable assignment\n  \t\t        else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {\n  \t\t            let varAss = contentObj;\n  \t\t            let assignedVal = this.state.PopEvaluationStack();\n  \t\t            this.state.variablesState.Assign(varAss, assignedVal);\n  \t\t            return true;\n  \t\t        }\n  \t\t        // Variable reference\n  \t\t        else if (contentObj instanceof VariableReference_1.VariableReference) {\n  \t\t            let varRef = contentObj;\n  \t\t            let foundValue = null;\n  \t\t            // Explicit read count value\n  \t\t            if (varRef.pathForCount != null) {\n  \t\t                let container = varRef.containerForCount;\n  \t\t                let count = this.state.VisitCountForContainer(container);\n  \t\t                foundValue = new Value_1.IntValue(count);\n  \t\t            }\n  \t\t            // Normal variable reference\n  \t\t            else {\n  \t\t                foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n  \t\t                if (foundValue == null) {\n  \t\t                    this.Warning(\"Variable not found: '\" +\n  \t\t                        varRef.name +\n  \t\t                        \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\");\n  \t\t                    foundValue = new Value_1.IntValue(0);\n  \t\t                }\n  \t\t            }\n  \t\t            this.state.PushEvaluationStack(foundValue);\n  \t\t            return true;\n  \t\t        }\n  \t\t        // Native function call\n  \t\t        else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {\n  \t\t            let func = contentObj;\n  \t\t            let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n  \t\t            let result = func.Call(funcParams);\n  \t\t            this.state.PushEvaluationStack(result);\n  \t\t            return true;\n  \t\t        }\n  \t\t        // No control content, must be ordinary content\n  \t\t        return false;\n  \t\t    }\n  \t\t    ChoosePathString(path, resetCallstack = true, args = []) {\n  \t\t        this.IfAsyncWeCant(\"call ChoosePathString right now\");\n  \t\t        if (this.onChoosePathString !== null)\n  \t\t            this.onChoosePathString(path, args);\n  \t\t        if (resetCallstack) {\n  \t\t            this.ResetCallstack();\n  \t\t        }\n  \t\t        else {\n  \t\t            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {\n  \t\t                let funcDetail = \"\";\n  \t\t                let container = this.state.callStack.currentElement.currentPointer.container;\n  \t\t                if (container != null) {\n  \t\t                    funcDetail = \"(\" + container.path.toString() + \") \";\n  \t\t                }\n  \t\t                throw new Error(\"Story was running a function \" +\n  \t\t                    funcDetail +\n  \t\t                    \"when you called ChoosePathString(\" +\n  \t\t                    path +\n  \t\t                    \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n  \t\t                    this.state.callStack.callStackTrace);\n  \t\t            }\n  \t\t        }\n  \t\t        this.state.PassArgumentsToEvaluationStack(args);\n  \t\t        this.ChoosePath(new Path_1.Path(path));\n  \t\t    }\n  \t\t    IfAsyncWeCant(activityStr) {\n  \t\t        if (this._asyncContinueActive)\n  \t\t            throw new Error(\"Can't \" +\n  \t\t                activityStr +\n  \t\t                \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\");\n  \t\t    }\n  \t\t    ChoosePath(p, incrementingTurnIndex = true) {\n  \t\t        this.state.SetChosenPath(p, incrementingTurnIndex);\n  \t\t        // Take a note of newly visited containers for read counts etc\n  \t\t        this.VisitChangedContainersDueToDivert();\n  \t\t    }\n  \t\t    ChooseChoiceIndex(choiceIdx) {\n  \t\t        choiceIdx = choiceIdx;\n  \t\t        let choices = this.currentChoices;\n  \t\t        this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, \"choice out of range\");\n  \t\t        let choiceToChoose = choices[choiceIdx];\n  \t\t        if (this.onMakeChoice !== null)\n  \t\t            this.onMakeChoice(choiceToChoose);\n  \t\t        if (choiceToChoose.threadAtGeneration === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"choiceToChoose.threadAtGeneration\");\n  \t\t        }\n  \t\t        if (choiceToChoose.targetPath === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"choiceToChoose.targetPath\");\n  \t\t        }\n  \t\t        this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n  \t\t        this.ChoosePath(choiceToChoose.targetPath);\n  \t\t    }\n  \t\t    HasFunction(functionName) {\n  \t\t        try {\n  \t\t            return this.KnotContainerWithName(functionName) != null;\n  \t\t        }\n  \t\t        catch (e) {\n  \t\t            return false;\n  \t\t        }\n  \t\t    }\n  \t\t    EvaluateFunction(functionName, args = [], returnTextOutput = false) {\n  \t\t        // EvaluateFunction behaves slightly differently than the C# version.\n  \t\t        // In C#, you can pass a (second) parameter `out textOutput` to get the\n  \t\t        // text outputted by the function. This is not possible in js. Instead,\n  \t\t        // we maintain the regular signature (functionName, args), plus an\n  \t\t        // optional third parameter returnTextOutput. If set to true, we will\n  \t\t        // return both the textOutput and the returned value, as an object.\n  \t\t        if (this.onEvaluateFunction !== null)\n  \t\t            this.onEvaluateFunction(functionName, args);\n  \t\t        this.IfAsyncWeCant(\"evaluate a function\");\n  \t\t        if (functionName == null) {\n  \t\t            throw new Error(\"Function is null\");\n  \t\t        }\n  \t\t        else if (functionName == \"\" || functionName.trim() == \"\") {\n  \t\t            throw new Error(\"Function is empty or white space.\");\n  \t\t        }\n  \t\t        let funcContainer = this.KnotContainerWithName(functionName);\n  \t\t        if (funcContainer == null) {\n  \t\t            throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n  \t\t        }\n  \t\t        let outputStreamBefore = [];\n  \t\t        outputStreamBefore.push(...this.state.outputStream);\n  \t\t        this._state.ResetOutput();\n  \t\t        this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n  \t\t        // Evaluate the function, and collect the string output\n  \t\t        let stringOutput = new StringBuilder_1.StringBuilder();\n  \t\t        while (this.canContinue) {\n  \t\t            stringOutput.Append(this.Continue());\n  \t\t        }\n  \t\t        let textOutput = stringOutput.toString();\n  \t\t        this._state.ResetOutput(outputStreamBefore);\n  \t\t        let result = this.state.CompleteFunctionEvaluationFromGame();\n  \t\t        if (this.onCompleteEvaluateFunction != null)\n  \t\t            this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n  \t\t        return returnTextOutput ? { returned: result, output: textOutput } : result;\n  \t\t    }\n  \t\t    EvaluateExpression(exprContainer) {\n  \t\t        let startCallStackHeight = this.state.callStack.elements.length;\n  \t\t        this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);\n  \t\t        this._temporaryEvaluationContainer = exprContainer;\n  \t\t        this.state.GoToStart();\n  \t\t        let evalStackHeight = this.state.evaluationStack.length;\n  \t\t        this.Continue();\n  \t\t        this._temporaryEvaluationContainer = null;\n  \t\t        // Should have fallen off the end of the Container, which should\n  \t\t        // have auto-popped, but just in case we didn't for some reason,\n  \t\t        // manually pop to restore the state (including currentPath).\n  \t\t        if (this.state.callStack.elements.length > startCallStackHeight) {\n  \t\t            this.state.PopCallStack();\n  \t\t        }\n  \t\t        let endStackHeight = this.state.evaluationStack.length;\n  \t\t        if (endStackHeight > evalStackHeight) {\n  \t\t            return this.state.PopEvaluationStack();\n  \t\t        }\n  \t\t        else {\n  \t\t            return null;\n  \t\t        }\n  \t\t    }\n  \t\t    CallExternalFunction(funcName, numberOfArguments) {\n  \t\t        if (funcName === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"funcName\");\n  \t\t        }\n  \t\t        let funcDef = this._externals.get(funcName);\n  \t\t        let fallbackFunctionContainer = null;\n  \t\t        let foundExternal = typeof funcDef !== \"undefined\";\n  \t\t        if (foundExternal &&\n  \t\t            !funcDef.lookAheadSafe &&\n  \t\t            this._state.inStringEvaluation) {\n  \t\t            this.Error(\"External function \" +\n  \t\t                funcName +\n  \t\t                ' could not be called because 1) it wasn\\'t marked as lookaheadSafe when BindExternalFunction was called and 2) the story is in the middle of string generation, either because choice text is being generated, or because you have ink like \"hello {func()}\". You can work around this by generating the result of your function into a temporary variable before the string or choice gets generated: ~ temp x = ' +\n  \t\t                funcName +\n  \t\t                \"()\");\n  \t\t        }\n  \t\t        if (foundExternal &&\n  \t\t            !funcDef.lookAheadSafe &&\n  \t\t            this._stateSnapshotAtLastNewline !== null) {\n  \t\t            this._sawLookaheadUnsafeFunctionAfterNewline = true;\n  \t\t            return;\n  \t\t        }\n  \t\t        if (!foundExternal) {\n  \t\t            if (this.allowExternalFunctionFallbacks) {\n  \t\t                fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n  \t\t                this.Assert(fallbackFunctionContainer !== null, \"Trying to call EXTERNAL function '\" +\n  \t\t                    funcName +\n  \t\t                    \"' which has not been bound, and fallback ink function could not be found.\");\n  \t\t                // Divert direct into fallback function and we're done\n  \t\t                this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);\n  \t\t                this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);\n  \t\t                return;\n  \t\t            }\n  \t\t            else {\n  \t\t                this.Assert(false, \"Trying to call EXTERNAL function '\" +\n  \t\t                    funcName +\n  \t\t                    \"' which has not been bound (and ink fallbacks disabled).\");\n  \t\t            }\n  \t\t        }\n  \t\t        // Pop arguments\n  \t\t        let args = [];\n  \t\t        for (let i = 0; i < numberOfArguments; ++i) {\n  \t\t            // var poppedObj = state.PopEvaluationStack () as Value;\n  \t\t            let poppedObj = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.Value);\n  \t\t            let valueObj = poppedObj.valueObject;\n  \t\t            args.push(valueObj);\n  \t\t        }\n  \t\t        // Reverse arguments from the order they were popped,\n  \t\t        // so they're the right way round again.\n  \t\t        args.reverse();\n  \t\t        // Run the function!\n  \t\t        let funcResult = funcDef.function(args);\n  \t\t        // Convert return value (if any) to the a type that the ink engine can use\n  \t\t        let returnObj = null;\n  \t\t        if (funcResult != null) {\n  \t\t            returnObj = Value_1.Value.Create(funcResult);\n  \t\t            this.Assert(returnObj !== null, \"Could not create ink value from returned object of type \" +\n  \t\t                typeof funcResult);\n  \t\t        }\n  \t\t        else {\n  \t\t            returnObj = new Void_1.Void();\n  \t\t        }\n  \t\t        this.state.PushEvaluationStack(returnObj);\n  \t\t    }\n  \t\t    BindExternalFunctionGeneral(funcName, func, lookaheadSafe = true) {\n  \t\t        this.IfAsyncWeCant(\"bind an external function\");\n  \t\t        this.Assert(!this._externals.has(funcName), \"Function '\" + funcName + \"' has already been bound.\");\n  \t\t        this._externals.set(funcName, {\n  \t\t            function: func,\n  \t\t            lookAheadSafe: lookaheadSafe,\n  \t\t        });\n  \t\t    }\n  \t\t    TryCoerce(value) {\n  \t\t        // We're skipping type coercition in this implementation. First of, js\n  \t\t        // is loosely typed, so it's not that important. Secondly, there is no\n  \t\t        // clean way (AFAIK) for the user to describe what type of parameters\n  \t\t        // they expect.\n  \t\t        return value;\n  \t\t    }\n  \t\t    BindExternalFunction(funcName, func, lookaheadSafe = false) {\n  \t\t        this.Assert(func != null, \"Can't bind a null function\");\n  \t\t        this.BindExternalFunctionGeneral(funcName, (args) => {\n  \t\t            this.Assert(args.length >= func.length, \"External function expected \" + func.length + \" arguments\");\n  \t\t            let coercedArgs = [];\n  \t\t            for (let i = 0, l = args.length; i < l; i++) {\n  \t\t                coercedArgs[i] = this.TryCoerce(args[i]);\n  \t\t            }\n  \t\t            return func.apply(null, coercedArgs);\n  \t\t        }, lookaheadSafe);\n  \t\t    }\n  \t\t    UnbindExternalFunction(funcName) {\n  \t\t        this.IfAsyncWeCant(\"unbind an external a function\");\n  \t\t        this.Assert(this._externals.has(funcName), \"Function '\" + funcName + \"' has not been bound.\");\n  \t\t        this._externals.delete(funcName);\n  \t\t    }\n  \t\t    ValidateExternalBindings() {\n  \t\t        let c = null;\n  \t\t        let o = null;\n  \t\t        let missingExternals = arguments[1] || new Set();\n  \t\t        if (arguments[0] instanceof Container_1.Container) {\n  \t\t            c = arguments[0];\n  \t\t        }\n  \t\t        if (arguments[0] instanceof Object_1.InkObject) {\n  \t\t            o = arguments[0];\n  \t\t        }\n  \t\t        if (c === null && o === null) {\n  \t\t            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);\n  \t\t            this._hasValidatedExternals = true;\n  \t\t            // No problem! Validation complete\n  \t\t            if (missingExternals.size == 0) {\n  \t\t                this._hasValidatedExternals = true;\n  \t\t            }\n  \t\t            else {\n  \t\t                let message = \"Error: Missing function binding for external\";\n  \t\t                message += missingExternals.size > 1 ? \"s\" : \"\";\n  \t\t                message += \": '\";\n  \t\t                message += Array.from(missingExternals).join(\"', '\");\n  \t\t                message += \"' \";\n  \t\t                message += this.allowExternalFunctionFallbacks\n  \t\t                    ? \", and no fallback ink function found.\"\n  \t\t                    : \" (ink fallbacks disabled)\";\n  \t\t                this.Error(message);\n  \t\t            }\n  \t\t        }\n  \t\t        else if (c != null) {\n  \t\t            for (let innerContent of c.content) {\n  \t\t                let container = innerContent;\n  \t\t                if (container == null || !container.hasValidName)\n  \t\t                    this.ValidateExternalBindings(innerContent, missingExternals);\n  \t\t            }\n  \t\t            for (let [, value] of c.namedContent) {\n  \t\t                this.ValidateExternalBindings((0, TypeAssertion_1.asOrNull)(value, Object_1.InkObject), missingExternals);\n  \t\t            }\n  \t\t        }\n  \t\t        else if (o != null) {\n  \t\t            let divert = (0, TypeAssertion_1.asOrNull)(o, Divert_1.Divert);\n  \t\t            if (divert && divert.isExternal) {\n  \t\t                let name = divert.targetPathString;\n  \t\t                if (name === null) {\n  \t\t                    return (0, NullException_1.throwNullException)(\"name\");\n  \t\t                }\n  \t\t                if (!this._externals.has(name)) {\n  \t\t                    if (this.allowExternalFunctionFallbacks) {\n  \t\t                        let fallbackFound = this.mainContentContainer.namedContent.has(name);\n  \t\t                        if (!fallbackFound) {\n  \t\t                            missingExternals.add(name);\n  \t\t                        }\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        missingExternals.add(name);\n  \t\t                    }\n  \t\t                }\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    ObserveVariable(variableName, observer) {\n  \t\t        this.IfAsyncWeCant(\"observe a new variable\");\n  \t\t        if (this._variableObservers === null)\n  \t\t            this._variableObservers = new Map();\n  \t\t        if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n  \t\t            throw new Error(\"Cannot observe variable '\" +\n  \t\t                variableName +\n  \t\t                \"' because it wasn't declared in the ink story.\");\n  \t\t        if (this._variableObservers.has(variableName)) {\n  \t\t            this._variableObservers.get(variableName).push(observer);\n  \t\t        }\n  \t\t        else {\n  \t\t            this._variableObservers.set(variableName, [observer]);\n  \t\t        }\n  \t\t    }\n  \t\t    ObserveVariables(variableNames, observers) {\n  \t\t        for (let i = 0, l = variableNames.length; i < l; i++) {\n  \t\t            this.ObserveVariable(variableNames[i], observers[i]);\n  \t\t        }\n  \t\t    }\n  \t\t    RemoveVariableObserver(observer, specificVariableName) {\n  \t\t        // A couple of things to know about this method:\n  \t\t        //\n  \t\t        // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n  \t\t        //    optionality is marked as `undefined` rather than `null`.\n  \t\t        //    To keep things simple, null-checks are performed using regular\n  \t\t        //    equality operators, where undefined == null.\n  \t\t        //\n  \t\t        // 2. Since C# delegates are translated to arrays of functions,\n  \t\t        //    -= becomes a call to splice and null-checks are replaced by\n  \t\t        //    emptiness-checks.\n  \t\t        //\n  \t\t        this.IfAsyncWeCant(\"remove a variable observer\");\n  \t\t        if (this._variableObservers === null)\n  \t\t            return;\n  \t\t        if (specificVariableName != null) {\n  \t\t            if (this._variableObservers.has(specificVariableName)) {\n  \t\t                if (observer != null) {\n  \t\t                    let variableObservers = this._variableObservers.get(specificVariableName);\n  \t\t                    if (variableObservers != null) {\n  \t\t                        variableObservers.splice(variableObservers.indexOf(observer), 1);\n  \t\t                        if (variableObservers.length === 0) {\n  \t\t                            this._variableObservers.delete(specificVariableName);\n  \t\t                        }\n  \t\t                    }\n  \t\t                }\n  \t\t                else {\n  \t\t                    this._variableObservers.delete(specificVariableName);\n  \t\t                }\n  \t\t            }\n  \t\t        }\n  \t\t        else if (observer != null) {\n  \t\t            let keys = this._variableObservers.keys();\n  \t\t            for (let varName of keys) {\n  \t\t                let variableObservers = this._variableObservers.get(varName);\n  \t\t                if (variableObservers != null) {\n  \t\t                    variableObservers.splice(variableObservers.indexOf(observer), 1);\n  \t\t                    if (variableObservers.length === 0) {\n  \t\t                        this._variableObservers.delete(varName);\n  \t\t                    }\n  \t\t                }\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    VariableStateDidChangeEvent(variableName, newValueObj) {\n  \t\t        if (this._variableObservers === null)\n  \t\t            return;\n  \t\t        let observers = this._variableObservers.get(variableName);\n  \t\t        if (typeof observers !== \"undefined\") {\n  \t\t            if (!(newValueObj instanceof Value_1.Value)) {\n  \t\t                throw new Error(\"Tried to get the value of a variable that isn't a standard type\");\n  \t\t            }\n  \t\t            // var val = newValueObj as Value;\n  \t\t            let val = (0, TypeAssertion_1.asOrThrows)(newValueObj, Value_1.Value);\n  \t\t            for (let observer of observers) {\n  \t\t                observer(variableName, val.valueObject);\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    get globalTags() {\n  \t\t        return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  \t\t    }\n  \t\t    TagsForContentAtPath(path) {\n  \t\t        return this.TagsAtStartOfFlowContainerWithPathString(path);\n  \t\t    }\n  \t\t    TagsAtStartOfFlowContainerWithPathString(pathString) {\n  \t\t        let path = new Path_1.Path(pathString);\n  \t\t        let flowContainer = this.ContentAtPath(path).container;\n  \t\t        if (flowContainer === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"flowContainer\");\n  \t\t        }\n  \t\t        while (true) {\n  \t\t            let firstContent = flowContainer.content[0];\n  \t\t            if (firstContent instanceof Container_1.Container)\n  \t\t                flowContainer = firstContent;\n  \t\t            else\n  \t\t                break;\n  \t\t        }\n  \t\t        let inTag = false;\n  \t\t        let tags = null;\n  \t\t        for (let c of flowContainer.content) {\n  \t\t            // var tag = c as Runtime.Tag;\n  \t\t            let command = (0, TypeAssertion_1.asOrNull)(c, ControlCommand_1.ControlCommand);\n  \t\t            if (command != null) {\n  \t\t                if (command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n  \t\t                    inTag = true;\n  \t\t                }\n  \t\t                else if (command.commandType == ControlCommand_1.ControlCommand.CommandType.EndTag) {\n  \t\t                    inTag = false;\n  \t\t                }\n  \t\t            }\n  \t\t            else if (inTag) {\n  \t\t                let str = (0, TypeAssertion_1.asOrNull)(c, Value_1.StringValue);\n  \t\t                if (str !== null) {\n  \t\t                    if (tags === null)\n  \t\t                        tags = [];\n  \t\t                    if (str.value !== null)\n  \t\t                        tags.push(str.value);\n  \t\t                }\n  \t\t                else {\n  \t\t                    this.Error(\"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\");\n  \t\t                }\n  \t\t            }\n  \t\t            else {\n  \t\t                break;\n  \t\t            }\n  \t\t        }\n  \t\t        return tags;\n  \t\t    }\n  \t\t    BuildStringOfHierarchy() {\n  \t\t        let sb = new StringBuilder_1.StringBuilder();\n  \t\t        this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());\n  \t\t        return sb.toString();\n  \t\t    }\n  \t\t    BuildStringOfContainer(container) {\n  \t\t        let sb = new StringBuilder_1.StringBuilder();\n  \t\t        container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());\n  \t\t        return sb.toString();\n  \t\t    }\n  \t\t    NextContent() {\n  \t\t        this.state.previousPointer = this.state.currentPointer.copy();\n  \t\t        if (!this.state.divertedPointer.isNull) {\n  \t\t            this.state.currentPointer = this.state.divertedPointer.copy();\n  \t\t            this.state.divertedPointer = Pointer_1.Pointer.Null;\n  \t\t            this.VisitChangedContainersDueToDivert();\n  \t\t            if (!this.state.currentPointer.isNull) {\n  \t\t                return;\n  \t\t            }\n  \t\t        }\n  \t\t        let successfulPointerIncrement = this.IncrementContentPointer();\n  \t\t        if (!successfulPointerIncrement) {\n  \t\t            let didPop = false;\n  \t\t            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {\n  \t\t                this.state.PopCallStack(PushPop_1.PushPopType.Function);\n  \t\t                if (this.state.inExpressionEvaluation) {\n  \t\t                    this.state.PushEvaluationStack(new Void_1.Void());\n  \t\t                }\n  \t\t                didPop = true;\n  \t\t            }\n  \t\t            else if (this.state.callStack.canPopThread) {\n  \t\t                this.state.callStack.PopThread();\n  \t\t                didPop = true;\n  \t\t            }\n  \t\t            else {\n  \t\t                this.state.TryExitFunctionEvaluationFromGame();\n  \t\t            }\n  \t\t            if (didPop && !this.state.currentPointer.isNull) {\n  \t\t                this.NextContent();\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    IncrementContentPointer() {\n  \t\t        let successfulIncrement = true;\n  \t\t        let pointer = this.state.callStack.currentElement.currentPointer.copy();\n  \t\t        pointer.index++;\n  \t\t        if (pointer.container === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"pointer.container\");\n  \t\t        }\n  \t\t        while (pointer.index >= pointer.container.content.length) {\n  \t\t            successfulIncrement = false;\n  \t\t            // Container nextAncestor = pointer.container.parent as Container;\n  \t\t            let nextAncestor = (0, TypeAssertion_1.asOrNull)(pointer.container.parent, Container_1.Container);\n  \t\t            if (nextAncestor instanceof Container_1.Container === false) {\n  \t\t                break;\n  \t\t            }\n  \t\t            let indexInAncestor = nextAncestor.content.indexOf(pointer.container);\n  \t\t            if (indexInAncestor == -1) {\n  \t\t                break;\n  \t\t            }\n  \t\t            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);\n  \t\t            pointer.index++;\n  \t\t            successfulIncrement = true;\n  \t\t            if (pointer.container === null) {\n  \t\t                return (0, NullException_1.throwNullException)(\"pointer.container\");\n  \t\t            }\n  \t\t        }\n  \t\t        if (!successfulIncrement)\n  \t\t            pointer = Pointer_1.Pointer.Null;\n  \t\t        this.state.callStack.currentElement.currentPointer = pointer.copy();\n  \t\t        return successfulIncrement;\n  \t\t    }\n  \t\t    TryFollowDefaultInvisibleChoice() {\n  \t\t        let allChoices = this._state.currentChoices;\n  \t\t        let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n  \t\t        if (invisibleChoices.length == 0 ||\n  \t\t            allChoices.length > invisibleChoices.length)\n  \t\t            return false;\n  \t\t        let choice = invisibleChoices[0];\n  \t\t        if (choice.targetPath === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"choice.targetPath\");\n  \t\t        }\n  \t\t        if (choice.threadAtGeneration === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"choice.threadAtGeneration\");\n  \t\t        }\n  \t\t        this.state.callStack.currentThread = choice.threadAtGeneration;\n  \t\t        if (this._stateSnapshotAtLastNewline !== null) {\n  \t\t            this.state.callStack.currentThread = this.state.callStack.ForkThread();\n  \t\t        }\n  \t\t        this.ChoosePath(choice.targetPath, false);\n  \t\t        return true;\n  \t\t    }\n  \t\t    NextSequenceShuffleIndex() {\n  \t\t        // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n  \t\t        let numElementsIntVal = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n  \t\t        if (!(numElementsIntVal instanceof Value_1.IntValue)) {\n  \t\t            this.Error(\"expected number of elements in sequence for shuffle index\");\n  \t\t            return 0;\n  \t\t        }\n  \t\t        let seqContainer = this.state.currentPointer.container;\n  \t\t        if (seqContainer === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"seqContainer\");\n  \t\t        }\n  \t\t        // Originally a primitive type, but here, can be null.\n  \t\t        // TODO: Replace by default value?\n  \t\t        if (numElementsIntVal.value === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"numElementsIntVal.value\");\n  \t\t        }\n  \t\t        let numElements = numElementsIntVal.value;\n  \t\t        // var seqCountVal = state.PopEvaluationStack () as IntValue;\n  \t\t        let seqCountVal = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.IntValue);\n  \t\t        let seqCount = seqCountVal.value;\n  \t\t        // Originally a primitive type, but here, can be null.\n  \t\t        // TODO: Replace by default value?\n  \t\t        if (seqCount === null) {\n  \t\t            return (0, NullException_1.throwNullException)(\"seqCount\");\n  \t\t        }\n  \t\t        let loopIndex = seqCount / numElements;\n  \t\t        let iterationIndex = seqCount % numElements;\n  \t\t        let seqPathStr = seqContainer.path.toString();\n  \t\t        let sequenceHash = 0;\n  \t\t        for (let i = 0, l = seqPathStr.length; i < l; i++) {\n  \t\t            sequenceHash += seqPathStr.charCodeAt(i) || 0;\n  \t\t        }\n  \t\t        let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n  \t\t        let random = new PRNG_1.PRNG(Math.floor(randomSeed));\n  \t\t        let unpickedIndices = [];\n  \t\t        for (let i = 0; i < numElements; ++i) {\n  \t\t            unpickedIndices.push(i);\n  \t\t        }\n  \t\t        for (let i = 0; i <= iterationIndex; ++i) {\n  \t\t            let chosen = random.next() % unpickedIndices.length;\n  \t\t            let chosenIndex = unpickedIndices[chosen];\n  \t\t            unpickedIndices.splice(chosen, 1);\n  \t\t            if (i == iterationIndex) {\n  \t\t                return chosenIndex;\n  \t\t            }\n  \t\t        }\n  \t\t        throw new Error(\"Should never reach here\");\n  \t\t    }\n  \t\t    Error(message, useEndLineNumber = false) {\n  \t\t        let e = new StoryException_1.StoryException(message);\n  \t\t        e.useEndLineNumber = useEndLineNumber;\n  \t\t        throw e;\n  \t\t    }\n  \t\t    Warning(message) {\n  \t\t        this.AddError(message, true);\n  \t\t    }\n  \t\t    AddError(message, isWarning = false, useEndLineNumber = false) {\n  \t\t        let dm = this.currentDebugMetadata;\n  \t\t        let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n  \t\t        if (dm != null) {\n  \t\t            let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n  \t\t            message =\n  \t\t                \"RUNTIME \" +\n  \t\t                    errorTypeStr +\n  \t\t                    \": '\" +\n  \t\t                    dm.fileName +\n  \t\t                    \"' line \" +\n  \t\t                    lineNum +\n  \t\t                    \": \" +\n  \t\t                    message;\n  \t\t        }\n  \t\t        else if (!this.state.currentPointer.isNull) {\n  \t\t            message =\n  \t\t                \"RUNTIME \" +\n  \t\t                    errorTypeStr +\n  \t\t                    \": (\" +\n  \t\t                    this.state.currentPointer +\n  \t\t                    \"): \" +\n  \t\t                    message;\n  \t\t        }\n  \t\t        else {\n  \t\t            message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n  \t\t        }\n  \t\t        this.state.AddError(message, isWarning);\n  \t\t        // In a broken state don't need to know about any other errors.\n  \t\t        if (!isWarning)\n  \t\t            this.state.ForceEnd();\n  \t\t    }\n  \t\t    Assert(condition, message = null) {\n  \t\t        if (condition == false) {\n  \t\t            if (message == null) {\n  \t\t                message = \"Story assert\";\n  \t\t            }\n  \t\t            throw new Error(message + \" \" + this.currentDebugMetadata);\n  \t\t        }\n  \t\t    }\n  \t\t    get currentDebugMetadata() {\n  \t\t        let dm;\n  \t\t        let pointer = this.state.currentPointer;\n  \t\t        if (!pointer.isNull && pointer.Resolve() !== null) {\n  \t\t            dm = pointer.Resolve().debugMetadata;\n  \t\t            if (dm !== null) {\n  \t\t                return dm;\n  \t\t            }\n  \t\t        }\n  \t\t        for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n  \t\t            pointer = this.state.callStack.elements[i].currentPointer;\n  \t\t            if (!pointer.isNull && pointer.Resolve() !== null) {\n  \t\t                dm = pointer.Resolve().debugMetadata;\n  \t\t                if (dm !== null) {\n  \t\t                    return dm;\n  \t\t                }\n  \t\t            }\n  \t\t        }\n  \t\t        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n  \t\t            let outputObj = this.state.outputStream[i];\n  \t\t            dm = outputObj.debugMetadata;\n  \t\t            if (dm !== null) {\n  \t\t                return dm;\n  \t\t            }\n  \t\t        }\n  \t\t        return null;\n  \t\t    }\n  \t\t    get mainContentContainer() {\n  \t\t        if (this._temporaryEvaluationContainer) {\n  \t\t            return this._temporaryEvaluationContainer;\n  \t\t        }\n  \t\t        else {\n  \t\t            return this._mainContentContainer;\n  \t\t        }\n  \t\t    }\n  \t\t}\n  \t\texports.Story = Story;\n  \t\tStory.inkVersionCurrent = 21;\n  \t\t(function (Story) {\n  \t\t    (function (OutputStateChange) {\n  \t\t        OutputStateChange[OutputStateChange[\"NoChange\"] = 0] = \"NoChange\";\n  \t\t        OutputStateChange[OutputStateChange[\"ExtendedBeyondNewline\"] = 1] = \"ExtendedBeyondNewline\";\n  \t\t        OutputStateChange[OutputStateChange[\"NewlineRemoved\"] = 2] = \"NewlineRemoved\";\n  \t\t    })(Story.OutputStateChange || (Story.OutputStateChange = {}));\n  \t\t})(Story || (exports.Story = Story = {}));\n  \t\t\n  \t} (Story$2));\n  \treturn Story$2;\n  }\n\n  var Compiler = {};\n\n  var CompilerOptions = {};\n\n  var hasRequiredCompilerOptions;\n\n  function requireCompilerOptions () {\n  \tif (hasRequiredCompilerOptions) return CompilerOptions;\n  \thasRequiredCompilerOptions = 1;\n  \tObject.defineProperty(CompilerOptions, \"__esModule\", { value: true });\n  \tCompilerOptions.CompilerOptions = void 0;\n  \tlet CompilerOptions$1 = class CompilerOptions {\n  \t    constructor(sourceFilename = null, pluginNames = [], countAllVisits = false, errorHandler = null, fileHandler = null) {\n  \t        this.sourceFilename = sourceFilename;\n  \t        this.pluginNames = pluginNames;\n  \t        this.countAllVisits = countAllVisits;\n  \t        this.errorHandler = errorHandler;\n  \t        this.fileHandler = fileHandler;\n  \t    }\n  \t};\n  \tCompilerOptions.CompilerOptions = CompilerOptions$1;\n  \t\n  \treturn CompilerOptions;\n  }\n\n  var DebugSourceRange = {};\n\n  var hasRequiredDebugSourceRange;\n\n  function requireDebugSourceRange () {\n  \tif (hasRequiredDebugSourceRange) return DebugSourceRange;\n  \thasRequiredDebugSourceRange = 1;\n  \tObject.defineProperty(DebugSourceRange, \"__esModule\", { value: true });\n  \tDebugSourceRange.DebugSourceRange = void 0;\n  \tlet DebugSourceRange$1 = class DebugSourceRange {\n  \t    constructor(length, debugMetadata, text) {\n  \t        this.length = length;\n  \t        this.debugMetadata = debugMetadata;\n  \t        this.text = text;\n  \t    }\n  \t};\n  \tDebugSourceRange.DebugSourceRange = DebugSourceRange$1;\n  \t\n  \treturn DebugSourceRange;\n  }\n\n  var ErrorType = {};\n\n  var hasRequiredErrorType;\n\n  function requireErrorType () {\n  \tif (hasRequiredErrorType) return ErrorType;\n  \thasRequiredErrorType = 1;\n  \t// TODO: Unifify with Engine.\n  \tObject.defineProperty(ErrorType, \"__esModule\", { value: true });\n  \tErrorType.ErrorType = void 0;\n  \tvar ErrorType$1;\n  \t(function (ErrorType) {\n  \t    ErrorType[ErrorType[\"Author\"] = 0] = \"Author\";\n  \t    ErrorType[ErrorType[\"Warning\"] = 1] = \"Warning\";\n  \t    ErrorType[ErrorType[\"Error\"] = 2] = \"Error\";\n  \t})(ErrorType$1 || (ErrorType.ErrorType = ErrorType$1 = {}));\n  \t\n  \treturn ErrorType;\n  }\n\n  var InkParser = {};\n\n  var Argument = {};\n\n  var hasRequiredArgument;\n\n  function requireArgument () {\n  \tif (hasRequiredArgument) return Argument;\n  \thasRequiredArgument = 1;\n  \tObject.defineProperty(Argument, \"__esModule\", { value: true });\n  \tArgument.Argument = void 0;\n  \tlet Argument$1 = class Argument {\n  \t    constructor(identifier = null, isByReference = null, isDivertTarget = null) {\n  \t        this.identifier = identifier;\n  \t        this.isByReference = isByReference;\n  \t        this.isDivertTarget = isDivertTarget;\n  \t    }\n  \t    get typeName() {\n  \t        return \"Argument\";\n  \t    }\n  \t};\n  \tArgument.Argument = Argument$1;\n  \t\n  \treturn Argument;\n  }\n\n  var AuthorWarning = {};\n\n  var _Object = {};\n\n  var hasRequired_Object;\n\n  function require_Object () {\n  \tif (hasRequired_Object) return _Object;\n  \thasRequired_Object = 1;\n  \tObject.defineProperty(_Object, \"__esModule\", { value: true });\n  \t_Object.ParsedObject = void 0;\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tclass ParsedObject {\n  \t    constructor() {\n  \t        this._alreadyHadError = false;\n  \t        this._alreadyHadWarning = false;\n  \t        this._debugMetadata = null;\n  \t        this._runtimeObject = null;\n  \t        this.content = [];\n  \t        this.parent = null;\n  \t        this.GetType = () => this.typeName;\n  \t        /*\n  \t        get descriptionOfScope(): string {\n  \t          const locationNames: string[] = [];\n  \t      \n  \t          let ancestor: ParsedObject | null = this;\n  \t          while (ancestor) {\n  \t            var ancestorFlow = ancestor as FlowBase;\n  \t            if (ancestorFlow && ancestorFlow.name != null) {\n  \t              locationNames.push(`'${ancestorFlow.name}'`);\n  \t            }\n  \t            ancestor = ancestor.parent;\n  \t          }\n  \t      \n  \t          let scopeSB = '';\n  \t          if (locationNames.length > 0) {\n  \t            const locationsListStr = locationNames.join(', ');\n  \t            scopeSB += `${locationsListStr} and`;\n  \t          }\n  \t      \n  \t          scopeSB += 'at top scope';\n  \t      \n  \t          return scopeSB;\n  \t        }\n  \t      */\n  \t        // Return the object so that method can be chained easily\n  \t        this.AddContent = (subContent) => {\n  \t            if (this.content === null) {\n  \t                this.content = [];\n  \t            }\n  \t            const sub = Array.isArray(subContent) ? subContent : [subContent];\n  \t            // Make resilient to content not existing, which can happen\n  \t            // in the case of parse errors where we've already reported\n  \t            // an error but still want a valid structure so we can\n  \t            // carry on parsing.\n  \t            for (const ss of sub) {\n  \t                if (ss.hasOwnProperty(\"parent\")) {\n  \t                    ss.parent = this;\n  \t                }\n  \t                this.content.push(ss);\n  \t            }\n  \t            if (Array.isArray(subContent)) {\n  \t                return;\n  \t            }\n  \t            else {\n  \t                return subContent;\n  \t            }\n  \t        };\n  \t        this.InsertContent = (index, subContent) => {\n  \t            if (this.content === null) {\n  \t                this.content = [];\n  \t            }\n  \t            subContent.parent = this;\n  \t            this.content.splice(index, 0, subContent);\n  \t            return subContent;\n  \t        };\n  \t        this.Find = (type) => (queryFunc = null) => {\n  \t            let tObj = (0, TypeAssertion_1.asOrNull)(this, type);\n  \t            if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {\n  \t                return tObj;\n  \t            }\n  \t            if (this.content === null) {\n  \t                return null;\n  \t            }\n  \t            for (const obj of this.content) {\n  \t                let nestedResult = obj.Find && obj.Find(type)(queryFunc);\n  \t                if (nestedResult) {\n  \t                    return nestedResult;\n  \t                }\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.FindAll = (type) => (queryFunc, foundSoFar) => {\n  \t            const found = Array.isArray(foundSoFar) ? foundSoFar : [];\n  \t            const tObj = (0, TypeAssertion_1.asOrNull)(this, type);\n  \t            if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {\n  \t                found.push(tObj);\n  \t            }\n  \t            if (this.content === null) {\n  \t                return [];\n  \t            }\n  \t            for (const obj of this.content) {\n  \t                obj.FindAll && obj.FindAll(type)(queryFunc, found);\n  \t            }\n  \t            return found;\n  \t        };\n  \t        this.Warning = (message, source = null) => {\n  \t            this.Error(message, source, true);\n  \t        };\n  \t    }\n  \t    get debugMetadata() {\n  \t        if (this._debugMetadata === null && this.parent) {\n  \t            return this.parent.debugMetadata;\n  \t        }\n  \t        return this._debugMetadata;\n  \t    }\n  \t    set debugMetadata(value) {\n  \t        this._debugMetadata = value;\n  \t    }\n  \t    get hasOwnDebugMetadata() {\n  \t        return Boolean(this.debugMetadata);\n  \t    }\n  \t    get typeName() {\n  \t        return \"ParsedObject\";\n  \t    }\n  \t    get story() {\n  \t        let ancestor = this;\n  \t        while (ancestor.parent) {\n  \t            ancestor = ancestor.parent;\n  \t        }\n  \t        return ancestor;\n  \t    }\n  \t    get runtimeObject() {\n  \t        if (!this._runtimeObject) {\n  \t            this._runtimeObject = this.GenerateRuntimeObject();\n  \t            if (this._runtimeObject) {\n  \t                this._runtimeObject.debugMetadata = this.debugMetadata;\n  \t            }\n  \t        }\n  \t        return this._runtimeObject;\n  \t    }\n  \t    set runtimeObject(value) {\n  \t        this._runtimeObject = value;\n  \t    }\n  \t    get runtimePath() {\n  \t        if (!this.runtimeObject.path) {\n  \t            throw new Error();\n  \t        }\n  \t        return this.runtimeObject.path;\n  \t    }\n  \t    // When counting visits and turns since, different object\n  \t    // types may have different containers that needs to be counted.\n  \t    // For most it'll just be the object's main runtime object,\n  \t    // but for e.g. choices, it'll be the target container.\n  \t    get containerForCounting() {\n  \t        return this.runtimeObject;\n  \t    }\n  \t    get ancestry() {\n  \t        let result = [];\n  \t        let ancestor = this.parent;\n  \t        while (ancestor) {\n  \t            result.push(ancestor);\n  \t            ancestor = ancestor.parent;\n  \t        }\n  \t        result = result.reverse();\n  \t        return result;\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        if (this.content !== null) {\n  \t            for (const obj of this.content) {\n  \t                obj.ResolveReferences(context);\n  \t            }\n  \t        }\n  \t    }\n  \t    Error(message, source = null, isWarning = false) {\n  \t        if (source === null) {\n  \t            source = this;\n  \t        }\n  \t        // Only allow a single parsed object to have a single error *directly* associated with it\n  \t        if ((source._alreadyHadError && !isWarning) ||\n  \t            (source._alreadyHadWarning && isWarning)) {\n  \t            return;\n  \t        }\n  \t        if (this.parent) {\n  \t            this.parent.Error(message, source, isWarning);\n  \t        }\n  \t        else {\n  \t            throw new Error(`No parent object to send error to: ${message}`);\n  \t        }\n  \t        if (isWarning) {\n  \t            source._alreadyHadWarning = true;\n  \t        }\n  \t        else {\n  \t            source._alreadyHadError = true;\n  \t        }\n  \t    }\n  \t}\n  \t_Object.ParsedObject = ParsedObject;\n  \t\n  \treturn _Object;\n  }\n\n  var hasRequiredAuthorWarning;\n\n  function requireAuthorWarning () {\n  \tif (hasRequiredAuthorWarning) return AuthorWarning;\n  \thasRequiredAuthorWarning = 1;\n  \tObject.defineProperty(AuthorWarning, \"__esModule\", { value: true });\n  \tAuthorWarning.AuthorWarning = void 0;\n  \tconst Object_1 = require_Object();\n  \tlet AuthorWarning$1 = class AuthorWarning extends Object_1.ParsedObject {\n  \t    constructor(warningMessage) {\n  \t        super();\n  \t        this.warningMessage = warningMessage;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            this.Warning(this.warningMessage);\n  \t            return null;\n  \t        };\n  \t    }\n  \t    get typeName() {\n  \t        return \"AuthorWarning\";\n  \t    }\n  \t};\n  \tAuthorWarning.AuthorWarning = AuthorWarning$1;\n  \t\n  \treturn AuthorWarning;\n  }\n\n  var BinaryExpression = {};\n\n  var Expression = {};\n\n  var hasRequiredExpression;\n\n  function requireExpression () {\n  \tif (hasRequiredExpression) return Expression;\n  \thasRequiredExpression = 1;\n  \tObject.defineProperty(Expression, \"__esModule\", { value: true });\n  \tExpression.Expression = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Object_1 = require_Object();\n  \tlet Expression$1 = class Expression extends Object_1.ParsedObject {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this._prototypeRuntimeConstantExpression = null;\n  \t        this.outputWhenComplete = false;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            // Tell Runtime to start evaluating the following content as an expression\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t            this.GenerateIntoContainer(container);\n  \t            // Tell Runtime to output the result of the expression evaluation to the output stream\n  \t            if (this.outputWhenComplete) {\n  \t                container.AddContent(ControlCommand_1.ControlCommand.EvalOutput());\n  \t            }\n  \t            // Tell Runtime to stop evaluating the content as an expression\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t            return container;\n  \t        };\n  \t        // When generating the value of a constant expression,\n  \t        // we can't just keep generating the same constant expression into\n  \t        // different places where the constant value is referenced, since then\n  \t        // the same runtime objects would be used in multiple places, which\n  \t        // is impossible since each runtime object should have one parent.\n  \t        // Instead, we generate a prototype of the runtime object(s), then\n  \t        // copy them each time they're used.\n  \t        this.GenerateConstantIntoContainer = (container) => {\n  \t            if (this._prototypeRuntimeConstantExpression === null) {\n  \t                this._prototypeRuntimeConstantExpression = new Container_1.Container();\n  \t                this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);\n  \t            }\n  \t            for (const runtimeObj of this._prototypeRuntimeConstantExpression.content) {\n  \t                const copy = runtimeObj.Copy();\n  \t                if (copy) {\n  \t                    container.AddContent(copy);\n  \t                }\n  \t            }\n  \t        };\n  \t        this.toString = () => \"No string value in JavaScript.\";\n  \t    }\n  \t    get typeName() {\n  \t        return \"Expression\";\n  \t    }\n  \t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t    Equals(obj) {\n  \t        return false;\n  \t    }\n  \t};\n  \tExpression.Expression = Expression$1;\n  \t\n  \treturn Expression;\n  }\n\n  var UnaryExpression = {};\n\n  var NumberExpression = {};\n\n  var hasRequiredNumberExpression;\n\n  function requireNumberExpression () {\n  \tif (hasRequiredNumberExpression) return NumberExpression;\n  \thasRequiredNumberExpression = 1;\n  \tObject.defineProperty(NumberExpression, \"__esModule\", { value: true });\n  \tNumberExpression.NumberExpression = void 0;\n  \tconst Expression_1 = requireExpression();\n  \tconst Value_1 = requireValue();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \t// This class is named Number in the C# codebase\n  \t// but this conflict with the built-in Number class\n  \tlet NumberExpression$1 = class NumberExpression extends Expression_1.Expression {\n  \t    constructor(value, subtype) {\n  \t        super();\n  \t        this.isInt = () => this.subtype == \"int\";\n  \t        this.isFloat = () => this.subtype == \"float\";\n  \t        this.isBool = () => this.subtype == \"bool\";\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            if (this.isInt()) {\n  \t                container.AddContent(new Value_1.IntValue(this.value));\n  \t            }\n  \t            else if (this.isFloat()) {\n  \t                container.AddContent(new Value_1.FloatValue(this.value));\n  \t            }\n  \t            else if (this.isBool()) {\n  \t                container.AddContent(new Value_1.BoolValue(this.value));\n  \t            }\n  \t        };\n  \t        this.toString = () => String(this.value);\n  \t        if ((typeof value === \"number\" && !Number.isNaN(value)) ||\n  \t            typeof value == \"boolean\") {\n  \t            this.value = value;\n  \t            this.subtype = subtype;\n  \t        }\n  \t        else {\n  \t            throw new Error(\"Unexpected object type in NumberExpression.\");\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"Number\";\n  \t    }\n  \t    Equals(obj) {\n  \t        const numberExpression = (0, TypeAssertion_1.asOrNull)(obj, NumberExpression);\n  \t        if (!numberExpression)\n  \t            return false;\n  \t        return (numberExpression.subtype == this.subtype &&\n  \t            numberExpression.value == this.value);\n  \t    }\n  \t};\n  \tNumberExpression.NumberExpression = NumberExpression$1;\n  \t\n  \treturn NumberExpression;\n  }\n\n  var hasRequiredUnaryExpression;\n\n  function requireUnaryExpression () {\n  \tif (hasRequiredUnaryExpression) return UnaryExpression;\n  \thasRequiredUnaryExpression = 1;\n  \tObject.defineProperty(UnaryExpression, \"__esModule\", { value: true });\n  \tUnaryExpression.UnaryExpression = void 0;\n  \tconst Expression_1 = requireExpression();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst NumberExpression_1 = requireNumberExpression();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet UnaryExpression$1 = class UnaryExpression extends Expression_1.Expression {\n  \t    get nativeNameForOp() {\n  \t        // Replace \"-\" with \"_\" to make it unique (compared to subtraction)\n  \t        if (this.op === \"-\") {\n  \t            return \"_\";\n  \t        }\n  \t        else if (this.op === \"not\") {\n  \t            return \"!\";\n  \t        }\n  \t        return this.op;\n  \t    }\n  \t    constructor(inner, op) {\n  \t        super();\n  \t        this.op = op;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            this.innerExpression.GenerateIntoContainer(container);\n  \t            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.nativeNameForOp));\n  \t        };\n  \t        this.toString = () => this.nativeNameForOp + this.innerExpression;\n  \t        this.innerExpression = this.AddContent(inner);\n  \t    }\n  \t    get typeName() {\n  \t        return \"UnaryExpression\";\n  \t    }\n  \t};\n  \tUnaryExpression.UnaryExpression = UnaryExpression$1;\n  \t// Attempt to flatten inner expression immediately\n  \t// e.g. convert (-(5)) into (-5)\n  \tUnaryExpression$1.WithInner = (inner, op) => {\n  \t    const innerNumber = (0, TypeAssertion_1.asOrNull)(inner, NumberExpression_1.NumberExpression);\n  \t    if (innerNumber) {\n  \t        if (op === \"-\") {\n  \t            if (innerNumber.isInt()) {\n  \t                return new NumberExpression_1.NumberExpression(-innerNumber.value, \"int\");\n  \t            }\n  \t            else if (innerNumber.isFloat()) {\n  \t                return new NumberExpression_1.NumberExpression(-innerNumber.value, \"float\");\n  \t            }\n  \t        }\n  \t        else if (op == \"!\" || op == \"not\") {\n  \t            if (innerNumber.isInt()) {\n  \t                return new NumberExpression_1.NumberExpression(innerNumber.value == 0, \"bool\");\n  \t            }\n  \t            else if (innerNumber.isFloat()) {\n  \t                return new NumberExpression_1.NumberExpression(innerNumber.value == 0.0, \"bool\");\n  \t            }\n  \t            else if (innerNumber.isBool()) {\n  \t                return new NumberExpression_1.NumberExpression(!innerNumber.value, \"bool\");\n  \t            }\n  \t        }\n  \t        throw new Error(\"Unexpected operation or number type\");\n  \t    }\n  \t    // Normal fallback\n  \t    const unary = new UnaryExpression$1(inner, op);\n  \t    return unary;\n  \t};\n  \t\n  \treturn UnaryExpression;\n  }\n\n  var hasRequiredBinaryExpression;\n\n  function requireBinaryExpression () {\n  \tif (hasRequiredBinaryExpression) return BinaryExpression;\n  \thasRequiredBinaryExpression = 1;\n  \tObject.defineProperty(BinaryExpression, \"__esModule\", { value: true });\n  \tBinaryExpression.BinaryExpression = void 0;\n  \tconst Expression_1 = requireExpression();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst UnaryExpression_1 = requireUnaryExpression();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet BinaryExpression$1 = class BinaryExpression extends Expression_1.Expression {\n  \t    constructor(left, right, opName) {\n  \t        super();\n  \t        this.opName = opName;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            this.leftExpression.GenerateIntoContainer(container);\n  \t            this.rightExpression.GenerateIntoContainer(container);\n  \t            this.opName = this.NativeNameForOp(this.opName);\n  \t            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.opName));\n  \t        };\n  \t        this.NativeNameForOp = (opName) => {\n  \t            if (opName === \"and\") {\n  \t                return \"&&\";\n  \t            }\n  \t            else if (opName === \"or\") {\n  \t                return \"||\";\n  \t            }\n  \t            else if (opName === \"mod\") {\n  \t                return \"%\";\n  \t            }\n  \t            else if (opName === \"has\") {\n  \t                return \"?\";\n  \t            }\n  \t            else if (opName === \"hasnt\") {\n  \t                return \"!?\";\n  \t            }\n  \t            return opName;\n  \t        };\n  \t        this.toString = () => `(${this.leftExpression} ${this.opName} ${this.rightExpression})`;\n  \t        this.leftExpression = this.AddContent(left);\n  \t        this.rightExpression = this.AddContent(right);\n  \t        this.opName = opName;\n  \t    }\n  \t    get typeName() {\n  \t        return \"BinaryExpression\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        // Check for the following case:\n  \t        //\n  \t        //    (not A) ? B\n  \t        //\n  \t        // Since this easy to accidentally do:\n  \t        //\n  \t        //    not A ? B\n  \t        //\n  \t        // when you intend:\n  \t        //\n  \t        //    not (A ? B)\n  \t        if (this.NativeNameForOp(this.opName) === \"?\") {\n  \t            const leftUnary = (0, TypeAssertion_1.asOrNull)(this.leftExpression, UnaryExpression_1.UnaryExpression);\n  \t            if (leftUnary !== null &&\n  \t                (leftUnary.op === \"not\" || leftUnary.op === \"!\")) {\n  \t                this.Error(`Using 'not' or '!' here negates '${leftUnary.innerExpression}' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.`);\n  \t            }\n  \t        }\n  \t    }\n  \t};\n  \tBinaryExpression.BinaryExpression = BinaryExpression$1;\n  \t\n  \treturn BinaryExpression;\n  }\n\n  var CharacterRange = {};\n\n  var CharacterSet = {};\n\n  var hasRequiredCharacterSet;\n\n  function requireCharacterSet () {\n  \tif (hasRequiredCharacterSet) return CharacterSet;\n  \thasRequiredCharacterSet = 1;\n  \tObject.defineProperty(CharacterSet, \"__esModule\", { value: true });\n  \tCharacterSet.CharacterSet = void 0;\n  \tlet CharacterSet$1 = class CharacterSet {\n  \t    constructor(arg) {\n  \t        this.set = new Set();\n  \t        this.Add = (arg) => this.set.add(arg);\n  \t        this.AddRange = (start, end) => {\n  \t            for (let c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {\n  \t                this.Add(String.fromCharCode(c));\n  \t            }\n  \t            return this;\n  \t        };\n  \t        this.AddCharacters = (chars) => {\n  \t            if (typeof chars === \"string\" || Array.isArray(chars)) {\n  \t                for (const c of chars) {\n  \t                    this.Add(c);\n  \t                }\n  \t            }\n  \t            else {\n  \t                for (const c of chars.set) {\n  \t                    this.Add(c);\n  \t                }\n  \t            }\n  \t            return this;\n  \t        };\n  \t        if (arg) {\n  \t            this.AddCharacters(arg);\n  \t        }\n  \t    }\n  \t};\n  \tCharacterSet.CharacterSet = CharacterSet$1;\n  \tCharacterSet$1.FromRange = (start, end) => new CharacterSet$1().AddRange(start, end);\n  \t\n  \treturn CharacterSet;\n  }\n\n  var hasRequiredCharacterRange;\n\n  function requireCharacterRange () {\n  \tif (hasRequiredCharacterRange) return CharacterRange;\n  \thasRequiredCharacterRange = 1;\n  \tObject.defineProperty(CharacterRange, \"__esModule\", { value: true });\n  \tCharacterRange.CharacterRange = void 0;\n  \tconst CharacterSet_1 = requireCharacterSet();\n  \t/// <summary>\n  \t/// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.\n  \t/// </summary>\n  \tlet CharacterRange$1 = class CharacterRange {\n  \t    constructor(_start, _end, excludes = []) {\n  \t        this._start = _start;\n  \t        this._end = _end;\n  \t        this._correspondingCharSet = new CharacterSet_1.CharacterSet();\n  \t        this._excludes = new Set();\n  \t        /// <summary>\n  \t        /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range\n  \t        /// represented by the current instance.\n  \t        /// </summary>\n  \t        /// <remarks>\n  \t        /// The internal character set is created once and cached in memory.\n  \t        /// </remarks>\n  \t        /// <returns>The char set.</returns>\n  \t        this.ToCharacterSet = () => {\n  \t            if (this._correspondingCharSet.set.size === 0) {\n  \t                for (let ii = this.start.charCodeAt(0), c; ii <= this.end.charCodeAt(0); ii += 1) {\n  \t                    c = String.fromCharCode(ii);\n  \t                    if (!this._excludes.has(c)) {\n  \t                        this._correspondingCharSet.AddCharacters(c);\n  \t                    }\n  \t                }\n  \t            }\n  \t            return this._correspondingCharSet;\n  \t        };\n  \t        if (excludes instanceof CharacterSet_1.CharacterSet) {\n  \t            this._excludes = excludes.set;\n  \t        }\n  \t        else {\n  \t            for (const item of excludes) {\n  \t                this._excludes.add(item);\n  \t            }\n  \t        }\n  \t    }\n  \t    get start() {\n  \t        return this._start;\n  \t    }\n  \t    get end() {\n  \t        return this._end;\n  \t    }\n  \t};\n  \tCharacterRange.CharacterRange = CharacterRange$1;\n  \tCharacterRange$1.Define = (start, end, excludes = []) => new CharacterRange$1(start, end, excludes);\n  \t\n  \treturn CharacterRange;\n  }\n\n  var Choice = {};\n\n  var SymbolType = {};\n\n  var hasRequiredSymbolType;\n\n  function requireSymbolType () {\n  \tif (hasRequiredSymbolType) return SymbolType;\n  \thasRequiredSymbolType = 1;\n  \tObject.defineProperty(SymbolType, \"__esModule\", { value: true });\n  \tSymbolType.SymbolType = void 0;\n  \tvar SymbolType$1;\n  \t(function (SymbolType) {\n  \t    SymbolType[SymbolType[\"Knot\"] = 0] = \"Knot\";\n  \t    SymbolType[SymbolType[\"List\"] = 1] = \"List\";\n  \t    SymbolType[SymbolType[\"ListItem\"] = 2] = \"ListItem\";\n  \t    SymbolType[SymbolType[\"Var\"] = 3] = \"Var\";\n  \t    SymbolType[SymbolType[\"SubFlowAndWeave\"] = 4] = \"SubFlowAndWeave\";\n  \t    SymbolType[SymbolType[\"Arg\"] = 5] = \"Arg\";\n  \t    SymbolType[SymbolType[\"Temp\"] = 6] = \"Temp\";\n  \t})(SymbolType$1 || (SymbolType.SymbolType = SymbolType$1 = {}));\n  \t\n  \treturn SymbolType;\n  }\n\n  var hasRequiredChoice;\n\n  function requireChoice () {\n  \tif (hasRequiredChoice) return Choice;\n  \thasRequiredChoice = 1;\n  \tObject.defineProperty(Choice, \"__esModule\", { value: true });\n  \tChoice.Choice = void 0;\n  \tconst ChoicePoint_1 = requireChoicePoint();\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Divert_1 = requireDivert$1();\n  \tconst Value_1 = requireValue();\n  \tconst Object_1 = require_Object();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \tlet Choice$1 = class Choice extends Object_1.ParsedObject {\n  \t    get runtimeChoice() {\n  \t        if (!this._runtimeChoice) {\n  \t            throw new Error();\n  \t        }\n  \t        return this._runtimeChoice;\n  \t    }\n  \t    get name() {\n  \t        var _a;\n  \t        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n  \t    }\n  \t    get condition() {\n  \t        return this._condition;\n  \t    }\n  \t    set condition(value) {\n  \t        this._condition = value;\n  \t        if (value) {\n  \t            this.AddContent(value);\n  \t        }\n  \t    }\n  \t    // Required for IWeavePoint interface\n  \t    // Choice's target container. Used by weave to append any extra\n  \t    // nested weave content into.\n  \t    get runtimeContainer() {\n  \t        return this._innerContentContainer;\n  \t    }\n  \t    get innerContentContainer() {\n  \t        return this._innerContentContainer;\n  \t    }\n  \t    get containerForCounting() {\n  \t        return this._innerContentContainer;\n  \t    }\n  \t    // Override runtimePath to point to the Choice's target content (after it's chosen),\n  \t    // as opposed to the default implementation which would point to the choice itself\n  \t    // (or it's outer container), which is what runtimeObject is.\n  \t    get runtimePath() {\n  \t        if (!this.innerContentContainer || !this.innerContentContainer.path) {\n  \t            throw new Error();\n  \t        }\n  \t        return this.innerContentContainer.path;\n  \t    }\n  \t    constructor(startContent, choiceOnlyContent, innerContent) {\n  \t        super();\n  \t        this._condition = null;\n  \t        this._innerContentContainer = null;\n  \t        this._outerContainer = null;\n  \t        this._runtimeChoice = null;\n  \t        this._returnToR1 = null;\n  \t        this._returnToR2 = null;\n  \t        this._r1Label = null;\n  \t        this._r2Label = null;\n  \t        this._divertToStartContentOuter = null;\n  \t        this._divertToStartContentInner = null;\n  \t        this._startContentRuntimeContainer = null;\n  \t        this.isInvisibleDefault = false;\n  \t        this.hasWeaveStyleInlineBrackets = false;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            this._outerContainer = new Container_1.Container();\n  \t            // Content names for different types of choice:\n  \t            //  * start content [choice only content] inner content\n  \t            //  * start content   -> divert\n  \t            //  * start content\n  \t            //  * [choice only content]\n  \t            // Hmm, this structure has become slightly insane!\n  \t            //\n  \t            // [\n  \t            //     EvalStart\n  \t            //     assign $r = $r1   -- return target = return label 1\n  \t            //     BeginString\n  \t            //     -> s\n  \t            //     [(r1)]            -- return label 1 (after start content)\n  \t            //     EndString\n  \t            //     BeginString\n  \t            //     ... choice only content\n  \t            //     EndEval\n  \t            //     Condition expression\n  \t            //     choice: -> \"c-0\"\n  \t            //     (s) = [\n  \t            //         start content\n  \t            //         -> r          -- goto return label 1 or 2\n  \t            //     ]\n  \t            //  ]\n  \t            //\n  \t            //  in parent's container: (the inner content for the choice)\n  \t            //\n  \t            //  (c-0) = [\n  \t            //      EvalStart\n  \t            //      assign $r = $r2   -- return target = return label 2\n  \t            //      EndEval\n  \t            //      -> s\n  \t            //      [(r2)]            -- return label 1 (after start content)\n  \t            //      inner content\n  \t            //  ]\n  \t            //\n  \t            this._runtimeChoice = new ChoicePoint_1.ChoicePoint(this.onceOnly);\n  \t            this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;\n  \t            if (this.startContent || this.choiceOnlyContent || this.condition) {\n  \t                this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t            }\n  \t            // Start content is put into a named container that's referenced both\n  \t            // when displaying the choice initially, and when generating the text\n  \t            // when the choice is chosen.\n  \t            if (this.startContent) {\n  \t                // Generate start content and return\n  \t                //  - We can't use a function since it uses a call stack element, which would\n  \t                //    put temporary values out of scope. Instead we manually divert around.\n  \t                //  - $r is a variable divert target contains the return point\n  \t                this._returnToR1 = new Value_1.DivertTargetValue();\n  \t                this._outerContainer.AddContent(this._returnToR1);\n  \t                const varAssign = new VariableAssignment_1.VariableAssignment(\"$r\", true);\n  \t                this._outerContainer.AddContent(varAssign);\n  \t                // Mark the start of the choice text generation, so that the runtime\n  \t                // knows where to rewind to to extract the content from the output stream.\n  \t                this._outerContainer.AddContent(ControlCommand_1.ControlCommand.BeginString());\n  \t                this._divertToStartContentOuter = new Divert_1.Divert();\n  \t                this._outerContainer.AddContent(this._divertToStartContentOuter);\n  \t                // Start content itself in a named container\n  \t                this._startContentRuntimeContainer =\n  \t                    this.startContent.GenerateRuntimeObject();\n  \t                this._startContentRuntimeContainer.name = \"s\";\n  \t                // Effectively, the \"return\" statement - return to the point specified by $r\n  \t                const varDivert = new Divert_1.Divert();\n  \t                varDivert.variableDivertName = \"$r\";\n  \t                this._startContentRuntimeContainer.AddContent(varDivert);\n  \t                // Add the container\n  \t                this._outerContainer.AddToNamedContentOnly(this._startContentRuntimeContainer);\n  \t                // This is the label to return to\n  \t                this._r1Label = new Container_1.Container();\n  \t                this._r1Label.name = \"$r1\";\n  \t                this._outerContainer.AddContent(this._r1Label);\n  \t                this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EndString());\n  \t                this._runtimeChoice.hasStartContent = true;\n  \t            }\n  \t            // Choice only content - mark the start, then generate it directly into the outer container\n  \t            if (this.choiceOnlyContent) {\n  \t                this._outerContainer.AddContent(ControlCommand_1.ControlCommand.BeginString());\n  \t                const choiceOnlyRuntimeContent = this.choiceOnlyContent.GenerateRuntimeObject();\n  \t                this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);\n  \t                this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EndString());\n  \t                this._runtimeChoice.hasChoiceOnlyContent = true;\n  \t            }\n  \t            // Generate any condition for this choice\n  \t            if (this.condition) {\n  \t                this.condition.GenerateIntoContainer(this._outerContainer);\n  \t                this._runtimeChoice.hasCondition = true;\n  \t            }\n  \t            if (this.startContent || this.choiceOnlyContent || this.condition) {\n  \t                this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t            }\n  \t            // Add choice itself\n  \t            this._outerContainer.AddContent(this._runtimeChoice);\n  \t            // Container that choice points to for when it's chosen\n  \t            this._innerContentContainer = new Container_1.Container();\n  \t            // Repeat start content by diverting to its container\n  \t            if (this.startContent) {\n  \t                // Set the return point when jumping back into the start content\n  \t                //  - In this case, it's the $r2 point, within the choice content \"c\".\n  \t                this._returnToR2 = new Value_1.DivertTargetValue();\n  \t                this._innerContentContainer.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t                this._innerContentContainer.AddContent(this._returnToR2);\n  \t                this._innerContentContainer.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t                const varAssign = new VariableAssignment_1.VariableAssignment(\"$r\", true);\n  \t                this._innerContentContainer.AddContent(varAssign);\n  \t                // Main divert into start content\n  \t                this._divertToStartContentInner = new Divert_1.Divert();\n  \t                this._innerContentContainer.AddContent(this._divertToStartContentInner);\n  \t                // Define label to return to\n  \t                this._r2Label = new Container_1.Container();\n  \t                this._r2Label.name = \"$r2\";\n  \t                this._innerContentContainer.AddContent(this._r2Label);\n  \t            }\n  \t            // Choice's own inner content\n  \t            if (this.innerContent) {\n  \t                const innerChoiceOnlyContent = this.innerContent.GenerateRuntimeObject();\n  \t                this._innerContentContainer.AddContentsOfContainer(innerChoiceOnlyContent);\n  \t            }\n  \t            if (this.story.countAllVisits) {\n  \t                this._innerContentContainer.visitsShouldBeCounted = true;\n  \t            }\n  \t            this._innerContentContainer.countingAtStartOnly = true;\n  \t            return this._outerContainer;\n  \t        };\n  \t        this.toString = () => {\n  \t            if (this.choiceOnlyContent !== null) {\n  \t                return `* ${this.startContent}[${this.choiceOnlyContent}]...`;\n  \t            }\n  \t            return `* ${this.startContent}...`;\n  \t        };\n  \t        this.startContent = startContent;\n  \t        this.choiceOnlyContent = choiceOnlyContent;\n  \t        this.innerContent = innerContent;\n  \t        this.indentationDepth = 1;\n  \t        if (startContent) {\n  \t            this.AddContent(this.startContent);\n  \t        }\n  \t        if (choiceOnlyContent) {\n  \t            this.AddContent(this.choiceOnlyContent);\n  \t        }\n  \t        if (innerContent) {\n  \t            this.AddContent(this.innerContent);\n  \t        }\n  \t        this.onceOnly = true; // default\n  \t    }\n  \t    get typeName() {\n  \t        return \"Choice\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        var _a;\n  \t        // Weave style choice - target own content container\n  \t        if (this._innerContentContainer) {\n  \t            this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;\n  \t            if (this.onceOnly) {\n  \t                this._innerContentContainer.visitsShouldBeCounted = true;\n  \t            }\n  \t        }\n  \t        if (this._returnToR1) {\n  \t            if (!this._r1Label) {\n  \t                throw new Error();\n  \t            }\n  \t            this._returnToR1.targetPath = this._r1Label.path;\n  \t        }\n  \t        if (this._returnToR2) {\n  \t            if (!this._r2Label) {\n  \t                throw new Error();\n  \t            }\n  \t            this._returnToR2.targetPath = this._r2Label.path;\n  \t        }\n  \t        if (this._divertToStartContentOuter) {\n  \t            if (!this._startContentRuntimeContainer) {\n  \t                throw new Error();\n  \t            }\n  \t            this._divertToStartContentOuter.targetPath =\n  \t                this._startContentRuntimeContainer.path;\n  \t        }\n  \t        if (this._divertToStartContentInner) {\n  \t            if (!this._startContentRuntimeContainer) {\n  \t                throw new Error();\n  \t            }\n  \t            this._divertToStartContentInner.targetPath =\n  \t                this._startContentRuntimeContainer.path;\n  \t        }\n  \t        super.ResolveReferences(context);\n  \t        if (this.identifier && (((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\").length > 0) {\n  \t            context.CheckForNamingCollisions(this, this.identifier, SymbolType_1.SymbolType.SubFlowAndWeave);\n  \t        }\n  \t    }\n  \t};\n  \tChoice.Choice = Choice$1;\n  \t\n  \treturn Choice;\n  }\n\n  var CommentEliminator = {};\n\n  var StringParser = {};\n\n  var StringParserState = {};\n\n  var StringParserElement = {};\n\n  var hasRequiredStringParserElement;\n\n  function requireStringParserElement () {\n  \tif (hasRequiredStringParserElement) return StringParserElement;\n  \thasRequiredStringParserElement = 1;\n  \tObject.defineProperty(StringParserElement, \"__esModule\", { value: true });\n  \tStringParserElement.StringParserElement = void 0;\n  \tlet StringParserElement$1 = class StringParserElement {\n  \t    constructor() {\n  \t        this.characterIndex = 0;\n  \t        this.characterInLineIndex = 0;\n  \t        this.lineIndex = 0;\n  \t        this.reportedErrorInScope = false;\n  \t        this.uniqueId = 0;\n  \t        this.customFlags = 0;\n  \t        this.CopyFrom = (fromElement) => {\n  \t            StringParserElement._uniqueIdCounter++;\n  \t            this.uniqueId = StringParserElement._uniqueIdCounter;\n  \t            this.characterIndex = fromElement.characterIndex;\n  \t            this.characterInLineIndex = fromElement.characterInLineIndex;\n  \t            this.lineIndex = fromElement.lineIndex;\n  \t            this.customFlags = fromElement.customFlags;\n  \t            this.reportedErrorInScope = false;\n  \t        };\n  \t        // Squash is used when succeeding from a rule,\n  \t        // so only the state information we wanted to carry forward is\n  \t        // retained. e.g. characterIndex and lineIndex are global,\n  \t        // however uniqueId is specific to the individual rule,\n  \t        // and likewise, custom flags are designed for the temporary\n  \t        // state of the individual rule too.\n  \t        this.SquashFrom = (fromElement) => {\n  \t            this.characterIndex = fromElement.characterIndex;\n  \t            this.characterInLineIndex = fromElement.characterInLineIndex;\n  \t            this.lineIndex = fromElement.lineIndex;\n  \t            this.reportedErrorInScope = fromElement.reportedErrorInScope;\n  \t            this.customFlags = fromElement.customFlags;\n  \t        };\n  \t    }\n  \t};\n  \tStringParserElement.StringParserElement = StringParserElement$1;\n  \tStringParserElement$1._uniqueIdCounter = 1000;\n  \t\n  \treturn StringParserElement;\n  }\n\n  var hasRequiredStringParserState;\n\n  function requireStringParserState () {\n  \tif (hasRequiredStringParserState) return StringParserState;\n  \thasRequiredStringParserState = 1;\n  \tObject.defineProperty(StringParserState, \"__esModule\", { value: true });\n  \tStringParserState.StringParserState = void 0;\n  \tconst StringParserElement_1 = requireStringParserElement();\n  \tlet StringParserState$1 = class StringParserState {\n  \t    get currentElement() {\n  \t        return this._stack[this._numElements - 1];\n  \t    }\n  \t    get lineIndex() {\n  \t        return this.currentElement.lineIndex;\n  \t    }\n  \t    set lineIndex(value) {\n  \t        this.currentElement.lineIndex = value;\n  \t    }\n  \t    get characterIndex() {\n  \t        return this.currentElement.characterIndex;\n  \t    }\n  \t    set characterIndex(value) {\n  \t        this.currentElement.characterIndex = value;\n  \t    }\n  \t    get characterInLineIndex() {\n  \t        return this.currentElement.characterInLineIndex;\n  \t    }\n  \t    set characterInLineIndex(value) {\n  \t        this.currentElement.characterInLineIndex = value;\n  \t    }\n  \t    get customFlags() {\n  \t        return this.currentElement.customFlags;\n  \t    }\n  \t    set customFlags(value) {\n  \t        this.currentElement.customFlags = value;\n  \t    }\n  \t    get errorReportedAlreadyInScope() {\n  \t        return this.currentElement.reportedErrorInScope;\n  \t    }\n  \t    get stackHeight() {\n  \t        return this._numElements;\n  \t    }\n  \t    constructor() {\n  \t        this._stack = [];\n  \t        this._numElements = 0;\n  \t        this.StringParserState = () => {\n  \t            const kExpectedMaxStackDepth = 200;\n  \t            this._stack = new Array(kExpectedMaxStackDepth);\n  \t            for (let ii = 0; ii < kExpectedMaxStackDepth; ++ii) {\n  \t                this._stack[ii] = new StringParserElement_1.StringParserElement();\n  \t            }\n  \t            this._numElements = 1;\n  \t        };\n  \t        this.Push = () => {\n  \t            if (this._numElements >= this._stack.length && this._numElements > 0) {\n  \t                throw new Error(\"Stack overflow in parser state.\");\n  \t            }\n  \t            const prevElement = this._stack[this._numElements - 1];\n  \t            const newElement = this._stack[this._numElements];\n  \t            this._numElements++;\n  \t            newElement.CopyFrom(prevElement);\n  \t            return newElement.uniqueId;\n  \t        };\n  \t        this.Pop = (expectedRuleId) => {\n  \t            if (this._numElements == 1) {\n  \t                throw new Error(\"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\");\n  \t            }\n  \t            if (this.currentElement.uniqueId != expectedRuleId) {\n  \t                throw new Error(\"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\");\n  \t            }\n  \t            // Restore state\n  \t            this._numElements -= 1;\n  \t        };\n  \t        this.Peek = (expectedRuleId) => {\n  \t            if (this.currentElement.uniqueId != expectedRuleId) {\n  \t                throw new Error(\"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\");\n  \t            }\n  \t            return this._stack[this._numElements - 1];\n  \t        };\n  \t        this.PeekPenultimate = () => {\n  \t            if (this._numElements >= 2) {\n  \t                return this._stack[this._numElements - 2];\n  \t            }\n  \t            return null;\n  \t        };\n  \t        // Reduce stack height while maintaining currentElement\n  \t        // Remove second last element: i.e. \"squash last two elements together\"\n  \t        // Used when succeeding from a rule (and ONLY when succeeding, since\n  \t        // the state of the top element is retained).\n  \t        this.Squash = () => {\n  \t            if (this._numElements < 2) {\n  \t                throw new Error(\"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\");\n  \t            }\n  \t            const penultimateEl = this._stack[this._numElements - 2];\n  \t            const lastEl = this._stack[this._numElements - 1];\n  \t            penultimateEl.SquashFrom(lastEl);\n  \t            this._numElements -= 1;\n  \t        };\n  \t        this.NoteErrorReported = () => {\n  \t            for (const el of this._stack) {\n  \t                el.reportedErrorInScope = true;\n  \t            }\n  \t        };\n  \t        const kExpectedMaxStackDepth = 200;\n  \t        for (let i = 0; i < kExpectedMaxStackDepth; i++) {\n  \t            this._stack[i] = new StringParserElement_1.StringParserElement();\n  \t        }\n  \t        this._numElements = 1;\n  \t    }\n  \t};\n  \tStringParserState.StringParserState = StringParserState$1;\n  \t\n  \treturn StringParserState;\n  }\n\n  var hasRequiredStringParser;\n\n  function requireStringParser () {\n  \tif (hasRequiredStringParser) return StringParser;\n  \thasRequiredStringParser = 1;\n  \t(function (exports) {\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.StringParser = exports.ParseSuccess = void 0;\n  \t\tconst CharacterSet_1 = requireCharacterSet();\n  \t\tconst StringParserState_1 = requireStringParserState();\n  \t\texports.ParseSuccess = Symbol(\"ParseSuccessStruct\");\n  \t\tclass StringParser {\n  \t\t    constructor(str) {\n  \t\t        this.ParseRule = null;\n  \t\t        this.errorHandler = null;\n  \t\t        this.hadError = false;\n  \t\t        //--------------------------------\n  \t\t        // Parse state\n  \t\t        //--------------------------------\n  \t\t        this.BeginRule = () => this.state.Push();\n  \t\t        this.FailRule = (expectedRuleId) => {\n  \t\t            this.state.Pop(expectedRuleId);\n  \t\t            return null;\n  \t\t        };\n  \t\t        this.CancelRule = (expectedRuleId) => {\n  \t\t            this.state.Pop(expectedRuleId);\n  \t\t        };\n  \t\t        this.SucceedRule = (expectedRuleId, result = null) => {\n  \t\t            // Get state at point where this rule stared evaluating\n  \t\t            const stateAtSucceedRule = this.state.Peek(expectedRuleId);\n  \t\t            const stateAtBeginRule = this.state.PeekPenultimate();\n  \t\t            // Allow subclass to receive callback\n  \t\t            if (this.RuleDidSucceed) {\n  \t\t                this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);\n  \t\t            }\n  \t\t            // Flatten state stack so that we maintain the same values,\n  \t\t            // but remove one level in the stack.\n  \t\t            this.state.Squash();\n  \t\t            let finalResult = result;\n  \t\t            if (finalResult === null) {\n  \t\t                finalResult = StringParser.ParseSuccess;\n  \t\t            }\n  \t\t            return finalResult;\n  \t\t        };\n  \t\t        this.Expect = (rule, message = null, recoveryRule = null) => {\n  \t\t            let result = this.ParseObject(rule);\n  \t\t            if (result === null) {\n  \t\t                if (message === null) {\n  \t\t                    message = rule.name;\n  \t\t                }\n  \t\t                let butSaw;\n  \t\t                const lineRemainder = this.LineRemainder();\n  \t\t                if (lineRemainder === null || lineRemainder.length === 0) {\n  \t\t                    butSaw = \"end of line\";\n  \t\t                }\n  \t\t                else {\n  \t\t                    butSaw = `'${lineRemainder}'`;\n  \t\t                }\n  \t\t                this.Error(`Expected ${message} but saw ${butSaw}`);\n  \t\t                if (recoveryRule !== null) {\n  \t\t                    result = recoveryRule();\n  \t\t                }\n  \t\t            }\n  \t\t            return result;\n  \t\t        };\n  \t\t        this.Error = (message, isWarning = false) => {\n  \t\t            this.ErrorOnLine(message, this.lineIndex + 1, isWarning);\n  \t\t        };\n  \t\t        this.ErrorWithParsedObject = (message, result, isWarning = false) => {\n  \t\t            this.ErrorOnLine(message, result.debugMetadata ? result.debugMetadata.startLineNumber : -1, isWarning);\n  \t\t        };\n  \t\t        this.ErrorOnLine = (message, lineNumber, isWarning) => {\n  \t\t            if (!this.state.errorReportedAlreadyInScope) {\n  \t\t                const errorType = isWarning ? \"Warning\" : \"Error\";\n  \t\t                if (!this.errorHandler) {\n  \t\t                    throw new Error(`${errorType} on line ${lineNumber}: ${message}`);\n  \t\t                }\n  \t\t                else {\n  \t\t                    this.errorHandler(message, this.index, lineNumber - 1, isWarning);\n  \t\t                }\n  \t\t                this.state.NoteErrorReported();\n  \t\t            }\n  \t\t            if (!isWarning) {\n  \t\t                this.hadError = true;\n  \t\t            }\n  \t\t        };\n  \t\t        this.Warning = (message) => this.Error(message, true);\n  \t\t        this.LineRemainder = () => this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\"));\n  \t\t        this.SetFlag = (flag, trueOrFalse) => {\n  \t\t            if (trueOrFalse) {\n  \t\t                this.state.customFlags |= flag;\n  \t\t            }\n  \t\t            else {\n  \t\t                this.state.customFlags &= ~flag;\n  \t\t            }\n  \t\t        };\n  \t\t        this.GetFlag = (flag) => Boolean(this.state.customFlags & flag);\n  \t\t        //--------------------------------\n  \t\t        // Structuring\n  \t\t        //--------------------------------\n  \t\t        this.ParseObject = (rule) => {\n  \t\t            const ruleId = this.BeginRule();\n  \t\t            const stackHeightBefore = this.state.stackHeight;\n  \t\t            const result = rule();\n  \t\t            if (stackHeightBefore !== this.state.stackHeight) {\n  \t\t                throw new Error(\"Mismatched Begin/Fail/Succeed rules\");\n  \t\t            }\n  \t\t            if (result === null) {\n  \t\t                return this.FailRule(ruleId);\n  \t\t            }\n  \t\t            this.SucceedRule(ruleId, result);\n  \t\t            return result;\n  \t\t        };\n  \t\t        this.Parse = (rule) => {\n  \t\t            const ruleId = this.BeginRule();\n  \t\t            const result = rule();\n  \t\t            if (result === null) {\n  \t\t                this.FailRule(ruleId);\n  \t\t                return null;\n  \t\t            }\n  \t\t            this.SucceedRule(ruleId, result);\n  \t\t            return result;\n  \t\t        };\n  \t\t        this.OneOf = (array) => {\n  \t\t            for (const rule of array) {\n  \t\t                const result = this.ParseObject(rule);\n  \t\t                if (result !== null) {\n  \t\t                    return result;\n  \t\t                }\n  \t\t            }\n  \t\t            return null;\n  \t\t        };\n  \t\t        this.OneOrMore = (rule) => {\n  \t\t            const results = [];\n  \t\t            let result = null;\n  \t\t            do {\n  \t\t                result = this.ParseObject(rule);\n  \t\t                if (result !== null) {\n  \t\t                    results.push(result);\n  \t\t                }\n  \t\t            } while (result !== null);\n  \t\t            if (results.length > 0) {\n  \t\t                return results;\n  \t\t            }\n  \t\t            return null;\n  \t\t        };\n  \t\t        this.Optional = (rule) => () => {\n  \t\t            const result = this.ParseObject(rule);\n  \t\t            if (result === null)\n  \t\t                return StringParser.ParseSuccess;\n  \t\t            return result;\n  \t\t        };\n  \t\t        // Return ParseSuccess instead the real result so that it gets excluded\n  \t\t        // from result arrays (e.g. Interleave)\n  \t\t        this.Exclude = (rule) => () => this.ParseObject(rule) && StringParser.ParseSuccess;\n  \t\t        // Combination of both of the above\n  \t\t        this.OptionalExclude = (rule) => () => {\n  \t\t            this.ParseObject(rule);\n  \t\t            return StringParser.ParseSuccess;\n  \t\t        };\n  \t\t        // Convenience method for creating more readable ParseString rules that can be combined\n  \t\t        // in other structuring rules (like OneOf etc)\n  \t\t        // e.g. OneOf(String(\"one\"), String(\"two\"))\n  \t\t        this.String = (str) => () => this.ParseString(str);\n  \t\t        this.TryAddResultToList = (result, list, flatten = true) => {\n  \t\t            if (result === StringParser.ParseSuccess) {\n  \t\t                return;\n  \t\t            }\n  \t\t            if (flatten && Array.isArray(result)) {\n  \t\t                const resultCollection = result;\n  \t\t                if (resultCollection !== null) {\n  \t\t                    for (const obj of resultCollection) {\n  \t\t                        list.push(obj);\n  \t\t                    }\n  \t\t                    return;\n  \t\t                }\n  \t\t            }\n  \t\t            list.push(result);\n  \t\t        };\n  \t\t        this.Interleave = (ruleA, ruleB, untilTerminator = null, flatten = true) => {\n  \t\t            const ruleId = this.BeginRule();\n  \t\t            const results = [];\n  \t\t            // First outer padding\n  \t\t            const firstA = this.ParseObject(ruleA);\n  \t\t            if (firstA === null) {\n  \t\t                return this.FailRule(ruleId);\n  \t\t            }\n  \t\t            else {\n  \t\t                this.TryAddResultToList(firstA, results, flatten);\n  \t\t            }\n  \t\t            let lastMainResult = null;\n  \t\t            let outerResult = null;\n  \t\t            do {\n  \t\t                // \"until\" condition hit?\n  \t\t                if (untilTerminator !== null && this.Peek(untilTerminator) !== null) {\n  \t\t                    break;\n  \t\t                }\n  \t\t                // Main inner\n  \t\t                lastMainResult = this.ParseObject(ruleB);\n  \t\t                if (lastMainResult === null) {\n  \t\t                    break;\n  \t\t                }\n  \t\t                else {\n  \t\t                    this.TryAddResultToList(lastMainResult, results, flatten);\n  \t\t                }\n  \t\t                // Outer result (i.e. last A in ABA)\n  \t\t                outerResult = null;\n  \t\t                if (lastMainResult !== null) {\n  \t\t                    outerResult = this.ParseObject(ruleA);\n  \t\t                    if (outerResult === null) {\n  \t\t                        break;\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        this.TryAddResultToList(outerResult, results, flatten);\n  \t\t                    }\n  \t\t                }\n  \t\t                // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)\n  \t\t            } while ((lastMainResult !== null || outerResult !== null) &&\n  \t\t                !(lastMainResult === StringParser.ParseSuccess &&\n  \t\t                    outerResult == StringParser.ParseSuccess) &&\n  \t\t                this.remainingLength > 0);\n  \t\t            if (results.length === 0) {\n  \t\t                return this.FailRule(ruleId);\n  \t\t            }\n  \t\t            return this.SucceedRule(ruleId, results);\n  \t\t        };\n  \t\t        //--------------------------------\n  \t\t        // Basic string parsing\n  \t\t        //--------------------------------\n  \t\t        this.ParseString = (str) => {\n  \t\t            if (str.length > this.remainingLength) {\n  \t\t                return null;\n  \t\t            }\n  \t\t            const ruleId = this.BeginRule();\n  \t\t            // Optimisation from profiling:\n  \t\t            // Store in temporary local variables\n  \t\t            // since they're properties that would have to access\n  \t\t            // the rule stack every time otherwise.\n  \t\t            let i = this.index;\n  \t\t            let cli = this.characterInLineIndex;\n  \t\t            let li = this.lineIndex;\n  \t\t            let success = true;\n  \t\t            for (let tempIdx = 0; tempIdx < str.length; tempIdx += 1) {\n  \t\t                const c = str[tempIdx];\n  \t\t                if (this._chars[i] !== c) {\n  \t\t                    success = false;\n  \t\t                    break;\n  \t\t                }\n  \t\t                if (c === \"\\n\") {\n  \t\t                    li++;\n  \t\t                    cli = -1;\n  \t\t                }\n  \t\t                i++;\n  \t\t                cli++;\n  \t\t            }\n  \t\t            this.index = i;\n  \t\t            this.characterInLineIndex = cli;\n  \t\t            this.lineIndex = li;\n  \t\t            if (success) {\n  \t\t                return this.SucceedRule(ruleId, str);\n  \t\t            }\n  \t\t            return this.FailRule(ruleId);\n  \t\t        };\n  \t\t        this.ParseSingleCharacter = () => {\n  \t\t            if (this.remainingLength > 0) {\n  \t\t                const c = this._chars[this.index];\n  \t\t                if (c === \"\\n\") {\n  \t\t                    this.lineIndex += 1;\n  \t\t                    this.characterInLineIndex = -1;\n  \t\t                }\n  \t\t                this.index += 1;\n  \t\t                this.characterInLineIndex += 1;\n  \t\t                return c;\n  \t\t            }\n  \t\t            return \"0\";\n  \t\t        };\n  \t\t        this.ParseUntilCharactersFromString = (str, maxCount = -1) => this.ParseCharactersFromString(str, false, maxCount);\n  \t\t        this.ParseUntilCharactersFromCharSet = (charSet, maxCount = -1) => this.ParseCharactersFromCharSet(charSet, false, maxCount);\n  \t\t        this.ParseCharactersFromString = (str, maxCountOrShouldIncludeStrChars = -1, maxCount = -1) => {\n  \t\t            const charSet = new CharacterSet_1.CharacterSet(str);\n  \t\t            if (typeof maxCountOrShouldIncludeStrChars === \"number\") {\n  \t\t                return this.ParseCharactersFromCharSet(charSet, true, maxCountOrShouldIncludeStrChars);\n  \t\t            }\n  \t\t            return this.ParseCharactersFromCharSet(charSet, maxCountOrShouldIncludeStrChars, maxCount);\n  \t\t        };\n  \t\t        this.ParseCharactersFromCharSet = (charSet, shouldIncludeChars = true, maxCount = -1) => {\n  \t\t            if (maxCount === -1) {\n  \t\t                maxCount = Number.MAX_SAFE_INTEGER;\n  \t\t            }\n  \t\t            const startIndex = this.index;\n  \t\t            // Optimisation from profiling:\n  \t\t            // Store in temporary local variables\n  \t\t            // since they're properties that would have to access\n  \t\t            // the rule stack every time otherwise.\n  \t\t            let ii = this.index;\n  \t\t            let cli = this.characterInLineIndex;\n  \t\t            let li = this.lineIndex;\n  \t\t            let count = 0;\n  \t\t            while (ii < this._chars.length &&\n  \t\t                charSet.set.has(this._chars[ii]) === shouldIncludeChars &&\n  \t\t                count < maxCount) {\n  \t\t                if (this._chars[ii] === \"\\n\") {\n  \t\t                    li += 1;\n  \t\t                    cli = -1;\n  \t\t                }\n  \t\t                ii += 1;\n  \t\t                cli += 1;\n  \t\t                count += 1;\n  \t\t            }\n  \t\t            this.index = ii;\n  \t\t            this.characterInLineIndex = cli;\n  \t\t            this.lineIndex = li;\n  \t\t            const lastCharIndex = this.index;\n  \t\t            if (lastCharIndex > startIndex) {\n  \t\t                return this._chars.slice(startIndex, this.index).join(\"\");\n  \t\t            }\n  \t\t            return null;\n  \t\t        };\n  \t\t        this.Peek = (rule) => {\n  \t\t            const ruleId = this.BeginRule();\n  \t\t            const result = rule();\n  \t\t            this.CancelRule(ruleId);\n  \t\t            return result;\n  \t\t        };\n  \t\t        // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  \t\t        this.ParseInt = () => {\n  \t\t            const oldIndex = this.index;\n  \t\t            const oldCharacterInLineIndex = this.characterInLineIndex;\n  \t\t            const negative = this.ParseString(\"-\") !== null;\n  \t\t            // Optional whitespace\n  \t\t            this.ParseCharactersFromString(\" \\t\");\n  \t\t            const parsedString = this.ParseCharactersFromCharSet(StringParser.numbersCharacterSet);\n  \t\t            if (parsedString === null) {\n  \t\t                // Roll back and fail\n  \t\t                this.index = oldIndex;\n  \t\t                this.characterInLineIndex = oldCharacterInLineIndex;\n  \t\t                return null;\n  \t\t            }\n  \t\t            let parsedInt;\n  \t\t            if (!Number.isNaN(Number(parsedString))) {\n  \t\t                parsedInt = Number(parsedString);\n  \t\t                return negative ? -parsedInt : parsedInt;\n  \t\t            }\n  \t\t            this.Error(\"Failed to read integer value: \" +\n  \t\t                parsedString +\n  \t\t                \". Perhaps it's out of the range of acceptable numbers ink supports? (\" +\n  \t\t                Number.MIN_SAFE_INTEGER +\n  \t\t                \" to \" +\n  \t\t                Number.MAX_SAFE_INTEGER +\n  \t\t                \")\");\n  \t\t            return null;\n  \t\t        };\n  \t\t        // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  \t\t        this.ParseFloat = () => {\n  \t\t            const oldIndex = this.index;\n  \t\t            const oldCharacterInLineIndex = this.characterInLineIndex;\n  \t\t            const leadingInt = this.ParseInt();\n  \t\t            if (leadingInt !== null) {\n  \t\t                if (this.ParseString(\".\") !== null) {\n  \t\t                    const afterDecimalPointStr = this.ParseCharactersFromCharSet(StringParser.numbersCharacterSet);\n  \t\t                    return Number(`${leadingInt}.${afterDecimalPointStr}`);\n  \t\t                }\n  \t\t            }\n  \t\t            // Roll back and fail\n  \t\t            this.index = oldIndex;\n  \t\t            this.characterInLineIndex = oldCharacterInLineIndex;\n  \t\t            return null;\n  \t\t        };\n  \t\t        this.ParseNewline = () => {\n  \t\t            const ruleId = this.BeginRule();\n  \t\t            // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n  \t\t            // 2nd May 2016: Always collapse \\r\\n to just \\n\n  \t\t            this.ParseString(\"\\r\");\n  \t\t            if (this.ParseString(\"\\n\") === null) {\n  \t\t                return this.FailRule(ruleId);\n  \t\t            }\n  \t\t            return this.SucceedRule(ruleId, \"\\n\");\n  \t\t        };\n  \t\t        const strPreProc = this.PreProcessInputString(str);\n  \t\t        this.state = new StringParserState_1.StringParserState();\n  \t\t        if (str) {\n  \t\t            this._chars = strPreProc.split(\"\");\n  \t\t        }\n  \t\t        else {\n  \t\t            this._chars = [];\n  \t\t        }\n  \t\t        this.inputString = strPreProc;\n  \t\t    }\n  \t\t    get currentCharacter() {\n  \t\t        if (this.index >= 0 && this.remainingLength > 0) {\n  \t\t            return this._chars[this.index];\n  \t\t        }\n  \t\t        return \"0\";\n  \t\t    }\n  \t\t    // Don't do anything by default, but provide ability for subclasses\n  \t\t    // to manipulate the string before it's used as input (converted to a char array)\n  \t\t    PreProcessInputString(str) {\n  \t\t        return str;\n  \t\t    }\n  \t\t    get endOfInput() {\n  \t\t        return this.index >= this._chars.length;\n  \t\t    }\n  \t\t    get remainingString() {\n  \t\t        return this._chars\n  \t\t            .slice(this.index, this.index + this.remainingLength)\n  \t\t            .join(\"\");\n  \t\t    }\n  \t\t    get remainingLength() {\n  \t\t        return this._chars.length - this.index;\n  \t\t    }\n  \t\t    get lineIndex() {\n  \t\t        return this.state.lineIndex;\n  \t\t    }\n  \t\t    set lineIndex(value) {\n  \t\t        this.state.lineIndex = value;\n  \t\t    }\n  \t\t    set characterInLineIndex(value) {\n  \t\t        this.state.characterInLineIndex = value;\n  \t\t    }\n  \t\t    get characterInLineIndex() {\n  \t\t        return this.state.characterInLineIndex;\n  \t\t    }\n  \t\t    get index() {\n  \t\t        // If we want subclass parsers to be able to set the index directly,\n  \t\t        // then we would need to know what the lineIndex of the new\n  \t\t        // index would be - would we have to step through manually\n  \t\t        // counting the newlines to do so?\n  \t\t        return this.state.characterIndex;\n  \t\t    }\n  \t\t    set index(value) {\n  \t\t        this.state.characterIndex = value;\n  \t\t    }\n  \t\t    ParseUntil(stopRule, pauseCharacters = null, endCharacters = null) {\n  \t\t        const ruleId = this.BeginRule();\n  \t\t        const pauseAndEnd = new CharacterSet_1.CharacterSet();\n  \t\t        if (pauseCharacters !== null) {\n  \t\t            pauseAndEnd.set = new Set([\n  \t\t                ...pauseAndEnd.set.values(),\n  \t\t                ...pauseCharacters.set.values(),\n  \t\t            ]);\n  \t\t        }\n  \t\t        if (endCharacters !== null) {\n  \t\t            pauseAndEnd.set = new Set([\n  \t\t                ...pauseAndEnd.set.values(),\n  \t\t                ...endCharacters.set.values(),\n  \t\t            ]);\n  \t\t        }\n  \t\t        let parsedString = \"\";\n  \t\t        let ruleResultAtPause = null;\n  \t\t        // Keep attempting to parse strings up to the pause (and end) points.\n  \t\t        //  - At each of the pause points, attempt to parse according to the rule\n  \t\t        //  - When the end point is reached (or EOF), we're done\n  \t\t        do {\n  \t\t            // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?\n  \t\t            const partialParsedString = this.ParseUntilCharactersFromCharSet(pauseAndEnd);\n  \t\t            if (partialParsedString) {\n  \t\t                parsedString += partialParsedString;\n  \t\t            }\n  \t\t            // Attempt to run the parse rule at this pause point\n  \t\t            ruleResultAtPause = this.Peek(stopRule);\n  \t\t            // Rule completed - we're done\n  \t\t            if (ruleResultAtPause !== null) {\n  \t\t                break;\n  \t\t            }\n  \t\t            else {\n  \t\t                if (this.endOfInput) {\n  \t\t                    break;\n  \t\t                }\n  \t\t                // Reached a pause point, but rule failed. Step past and continue parsing string\n  \t\t                const pauseCharacter = this.currentCharacter;\n  \t\t                if (pauseCharacters !== null &&\n  \t\t                    pauseCharacters.set.has(pauseCharacter)) {\n  \t\t                    parsedString += pauseCharacter;\n  \t\t                    if (pauseCharacter === \"\\n\") {\n  \t\t                        this.lineIndex += 1;\n  \t\t                        this.characterInLineIndex = -1;\n  \t\t                    }\n  \t\t                    this.index += 1;\n  \t\t                    this.characterInLineIndex += 1;\n  \t\t                    continue;\n  \t\t                }\n  \t\t                else {\n  \t\t                    break;\n  \t\t                }\n  \t\t            }\n  \t\t        } while (true);\n  \t\t        if (parsedString.length > 0) {\n  \t\t            return this.SucceedRule(ruleId, String(parsedString));\n  \t\t        }\n  \t\t        return this.FailRule(ruleId);\n  \t\t    }\n  \t\t}\n  \t\texports.StringParser = StringParser;\n  \t\tStringParser.ParseSuccess = exports.ParseSuccess;\n  \t\tStringParser.numbersCharacterSet = new CharacterSet_1.CharacterSet(\"0123456789\");\n  \t\t\n  \t} (StringParser));\n  \treturn StringParser;\n  }\n\n  var hasRequiredCommentEliminator;\n\n  function requireCommentEliminator () {\n  \tif (hasRequiredCommentEliminator) return CommentEliminator;\n  \thasRequiredCommentEliminator = 1;\n  \tObject.defineProperty(CommentEliminator, \"__esModule\", { value: true });\n  \tCommentEliminator.CommentEliminator = void 0;\n  \tconst CharacterSet_1 = requireCharacterSet();\n  \tconst StringParser_1 = requireStringParser();\n  \t/// <summary>\n  \t/// Pre-pass before main ink parser runs. It actually performs two main tasks:\n  \t///  - comment elimination to simplify the parse rules in the main parser\n  \t///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so\n  \t///    we don't have to worry about them later.\n  \t/// </summary>\n  \tlet CommentEliminator$1 = class CommentEliminator extends StringParser_1.StringParser {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this._commentOrNewlineStartCharacter = new CharacterSet_1.CharacterSet(\"/\\r\\n\");\n  \t        this._commentBlockEndCharacter = new CharacterSet_1.CharacterSet(\"*\");\n  \t        this._newlineCharacters = new CharacterSet_1.CharacterSet(\"\\n\\r\");\n  \t        this.Process = () => {\n  \t            // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)\n  \t            const stringList = this.Interleave(this.Optional(this.CommentsAndNewlines), this.Optional(this.MainInk));\n  \t            if (stringList !== null) {\n  \t                return stringList.join(\"\");\n  \t            }\n  \t            else {\n  \t                return \"\";\n  \t            }\n  \t        };\n  \t        this.MainInk = () => this.ParseUntil(this.CommentsAndNewlines, this._commentOrNewlineStartCharacter, null);\n  \t        this.CommentsAndNewlines = () => {\n  \t            let newLines = this.Interleave(this.Optional(this.ParseNewline), this.Optional(this.ParseSingleComment));\n  \t            if (newLines !== null) {\n  \t                return newLines.join(\"\");\n  \t            }\n  \t            return null;\n  \t        };\n  \t        // Valid comments always return either an empty string or pure newlines,\n  \t        // which we want to keep so that line numbers stay the same\n  \t        this.ParseSingleComment = () => this.OneOf([this.EndOfLineComment, this.BlockComment]);\n  \t        this.EndOfLineComment = () => {\n  \t            if (this.ParseString(\"//\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.ParseUntilCharactersFromCharSet(this._newlineCharacters);\n  \t            return \"\";\n  \t        };\n  \t        this.BlockComment = () => {\n  \t            if (this.ParseString(\"/*\") === null) {\n  \t                return null;\n  \t            }\n  \t            const startLineIndex = this.lineIndex;\n  \t            const commentResult = this.ParseUntil(this.String(\"*/\"), this._commentBlockEndCharacter, null);\n  \t            if (!this.endOfInput) {\n  \t                this.ParseString(\"*/\");\n  \t            }\n  \t            // Count the number of lines that were inside the block, and replicate them as newlines\n  \t            // so that the line indexing still works from the original source\n  \t            if (commentResult != null) {\n  \t                return \"\\n\".repeat(this.lineIndex - startLineIndex);\n  \t            }\n  \t            // No comment at all\n  \t            return null;\n  \t        };\n  \t    }\n  \t    PreProcessInputString(str) {\n  \t        return str;\n  \t    }\n  \t};\n  \tCommentEliminator.CommentEliminator = CommentEliminator$1;\n  \t\n  \treturn CommentEliminator;\n  }\n\n  var Conditional = {};\n\n  var hasRequiredConditional;\n\n  function requireConditional () {\n  \tif (hasRequiredConditional) return Conditional;\n  \thasRequiredConditional = 1;\n  \tObject.defineProperty(Conditional, \"__esModule\", { value: true });\n  \tConditional.Conditional = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Object_1 = require_Object();\n  \tlet Conditional$1 = class Conditional extends Object_1.ParsedObject {\n  \t    constructor(initialCondition, branches) {\n  \t        super();\n  \t        this.initialCondition = initialCondition;\n  \t        this.branches = branches;\n  \t        this._reJoinTarget = null;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            // Initial condition\n  \t            if (this.initialCondition) {\n  \t                container.AddContent(this.initialCondition.runtimeObject);\n  \t            }\n  \t            // Individual branches\n  \t            for (const branch of this.branches) {\n  \t                const branchContainer = branch.runtimeObject;\n  \t                container.AddContent(branchContainer);\n  \t            }\n  \t            // If it's a switch-like conditional, each branch\n  \t            // will have a \"duplicate\" operation for the original\n  \t            // switched value. If there's no final else clause\n  \t            // and we fall all the way through, we need to clean up.\n  \t            // (An else clause doesn't dup but it *does* pop)\n  \t            if (this.initialCondition !== null &&\n  \t                this.branches[0].ownExpression !== null &&\n  \t                !this.branches[this.branches.length - 1].isElse) {\n  \t                container.AddContent(ControlCommand_1.ControlCommand.PopEvaluatedValue());\n  \t            }\n  \t            // Target for branches to rejoin to\n  \t            this._reJoinTarget = ControlCommand_1.ControlCommand.NoOp();\n  \t            container.AddContent(this._reJoinTarget);\n  \t            return container;\n  \t        };\n  \t        if (this.initialCondition) {\n  \t            this.AddContent(this.initialCondition);\n  \t        }\n  \t        if (this.branches !== null) {\n  \t            this.AddContent(this.branches);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"Conditional\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        const pathToReJoin = this._reJoinTarget.path;\n  \t        for (const branch of this.branches) {\n  \t            if (!branch.returnDivert) {\n  \t                throw new Error();\n  \t            }\n  \t            branch.returnDivert.targetPath = pathToReJoin;\n  \t        }\n  \t        super.ResolveReferences(context);\n  \t    }\n  \t};\n  \tConditional.Conditional = Conditional$1;\n  \t\n  \treturn Conditional;\n  }\n\n  var ConditionalSingleBranch = {};\n\n  var Text = {};\n\n  var hasRequiredText;\n\n  function requireText () {\n  \tif (hasRequiredText) return Text;\n  \thasRequiredText = 1;\n  \tObject.defineProperty(Text, \"__esModule\", { value: true });\n  \tText.Text = void 0;\n  \tconst Object_1 = require_Object();\n  \tconst Value_1 = requireValue();\n  \tlet Text$1 = class Text extends Object_1.ParsedObject {\n  \t    constructor(text) {\n  \t        super();\n  \t        this.text = text;\n  \t        this.GenerateRuntimeObject = () => new Value_1.StringValue(this.text);\n  \t        this.toString = () => this.text;\n  \t    }\n  \t    get typeName() {\n  \t        return \"Text\";\n  \t    }\n  \t};\n  \tText.Text = Text$1;\n  \t\n  \treturn Text;\n  }\n\n  var Weave = {};\n\n  var ConstantDeclaration = {};\n\n  var hasRequiredConstantDeclaration;\n\n  function requireConstantDeclaration () {\n  \tif (hasRequiredConstantDeclaration) return ConstantDeclaration;\n  \thasRequiredConstantDeclaration = 1;\n  \tObject.defineProperty(ConstantDeclaration, \"__esModule\", { value: true });\n  \tConstantDeclaration.ConstantDeclaration = void 0;\n  \tconst Object_1 = require_Object();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tlet ConstantDeclaration$1 = class ConstantDeclaration extends Object_1.ParsedObject {\n  \t    get constantName() {\n  \t        var _a;\n  \t        return (_a = this.constantIdentifier) === null || _a === void 0 ? void 0 : _a.name;\n  \t    }\n  \t    get expression() {\n  \t        if (!this._expression) {\n  \t            throw new Error();\n  \t        }\n  \t        return this._expression;\n  \t    }\n  \t    constructor(name, assignedExpression) {\n  \t        super();\n  \t        this._expression = null;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            // Global declarations don't generate actual procedural\n  \t            // runtime objects, but instead add a global variable to the story itself.\n  \t            // The story then initialises them all in one go at the start of the game.\n  \t            return null;\n  \t        };\n  \t        this.constantIdentifier = name;\n  \t        // Defensive programming in case parsing of assignedExpression failed\n  \t        if (assignedExpression) {\n  \t            this._expression = this.AddContent(assignedExpression);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"CONST\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        context.CheckForNamingCollisions(this, this.constantIdentifier, SymbolType_1.SymbolType.Var);\n  \t    }\n  \t};\n  \tConstantDeclaration.ConstantDeclaration = ConstantDeclaration$1;\n  \t\n  \treturn ConstantDeclaration;\n  }\n\n  var Divert = {};\n\n  var DivertTarget = {};\n\n  var FlowBase = {};\n\n  var FlowLevel = {};\n\n  var hasRequiredFlowLevel;\n\n  function requireFlowLevel () {\n  \tif (hasRequiredFlowLevel) return FlowLevel;\n  \thasRequiredFlowLevel = 1;\n  \tObject.defineProperty(FlowLevel, \"__esModule\", { value: true });\n  \tFlowLevel.FlowLevel = void 0;\n  \tvar FlowLevel$1;\n  \t(function (FlowLevel) {\n  \t    FlowLevel[FlowLevel[\"Story\"] = 0] = \"Story\";\n  \t    FlowLevel[FlowLevel[\"Knot\"] = 1] = \"Knot\";\n  \t    FlowLevel[FlowLevel[\"Stitch\"] = 2] = \"Stitch\";\n  \t    // not actually a FlowBase, but used for diverts\n  \t    FlowLevel[FlowLevel[\"WeavePoint\"] = 3] = \"WeavePoint\";\n  \t})(FlowLevel$1 || (FlowLevel.FlowLevel = FlowLevel$1 = {}));\n  \t\n  \treturn FlowLevel;\n  }\n\n  var Gather = {};\n\n  var hasRequiredGather;\n\n  function requireGather () {\n  \tif (hasRequiredGather) return Gather;\n  \thasRequiredGather = 1;\n  \tObject.defineProperty(Gather, \"__esModule\", { value: true });\n  \tGather.Gather = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst Object_1 = require_Object();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tlet Gather$1 = class Gather extends Object_1.ParsedObject {\n  \t    get name() {\n  \t        var _a;\n  \t        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n  \t    }\n  \t    get runtimeContainer() {\n  \t        return this.runtimeObject;\n  \t    }\n  \t    constructor(identifier, indentationDepth) {\n  \t        super();\n  \t        this.indentationDepth = indentationDepth;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            container.name = this.name;\n  \t            if (this.story.countAllVisits) {\n  \t                container.visitsShouldBeCounted = true;\n  \t            }\n  \t            container.countingAtStartOnly = true;\n  \t            // A gather can have null content, e.g. it's just purely a line with \"-\"\n  \t            if (this.content) {\n  \t                for (const c of this.content) {\n  \t                    container.AddContent(c.runtimeObject);\n  \t                }\n  \t            }\n  \t            return container;\n  \t        };\n  \t        this.toString = () => { var _a, _b; return `- ${((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) ? \"(\" + ((_b = this.identifier) === null || _b === void 0 ? void 0 : _b.name) + \")\" : \"gather\"}`; };\n  \t        if (identifier)\n  \t            this.identifier = identifier;\n  \t    }\n  \t    get typeName() {\n  \t        return \"Gather\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        if (this.identifier && (this.identifier.name || \"\").length > 0) {\n  \t            context.CheckForNamingCollisions(this, this.identifier, SymbolType_1.SymbolType.SubFlowAndWeave);\n  \t        }\n  \t    }\n  \t};\n  \tGather.Gather = Gather$1;\n  \t\n  \treturn Gather;\n  }\n\n  var Path = {};\n\n  var hasRequiredPath;\n\n  function requirePath () {\n  \tif (hasRequiredPath) return Path;\n  \thasRequiredPath = 1;\n  \tObject.defineProperty(Path, \"__esModule\", { value: true });\n  \tPath.Path = void 0;\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst FlowLevel_1 = requireFlowLevel();\n  \tconst Weave_1 = requireWeave();\n  \tlet Path$1 = class Path {\n  \t    get baseTargetLevel() {\n  \t        if (this.baseLevelIsAmbiguous) {\n  \t            return FlowLevel_1.FlowLevel.Story;\n  \t        }\n  \t        return this._baseTargetLevel;\n  \t    }\n  \t    get baseLevelIsAmbiguous() {\n  \t        return !this._baseTargetLevel;\n  \t    }\n  \t    get firstComponent() {\n  \t        if (this.components == null || !this.components.length) {\n  \t            return null;\n  \t        }\n  \t        return this.components[0].name;\n  \t    }\n  \t    get numberOfComponents() {\n  \t        return this.components ? this.components.length : 0;\n  \t    }\n  \t    get dotSeparatedComponents() {\n  \t        if (this._dotSeparatedComponents == null) {\n  \t            this._dotSeparatedComponents = (this.components ? this.components : [])\n  \t                .map((c) => c.name)\n  \t                .filter(TypeAssertion_1.filterUndef)\n  \t                .join(\".\");\n  \t        }\n  \t        return this._dotSeparatedComponents;\n  \t    }\n  \t    constructor(argOne, argTwo) {\n  \t        this._dotSeparatedComponents = null;\n  \t        this.toString = () => {\n  \t            if (this.components === null || this.components.length === 0) {\n  \t                if (this.baseTargetLevel === FlowLevel_1.FlowLevel.WeavePoint) {\n  \t                    return \"-> <next gather point>\";\n  \t                }\n  \t                return \"<invalid Path>\";\n  \t            }\n  \t            return `-> ${this.dotSeparatedComponents}`;\n  \t        };\n  \t        this.ResolveFromContext = (context) => {\n  \t            if (this.components == null || this.components.length == 0) {\n  \t                return null;\n  \t            }\n  \t            // Find base target of path from current context. e.g.\n  \t            //   ==> BASE.sub.sub\n  \t            let baseTargetObject = this.ResolveBaseTarget(context);\n  \t            if (baseTargetObject === null) {\n  \t                return null;\n  \t            }\n  \t            // Given base of path, resolve final target by working deeper into hierarchy\n  \t            //  e.g. ==> base.mid.FINAL\n  \t            if (this.components.length > 1) {\n  \t                return this.ResolveTailComponents(baseTargetObject);\n  \t            }\n  \t            return baseTargetObject;\n  \t        };\n  \t        // Find the root object from the base, i.e. root from:\n  \t        //    root.sub1.sub2\n  \t        this.ResolveBaseTarget = (originalContext) => {\n  \t            const firstComp = this.firstComponent;\n  \t            // Work up the ancestry to find the node that has the named object\n  \t            let ancestorContext = originalContext;\n  \t            while (ancestorContext) {\n  \t                // Only allow deep search when searching deeper from original context.\n  \t                // Don't allow search upward *then* downward, since that's searching *everywhere*!\n  \t                // Allowed examples:\n  \t                //  - From an inner gather of a stitch, you should search up to find a knot called 'x'\n  \t                //    at the root of a story, but not a stitch called 'x' in that knot.\n  \t                //  - However, from within a knot, you should be able to find a gather/choice\n  \t                //    anywhere called 'x'\n  \t                // (that latter example is quite loose, but we allow it)\n  \t                const deepSearch = ancestorContext === originalContext;\n  \t                const foundBase = this.GetChildFromContext(ancestorContext, firstComp, null, deepSearch);\n  \t                if (foundBase) {\n  \t                    return foundBase;\n  \t                }\n  \t                ancestorContext = ancestorContext.parent;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        // Find the final child from path given root, i.e.:\n  \t        //   root.sub.finalChild\n  \t        this.ResolveTailComponents = (rootTarget) => {\n  \t            let foundComponent = rootTarget;\n  \t            if (!this.components)\n  \t                return null;\n  \t            for (let ii = 1; ii < this.components.length; ++ii) {\n  \t                const compName = this.components[ii].name;\n  \t                let minimumExpectedLevel;\n  \t                let foundFlow = (0, TypeAssertion_1.asOrNull)(foundComponent, FlowBase_1.FlowBase);\n  \t                if (foundFlow !== null) {\n  \t                    minimumExpectedLevel = (foundFlow.flowLevel + 1);\n  \t                }\n  \t                else {\n  \t                    minimumExpectedLevel = FlowLevel_1.FlowLevel.WeavePoint;\n  \t                }\n  \t                foundComponent = this.GetChildFromContext(foundComponent, compName, minimumExpectedLevel);\n  \t                if (foundComponent === null) {\n  \t                    break;\n  \t                }\n  \t            }\n  \t            return foundComponent;\n  \t        };\n  \t        // See whether \"context\" contains a child with a given name at a given flow level\n  \t        // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)\n  \t        // This function also ignores any other object types that are neither FlowBase nor Weave.\n  \t        // Called from both ResolveBase (force deep) and ResolveTail for the individual components.\n  \t        this.GetChildFromContext = (context, childName, minimumLevel, forceDeepSearch = false) => {\n  \t            // null childLevel means that we don't know where to find it\n  \t            const ambiguousChildLevel = minimumLevel === null;\n  \t            // Search for WeavePoint within Weave\n  \t            const weaveContext = (0, TypeAssertion_1.asOrNull)(context, Weave_1.Weave);\n  \t            if (childName &&\n  \t                weaveContext !== null &&\n  \t                (ambiguousChildLevel || minimumLevel === FlowLevel_1.FlowLevel.WeavePoint)) {\n  \t                return weaveContext.WeavePointNamed(childName);\n  \t            }\n  \t            // Search for content within Flow (either a sub-Flow or a WeavePoint)\n  \t            let flowContext = (0, TypeAssertion_1.asOrNull)(context, FlowBase_1.FlowBase);\n  \t            if (childName && flowContext !== null) {\n  \t                // When searching within a Knot, allow a deep searches so that\n  \t                // named weave points (choices and gathers) can be found within any stitch\n  \t                // Otherwise, we just search within the immediate object.\n  \t                const shouldDeepSearch = forceDeepSearch || flowContext.flowLevel === FlowLevel_1.FlowLevel.Knot;\n  \t                return flowContext.ContentWithNameAtLevel(childName, minimumLevel, shouldDeepSearch);\n  \t            }\n  \t            return null;\n  \t        };\n  \t        if (Object.values(FlowLevel_1.FlowLevel).includes(argOne)) {\n  \t            this._baseTargetLevel = argOne;\n  \t            this.components = argTwo || [];\n  \t        }\n  \t        else if (Array.isArray(argOne)) {\n  \t            this._baseTargetLevel = null;\n  \t            this.components = argOne || [];\n  \t        }\n  \t        else {\n  \t            this._baseTargetLevel = null;\n  \t            this.components = [argOne];\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"Path\";\n  \t    }\n  \t};\n  \tPath.Path = Path$1;\n  \t\n  \treturn Path;\n  }\n\n  var ReturnType = {};\n\n  var hasRequiredReturnType;\n\n  function requireReturnType () {\n  \tif (hasRequiredReturnType) return ReturnType;\n  \thasRequiredReturnType = 1;\n  \tObject.defineProperty(ReturnType, \"__esModule\", { value: true });\n  \tReturnType.ReturnType = void 0;\n  \tconst Object_1 = require_Object();\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Void_1 = requireVoid();\n  \tlet ReturnType$1 = class ReturnType extends Object_1.ParsedObject {\n  \t    constructor(returnedExpression = null) {\n  \t        super();\n  \t        this.returnedExpression = null;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            if (this.returnedExpression) {\n  \t                // Evaluate expression\n  \t                container.AddContent(this.returnedExpression.runtimeObject);\n  \t            }\n  \t            else {\n  \t                // Return Runtime.Void when there's no expression to evaluate\n  \t                // (This evaluation will just add the Void object to the evaluation stack)\n  \t                container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t                container.AddContent(new Void_1.Void());\n  \t                container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t            }\n  \t            // Then pop the call stack\n  \t            // (the evaluated expression will leave the return value on the evaluation stack)\n  \t            container.AddContent(ControlCommand_1.ControlCommand.PopFunction());\n  \t            return container;\n  \t        };\n  \t        if (returnedExpression) {\n  \t            this.returnedExpression = this.AddContent(returnedExpression);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"ReturnType\";\n  \t    }\n  \t};\n  \tReturnType.ReturnType = ReturnType$1;\n  \t\n  \treturn ReturnType;\n  }\n\n  var ClosestFlowBase = {};\n\n  var hasRequiredClosestFlowBase;\n\n  function requireClosestFlowBase () {\n  \tif (hasRequiredClosestFlowBase) return ClosestFlowBase;\n  \thasRequiredClosestFlowBase = 1;\n  \t// import { FlowBase } from './FlowBase';\n  \tObject.defineProperty(ClosestFlowBase, \"__esModule\", { value: true });\n  \tClosestFlowBase.ClosestFlowBase = void 0;\n  \tfunction ClosestFlowBase$1(obj) {\n  \t    let ancestor = obj.parent;\n  \t    while (ancestor) {\n  \t        if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {\n  \t            return ancestor;\n  \t        }\n  \t        ancestor = ancestor.parent;\n  \t    }\n  \t    return null;\n  \t}\n  \tClosestFlowBase.ClosestFlowBase = ClosestFlowBase$1;\n  \t\n  \treturn ClosestFlowBase;\n  }\n\n  var Identifier = {};\n\n  var hasRequiredIdentifier;\n\n  function requireIdentifier () {\n  \tif (hasRequiredIdentifier) return Identifier;\n  \thasRequiredIdentifier = 1;\n  \tObject.defineProperty(Identifier, \"__esModule\", { value: true });\n  \tIdentifier.Identifier = void 0;\n  \tlet Identifier$1 = class Identifier {\n  \t    constructor(name) {\n  \t        this.debugMetadata = null;\n  \t        this.toString = () => this.name || \"undefined identifer\";\n  \t        this.name = name;\n  \t    }\n  \t    get typeName() {\n  \t        return \"Identifier\";\n  \t    }\n  \t    static Done() {\n  \t        return new Identifier(\"DONE\");\n  \t    }\n  \t};\n  \tIdentifier.Identifier = Identifier$1;\n  \t\n  \treturn Identifier;\n  }\n\n  var hasRequiredFlowBase;\n\n  function requireFlowBase () {\n  \tif (hasRequiredFlowBase) return FlowBase;\n  \thasRequiredFlowBase = 1;\n  \tObject.defineProperty(FlowBase, \"__esModule\", { value: true });\n  \tFlowBase.FlowBase = void 0;\n  \tconst Choice_1 = requireChoice();\n  \tconst Divert_1 = requireDivert();\n  \tconst DivertTarget_1 = requireDivertTarget();\n  \tconst FlowLevel_1 = requireFlowLevel();\n  \tconst Gather_1 = requireGather();\n  \t// import { Knot } from '../Knot';\n  \tconst Object_1 = require_Object();\n  \tconst Path_1 = requirePath();\n  \tconst ReturnType_1 = requireReturnType();\n  \tconst Container_1 = requireContainer();\n  \tconst Divert_2 = requireDivert$1();\n  \tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \t//import { Story } from '../Story';\n  \tconst SymbolType_1 = requireSymbolType();\n  \tconst Weave_1 = requireWeave();\n  \tconst ClosestFlowBase_1 = requireClosestFlowBase();\n  \tconst Identifier_1 = requireIdentifier();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \t// Base class for Knots and Stitches\n  \tlet FlowBase$1 = class FlowBase extends Object_1.ParsedObject {\n  \t    get hasParameters() {\n  \t        return this.args !== null && this.args.length > 0;\n  \t    }\n  \t    get subFlowsByName() {\n  \t        return this._subFlowsByName;\n  \t    }\n  \t    get typeName() {\n  \t        if (this.isFunction) {\n  \t            return \"Function\";\n  \t        }\n  \t        return String(this.flowLevel);\n  \t    }\n  \t    get name() {\n  \t        var _a;\n  \t        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n  \t    }\n  \t    constructor(identifier, topLevelObjects = null, args = null, isFunction = false, isIncludedStory = false) {\n  \t        super();\n  \t        this.isFunction = isFunction;\n  \t        this._rootWeave = null;\n  \t        this._subFlowsByName = new Map();\n  \t        this._startingSubFlowDivert = null;\n  \t        this._startingSubFlowRuntime = null;\n  \t        this._firstChildFlow = null;\n  \t        this.variableDeclarations = new Map();\n  \t        this.identifier = null;\n  \t        this.args = null;\n  \t        this.iamFlowbase = () => true;\n  \t        this.SplitWeaveAndSubFlowContent = (contentObjs, isRootStory) => {\n  \t            var _a, _b;\n  \t            const weaveObjs = [];\n  \t            const subFlowObjs = [];\n  \t            this._subFlowsByName = new Map();\n  \t            for (const obj of contentObjs) {\n  \t                const subFlow = (0, TypeAssertion_1.asOrNull)(obj, FlowBase);\n  \t                if (subFlow) {\n  \t                    if (this._firstChildFlow === null) {\n  \t                        this._firstChildFlow = subFlow;\n  \t                    }\n  \t                    subFlowObjs.push(obj);\n  \t                    if ((_a = subFlow.identifier) === null || _a === void 0 ? void 0 : _a.name) {\n  \t                        this._subFlowsByName.set((_b = subFlow.identifier) === null || _b === void 0 ? void 0 : _b.name, subFlow);\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    weaveObjs.push(obj);\n  \t                }\n  \t            }\n  \t            // Implicit final gather in top level story for ending without warning that you run out of content\n  \t            if (isRootStory) {\n  \t                weaveObjs.push(new Gather_1.Gather(null, 1), new Divert_1.Divert(new Path_1.Path(Identifier_1.Identifier.Done())));\n  \t            }\n  \t            const finalContent = [];\n  \t            if (weaveObjs.length > 0) {\n  \t                this._rootWeave = new Weave_1.Weave(weaveObjs, 0);\n  \t                finalContent.push(this._rootWeave);\n  \t            }\n  \t            if (subFlowObjs.length > 0) {\n  \t                finalContent.push(...subFlowObjs);\n  \t            }\n  \t            return finalContent;\n  \t        };\n  \t        this.ResolveVariableWithName = (varName, fromNode) => {\n  \t            var _a;\n  \t            const result = {};\n  \t            // Search in the stitch / knot that owns the node first\n  \t            const ownerFlow = fromNode === null ? this : (0, ClosestFlowBase_1.ClosestFlowBase)(fromNode);\n  \t            if (ownerFlow) {\n  \t                // Argument\n  \t                if (ownerFlow.args !== null) {\n  \t                    for (const arg of ownerFlow.args) {\n  \t                        if (((_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name) === varName) {\n  \t                            result.found = true;\n  \t                            result.isArgument = true;\n  \t                            result.ownerFlow = ownerFlow;\n  \t                            return result;\n  \t                        }\n  \t                    }\n  \t                }\n  \t                // Temp\n  \t                if (ownerFlow !== this.story &&\n  \t                    ownerFlow.variableDeclarations.has(varName)) {\n  \t                    result.found = true;\n  \t                    result.ownerFlow = ownerFlow;\n  \t                    result.isTemporary = true;\n  \t                    return result;\n  \t                }\n  \t            }\n  \t            // Global\n  \t            if (this.story.variableDeclarations.has(varName)) {\n  \t                result.found = true;\n  \t                result.ownerFlow = this.story;\n  \t                result.isGlobal = true;\n  \t                return result;\n  \t            }\n  \t            result.found = false;\n  \t            return result;\n  \t        };\n  \t        this.AddNewVariableDeclaration = (varDecl) => {\n  \t            const varName = varDecl.variableName;\n  \t            if (this.variableDeclarations.has(varName)) {\n  \t                const varab = this.variableDeclarations.get(varName);\n  \t                let prevDeclError = \"\";\n  \t                const debugMetadata = varab.debugMetadata;\n  \t                if (debugMetadata) {\n  \t                    prevDeclError = ` (${varab.debugMetadata})`;\n  \t                }\n  \t                this.Error(`found declaration variable '${varName}' that was already declared${prevDeclError}`, varDecl, false);\n  \t                return;\n  \t            }\n  \t            this.variableDeclarations.set(varDecl.variableName, varDecl);\n  \t        };\n  \t        this.ResolveWeavePointNaming = () => {\n  \t            // Find all weave points and organise them by name ready for\n  \t            // diverting. Also detect naming collisions.\n  \t            if (this._rootWeave) {\n  \t                this._rootWeave.ResolveWeavePointNaming();\n  \t            }\n  \t            for (const [, value] of this._subFlowsByName) {\n  \t                if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {\n  \t                    value.ResolveWeavePointNaming();\n  \t                }\n  \t            }\n  \t        };\n  \t        this.GenerateRuntimeObject = () => {\n  \t            var _a;\n  \t            let foundReturn = null;\n  \t            if (this.isFunction) {\n  \t                this.CheckForDisallowedFunctionFlowControl();\n  \t            }\n  \t            else if (this.flowLevel === FlowLevel_1.FlowLevel.Knot ||\n  \t                this.flowLevel === FlowLevel_1.FlowLevel.Stitch) {\n  \t                // Non-functon: Make sure knots and stitches don't attempt to use Return statement\n  \t                foundReturn = this.Find(ReturnType_1.ReturnType)();\n  \t                if (foundReturn !== null) {\n  \t                    this.Error(`Return statements can only be used in knots that are declared as functions: == function ${this.identifier} ==`, foundReturn);\n  \t                }\n  \t            }\n  \t            const container = new Container_1.Container();\n  \t            container.name = (_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name;\n  \t            if (this.story.countAllVisits) {\n  \t                container.visitsShouldBeCounted = true;\n  \t            }\n  \t            this.GenerateArgumentVariableAssignments(container);\n  \t            // Run through content defined for this knot/stitch:\n  \t            //  - First of all, any initial content before a sub-stitch\n  \t            //    or any weave content is added to the main content container\n  \t            //  - The first inner knot/stitch is automatically entered, while\n  \t            //    the others are only accessible by an explicit divert\n  \t            //       - The exception to this rule is if the knot/stitch takes\n  \t            //         parameters, in which case it can't be auto-entered.\n  \t            //  - Any Choices and Gathers (i.e. IWeavePoint) found are\n  \t            //    processsed by GenerateFlowContent.\n  \t            let contentIdx = 0;\n  \t            while (this.content !== null && contentIdx < this.content.length) {\n  \t                const obj = this.content[contentIdx];\n  \t                // Inner knots and stitches\n  \t                if (obj instanceof FlowBase) {\n  \t                    const childFlow = obj;\n  \t                    const childFlowRuntime = childFlow.runtimeObject;\n  \t                    // First inner stitch - automatically step into it\n  \t                    // 20/09/2016 - let's not auto step into knots\n  \t                    if (contentIdx === 0 &&\n  \t                        !childFlow.hasParameters &&\n  \t                        this.flowLevel === FlowLevel_1.FlowLevel.Knot) {\n  \t                        this._startingSubFlowDivert = new Divert_2.Divert();\n  \t                        container.AddContent(this._startingSubFlowDivert);\n  \t                        this._startingSubFlowRuntime = childFlowRuntime;\n  \t                    }\n  \t                    // Check for duplicate knots/stitches with same name\n  \t                    const namedChild = childFlowRuntime;\n  \t                    const existingChild = container.namedContent.get(namedChild.name) || null;\n  \t                    if (existingChild) {\n  \t                        const errorMsg = `${this.GetType()} already contains flow named '${namedChild.name}' (at ${existingChild.debugMetadata})`;\n  \t                        this.Error(errorMsg, childFlow);\n  \t                    }\n  \t                    container.AddToNamedContentOnly(namedChild);\n  \t                }\n  \t                else if (obj) {\n  \t                    // Other content (including entire Weaves that were grouped in the constructor)\n  \t                    // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"\n  \t                    // and it's always the root Weave\n  \t                    container.AddContent(obj.runtimeObject);\n  \t                }\n  \t                contentIdx += 1;\n  \t            }\n  \t            // CHECK FOR FINAL LOOSE ENDS!\n  \t            // Notes:\n  \t            //  - Functions don't need to terminate - they just implicitly return\n  \t            //  - If return statement was found, don't continue finding warnings for missing control flow,\n  \t            // since it's likely that a return statement has been used instead of a ->-> or something,\n  \t            // or the writer failed to mark the knot as a function.\n  \t            //  - _rootWeave may be null if it's a knot that only has stitches\n  \t            if (this.flowLevel !== FlowLevel_1.FlowLevel.Story &&\n  \t                !this.isFunction &&\n  \t                this._rootWeave !== null &&\n  \t                foundReturn === null) {\n  \t                this._rootWeave.ValidateTermination(this.WarningInTermination);\n  \t            }\n  \t            return container;\n  \t        };\n  \t        this.GenerateArgumentVariableAssignments = (container) => {\n  \t            var _a;\n  \t            if (this.args === null || this.args.length === 0) {\n  \t                return;\n  \t            }\n  \t            // Assign parameters in reverse since they'll be popped off the evaluation stack\n  \t            // No need to generate EvalStart and EvalEnd since there's nothing being pushed\n  \t            // back onto the evaluation stack.\n  \t            for (let ii = this.args.length - 1; ii >= 0; --ii) {\n  \t                const paramName = ((_a = this.args[ii].identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n  \t                const assign = new VariableAssignment_1.VariableAssignment(paramName, true);\n  \t                container.AddContent(assign);\n  \t            }\n  \t        };\n  \t        this.ContentWithNameAtLevel = (name, level = null, deepSearch = false) => {\n  \t            var _a;\n  \t            // Referencing self?\n  \t            if (level === this.flowLevel || level === null) {\n  \t                if (name === ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name)) {\n  \t                    return this;\n  \t                }\n  \t            }\n  \t            if (level === FlowLevel_1.FlowLevel.WeavePoint || level === null) {\n  \t                let weavePointResult = null;\n  \t                if (this._rootWeave) {\n  \t                    weavePointResult = this._rootWeave.WeavePointNamed(name);\n  \t                    if (weavePointResult) {\n  \t                        return weavePointResult;\n  \t                    }\n  \t                }\n  \t                // Stop now if we only wanted a result if it's a weave point?\n  \t                if (level === FlowLevel_1.FlowLevel.WeavePoint) {\n  \t                    return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n  \t                }\n  \t            }\n  \t            // If this flow would be incapable of containing the requested level, early out\n  \t            // (e.g. asking for a Knot from a Stitch)\n  \t            if (level !== null && level < this.flowLevel) {\n  \t                return null;\n  \t            }\n  \t            let subFlow = this._subFlowsByName.get(name) || null;\n  \t            if (subFlow && (level === null || level === subFlow.flowLevel)) {\n  \t                return subFlow;\n  \t            }\n  \t            return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n  \t        };\n  \t        this.DeepSearchForAnyLevelContent = (name) => {\n  \t            const weaveResultSelf = this.ContentWithNameAtLevel(name, FlowLevel_1.FlowLevel.WeavePoint, false);\n  \t            if (weaveResultSelf) {\n  \t                return weaveResultSelf;\n  \t            }\n  \t            for (const [, value] of this._subFlowsByName) {\n  \t                const deepResult = value.ContentWithNameAtLevel(name, null, true);\n  \t                if (deepResult) {\n  \t                    return deepResult;\n  \t                }\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.CheckForDisallowedFunctionFlowControl = () => {\n  \t            // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy\n  \t            if (this.flowLevel !== FlowLevel_1.FlowLevel.Knot) {\n  \t                this.Error(\"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\");\n  \t            }\n  \t            // Not allowed sub-flows\n  \t            for (const [key, value] of this._subFlowsByName) {\n  \t                this.Error(`Functions may not contain stitches, but saw '${key}' within the function '${this.identifier}'`, value);\n  \t            }\n  \t            if (!this._rootWeave) {\n  \t                throw new Error();\n  \t            }\n  \t            const allDiverts = this._rootWeave.FindAll(Divert_1.Divert)();\n  \t            for (const divert of allDiverts) {\n  \t                if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget_1.DivertTarget)) {\n  \t                    this.Error(`Functions may not contain diverts, but saw '${divert}'`, divert);\n  \t                }\n  \t            }\n  \t            const allChoices = this._rootWeave.FindAll(Choice_1.Choice)();\n  \t            for (const choice of allChoices) {\n  \t                this.Error(`Functions may not contain choices, but saw '${choice}'`, choice);\n  \t            }\n  \t        };\n  \t        this.WarningInTermination = (terminatingObject) => {\n  \t            let message = \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";\n  \t            if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {\n  \t                message = `${message} Note that if you intend to enter '${this._firstChildFlow.identifier}' next, you need to divert to it explicitly.`;\n  \t            }\n  \t            const terminatingDivert = (0, TypeAssertion_1.asOrNull)(terminatingObject, Divert_1.Divert);\n  \t            if (terminatingDivert && terminatingDivert.isTunnel) {\n  \t                message += ` When final tunnel to '${terminatingDivert.target} ->' returns it won't have anywhere to go.`;\n  \t            }\n  \t            this.Warning(message, terminatingObject);\n  \t        };\n  \t        this.toString = () => `${this.typeName} '${this.identifier}'`;\n  \t        this.identifier = identifier;\n  \t        this.args = args;\n  \t        if (topLevelObjects === null) {\n  \t            topLevelObjects = [];\n  \t        }\n  \t        // Used by story to add includes\n  \t        this.PreProcessTopLevelObjects(topLevelObjects);\n  \t        topLevelObjects = this.SplitWeaveAndSubFlowContent(topLevelObjects, this.GetType() == \"Story\" && !isIncludedStory);\n  \t        this.AddContent(topLevelObjects);\n  \t    }\n  \t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  \t    PreProcessTopLevelObjects(_) {\n  \t        // empty by default, used by Story to process included file references\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        var _a, _b;\n  \t        if (this._startingSubFlowDivert) {\n  \t            if (!this._startingSubFlowRuntime) {\n  \t                throw new Error();\n  \t            }\n  \t            this._startingSubFlowDivert.targetPath =\n  \t                this._startingSubFlowRuntime.path;\n  \t        }\n  \t        super.ResolveReferences(context);\n  \t        // Check validity of parameter names\n  \t        if (this.args !== null) {\n  \t            for (const arg of this.args) {\n  \t                context.CheckForNamingCollisions(this, arg.identifier, SymbolType_1.SymbolType.Arg, \"argument\");\n  \t            }\n  \t            // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,\n  \t            // so have to be checked independently.\n  \t            for (let ii = 0; ii < this.args.length; ii += 1) {\n  \t                for (let jj = ii + 1; jj < this.args.length; jj += 1) {\n  \t                    if (((_a = this.args[ii].identifier) === null || _a === void 0 ? void 0 : _a.name) == ((_b = this.args[jj].identifier) === null || _b === void 0 ? void 0 : _b.name)) {\n  \t                        this.Error(`Multiple arguments with the same name: '${this.args[ii].identifier}'`);\n  \t                    }\n  \t                }\n  \t            }\n  \t        }\n  \t        // Check naming collisions for knots and stitches\n  \t        if (this.flowLevel !== FlowLevel_1.FlowLevel.Story) {\n  \t            // Weave points aren't FlowBases, so this will only be knot or stitch\n  \t            const symbolType = this.flowLevel === FlowLevel_1.FlowLevel.Knot\n  \t                ? SymbolType_1.SymbolType.Knot\n  \t                : SymbolType_1.SymbolType.SubFlowAndWeave;\n  \t            context.CheckForNamingCollisions(this, this.identifier, symbolType);\n  \t        }\n  \t    }\n  \t};\n  \tFlowBase.FlowBase = FlowBase$1;\n  \t\n  \treturn FlowBase;\n  }\n\n  var FunctionCall = {};\n\n  var VariableReference = {};\n\n  var ContentList = {};\n\n  var hasRequiredContentList;\n\n  function requireContentList () {\n  \tif (hasRequiredContentList) return ContentList;\n  \thasRequiredContentList = 1;\n  \tObject.defineProperty(ContentList, \"__esModule\", { value: true });\n  \tContentList.ContentList = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst Object_1 = require_Object();\n  \tconst Text_1 = requireText();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet ContentList$1 = class ContentList extends Object_1.ParsedObject {\n  \t    get runtimeContainer() {\n  \t        return this.runtimeObject;\n  \t    }\n  \t    constructor(objects, ...moreObjects) {\n  \t        super();\n  \t        this.dontFlatten = false;\n  \t        this.TrimTrailingWhitespace = () => {\n  \t            for (let ii = this.content.length - 1; ii >= 0; --ii) {\n  \t                const text = (0, TypeAssertion_1.asOrNull)(this.content[ii], Text_1.Text);\n  \t                if (text === null) {\n  \t                    break;\n  \t                }\n  \t                text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");\n  \t                if (text.text.length === 0) {\n  \t                    this.content.splice(ii, 1);\n  \t                }\n  \t                else {\n  \t                    break;\n  \t                }\n  \t            }\n  \t        };\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            if (this.content !== null) {\n  \t                for (const obj of this.content) {\n  \t                    const contentObjRuntime = obj.runtimeObject;\n  \t                    // Some objects (e.g. author warnings) don't generate runtime objects\n  \t                    if (contentObjRuntime) {\n  \t                        container.AddContent(contentObjRuntime);\n  \t                    }\n  \t                }\n  \t            }\n  \t            if (this.dontFlatten) {\n  \t                this.story.DontFlattenContainer(container);\n  \t            }\n  \t            return container;\n  \t        };\n  \t        this.toString = () => `ContentList(${this.content.join(\", \")})`;\n  \t        if (objects) {\n  \t            this.AddContent(objects);\n  \t        }\n  \t        if (moreObjects) {\n  \t            this.AddContent(moreObjects);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"ContentList\";\n  \t    }\n  \t};\n  \tContentList.ContentList = ContentList$1;\n  \t\n  \treturn ContentList;\n  }\n\n  var hasRequiredVariableReference;\n\n  function requireVariableReference () {\n  \tif (hasRequiredVariableReference) return VariableReference;\n  \thasRequiredVariableReference = 1;\n  \tObject.defineProperty(VariableReference, \"__esModule\", { value: true });\n  \tVariableReference.VariableReference = void 0;\n  \tconst ContentList_1 = requireContentList();\n  \tconst Expression_1 = requireExpression();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst Path_1 = requirePath();\n  \tconst VariableReference_1 = requireVariableReference$1();\n  \tconst Weave_1 = requireWeave();\n  \tconst Identifier_1 = requireIdentifier();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet VariableReference$1 = class VariableReference extends Expression_1.Expression {\n  \t    // - Normal variables have a single item in their \"path\"\n  \t    // - Knot/stitch names for read counts are actual dot-separated paths\n  \t    //   (though this isn't actually used at time of writing)\n  \t    // - List names are dot separated: listName.itemName (or just itemName)\n  \t    get name() {\n  \t        return this.path.join(\".\");\n  \t    }\n  \t    get path() {\n  \t        return this.pathIdentifiers.map((id) => id.name).filter(TypeAssertion_1.filterUndef);\n  \t    }\n  \t    get identifier() {\n  \t        if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {\n  \t            return null;\n  \t        }\n  \t        const name = this.path.join(\".\");\n  \t        const id = new Identifier_1.Identifier(name);\n  \t        return id;\n  \t    }\n  \t    get runtimeVarRef() {\n  \t        return this._runtimeVarRef;\n  \t    }\n  \t    constructor(pathIdentifiers) {\n  \t        super();\n  \t        this.pathIdentifiers = pathIdentifiers;\n  \t        this._runtimeVarRef = null;\n  \t        // Only known after GenerateIntoContainer has run\n  \t        this.isConstantReference = false;\n  \t        this.isListItemReference = false;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            let constantValue = this.story.constants.get(this.name);\n  \t            // If it's a constant reference, just generate the literal expression value\n  \t            // It's okay to access the constants at code generation time, since the\n  \t            // first thing the ExportRuntime function does it search for all the constants\n  \t            // in the story hierarchy, so they're all available.\n  \t            if (constantValue) {\n  \t                constantValue.GenerateConstantIntoContainer(container);\n  \t                this.isConstantReference = true;\n  \t                return;\n  \t            }\n  \t            this._runtimeVarRef = new VariableReference_1.VariableReference(this.name);\n  \t            // List item reference?\n  \t            // Path might be to a list (listName.listItemName or just listItemName)\n  \t            if (this.path.length === 1 || this.path.length === 2) {\n  \t                let listItemName = \"\";\n  \t                let listName = \"\";\n  \t                if (this.path.length === 1) {\n  \t                    listItemName = this.path[0];\n  \t                }\n  \t                else {\n  \t                    listName = this.path[0];\n  \t                    listItemName = this.path[1];\n  \t                }\n  \t                const listItem = this.story.ResolveListItem(listName, listItemName, this);\n  \t                if (listItem) {\n  \t                    this.isListItemReference = true;\n  \t                }\n  \t            }\n  \t            container.AddContent(this._runtimeVarRef);\n  \t        };\n  \t        this.toString = () => `{${this.path.join(\".\")}}`;\n  \t    }\n  \t    get typeName() {\n  \t        return \"ref\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        // Work is already done if it's a constant or list item reference\n  \t        if (this.isConstantReference || this.isListItemReference) {\n  \t            return;\n  \t        }\n  \t        // Is it a read count?\n  \t        const parsedPath = new Path_1.Path(this.pathIdentifiers);\n  \t        const targetForCount = parsedPath.ResolveFromContext(this);\n  \t        if (targetForCount) {\n  \t            if (!targetForCount.containerForCounting) {\n  \t                throw new Error();\n  \t            }\n  \t            targetForCount.containerForCounting.visitsShouldBeCounted = true;\n  \t            // If this is an argument to a function that wants a variable to be\n  \t            // passed by reference, then the Parsed.Divert will have generated a\n  \t            // Runtime.VariablePointerValue instead of allowing this object\n  \t            // to generate its RuntimeVariableReference. This only happens under\n  \t            // error condition since we shouldn't be passing a read count by\n  \t            // reference, but we don't want it to crash!\n  \t            if (this._runtimeVarRef === null) {\n  \t                return;\n  \t            }\n  \t            this._runtimeVarRef.pathForCount = targetForCount.runtimePath;\n  \t            this._runtimeVarRef.name = null;\n  \t            // Check for very specific writer error: getting read count and\n  \t            // printing it as content rather than as a piece of logic\n  \t            // e.g. Writing {myFunc} instead of {myFunc()}\n  \t            let targetFlow = (0, TypeAssertion_1.asOrNull)(targetForCount, FlowBase_1.FlowBase);\n  \t            if (targetFlow && targetFlow.isFunction) {\n  \t                // Is parent context content rather than logic?\n  \t                if (this.parent instanceof Weave_1.Weave ||\n  \t                    this.parent instanceof ContentList_1.ContentList ||\n  \t                    this.parent instanceof FlowBase_1.FlowBase) {\n  \t                    this.Warning(`'${targetFlow.identifier}' being used as read count rather than being called as function. Perhaps you intended to write ${targetFlow.identifier}()`);\n  \t                }\n  \t            }\n  \t            return;\n  \t        }\n  \t        // Couldn't find this multi-part path at all, whether as a divert\n  \t        // target or as a list item reference.\n  \t        if (this.path.length > 1) {\n  \t            let errorMsg = `Could not find target for read count: ${parsedPath}`;\n  \t            if (this.path.length <= 2) {\n  \t                errorMsg += `, or couldn't find list item with the name ${this.path.join(\",\")}`;\n  \t            }\n  \t            this.Error(errorMsg);\n  \t            return;\n  \t        }\n  \t        if (!context.ResolveVariableWithName(this.name, this).found) {\n  \t            this.Error(`Unresolved variable: ${this.name}`, this);\n  \t        }\n  \t    }\n  \t};\n  \tVariableReference.VariableReference = VariableReference$1;\n  \t\n  \treturn VariableReference;\n  }\n\n  var hasRequiredFunctionCall;\n\n  function requireFunctionCall () {\n  \tif (hasRequiredFunctionCall) return FunctionCall;\n  \thasRequiredFunctionCall = 1;\n  \tObject.defineProperty(FunctionCall, \"__esModule\", { value: true });\n  \tFunctionCall.FunctionCall = void 0;\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Divert_1 = requireDivert();\n  \tconst DivertTarget_1 = requireDivertTarget();\n  \tconst Expression_1 = requireExpression();\n  \tconst InkList_1 = requireInkList();\n  \tconst Value_1 = requireValue();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst NumberExpression_1 = requireNumberExpression();\n  \tconst Path_1 = requirePath();\n  \tconst Value_2 = requireValue();\n  \tconst VariableReference_1 = requireVariableReference();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet FunctionCall$1 = class FunctionCall extends Expression_1.Expression {\n  \t    get proxyDivert() {\n  \t        return this._proxyDivert;\n  \t    }\n  \t    get name() {\n  \t        return this._proxyDivert.target.firstComponent || \"\";\n  \t    }\n  \t    get args() {\n  \t        return this._proxyDivert.args;\n  \t    }\n  \t    get runtimeDivert() {\n  \t        return this._proxyDivert.runtimeDivert;\n  \t    }\n  \t    get isChoiceCount() {\n  \t        return this.name === \"CHOICE_COUNT\";\n  \t    }\n  \t    get isTurns() {\n  \t        return this.name === \"TURNS\";\n  \t    }\n  \t    get isTurnsSince() {\n  \t        return this.name === \"TURNS_SINCE\";\n  \t    }\n  \t    get isRandom() {\n  \t        return this.name === \"RANDOM\";\n  \t    }\n  \t    get isSeedRandom() {\n  \t        return this.name === \"SEED_RANDOM\";\n  \t    }\n  \t    get isListRange() {\n  \t        return this.name === \"LIST_RANGE\";\n  \t    }\n  \t    get isListRandom() {\n  \t        return this.name === \"LIST_RANDOM\";\n  \t    }\n  \t    get isReadCount() {\n  \t        return this.name === \"READ_COUNT\";\n  \t    }\n  \t    constructor(functionName, args) {\n  \t        super();\n  \t        this._divertTargetToCount = null;\n  \t        this._variableReferenceToCount = null;\n  \t        this.shouldPopReturnedValue = false;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            const foundList = this.story.ResolveList(this.name);\n  \t            let usingProxyDivert = false;\n  \t            if (this.isChoiceCount) {\n  \t                if (this.args.length > 0) {\n  \t                    this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");\n  \t                }\n  \t                container.AddContent(ControlCommand_1.ControlCommand.ChoiceCount());\n  \t            }\n  \t            else if (this.isTurns) {\n  \t                if (this.args.length > 0) {\n  \t                    this.Error(\"The TURNS() function shouldn't take any arguments\");\n  \t                }\n  \t                container.AddContent(ControlCommand_1.ControlCommand.Turns());\n  \t            }\n  \t            else if (this.isTurnsSince || this.isReadCount) {\n  \t                const divertTarget = (0, TypeAssertion_1.asOrNull)(this.args[0], DivertTarget_1.DivertTarget);\n  \t                const variableDivertTarget = (0, TypeAssertion_1.asOrNull)(this.args[0], VariableReference_1.VariableReference);\n  \t                if (this.args.length !== 1 ||\n  \t                    (divertTarget === null && variableDivertTarget === null)) {\n  \t                    this.Error(`The ${this.name}() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)`);\n  \t                    return;\n  \t                }\n  \t                if (divertTarget) {\n  \t                    this._divertTargetToCount = divertTarget;\n  \t                    this.AddContent(this._divertTargetToCount);\n  \t                    this._divertTargetToCount.GenerateIntoContainer(container);\n  \t                }\n  \t                else if (variableDivertTarget) {\n  \t                    this._variableReferenceToCount = variableDivertTarget;\n  \t                    this.AddContent(this._variableReferenceToCount);\n  \t                    this._variableReferenceToCount.GenerateIntoContainer(container);\n  \t                }\n  \t                if (this.isTurnsSince) {\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.TurnsSince());\n  \t                }\n  \t                else {\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.ReadCount());\n  \t                }\n  \t            }\n  \t            else if (this.isRandom) {\n  \t                if (this.args.length !== 2) {\n  \t                    this.Error(\"RANDOM should take 2 parameters: a minimum and a maximum integer\");\n  \t                }\n  \t                // We can type check single values, but not complex expressions\n  \t                for (let ii = 0; ii < this.args.length; ii += 1) {\n  \t                    const num = (0, TypeAssertion_1.asOrNull)(this.args[ii], NumberExpression_1.NumberExpression);\n  \t                    if (num && !num.isInt()) {\n  \t                        const paramName = ii === 0 ? \"minimum\" : \"maximum\";\n  \t                        this.Error(`RANDOM's ${paramName} parameter should be an integer`);\n  \t                    }\n  \t                    this.args[ii].GenerateIntoContainer(container);\n  \t                }\n  \t                container.AddContent(ControlCommand_1.ControlCommand.Random());\n  \t            }\n  \t            else if (this.isSeedRandom) {\n  \t                if (this.args.length !== 1) {\n  \t                    this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");\n  \t                }\n  \t                const num = (0, TypeAssertion_1.asOrNull)(this.args[0], NumberExpression_1.NumberExpression);\n  \t                if (num && !num.isInt()) {\n  \t                    this.Error(\"SEED_RANDOM's parameter should be an integer seed\");\n  \t                }\n  \t                this.args[0].GenerateIntoContainer(container);\n  \t                container.AddContent(ControlCommand_1.ControlCommand.SeedRandom());\n  \t            }\n  \t            else if (this.isListRange) {\n  \t                if (this.args.length !== 3) {\n  \t                    this.Error(\"LIST_RANGE should take 3 parameters - a list, a min and a max\");\n  \t                }\n  \t                for (let ii = 0; ii < this.args.length; ii += 1) {\n  \t                    this.args[ii].GenerateIntoContainer(container);\n  \t                }\n  \t                container.AddContent(ControlCommand_1.ControlCommand.ListRange());\n  \t            }\n  \t            else if (this.isListRandom) {\n  \t                if (this.args.length !== 1) {\n  \t                    this.Error(\"LIST_RANDOM should take 1 parameter - a list\");\n  \t                }\n  \t                this.args[0].GenerateIntoContainer(container);\n  \t                container.AddContent(ControlCommand_1.ControlCommand.ListRandom());\n  \t            }\n  \t            else if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(this.name)) {\n  \t                const nativeCall = NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.name);\n  \t                if (nativeCall.numberOfParameters !== this.args.length) {\n  \t                    let msg = `${FunctionCall.name} should take ${nativeCall.numberOfParameters} parameter`;\n  \t                    if (nativeCall.numberOfParameters > 1) {\n  \t                        msg += \"s\";\n  \t                    }\n  \t                    this.Error(msg);\n  \t                }\n  \t                for (let ii = 0; ii < this.args.length; ii += 1) {\n  \t                    this.args[ii].GenerateIntoContainer(container);\n  \t                }\n  \t                container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.name));\n  \t            }\n  \t            else if (foundList !== null) {\n  \t                if (this.args.length > 1) {\n  \t                    this.Error(\"Can currently only construct a list from one integer (or an empty list from a given list definition)\");\n  \t                }\n  \t                // List item from given int\n  \t                if (this.args.length === 1) {\n  \t                    container.AddContent(new Value_2.StringValue(this.name));\n  \t                    this.args[0].GenerateIntoContainer(container);\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.ListFromInt());\n  \t                }\n  \t                else {\n  \t                    // Empty list with given origin.\n  \t                    const list = new InkList_1.InkList();\n  \t                    list.SetInitialOriginName(this.name);\n  \t                    container.AddContent(new Value_1.ListValue(list));\n  \t                }\n  \t            }\n  \t            else {\n  \t                // Normal function call\n  \t                container.AddContent(this._proxyDivert.runtimeObject);\n  \t                usingProxyDivert = true;\n  \t            }\n  \t            // Don't attempt to resolve as a divert if we're not doing a normal function call\n  \t            if (!usingProxyDivert) {\n  \t                this.content.splice(this.content.indexOf(this._proxyDivert), 1);\n  \t            }\n  \t            // Function calls that are used alone on a tilda-based line:\n  \t            //  ~ func()\n  \t            // Should tidy up any returned value from the evaluation stack,\n  \t            // since it's unused.\n  \t            if (this.shouldPopReturnedValue) {\n  \t                container.AddContent(ControlCommand_1.ControlCommand.PopEvaluatedValue());\n  \t            }\n  \t        };\n  \t        this.toString = () => {\n  \t            const strArgs = this.args.join(\", \");\n  \t            return `${this.name}(${strArgs})`;\n  \t        };\n  \t        this._proxyDivert = new Divert_1.Divert(new Path_1.Path(functionName), args);\n  \t        this._proxyDivert.isFunctionCall = true;\n  \t        this.AddContent(this._proxyDivert);\n  \t    }\n  \t    get typeName() {\n  \t        return \"FunctionCall\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        // If we aren't using the proxy divert after all (e.g. if\n  \t        // it's a native function call), but we still have arguments,\n  \t        // we need to make sure they get resolved since the proxy divert\n  \t        // is no longer in the content array.\n  \t        if (!this.content.includes(this._proxyDivert) && this.args !== null) {\n  \t            for (const arg of this.args) {\n  \t                arg.ResolveReferences(context);\n  \t            }\n  \t        }\n  \t        if (this._divertTargetToCount) {\n  \t            const divert = this._divertTargetToCount.divert;\n  \t            const attemptingTurnCountOfVariableTarget = divert.runtimeDivert.variableDivertName != null;\n  \t            if (attemptingTurnCountOfVariableTarget) {\n  \t                this.Error(`When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(${divert.runtimeDivert.variableDivertName})`);\n  \t                return;\n  \t            }\n  \t            const targetObject = divert.targetContent;\n  \t            if (targetObject === null) {\n  \t                if (!attemptingTurnCountOfVariableTarget) {\n  \t                    this.Error(`Failed to find target for TURNS_SINCE: '${divert.target}'`);\n  \t                }\n  \t            }\n  \t            else {\n  \t                if (!targetObject.containerForCounting) {\n  \t                    throw new Error();\n  \t                }\n  \t                targetObject.containerForCounting.turnIndexShouldBeCounted = true;\n  \t            }\n  \t        }\n  \t        else if (this._variableReferenceToCount) {\n  \t            const runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;\n  \t            if (!runtimeVarRef) {\n  \t                throw new Error();\n  \t            }\n  \t            if (runtimeVarRef.pathForCount !== null) {\n  \t                this.Error(`Should be '${FunctionCall.name}'(-> '${this._variableReferenceToCount.name}). Usage without the '->' only makes sense for variable targets.`);\n  \t            }\n  \t        }\n  \t    }\n  \t};\n  \tFunctionCall.FunctionCall = FunctionCall$1;\n  \tFunctionCall$1.IsBuiltIn = (name) => {\n  \t    if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(name)) {\n  \t        return true;\n  \t    }\n  \t    return (name === \"CHOICE_COUNT\" ||\n  \t        name === \"TURNS_SINCE\" ||\n  \t        name === \"TURNS\" ||\n  \t        name === \"RANDOM\" ||\n  \t        name === \"SEED_RANDOM\" ||\n  \t        name === \"LIST_VALUE\" ||\n  \t        name === \"LIST_RANDOM\" ||\n  \t        name === \"READ_COUNT\");\n  \t};\n  \t\n  \treturn FunctionCall;\n  }\n\n  var MultipleConditionExpression = {};\n\n  var hasRequiredMultipleConditionExpression;\n\n  function requireMultipleConditionExpression () {\n  \tif (hasRequiredMultipleConditionExpression) return MultipleConditionExpression;\n  \thasRequiredMultipleConditionExpression = 1;\n  \tObject.defineProperty(MultipleConditionExpression, \"__esModule\", { value: true });\n  \tMultipleConditionExpression.MultipleConditionExpression = void 0;\n  \tconst Expression_1 = requireExpression();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tlet MultipleConditionExpression$1 = class MultipleConditionExpression extends Expression_1.Expression {\n  \t    get subExpressions() {\n  \t        return this.content;\n  \t    }\n  \t    constructor(conditionExpressions) {\n  \t        super();\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            //    A && B && C && D\n  \t            // => (((A B &&) C &&) D &&) etc\n  \t            let isFirst = true;\n  \t            for (const conditionExpr of this.subExpressions) {\n  \t                conditionExpr.GenerateIntoContainer(container);\n  \t                if (!isFirst) {\n  \t                    container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"&&\"));\n  \t                }\n  \t                isFirst = false;\n  \t            }\n  \t        };\n  \t        this.AddContent(conditionExpressions);\n  \t    }\n  \t    get typeName() {\n  \t        return \"MultipleConditionExpression\";\n  \t    }\n  \t};\n  \tMultipleConditionExpression.MultipleConditionExpression = MultipleConditionExpression$1;\n  \t\n  \treturn MultipleConditionExpression;\n  }\n\n  var hasRequiredDivertTarget;\n\n  function requireDivertTarget () {\n  \tif (hasRequiredDivertTarget) return DivertTarget;\n  \thasRequiredDivertTarget = 1;\n  \tObject.defineProperty(DivertTarget, \"__esModule\", { value: true });\n  \tDivertTarget.DivertTarget = void 0;\n  \tconst BinaryExpression_1 = requireBinaryExpression();\n  \tconst Choice_1 = requireChoice();\n  \tconst Conditional_1 = requireConditional();\n  \tconst ConditionalSingleBranch_1 = requireConditionalSingleBranch();\n  \tconst Value_1 = requireValue();\n  \tconst Expression_1 = requireExpression();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst FunctionCall_1 = requireFunctionCall();\n  \tconst MultipleConditionExpression_1 = requireMultipleConditionExpression();\n  \tconst VariableReference_1 = requireVariableReference();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet DivertTarget$1 = class DivertTarget extends Expression_1.Expression {\n  \t    get runtimeDivert() {\n  \t        if (!this._runtimeDivert) {\n  \t            throw new Error();\n  \t        }\n  \t        return this._runtimeDivert;\n  \t    }\n  \t    get runtimeDivertTargetValue() {\n  \t        if (!this._runtimeDivertTargetValue) {\n  \t            throw new Error();\n  \t        }\n  \t        return this._runtimeDivertTargetValue;\n  \t    }\n  \t    constructor(divert) {\n  \t        super();\n  \t        this._runtimeDivert = null;\n  \t        this._runtimeDivertTargetValue = null;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            this.divert.GenerateRuntimeObject();\n  \t            this._runtimeDivert = this.divert.runtimeDivert;\n  \t            this._runtimeDivertTargetValue = new Value_1.DivertTargetValue();\n  \t            container.AddContent(this.runtimeDivertTargetValue);\n  \t        };\n  \t        // Equals override necessary in order to check for CONST multiple definition equality\n  \t        this.Equals = (obj) => {\n  \t            const otherDivTarget = (0, TypeAssertion_1.asOrNull)(obj, DivertTarget);\n  \t            if (!otherDivTarget ||\n  \t                !this.divert.target ||\n  \t                !otherDivTarget.divert.target) {\n  \t                return false;\n  \t            }\n  \t            const targetStr = this.divert.target.dotSeparatedComponents;\n  \t            const otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;\n  \t            return targetStr === otherTargetStr;\n  \t        };\n  \t        this.divert = this.AddContent(divert);\n  \t    }\n  \t    get typeName() {\n  \t        return \"DivertTarget\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        if (this.divert.isDone || this.divert.isEnd) {\n  \t            this.Error(`Can't use -> DONE or -> END as variable divert targets`, this);\n  \t            return;\n  \t        }\n  \t        let usageContext = this;\n  \t        while (usageContext && usageContext instanceof Expression_1.Expression) {\n  \t            let badUsage = false;\n  \t            let foundUsage = false;\n  \t            const usageParent = usageContext.parent;\n  \t            if (usageParent instanceof BinaryExpression_1.BinaryExpression) {\n  \t                // Only allowed to compare for equality\n  \t                const binaryExprParent = usageParent;\n  \t                if (binaryExprParent.opName !== \"==\" &&\n  \t                    binaryExprParent.opName !== \"!=\") {\n  \t                    badUsage = true;\n  \t                }\n  \t                else {\n  \t                    if (!(binaryExprParent.leftExpression instanceof DivertTarget ||\n  \t                        binaryExprParent.leftExpression instanceof VariableReference_1.VariableReference)) {\n  \t                        badUsage = true;\n  \t                    }\n  \t                    else if (!(binaryExprParent.rightExpression instanceof DivertTarget ||\n  \t                        binaryExprParent.rightExpression instanceof VariableReference_1.VariableReference)) {\n  \t                        badUsage = true;\n  \t                    }\n  \t                }\n  \t                foundUsage = true;\n  \t            }\n  \t            else if (usageParent instanceof FunctionCall_1.FunctionCall) {\n  \t                const funcCall = usageParent;\n  \t                if (!funcCall.isTurnsSince && !funcCall.isReadCount) {\n  \t                    badUsage = true;\n  \t                }\n  \t                foundUsage = true;\n  \t            }\n  \t            else if (usageParent instanceof Expression_1.Expression) {\n  \t                badUsage = true;\n  \t                foundUsage = true;\n  \t            }\n  \t            else if (usageParent instanceof MultipleConditionExpression_1.MultipleConditionExpression) {\n  \t                badUsage = true;\n  \t                foundUsage = true;\n  \t            }\n  \t            else if (usageParent instanceof Choice_1.Choice &&\n  \t                usageParent.condition === usageContext) {\n  \t                badUsage = true;\n  \t                foundUsage = true;\n  \t            }\n  \t            else if (usageParent instanceof Conditional_1.Conditional ||\n  \t                usageParent instanceof ConditionalSingleBranch_1.ConditionalSingleBranch) {\n  \t                badUsage = true;\n  \t                foundUsage = true;\n  \t            }\n  \t            if (badUsage) {\n  \t                this.Error(`Can't use a divert target like that. Did you intend to call '${this.divert.target}' as a function: likeThis(), or check the read count: likeThis, with no arrows?`, this);\n  \t            }\n  \t            if (foundUsage) {\n  \t                break;\n  \t            }\n  \t            usageContext = usageParent;\n  \t        }\n  \t        // Example ink for this case:\n  \t        //\n  \t        //     VAR x = -> blah\n  \t        //\n  \t        // ...which means that \"blah\" is expected to be a literal stitch target rather\n  \t        // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to\n  \t        // contain a divert target itself) since really we should be generating a variable reference\n  \t        // rather than a concrete DivertTarget, so we list it as an error.\n  \t        if (this.runtimeDivert.hasVariableTarget) {\n  \t            if (!this.divert.target) {\n  \t                throw new Error();\n  \t            }\n  \t            this.Error(`Since '${this.divert.target.dotSeparatedComponents}' is a variable, it shouldn't be preceded by '->' here.`);\n  \t        }\n  \t        // Main resolve\n  \t        this.runtimeDivert.targetPath &&\n  \t            (this.runtimeDivertTargetValue.targetPath =\n  \t                this.runtimeDivert.targetPath);\n  \t        // Tell hard coded (yet variable) divert targets that they also need to be counted\n  \t        // TODO: Only detect DivertTargets that are values rather than being used directly for\n  \t        // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting\n  \t        let targetContent = this.divert.targetContent;\n  \t        if (targetContent !== null) {\n  \t            let target = targetContent.containerForCounting;\n  \t            if (target !== null) {\n  \t                // Purpose is known: used directly in TURNS_SINCE(-> divTarg)\n  \t                const parentFunc = (0, TypeAssertion_1.asOrNull)(this.parent, FunctionCall_1.FunctionCall);\n  \t                if (parentFunc && parentFunc.isTurnsSince) {\n  \t                    target.turnIndexShouldBeCounted = true;\n  \t                }\n  \t                else {\n  \t                    // Unknown purpose, count everything\n  \t                    target.visitsShouldBeCounted = true;\n  \t                    target.turnIndexShouldBeCounted = true;\n  \t                }\n  \t            }\n  \t            // Unfortunately not possible:\n  \t            // https://github.com/inkle/ink/issues/538\n  \t            //\n  \t            // VAR func = -> double\n  \t            //\n  \t            // === function double(ref x)\n  \t            //    ~ x = x * 2\n  \t            //\n  \t            // Because when generating the parameters for a function\n  \t            // to be called, it needs to know ahead of time when\n  \t            // compiling whether to pass a variable reference or value.\n  \t            //\n  \t            let targetFlow = (0, TypeAssertion_1.asOrNull)(targetContent, FlowBase_1.FlowBase);\n  \t            if (targetFlow != null && targetFlow.args !== null) {\n  \t                for (const arg of targetFlow.args) {\n  \t                    if (arg.isByReference) {\n  \t                        this.Error(`Can't store a divert target to a knot or function that has by-reference arguments ('${targetFlow.identifier}' has 'ref ${arg.identifier}').`);\n  \t                    }\n  \t                }\n  \t            }\n  \t        }\n  \t    }\n  \t};\n  \tDivertTarget.DivertTarget = DivertTarget$1;\n  \t\n  \treturn DivertTarget;\n  }\n\n  var hasRequiredDivert;\n\n  function requireDivert () {\n  \tif (hasRequiredDivert) return Divert;\n  \thasRequiredDivert = 1;\n  \tObject.defineProperty(Divert, \"__esModule\", { value: true });\n  \tDivert.Divert = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Divert_1 = requireDivert$1();\n  \tconst DivertTarget_1 = requireDivertTarget();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst FunctionCall_1 = requireFunctionCall();\n  \tconst Object_1 = require_Object();\n  \tconst Path_1 = requirePath();\n  \tconst Path_2 = requirePath$1();\n  \tconst PushPop_1 = requirePushPop();\n  \tconst Value_1 = requireValue();\n  \tconst VariableReference_1 = requireVariableReference();\n  \tconst ClosestFlowBase_1 = requireClosestFlowBase();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet Divert$1 = class Divert extends Object_1.ParsedObject {\n  \t    get runtimeDivert() {\n  \t        if (!this._runtimeDivert) {\n  \t            throw new Error();\n  \t        }\n  \t        return this._runtimeDivert;\n  \t    }\n  \t    set runtimeDivert(value) {\n  \t        this._runtimeDivert = value;\n  \t    }\n  \t    get isEnd() {\n  \t        return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");\n  \t    }\n  \t    get isDone() {\n  \t        return Boolean(this.target && this.target.dotSeparatedComponents === \"DONE\");\n  \t    }\n  \t    constructor(target, args) {\n  \t        super();\n  \t        this.args = [];\n  \t        this.target = null;\n  \t        this.targetContent = null;\n  \t        this._runtimeDivert = null;\n  \t        this.isFunctionCall = false;\n  \t        this.isEmpty = false;\n  \t        this.isTunnel = false;\n  \t        this.isThread = false;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            // End = end flow immediately\n  \t            // Done = return from thread or instruct the flow that it's safe to exit\n  \t            if (this.isEnd) {\n  \t                return ControlCommand_1.ControlCommand.End();\n  \t            }\n  \t            else if (this.isDone) {\n  \t                return ControlCommand_1.ControlCommand.Done();\n  \t            }\n  \t            this.runtimeDivert = new Divert_1.Divert();\n  \t            // Normally we resolve the target content during the\n  \t            // Resolve phase, since we expect all runtime objects to\n  \t            // be available in order to find the final runtime path for\n  \t            // the destination. However, we need to resolve the target\n  \t            // (albeit without the runtime target) early so that\n  \t            // we can get information about the arguments - whether\n  \t            // they're by reference - since it affects the code we\n  \t            // generate here.\n  \t            this.ResolveTargetContent();\n  \t            this.CheckArgumentValidity();\n  \t            // Passing arguments to the knot\n  \t            const requiresArgCodeGen = this.args !== null && this.args.length > 0;\n  \t            if (requiresArgCodeGen ||\n  \t                this.isFunctionCall ||\n  \t                this.isTunnel ||\n  \t                this.isThread) {\n  \t                const container = new Container_1.Container();\n  \t                // Generate code for argument evaluation\n  \t                // This argument generation is coded defensively - it should\n  \t                // attempt to generate the code for all the parameters, even if\n  \t                // they don't match the expected arguments. This is so that the\n  \t                // parameter objects themselves are generated correctly and don't\n  \t                // get into a state of attempting to resolve references etc\n  \t                // without being generated.\n  \t                if (requiresArgCodeGen) {\n  \t                    // Function calls already in an evaluation context\n  \t                    if (!this.isFunctionCall) {\n  \t                        container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t                    }\n  \t                    let targetArguments = null;\n  \t                    if (this.targetContent) {\n  \t                        targetArguments = this.targetContent.args;\n  \t                    }\n  \t                    for (let ii = 0; ii < this.args.length; ++ii) {\n  \t                        const argToPass = this.args[ii];\n  \t                        let argExpected = null;\n  \t                        if (targetArguments && ii < targetArguments.length) {\n  \t                            argExpected = targetArguments[ii];\n  \t                        }\n  \t                        // Pass by reference: argument needs to be a variable reference\n  \t                        if (argExpected && argExpected.isByReference) {\n  \t                            const varRef = (0, TypeAssertion_1.asOrNull)(argToPass, VariableReference_1.VariableReference);\n  \t                            if (!varRef) {\n  \t                                this.Error(`Expected variable name to pass by reference to 'ref ${argExpected.identifier}' but saw ${argToPass}`);\n  \t                                break;\n  \t                            }\n  \t                            // Check that we're not attempting to pass a read count by reference\n  \t                            const targetPath = new Path_1.Path(varRef.pathIdentifiers);\n  \t                            const targetForCount = targetPath.ResolveFromContext(this);\n  \t                            if (targetForCount) {\n  \t                                this.Error(`can't pass a read count by reference. '${targetPath.dotSeparatedComponents}' is a knot/stitch/label, but '${this.target.dotSeparatedComponents}' requires the name of a VAR to be passed.`);\n  \t                                break;\n  \t                            }\n  \t                            const varPointer = new Value_1.VariablePointerValue(varRef.name);\n  \t                            container.AddContent(varPointer);\n  \t                        }\n  \t                        else {\n  \t                            // Normal value being passed: evaluate it as normal\n  \t                            argToPass.GenerateIntoContainer(container);\n  \t                        }\n  \t                    }\n  \t                    // Function calls were already in an evaluation context\n  \t                    if (!this.isFunctionCall) {\n  \t                        container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t                    }\n  \t                }\n  \t                // Starting a thread? A bit like a push to the call stack below... but not.\n  \t                // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.\n  \t                if (this.isThread) {\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.StartThread());\n  \t                }\n  \t                else if (this.isFunctionCall || this.isTunnel) {\n  \t                    // If this divert is a function call, tunnel, we push to the call stack\n  \t                    // so we can return again\n  \t                    this.runtimeDivert.pushesToStack = true;\n  \t                    this.runtimeDivert.stackPushType = this.isFunctionCall\n  \t                        ? PushPop_1.PushPopType.Function\n  \t                        : PushPop_1.PushPopType.Tunnel;\n  \t                }\n  \t                // Jump into the \"function\" (knot/stitch)\n  \t                container.AddContent(this.runtimeDivert);\n  \t                return container;\n  \t            }\n  \t            // Simple divert\n  \t            return this.runtimeDivert;\n  \t        };\n  \t        // When the divert is to a target that's actually a variable name\n  \t        // rather than an explicit knot/stitch name, try interpretting it\n  \t        // as such by getting the variable name.\n  \t        this.PathAsVariableName = () => this.target ? this.target.firstComponent : null;\n  \t        this.ResolveTargetContent = () => {\n  \t            if (this.isEmpty || this.isEnd) {\n  \t                return;\n  \t            }\n  \t            if (this.targetContent === null) {\n  \t                // Is target of this divert a variable name that will be de-referenced\n  \t                // at runtime? If so, there won't be any further reference resolution\n  \t                // we can do at this point.\n  \t                let variableTargetName = this.PathAsVariableName();\n  \t                if (variableTargetName !== null) {\n  \t                    const flowBaseScope = (0, TypeAssertion_1.asOrNull)((0, ClosestFlowBase_1.ClosestFlowBase)(this), FlowBase_1.FlowBase);\n  \t                    if (flowBaseScope) {\n  \t                        const resolveResult = flowBaseScope.ResolveVariableWithName(variableTargetName, this);\n  \t                        if (resolveResult.found) {\n  \t                            // Make sure that the flow was typed correctly, given that we know that this\n  \t                            // is meant to be a divert target\n  \t                            if (resolveResult.isArgument &&\n  \t                                resolveResult.ownerFlow &&\n  \t                                resolveResult.ownerFlow.args) {\n  \t                                let argument = resolveResult.ownerFlow.args.find((a) => { var _a; return ((_a = a.identifier) === null || _a === void 0 ? void 0 : _a.name) == variableTargetName; });\n  \t                                if (argument && !argument.isDivertTarget) {\n  \t                                    this.Error(`Since '${argument.identifier}' is used as a variable divert target (on ${this.debugMetadata}), it should be marked as: -> ${argument.identifier}`, resolveResult.ownerFlow);\n  \t                                }\n  \t                            }\n  \t                            this.runtimeDivert.variableDivertName = variableTargetName;\n  \t                            return;\n  \t                        }\n  \t                    }\n  \t                }\n  \t                if (!this.target) {\n  \t                    throw new Error();\n  \t                }\n  \t                this.targetContent = this.target.ResolveFromContext(this);\n  \t            }\n  \t        };\n  \t        // Returns false if there's an error\n  \t        this.CheckArgumentValidity = () => {\n  \t            if (this.isEmpty) {\n  \t                return;\n  \t            }\n  \t            // Argument passing: Check for errors in number of arguments\n  \t            let numArgs = 0;\n  \t            if (this.args !== null && this.args.length > 0) {\n  \t                numArgs = this.args.length;\n  \t            }\n  \t            // Missing content?\n  \t            // Can't check arguments properly. It'll be due to some\n  \t            // other error though, so although there's a problem and\n  \t            // we report false, we don't need to report a specific error.\n  \t            // It may also be because it's a valid call to an external\n  \t            // function, that we check at the resolve stage.\n  \t            if (this.targetContent === null) {\n  \t                return;\n  \t            }\n  \t            const targetFlow = (0, TypeAssertion_1.asOrNull)(this.targetContent, FlowBase_1.FlowBase);\n  \t            // No error, crikey!\n  \t            if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {\n  \t                return;\n  \t            }\n  \t            else if (targetFlow === null && numArgs > 0) {\n  \t                this.Error(\"target needs to be a knot or stitch in order to pass arguments\");\n  \t                return;\n  \t            }\n  \t            else if (targetFlow !== null &&\n  \t                (targetFlow.args === null || (!targetFlow.args && numArgs > 0))) {\n  \t                this.Error(`target (${targetFlow.name}) doesn't take parameters`);\n  \t                return;\n  \t            }\n  \t            else if (this.parent instanceof DivertTarget_1.DivertTarget) {\n  \t                if (numArgs > 0) {\n  \t                    this.Error(`can't store arguments in a divert target variable`);\n  \t                }\n  \t                return;\n  \t            }\n  \t            const paramCount = targetFlow.args.length;\n  \t            if (paramCount !== numArgs) {\n  \t                let butClause;\n  \t                if (numArgs === 0) {\n  \t                    butClause = \"but there weren't any passed to it\";\n  \t                }\n  \t                else if (numArgs < paramCount) {\n  \t                    butClause = `but only got ${numArgs}`;\n  \t                }\n  \t                else {\n  \t                    butClause = `but got ${numArgs}`;\n  \t                }\n  \t                this.Error(`to '${targetFlow.identifier}' requires ${paramCount} arguments, ${butClause}`);\n  \t                return;\n  \t            }\n  \t            // Light type-checking for divert target arguments\n  \t            for (let ii = 0; ii < paramCount; ++ii) {\n  \t                const flowArg = targetFlow.args[ii];\n  \t                const divArgExpr = this.args[ii];\n  \t                // Expecting a divert target as an argument, let's do some basic type checking\n  \t                if (flowArg.isDivertTarget) {\n  \t                    // Not passing a divert target or any kind of variable reference?\n  \t                    let varRef = (0, TypeAssertion_1.asOrNull)(divArgExpr, VariableReference_1.VariableReference);\n  \t                    if (!(divArgExpr instanceof DivertTarget_1.DivertTarget) && varRef === null) {\n  \t                        this.Error(`Target '${targetFlow.identifier}' expects a divert target for the parameter named -> ${flowArg.identifier} but saw ${divArgExpr}`, divArgExpr);\n  \t                    }\n  \t                    else if (varRef) {\n  \t                        // Passing 'a' instead of '-> a'?\n  \t                        // i.e. read count instead of divert target\n  \t                        // Unfortunately have to manually resolve here since we're still in code gen\n  \t                        const knotCountPath = new Path_1.Path(varRef.pathIdentifiers);\n  \t                        const targetForCount = knotCountPath.ResolveFromContext(varRef);\n  \t                        if (targetForCount) {\n  \t                            this.Error(`Passing read count of '${knotCountPath.dotSeparatedComponents}' instead of a divert target. You probably meant '${knotCountPath}'`);\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t            if (targetFlow === null) {\n  \t                this.Error(\"Can't call as a function or with arguments unless it's a knot or stitch\");\n  \t                return;\n  \t            }\n  \t            return;\n  \t        };\n  \t        this.CheckExternalArgumentValidity = (context) => {\n  \t            const externalName = this.target\n  \t                ? this.target.firstComponent\n  \t                : null;\n  \t            const external = context.externals.get(externalName);\n  \t            if (!external) {\n  \t                throw new Error(\"external not found\");\n  \t            }\n  \t            const externalArgCount = external.argumentNames.length;\n  \t            let ownArgCount = 0;\n  \t            if (this.args) {\n  \t                ownArgCount = this.args.length;\n  \t            }\n  \t            if (ownArgCount !== externalArgCount) {\n  \t                this.Error(`incorrect number of arguments sent to external function '${externalName}'. Expected ${externalArgCount} but got ${ownArgCount}`);\n  \t            }\n  \t        };\n  \t        this.toString = () => {\n  \t            let returnString = \"\";\n  \t            if (this.target !== null) {\n  \t                returnString += this.target.toString();\n  \t            }\n  \t            else {\n  \t                return \"-> <empty divert>\";\n  \t            }\n  \t            if (this.isTunnel) {\n  \t                returnString += \" ->\";\n  \t            }\n  \t            if (this.isFunctionCall) {\n  \t                returnString += \" ()\";\n  \t            }\n  \t            return returnString;\n  \t        };\n  \t        if (target) {\n  \t            this.target = target;\n  \t        }\n  \t        if (args) {\n  \t            this.args = args;\n  \t            this.AddContent(args);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"Divert\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        if (this.isEmpty || this.isEnd || this.isDone) {\n  \t            return;\n  \t        }\n  \t        else if (!this.runtimeDivert) {\n  \t            throw new Error();\n  \t        }\n  \t        if (this.targetContent) {\n  \t            this.runtimeDivert.targetPath = this.targetContent.runtimePath;\n  \t        }\n  \t        // Resolve children (the arguments)\n  \t        super.ResolveReferences(context);\n  \t        // May be null if it's a built in function (e.g. TURNS_SINCE)\n  \t        // or if it's a variable target.\n  \t        let targetFlow = (0, TypeAssertion_1.asOrNull)(this.targetContent, FlowBase_1.FlowBase);\n  \t        if (targetFlow) {\n  \t            if (!targetFlow.isFunction && this.isFunctionCall) {\n  \t                super.Error(`${targetFlow.identifier} hasn't been marked as a function, but it's being called as one. Do you need to declare the knot as '== function ${targetFlow.identifier} =='?`);\n  \t            }\n  \t            else if (targetFlow.isFunction &&\n  \t                !this.isFunctionCall &&\n  \t                !(this.parent instanceof DivertTarget_1.DivertTarget)) {\n  \t                super.Error(targetFlow.identifier +\n  \t                    \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" +\n  \t                    targetFlow.identifier +\n  \t                    \"(...)'\");\n  \t            }\n  \t        }\n  \t        // Check validity of target content\n  \t        const targetWasFound = this.targetContent !== null;\n  \t        let isBuiltIn = false;\n  \t        let isExternal = false;\n  \t        if (!this.target) {\n  \t            throw new Error();\n  \t        }\n  \t        else if (this.target.numberOfComponents === 1) {\n  \t            if (!this.target.firstComponent) {\n  \t                throw new Error();\n  \t            }\n  \t            // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM\n  \t            isBuiltIn = FunctionCall_1.FunctionCall.IsBuiltIn(this.target.firstComponent);\n  \t            // Client-bound function?\n  \t            isExternal = context.IsExternal(this.target.firstComponent);\n  \t            if (isBuiltIn || isExternal) {\n  \t                if (!this.isFunctionCall) {\n  \t                    super.Error(`${this.target.firstComponent} must be called as a function: ~ ${this.target.firstComponent}()`);\n  \t                }\n  \t                if (isExternal) {\n  \t                    this.runtimeDivert.isExternal = true;\n  \t                    if (this.args !== null) {\n  \t                        this.runtimeDivert.externalArgs = this.args.length;\n  \t                    }\n  \t                    this.runtimeDivert.pushesToStack = false;\n  \t                    this.runtimeDivert.targetPath = new Path_2.Path(this.target.firstComponent);\n  \t                    this.CheckExternalArgumentValidity(context);\n  \t                }\n  \t                return;\n  \t            }\n  \t        }\n  \t        // Variable target?\n  \t        if (this.runtimeDivert.variableDivertName != null) {\n  \t            return;\n  \t        }\n  \t        if (!targetWasFound && !isBuiltIn && !isExternal) {\n  \t            this.Error(`target not found: '${this.target}'`);\n  \t        }\n  \t    }\n  \t    Error(message, source = null, isWarning = false) {\n  \t        // Could be getting an error from a nested Divert\n  \t        if (source !== this && source) {\n  \t            super.Error(message, source);\n  \t            return;\n  \t        }\n  \t        if (this.isFunctionCall) {\n  \t            super.Error(`Function call ${message}`, source, isWarning);\n  \t        }\n  \t        else {\n  \t            super.Error(`Divert ${message}`, source, isWarning);\n  \t        }\n  \t    }\n  \t};\n  \tDivert.Divert = Divert$1;\n  \t\n  \treturn Divert;\n  }\n\n  var GatherPointToResolve = {};\n\n  var hasRequiredGatherPointToResolve;\n\n  function requireGatherPointToResolve () {\n  \tif (hasRequiredGatherPointToResolve) return GatherPointToResolve;\n  \thasRequiredGatherPointToResolve = 1;\n  \tObject.defineProperty(GatherPointToResolve, \"__esModule\", { value: true });\n  \tGatherPointToResolve.GatherPointToResolve = void 0;\n  \tlet GatherPointToResolve$1 = class GatherPointToResolve {\n  \t    constructor(divert, targetRuntimeObj) {\n  \t        this.divert = divert;\n  \t        this.targetRuntimeObj = targetRuntimeObj;\n  \t    }\n  \t};\n  \tGatherPointToResolve.GatherPointToResolve = GatherPointToResolve$1;\n  \t\n  \treturn GatherPointToResolve;\n  }\n\n  var Sequence = {};\n\n  var SequenceDivertToResolve = {};\n\n  var hasRequiredSequenceDivertToResolve;\n\n  function requireSequenceDivertToResolve () {\n  \tif (hasRequiredSequenceDivertToResolve) return SequenceDivertToResolve;\n  \thasRequiredSequenceDivertToResolve = 1;\n  \tObject.defineProperty(SequenceDivertToResolve, \"__esModule\", { value: true });\n  \tSequenceDivertToResolve.SequenceDivertToResolve = void 0;\n  \tlet SequenceDivertToResolve$1 = class SequenceDivertToResolve {\n  \t    constructor(divert, targetContent) {\n  \t        this.divert = divert;\n  \t        this.targetContent = targetContent;\n  \t    }\n  \t};\n  \tSequenceDivertToResolve.SequenceDivertToResolve = SequenceDivertToResolve$1;\n  \t\n  \treturn SequenceDivertToResolve;\n  }\n\n  var SequenceType = {};\n\n  var hasRequiredSequenceType;\n\n  function requireSequenceType () {\n  \tif (hasRequiredSequenceType) return SequenceType;\n  \thasRequiredSequenceType = 1;\n  \tObject.defineProperty(SequenceType, \"__esModule\", { value: true });\n  \tSequenceType.SequenceType = void 0;\n  \tvar SequenceType$1;\n  \t(function (SequenceType) {\n  \t    SequenceType[SequenceType[\"Stopping\"] = 1] = \"Stopping\";\n  \t    SequenceType[SequenceType[\"Cycle\"] = 2] = \"Cycle\";\n  \t    SequenceType[SequenceType[\"Shuffle\"] = 4] = \"Shuffle\";\n  \t    SequenceType[SequenceType[\"Once\"] = 8] = \"Once\";\n  \t})(SequenceType$1 || (SequenceType.SequenceType = SequenceType$1 = {}));\n  \t\n  \treturn SequenceType;\n  }\n\n  var hasRequiredSequence;\n\n  function requireSequence () {\n  \tif (hasRequiredSequence) return Sequence;\n  \thasRequiredSequence = 1;\n  \tObject.defineProperty(Sequence, \"__esModule\", { value: true });\n  \tSequence.Sequence = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Divert_1 = requireDivert$1();\n  \tconst Value_1 = requireValue();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst Object_1 = require_Object();\n  \tconst SequenceDivertToResolve_1 = requireSequenceDivertToResolve();\n  \tconst SequenceType_1 = requireSequenceType();\n  \tconst Weave_1 = requireWeave();\n  \tlet Sequence$1 = class Sequence extends Object_1.ParsedObject {\n  \t    constructor(elementContentLists, sequenceType) {\n  \t        super();\n  \t        this.sequenceType = sequenceType;\n  \t        this._sequenceDivertsToResolve = [];\n  \t        // Generate runtime code that looks like:\n  \t        //\n  \t        //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"\n  \t        //   if chosenIndex == 0, divert to s0\n  \t        //   if chosenIndex == 1, divert to s1  [etc]\n  \t        //\n  \t        //   - s0:\n  \t        //      <content for sequence element>\n  \t        //      divert to no-op\n  \t        //   - s1:\n  \t        //      <content for sequence element>\n  \t        //      divert to no-op\n  \t        //   - s2:\n  \t        //      empty branch if using \"once\"\n  \t        //      divert to no-op\n  \t        //\n  \t        //    no-op\n  \t        //\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            container.visitsShouldBeCounted = true;\n  \t            container.countingAtStartOnly = true;\n  \t            this._sequenceDivertsToResolve = [];\n  \t            // Get sequence read count\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t            container.AddContent(ControlCommand_1.ControlCommand.VisitIndex());\n  \t            const once = (this.sequenceType & SequenceType_1.SequenceType.Once) > 0;\n  \t            const cycle = (this.sequenceType & SequenceType_1.SequenceType.Cycle) > 0;\n  \t            const stopping = (this.sequenceType & SequenceType_1.SequenceType.Stopping) > 0;\n  \t            const shuffle = (this.sequenceType & SequenceType_1.SequenceType.Shuffle) > 0;\n  \t            let seqBranchCount = this.sequenceElements.length;\n  \t            if (once) {\n  \t                seqBranchCount += 1;\n  \t            }\n  \t            // Chosen sequence index:\n  \t            //  - Stopping: take the MIN(read count, num elements - 1)\n  \t            //  - Once: take the MIN(read count, num elements)\n  \t            //    (the last one being empty)\n  \t            if (stopping || once) {\n  \t                //var limit = stopping ? seqBranchCount-1 : seqBranchCount;\n  \t                container.AddContent(new Value_1.IntValue(seqBranchCount - 1));\n  \t                container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"MIN\"));\n  \t            }\n  \t            else if (cycle) {\n  \t                // - Cycle: take (read count % num elements)\n  \t                container.AddContent(new Value_1.IntValue(this.sequenceElements.length));\n  \t                container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"%\"));\n  \t            }\n  \t            // Shuffle\n  \t            if (shuffle) {\n  \t                // Create point to return to when sequence is complete\n  \t                const postShuffleNoOp = ControlCommand_1.ControlCommand.NoOp();\n  \t                // When visitIndex == lastIdx, we skip the shuffle\n  \t                if (once || stopping) {\n  \t                    // if( visitIndex == lastIdx ) -> skipShuffle\n  \t                    const lastIdx = stopping\n  \t                        ? this.sequenceElements.length - 1\n  \t                        : this.sequenceElements.length;\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.Duplicate());\n  \t                    container.AddContent(new Value_1.IntValue(lastIdx));\n  \t                    container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"==\"));\n  \t                    const skipShuffleDivert = new Divert_1.Divert();\n  \t                    skipShuffleDivert.isConditional = true;\n  \t                    container.AddContent(skipShuffleDivert);\n  \t                    this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);\n  \t                }\n  \t                // This one's a bit more complex! Choose the index at runtime.\n  \t                let elementCountToShuffle = this.sequenceElements.length;\n  \t                if (stopping) {\n  \t                    elementCountToShuffle -= 1;\n  \t                }\n  \t                container.AddContent(new Value_1.IntValue(elementCountToShuffle));\n  \t                container.AddContent(ControlCommand_1.ControlCommand.SequenceShuffleIndex());\n  \t                if (once || stopping) {\n  \t                    container.AddContent(postShuffleNoOp);\n  \t                }\n  \t            }\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t            // Create point to return to when sequence is complete\n  \t            const postSequenceNoOp = ControlCommand_1.ControlCommand.NoOp();\n  \t            // Each of the main sequence branches, and one extra empty branch if\n  \t            // we have a \"once\" sequence.\n  \t            for (let elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {\n  \t                // This sequence element:\n  \t                //  if( chosenIndex == this index ) divert to this sequence element\n  \t                // duplicate chosen sequence index, since it'll be consumed by \"==\"\n  \t                container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t                container.AddContent(ControlCommand_1.ControlCommand.Duplicate());\n  \t                container.AddContent(new Value_1.IntValue(elIndex));\n  \t                container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"==\"));\n  \t                container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t                // Divert branch for this sequence element\n  \t                const sequenceDivert = new Divert_1.Divert();\n  \t                sequenceDivert.isConditional = true;\n  \t                container.AddContent(sequenceDivert);\n  \t                let contentContainerForSequenceBranch;\n  \t                // Generate content for this sequence element\n  \t                if (elIndex < this.sequenceElements.length) {\n  \t                    const el = this.sequenceElements[elIndex];\n  \t                    contentContainerForSequenceBranch =\n  \t                        el.runtimeObject;\n  \t                }\n  \t                else {\n  \t                    // Final empty branch for \"once\" sequences\n  \t                    contentContainerForSequenceBranch = new Container_1.Container();\n  \t                }\n  \t                contentContainerForSequenceBranch.name = `s${elIndex}`;\n  \t                contentContainerForSequenceBranch.InsertContent(ControlCommand_1.ControlCommand.PopEvaluatedValue(), 0);\n  \t                // When sequence element is complete, divert back to end of sequence\n  \t                const seqBranchCompleteDivert = new Divert_1.Divert();\n  \t                contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);\n  \t                container.AddToNamedContentOnly(contentContainerForSequenceBranch);\n  \t                // Save the diverts for reference resolution later (in ResolveReferences)\n  \t                this.AddDivertToResolve(sequenceDivert, contentContainerForSequenceBranch);\n  \t                this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);\n  \t            }\n  \t            container.AddContent(postSequenceNoOp);\n  \t            return container;\n  \t        };\n  \t        this.AddDivertToResolve = (divert, targetContent) => {\n  \t            this._sequenceDivertsToResolve.push(new SequenceDivertToResolve_1.SequenceDivertToResolve(divert, targetContent));\n  \t        };\n  \t        this.sequenceType = sequenceType;\n  \t        this.sequenceElements = [];\n  \t        for (const elementContentList of elementContentLists) {\n  \t            const contentObjs = elementContentList.content;\n  \t            let seqElObject = null;\n  \t            // Don't attempt to create a weave for the sequence element\n  \t            // if the content list is empty. Weaves don't like it!\n  \t            if (contentObjs === null || contentObjs.length === 0) {\n  \t                seqElObject = elementContentList;\n  \t            }\n  \t            else {\n  \t                seqElObject = new Weave_1.Weave(contentObjs);\n  \t            }\n  \t            this.sequenceElements.push(seqElObject);\n  \t            this.AddContent(seqElObject);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"Sequence\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        for (const toResolve of this._sequenceDivertsToResolve) {\n  \t            toResolve.divert.targetPath = toResolve.targetContent.path;\n  \t        }\n  \t    }\n  \t};\n  \tSequence.Sequence = Sequence$1;\n  \t\n  \treturn Sequence;\n  }\n\n  var TunnelOnwards = {};\n\n  var hasRequiredTunnelOnwards;\n\n  function requireTunnelOnwards () {\n  \tif (hasRequiredTunnelOnwards) return TunnelOnwards;\n  \thasRequiredTunnelOnwards = 1;\n  \tObject.defineProperty(TunnelOnwards, \"__esModule\", { value: true });\n  \tTunnelOnwards.TunnelOnwards = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Divert_1 = requireDivert$1();\n  \tconst Value_1 = requireValue();\n  \tconst Object_1 = require_Object();\n  \tconst Void_1 = requireVoid();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst VariableReference_1 = requireVariableReference$1();\n  \tlet TunnelOnwards$1 = class TunnelOnwards extends Object_1.ParsedObject {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this._overrideDivertTarget = null;\n  \t        this._divertAfter = null;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            const container = new Container_1.Container();\n  \t            // Set override path for tunnel onwards (or nothing)\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t            if (this.divertAfter) {\n  \t                // Generate runtime object's generated code and steal the arguments runtime code\n  \t                const returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();\n  \t                const returnRuntimeContainer = returnRuntimeObj;\n  \t                if (returnRuntimeContainer) {\n  \t                    // Steal all code for generating arguments from the divert\n  \t                    const args = this.divertAfter.args;\n  \t                    if (args !== null && args.length > 0) {\n  \t                        // Steal everything betwen eval start and eval end\n  \t                        let evalStart = -1;\n  \t                        let evalEnd = -1;\n  \t                        for (let ii = 0; ii < returnRuntimeContainer.content.length; ii += 1) {\n  \t                            const cmd = returnRuntimeContainer.content[ii];\n  \t                            if (cmd) {\n  \t                                if (evalStart == -1 &&\n  \t                                    cmd.commandType === ControlCommand_1.ControlCommand.CommandType.EvalStart) {\n  \t                                    evalStart = ii;\n  \t                                }\n  \t                                else if (cmd.commandType === ControlCommand_1.ControlCommand.CommandType.EvalEnd) {\n  \t                                    evalEnd = ii;\n  \t                                }\n  \t                            }\n  \t                        }\n  \t                        for (let ii = evalStart + 1; ii < evalEnd; ii += 1) {\n  \t                            const obj = returnRuntimeContainer.content[ii];\n  \t                            obj.parent = null; // prevent error of being moved between owners\n  \t                            container.AddContent(returnRuntimeContainer.content[ii]);\n  \t                        }\n  \t                    }\n  \t                }\n  \t                // Supply the divert target for the tunnel onwards target, either variable or more commonly, the explicit name\n  \t                // var returnDivertObj = returnRuntimeObj as Runtime.Divert;\n  \t                let returnDivertObj = (0, TypeAssertion_1.asOrNull)(returnRuntimeObj, Divert_1.Divert);\n  \t                if (returnDivertObj != null && returnDivertObj.hasVariableTarget) {\n  \t                    let runtimeVarRef = new VariableReference_1.VariableReference(returnDivertObj.variableDivertName);\n  \t                    container.AddContent(runtimeVarRef);\n  \t                }\n  \t                else {\n  \t                    this._overrideDivertTarget = new Value_1.DivertTargetValue();\n  \t                    container.AddContent(this._overrideDivertTarget);\n  \t                }\n  \t            }\n  \t            else {\n  \t                // No divert after tunnel onwards\n  \t                container.AddContent(new Void_1.Void());\n  \t            }\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t            container.AddContent(ControlCommand_1.ControlCommand.PopTunnel());\n  \t            return container;\n  \t        };\n  \t        this.toString = () => {\n  \t            return ` -> ${this._divertAfter}`;\n  \t        };\n  \t    }\n  \t    get divertAfter() {\n  \t        return this._divertAfter;\n  \t    }\n  \t    set divertAfter(value) {\n  \t        this._divertAfter = value;\n  \t        if (this._divertAfter) {\n  \t            this.AddContent(this._divertAfter);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"TunnelOnwards\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        if (this.divertAfter && this.divertAfter.targetContent) {\n  \t            this._overrideDivertTarget.targetPath =\n  \t                this.divertAfter.targetContent.runtimePath;\n  \t        }\n  \t    }\n  \t};\n  \tTunnelOnwards.TunnelOnwards = TunnelOnwards$1;\n  \t\n  \treturn TunnelOnwards;\n  }\n\n  var VariableAssignment = {};\n\n  var ListDefinition = {};\n\n  var hasRequiredListDefinition;\n\n  function requireListDefinition () {\n  \tif (hasRequiredListDefinition) return ListDefinition;\n  \thasRequiredListDefinition = 1;\n  \tObject.defineProperty(ListDefinition, \"__esModule\", { value: true });\n  \tListDefinition.ListDefinition = void 0;\n  \tconst InkList_1 = requireInkList();\n  \tconst InkList_2 = requireInkList();\n  \tconst ListDefinition_1 = requireListDefinition$1();\n  \tconst Value_1 = requireValue();\n  \tconst Object_1 = require_Object();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tlet ListDefinition$1 = class ListDefinition extends Object_1.ParsedObject {\n  \t    get typeName() {\n  \t        return \"ListDefinition\";\n  \t    }\n  \t    get runtimeListDefinition() {\n  \t        var _a;\n  \t        const allItems = new Map();\n  \t        for (const e of this.itemDefinitions) {\n  \t            if (!allItems.has(e.name)) {\n  \t                allItems.set(e.name, e.seriesValue);\n  \t            }\n  \t            else {\n  \t                this.Error(`List '${this.identifier}' contains duplicate items called '${e.name}'`);\n  \t            }\n  \t        }\n  \t        return new ListDefinition_1.ListDefinition(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\", allItems);\n  \t    }\n  \t    constructor(itemDefinitions) {\n  \t        super();\n  \t        this.itemDefinitions = itemDefinitions;\n  \t        this.identifier = null;\n  \t        this.variableAssignment = null;\n  \t        this._elementsByName = null;\n  \t        this.ItemNamed = (itemName) => {\n  \t            if (this._elementsByName === null) {\n  \t                this._elementsByName = new Map();\n  \t                for (const el of this.itemDefinitions) {\n  \t                    this._elementsByName.set(el.name, el);\n  \t                }\n  \t            }\n  \t            const foundElement = this._elementsByName.get(itemName) || null;\n  \t            return foundElement;\n  \t        };\n  \t        this.GenerateRuntimeObject = () => {\n  \t            var _a, _b;\n  \t            const initialValues = new InkList_1.InkList();\n  \t            for (const itemDef of this.itemDefinitions) {\n  \t                if (itemDef.inInitialList) {\n  \t                    const item = new InkList_2.InkListItem(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null, itemDef.name || null);\n  \t                    initialValues.Add(item, itemDef.seriesValue);\n  \t                }\n  \t            }\n  \t            // Set origin name, so\n  \t            initialValues.SetInitialOriginName(((_b = this.identifier) === null || _b === void 0 ? void 0 : _b.name) || \"\");\n  \t            return new Value_1.ListValue(initialValues);\n  \t        };\n  \t        let currentValue = 1;\n  \t        for (const e of this.itemDefinitions) {\n  \t            if (e.explicitValue !== null) {\n  \t                currentValue = e.explicitValue;\n  \t            }\n  \t            e.seriesValue = currentValue;\n  \t            currentValue += 1;\n  \t        }\n  \t        this.AddContent(itemDefinitions);\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        context.CheckForNamingCollisions(this, this.identifier, SymbolType_1.SymbolType.List);\n  \t    }\n  \t};\n  \tListDefinition.ListDefinition = ListDefinition$1;\n  \t\n  \treturn ListDefinition;\n  }\n\n  var hasRequiredVariableAssignment;\n\n  function requireVariableAssignment () {\n  \tif (hasRequiredVariableAssignment) return VariableAssignment;\n  \thasRequiredVariableAssignment = 1;\n  \tObject.defineProperty(VariableAssignment, \"__esModule\", { value: true });\n  \tVariableAssignment.VariableAssignment = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ClosestFlowBase_1 = requireClosestFlowBase();\n  \tconst ListDefinition_1 = requireListDefinition();\n  \tconst Object_1 = require_Object();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \tconst VariableReference_1 = requireVariableReference();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet VariableAssignment$1 = class VariableAssignment extends Object_1.ParsedObject {\n  \t    get variableName() {\n  \t        return this.variableIdentifier.name;\n  \t    }\n  \t    get typeName() {\n  \t        if (this.isNewTemporaryDeclaration) {\n  \t            return \"temp\";\n  \t        }\n  \t        else if (this.isGlobalDeclaration) {\n  \t            if (this.listDefinition !== null) {\n  \t                return \"LIST\";\n  \t            }\n  \t            return \"VAR\";\n  \t        }\n  \t        return \"variable assignment\";\n  \t    }\n  \t    get isDeclaration() {\n  \t        return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;\n  \t    }\n  \t    constructor({ assignedExpression, isGlobalDeclaration, isTemporaryNewDeclaration, listDef, variableIdentifier, }) {\n  \t        super();\n  \t        this._runtimeAssignment = null;\n  \t        this.expression = null;\n  \t        this.listDefinition = null;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            let newDeclScope = null;\n  \t            if (this.isGlobalDeclaration) {\n  \t                newDeclScope = this.story;\n  \t            }\n  \t            else if (this.isNewTemporaryDeclaration) {\n  \t                newDeclScope = (0, ClosestFlowBase_1.ClosestFlowBase)(this);\n  \t            }\n  \t            if (newDeclScope) {\n  \t                newDeclScope.AddNewVariableDeclaration(this);\n  \t            }\n  \t            // Global declarations don't generate actual procedural\n  \t            // runtime objects, but instead add a global variable to the story itself.\n  \t            // The story then initialises them all in one go at the start of the game.\n  \t            if (this.isGlobalDeclaration) {\n  \t                return null;\n  \t            }\n  \t            const container = new Container_1.Container();\n  \t            // The expression's runtimeObject is actually another nested container\n  \t            if (this.expression) {\n  \t                container.AddContent(this.expression.runtimeObject);\n  \t            }\n  \t            else if (this.listDefinition) {\n  \t                container.AddContent(this.listDefinition.runtimeObject);\n  \t            }\n  \t            this._runtimeAssignment = new VariableAssignment_1.VariableAssignment(this.variableName, this.isNewTemporaryDeclaration);\n  \t            container.AddContent(this._runtimeAssignment);\n  \t            return container;\n  \t        };\n  \t        this.toString = () => `${this.isGlobalDeclaration\n\t            ? \"VAR\"\n\t            : this.isNewTemporaryDeclaration\n\t                ? \"~ temp\"\n\t                : \"\"} ${this.variableName}`;\n  \t        this.variableIdentifier = variableIdentifier;\n  \t        this.isGlobalDeclaration = Boolean(isGlobalDeclaration);\n  \t        this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);\n  \t        // Defensive programming in case parsing of assignedExpression failed\n  \t        if (listDef instanceof ListDefinition_1.ListDefinition) {\n  \t            this.listDefinition = this.AddContent(listDef);\n  \t            this.listDefinition.variableAssignment = this;\n  \t            // List definitions are always global\n  \t            this.isGlobalDeclaration = true;\n  \t        }\n  \t        else if (assignedExpression) {\n  \t            this.expression = this.AddContent(assignedExpression);\n  \t        }\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        // List definitions are checked for conflicts separately\n  \t        if (this.isDeclaration && this.listDefinition === null) {\n  \t            context.CheckForNamingCollisions(this, this.variableIdentifier, this.isGlobalDeclaration ? SymbolType_1.SymbolType.Var : SymbolType_1.SymbolType.Temp);\n  \t        }\n  \t        // Initial VAR x = [intialValue] declaration, not re-assignment\n  \t        if (this.isGlobalDeclaration) {\n  \t            const variableReference = (0, TypeAssertion_1.asOrNull)(this.expression, VariableReference_1.VariableReference);\n  \t            if (variableReference &&\n  \t                !variableReference.isConstantReference &&\n  \t                !variableReference.isListItemReference) {\n  \t                this.Error(\"global variable assignments cannot refer to other variables, only literal values, constants and list items\");\n  \t            }\n  \t        }\n  \t        if (!this.isNewTemporaryDeclaration) {\n  \t            const resolvedVarAssignment = context.ResolveVariableWithName(this.variableName, this);\n  \t            if (!resolvedVarAssignment.found) {\n  \t                if (this.variableName in this.story.constants) {\n  \t                    this.Error(`Can't re-assign to a constant (do you need to use VAR when declaring '${this.variableName}'?)`, this);\n  \t                }\n  \t                else {\n  \t                    this.Error(`Variable could not be found to assign to: '${this.variableName}'`, this);\n  \t                }\n  \t            }\n  \t            // A runtime assignment may not have been generated if it's the initial global declaration,\n  \t            // since these are hoisted out and handled specially in Story.ExportRuntime.\n  \t            if (this._runtimeAssignment) {\n  \t                this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;\n  \t            }\n  \t        }\n  \t    }\n  \t};\n  \tVariableAssignment.VariableAssignment = VariableAssignment$1;\n  \t\n  \treturn VariableAssignment;\n  }\n\n  var hasRequiredWeave;\n\n  function requireWeave () {\n  \tif (hasRequiredWeave) return Weave;\n  \thasRequiredWeave = 1;\n  \tObject.defineProperty(Weave, \"__esModule\", { value: true });\n  \tWeave.Weave = void 0;\n  \tconst AuthorWarning_1 = requireAuthorWarning();\n  \tconst Choice_1 = requireChoice();\n  \tconst Conditional_1 = requireConditional();\n  \tconst ConstantDeclaration_1 = requireConstantDeclaration();\n  \tconst Container_1 = requireContainer();\n  \tconst Divert_1 = requireDivert();\n  \tconst Divert_2 = requireDivert$1();\n  \tconst DivertTarget_1 = requireDivertTarget();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst Gather_1 = requireGather();\n  \tconst GatherPointToResolve_1 = requireGatherPointToResolve();\n  \tconst Object_1 = require_Object();\n  \tconst Sequence_1 = requireSequence();\n  \tconst Text_1 = requireText();\n  \tconst TunnelOnwards_1 = requireTunnelOnwards();\n  \tconst VariableAssignment_1 = requireVariableAssignment();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \t// Used by the FlowBase when constructing the weave flow from\n  \t// a flat list of content objects.\n  \tlet Weave$1 = class Weave extends Object_1.ParsedObject {\n  \t    // Containers can be chained as multiple gather points\n  \t    // get created as the same indentation level.\n  \t    // rootContainer is always the first in the chain, while\n  \t    // currentContainer is the latest.\n  \t    get rootContainer() {\n  \t        if (!this._rootContainer) {\n  \t            this._rootContainer = this.GenerateRuntimeObject();\n  \t        }\n  \t        return this._rootContainer;\n  \t    }\n  \t    get namedWeavePoints() {\n  \t        return this._namedWeavePoints;\n  \t    }\n  \t    get lastParsedSignificantObject() {\n  \t        if (this.content.length === 0) {\n  \t            return null;\n  \t        }\n  \t        // Don't count extraneous newlines or VAR/CONST declarations,\n  \t        // since they're \"empty\" statements outside of the main flow.\n  \t        let lastObject = null;\n  \t        for (let ii = this.content.length - 1; ii >= 0; --ii) {\n  \t            lastObject = this.content[ii];\n  \t            let lastText = (0, TypeAssertion_1.asOrNull)(lastObject, Text_1.Text);\n  \t            if (lastText && lastText.text === \"\\n\") {\n  \t                continue;\n  \t            }\n  \t            if (this.IsGlobalDeclaration(lastObject)) {\n  \t                continue;\n  \t            }\n  \t            break;\n  \t        }\n  \t        const lastWeave = (0, TypeAssertion_1.asOrNull)(lastObject, Weave);\n  \t        if (lastWeave) {\n  \t            lastObject = lastWeave.lastParsedSignificantObject;\n  \t        }\n  \t        return lastObject;\n  \t    }\n  \t    constructor(cont, indentIndex = -1) {\n  \t        super();\n  \t        // Keep track of previous weave point (Choice or Gather)\n  \t        // at the current indentation level:\n  \t        //  - to add ordinary content to be nested under it\n  \t        //  - to add nested content under it when it's indented\n  \t        //  - to remove it from the list of loose ends when\n  \t        //     - it has indented content since it's no longer a loose end\n  \t        //     - it's a gather and it has a choice added to it\n  \t        this.previousWeavePoint = null;\n  \t        this.addContentToPreviousWeavePoint = false;\n  \t        // Used for determining whether the next Gather should auto-enter\n  \t        this.hasSeenChoiceInSection = false;\n  \t        this.currentContainer = null;\n  \t        this._unnamedGatherCount = 0;\n  \t        this._choiceCount = 0;\n  \t        this._rootContainer = null;\n  \t        this._namedWeavePoints = new Map();\n  \t        // Loose ends are:\n  \t        //  - Choices or Gathers that need to be joined up\n  \t        //  - Explicit Divert to gather points (i.e. \"->\" without a target)\n  \t        this.looseEnds = [];\n  \t        this.gatherPointsToResolve = [];\n  \t        this.ResolveWeavePointNaming = () => {\n  \t            var _a, _b, _c;\n  \t            const namedWeavePoints = [\n  \t                ...this.FindAll(Gather_1.Gather)((w) => !(w.name === null || w.name === undefined)),\n  \t                ...this.FindAll(Choice_1.Choice)((w) => !(w.name === null || w.name === undefined)),\n  \t            ];\n  \t            this._namedWeavePoints = new Map();\n  \t            for (const weavePoint of namedWeavePoints) {\n  \t                // Check for weave point naming collisions\n  \t                const existingWeavePoint = this.namedWeavePoints.get(((_a = weavePoint.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\");\n  \t                if (existingWeavePoint) {\n  \t                    const typeName = existingWeavePoint instanceof Gather_1.Gather ? \"gather\" : \"choice\";\n  \t                    const existingObj = existingWeavePoint;\n  \t                    this.Error(`A ${typeName} with the same label name '${weavePoint.name}' already exists in this context on line ${existingObj.debugMetadata\n\t                        ? existingObj.debugMetadata.startLineNumber\n\t                        : \"NO DEBUG METADATA AVAILABLE\"}`, weavePoint);\n  \t                }\n  \t                if ((_b = weavePoint.identifier) === null || _b === void 0 ? void 0 : _b.name) {\n  \t                    this.namedWeavePoints.set((_c = weavePoint.identifier) === null || _c === void 0 ? void 0 : _c.name, weavePoint);\n  \t                }\n  \t            }\n  \t        };\n  \t        this.ConstructWeaveHierarchyFromIndentation = () => {\n  \t            // Find nested indentation and convert to a proper object hierarchy\n  \t            // (i.e. indented content is replaced with a Weave object that contains\n  \t            // that nested content)\n  \t            let contentIdx = 0;\n  \t            while (contentIdx < this.content.length) {\n  \t                const obj = this.content[contentIdx];\n  \t                // Choice or Gather\n  \t                if (obj instanceof Choice_1.Choice || obj instanceof Gather_1.Gather) {\n  \t                    const weavePoint = obj;\n  \t                    const weaveIndentIdx = weavePoint.indentationDepth - 1;\n  \t                    // Inner level indentation - recurse\n  \t                    if (weaveIndentIdx > this.baseIndentIndex) {\n  \t                        // Step through content until indent jumps out again\n  \t                        let innerWeaveStartIdx = contentIdx;\n  \t                        while (contentIdx < this.content.length) {\n  \t                            const innerWeaveObj = (0, TypeAssertion_1.asOrNull)(this.content[contentIdx], Choice_1.Choice) ||\n  \t                                (0, TypeAssertion_1.asOrNull)(this.content[contentIdx], Gather_1.Gather);\n  \t                            if (innerWeaveObj !== null) {\n  \t                                const innerIndentIdx = innerWeaveObj.indentationDepth - 1;\n  \t                                if (innerIndentIdx <= this.baseIndentIndex) {\n  \t                                    break;\n  \t                                }\n  \t                            }\n  \t                            contentIdx += 1;\n  \t                        }\n  \t                        const weaveContentCount = contentIdx - innerWeaveStartIdx;\n  \t                        const weaveContent = this.content.slice(innerWeaveStartIdx, innerWeaveStartIdx + weaveContentCount);\n  \t                        this.content.splice(innerWeaveStartIdx, weaveContentCount);\n  \t                        const weave = new Weave(weaveContent, weaveIndentIdx);\n  \t                        this.InsertContent(innerWeaveStartIdx, weave);\n  \t                        // Continue iteration from this point\n  \t                        contentIdx = innerWeaveStartIdx;\n  \t                    }\n  \t                }\n  \t                contentIdx += 1;\n  \t            }\n  \t        };\n  \t        // When the indentation wasn't told to us at construction time using\n  \t        // a choice point with a known indentation level, we may be told to\n  \t        // determine the indentation level by incrementing from our closest ancestor.\n  \t        this.DetermineBaseIndentationFromContent = (contentList) => {\n  \t            for (const obj of contentList) {\n  \t                if (obj instanceof Choice_1.Choice || obj instanceof Gather_1.Gather) {\n  \t                    return obj.indentationDepth - 1;\n  \t                }\n  \t            }\n  \t            // No weave points, so it doesn't matter\n  \t            return 0;\n  \t        };\n  \t        this.GenerateRuntimeObject = () => {\n  \t            this._rootContainer = new Container_1.Container();\n  \t            this.currentContainer = this._rootContainer;\n  \t            this.looseEnds = [];\n  \t            this.gatherPointsToResolve = [];\n  \t            // Iterate through content for the block at this level of indentation\n  \t            //  - Normal content is nested under Choices and Gathers\n  \t            //  - Blocks that are further indented cause recursion\n  \t            //  - Keep track of loose ends so that they can be diverted to Gathers\n  \t            for (const obj of this.content) {\n  \t                // Choice or Gather\n  \t                if (obj instanceof Choice_1.Choice || obj instanceof Gather_1.Gather) {\n  \t                    this.AddRuntimeForWeavePoint(obj);\n  \t                }\n  \t                else {\n  \t                    // Non-weave point\n  \t                    if (obj instanceof Weave) {\n  \t                        // Nested weave\n  \t                        const weave = obj;\n  \t                        this.AddRuntimeForNestedWeave(weave);\n  \t                        this.gatherPointsToResolve.splice(0, 0, ...weave.gatherPointsToResolve);\n  \t                    }\n  \t                    else {\n  \t                        // Other object\n  \t                        // May be complex object that contains statements - e.g. a multi-line conditional\n  \t                        this.AddGeneralRuntimeContent(obj.runtimeObject);\n  \t                    }\n  \t                }\n  \t            }\n  \t            // Pass any loose ends up the hierarhcy\n  \t            this.PassLooseEndsToAncestors();\n  \t            return this._rootContainer;\n  \t        };\n  \t        // Found gather point:\n  \t        //  - gather any loose ends\n  \t        //  - set the gather as the main container to dump new content in\n  \t        this.AddRuntimeForGather = (gather) => {\n  \t            // Determine whether this Gather should be auto-entered:\n  \t            //  - It is auto-entered if there were no choices in the last section\n  \t            //  - A section is \"since the previous gather\" - so reset now\n  \t            const autoEnter = !this.hasSeenChoiceInSection;\n  \t            this.hasSeenChoiceInSection = false;\n  \t            const gatherContainer = gather.runtimeContainer;\n  \t            if (!gather.name) {\n  \t                // Use disallowed character so it's impossible to have a name collision\n  \t                gatherContainer.name = `g-${this._unnamedGatherCount}`;\n  \t                this._unnamedGatherCount += 1;\n  \t            }\n  \t            if (autoEnter) {\n  \t                if (!this.currentContainer) {\n  \t                    throw new Error();\n  \t                }\n  \t                // Auto-enter: include in main content\n  \t                this.currentContainer.AddContent(gatherContainer);\n  \t            }\n  \t            else {\n  \t                // Don't auto-enter:\n  \t                // Add this gather to the main content, but only accessible\n  \t                // by name so that it isn't stepped into automatically, but only via\n  \t                // a divert from a loose end.\n  \t                this.rootContainer.AddToNamedContentOnly(gatherContainer);\n  \t            }\n  \t            // Consume loose ends: divert them to this gather\n  \t            for (const looseEndWeavePoint of this.looseEnds) {\n  \t                const looseEnd = looseEndWeavePoint;\n  \t                // Skip gather loose ends that are at the same level\n  \t                // since they'll be handled by the auto-enter code below\n  \t                // that only jumps into the gather if (current runtime choices == 0)\n  \t                if (looseEnd instanceof Gather_1.Gather) {\n  \t                    const prevGather = looseEnd;\n  \t                    if (prevGather.indentationDepth == gather.indentationDepth) {\n  \t                        continue;\n  \t                    }\n  \t                }\n  \t                let divert = null;\n  \t                if (looseEnd instanceof Divert_1.Divert) {\n  \t                    divert = looseEnd.runtimeObject;\n  \t                }\n  \t                else {\n  \t                    divert = new Divert_2.Divert();\n  \t                    const looseWeavePoint = looseEnd;\n  \t                    if (!looseWeavePoint.runtimeContainer) {\n  \t                        throw new Error();\n  \t                    }\n  \t                    looseWeavePoint.runtimeContainer.AddContent(divert);\n  \t                }\n  \t                // Pass back knowledge of this loose end being diverted\n  \t                // to the FlowBase so that it can maintain a list of them,\n  \t                // and resolve the divert references later\n  \t                this.gatherPointsToResolve.push(new GatherPointToResolve_1.GatherPointToResolve(divert, gatherContainer));\n  \t            }\n  \t            this.looseEnds = [];\n  \t            // Replace the current container itself\n  \t            this.currentContainer = gatherContainer;\n  \t        };\n  \t        this.AddRuntimeForWeavePoint = (weavePoint) => {\n  \t            // Current level Gather\n  \t            if (weavePoint instanceof Gather_1.Gather) {\n  \t                this.AddRuntimeForGather(weavePoint);\n  \t            }\n  \t            // Current level choice\n  \t            else if (weavePoint instanceof Choice_1.Choice) {\n  \t                if (!this.currentContainer) {\n  \t                    throw new Error();\n  \t                }\n  \t                // Gathers that contain choices are no longer loose ends\n  \t                // (same as when weave points get nested content)\n  \t                if (this.previousWeavePoint instanceof Gather_1.Gather) {\n  \t                    this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n  \t                }\n  \t                // Add choice point content\n  \t                const choice = weavePoint; //, Choice);\n  \t                this.currentContainer.AddContent(choice.runtimeObject);\n  \t                if (!choice.innerContentContainer) {\n  \t                    throw new Error();\n  \t                } //guaranteed not to happen\n  \t                // Add choice's inner content to self\n  \t                choice.innerContentContainer.name = `c-${this._choiceCount}`;\n  \t                this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);\n  \t                this._choiceCount += 1;\n  \t                this.hasSeenChoiceInSection = true;\n  \t            }\n  \t            // Keep track of loose ends\n  \t            this.addContentToPreviousWeavePoint = false; // default\n  \t            if (this.WeavePointHasLooseEnd(weavePoint)) {\n  \t                this.looseEnds.push(weavePoint);\n  \t                const looseChoice = (0, TypeAssertion_1.asOrNull)(weavePoint, Choice_1.Choice);\n  \t                if (looseChoice) {\n  \t                    this.addContentToPreviousWeavePoint = true;\n  \t                }\n  \t            }\n  \t            this.previousWeavePoint = weavePoint;\n  \t        };\n  \t        // Add nested block at a greater indentation level\n  \t        this.AddRuntimeForNestedWeave = (nestedResult) => {\n  \t            // Add this inner block to current container\n  \t            // (i.e. within the main container, or within the last defined Choice/Gather)\n  \t            this.AddGeneralRuntimeContent(nestedResult.rootContainer);\n  \t            // Now there's a deeper indentation level, the previous weave point doesn't\n  \t            // count as a loose end (since it will have content to go to)\n  \t            if (this.previousWeavePoint !== null) {\n  \t                this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n  \t                this.addContentToPreviousWeavePoint = false;\n  \t            }\n  \t        };\n  \t        // Normal content gets added into the latest Choice or Gather by default,\n  \t        // unless there hasn't been one yet.\n  \t        this.AddGeneralRuntimeContent = (content) => {\n  \t            // Content is allowed to evaluate runtimeObject to null\n  \t            // (e.g. AuthorWarning, which doesn't make it into the runtime)\n  \t            if (content === null) {\n  \t                return;\n  \t            }\n  \t            if (this.addContentToPreviousWeavePoint) {\n  \t                if (!this.previousWeavePoint ||\n  \t                    !this.previousWeavePoint.runtimeContainer) {\n  \t                    throw new Error();\n  \t                }\n  \t                this.previousWeavePoint.runtimeContainer.AddContent(content);\n  \t            }\n  \t            else {\n  \t                if (!this.currentContainer) {\n  \t                    throw new Error();\n  \t                }\n  \t                this.currentContainer.AddContent(content);\n  \t            }\n  \t        };\n  \t        this.PassLooseEndsToAncestors = () => {\n  \t            if (this.looseEnds.length === 0) {\n  \t                return;\n  \t            }\n  \t            // Search for Weave ancestor to pass loose ends to for gathering.\n  \t            // There are two types depending on whether the current weave\n  \t            // is separated by a conditional or sequence.\n  \t            //  - An \"inner\" weave is one that is directly connected to the current\n  \t            //    weave - i.e. you don't have to pass through a conditional or\n  \t            //    sequence to get to it. We're allowed to pass all loose ends to\n  \t            //    one of these.\n  \t            //  - An \"outer\" weave is one that is outside of a conditional/sequence\n  \t            //    that the current weave is nested within. We're only allowed to\n  \t            //    pass gathers (i.e. 'normal flow') loose ends up there, not normal\n  \t            //    choices. The rule is that choices have to be diverted explicitly\n  \t            //    by the author since it's ambiguous where flow should go otherwise.\n  \t            //\n  \t            // e.g.:\n  \t            //\n  \t            //   - top                       <- e.g. outer weave\n  \t            //   {true:\n  \t            //       * choice                <- e.g. inner weave\n  \t            //         * * choice 2\n  \t            //             more content      <- e.g. current weave\n  \t            //       * choice 2\n  \t            //   }\n  \t            //   - more of outer weave\n  \t            //\n  \t            let closestInnerWeaveAncestor = null;\n  \t            let closestOuterWeaveAncestor = null;\n  \t            // Find inner and outer ancestor weaves as defined above.\n  \t            let nested = false;\n  \t            for (let ancestor = this.parent; ancestor !== null; ancestor = ancestor.parent) {\n  \t                // Found ancestor?\n  \t                const weaveAncestor = (0, TypeAssertion_1.asOrNull)(ancestor, Weave);\n  \t                if (weaveAncestor) {\n  \t                    if (!nested && closestInnerWeaveAncestor === null) {\n  \t                        closestInnerWeaveAncestor = weaveAncestor;\n  \t                    }\n  \t                    if (nested && closestOuterWeaveAncestor === null) {\n  \t                        closestOuterWeaveAncestor = weaveAncestor;\n  \t                    }\n  \t                }\n  \t                // Weaves nested within Sequences or Conditionals are\n  \t                // \"sealed\" - any loose ends require explicit diverts.\n  \t                if (ancestor instanceof Sequence_1.Sequence || ancestor instanceof Conditional_1.Conditional) {\n  \t                    nested = true;\n  \t                }\n  \t            }\n  \t            // No weave to pass loose ends to at all?\n  \t            if (closestInnerWeaveAncestor === null &&\n  \t                closestOuterWeaveAncestor === null) {\n  \t                return;\n  \t            }\n  \t            // Follow loose end passing logic as defined above\n  \t            for (let ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {\n  \t                const looseEnd = this.looseEnds[ii];\n  \t                let received = false;\n  \t                if (nested) {\n  \t                    // This weave is nested within a conditional or sequence:\n  \t                    //  - choices can only be passed up to direct ancestor (\"inner\") weaves\n  \t                    //  - gathers can be passed up to either, but favour the closer (inner) weave\n  \t                    //    if there is one\n  \t                    if (looseEnd instanceof Choice_1.Choice && closestInnerWeaveAncestor !== null) {\n  \t                        closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n  \t                        received = true;\n  \t                    }\n  \t                    else if (!(looseEnd instanceof Choice_1.Choice)) {\n  \t                        const receivingWeave = closestInnerWeaveAncestor || closestOuterWeaveAncestor;\n  \t                        if (receivingWeave !== null) {\n  \t                            receivingWeave.ReceiveLooseEnd(looseEnd);\n  \t                            received = true;\n  \t                        }\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    // No nesting, all loose ends can be safely passed up\n  \t                    if (closestInnerWeaveAncestor === null || closestInnerWeaveAncestor === void 0 ? void 0 : closestInnerWeaveAncestor.hasOwnProperty(\"ReceiveLooseEnd\")) {\n  \t                        closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n  \t                    }\n  \t                    received = true;\n  \t                }\n  \t                if (received) {\n  \t                    this.looseEnds.splice(ii, 1);\n  \t                }\n  \t            }\n  \t        };\n  \t        this.ReceiveLooseEnd = (childWeaveLooseEnd) => {\n  \t            this.looseEnds.push(childWeaveLooseEnd);\n  \t        };\n  \t        this.WeavePointNamed = (name) => {\n  \t            if (!this.namedWeavePoints) {\n  \t                return null;\n  \t            }\n  \t            let weavePointResult = this.namedWeavePoints.get(name);\n  \t            if (weavePointResult) {\n  \t                return weavePointResult;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        // Global VARs and CONSTs are treated as \"outside of the flow\"\n  \t        // when iterating over content that follows loose ends\n  \t        this.IsGlobalDeclaration = (obj) => {\n  \t            const varAss = (0, TypeAssertion_1.asOrNull)(obj, VariableAssignment_1.VariableAssignment);\n  \t            if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {\n  \t                return true;\n  \t            }\n  \t            const constDecl = (0, TypeAssertion_1.asOrNull)(obj, ConstantDeclaration_1.ConstantDeclaration);\n  \t            if (constDecl) {\n  \t                return true;\n  \t            }\n  \t            return false;\n  \t        };\n  \t        // While analysing final loose ends, we look to see whether there\n  \t        // are any diverts etc which choices etc divert from\n  \t        this.ContentThatFollowsWeavePoint = (weavePoint) => {\n  \t            const returned = [];\n  \t            const obj = weavePoint;\n  \t            // Inner content first (e.g. for a choice)\n  \t            if (obj.content !== null) {\n  \t                for (const contentObj of obj.content) {\n  \t                    // Global VARs and CONSTs are treated as \"outside of the flow\"\n  \t                    if (this.IsGlobalDeclaration(contentObj)) {\n  \t                        continue;\n  \t                    }\n  \t                    returned.push(contentObj);\n  \t                }\n  \t            }\n  \t            const parentWeave = (0, TypeAssertion_1.asOrNull)(obj.parent, Weave);\n  \t            if (parentWeave === null) {\n  \t                throw new Error(\"Expected weave point parent to be weave?\");\n  \t            }\n  \t            const weavePointIdx = parentWeave.content.indexOf(obj);\n  \t            for (let ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {\n  \t                const laterObj = parentWeave.content[ii];\n  \t                // Global VARs and CONSTs are treated as \"outside of the flow\"\n  \t                if (this.IsGlobalDeclaration(laterObj)) {\n  \t                    continue;\n  \t                }\n  \t                // End of the current flow\n  \t                // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts\n  \t                if (laterObj instanceof Choice_1.Choice || laterObj instanceof Gather_1.Gather) {\n  \t                    break;\n  \t                }\n  \t                // Other weaves will be have their own loose ends\n  \t                if (laterObj instanceof Weave) {\n  \t                    break;\n  \t                }\n  \t                returned.push(laterObj);\n  \t            }\n  \t            return returned;\n  \t        };\n  \t        this.ValidateTermination = (badTerminationHandler) => {\n  \t            // Don't worry if the last object in the flow is a \"TODO\",\n  \t            // even if there are other loose ends in other places\n  \t            if (this.lastParsedSignificantObject instanceof AuthorWarning_1.AuthorWarning) {\n  \t                return;\n  \t            }\n  \t            // By now, any sub-weaves will have passed loose ends up to the root weave (this).\n  \t            // So there are 2 possible situations:\n  \t            //  - There are loose ends from somewhere in the flow.\n  \t            //    These aren't necessarily \"real\" loose ends - they're weave points\n  \t            //    that don't connect to any lower weave points, so we just\n  \t            //    have to check that they terminate properly.\n  \t            //  - This weave is just a list of content with no actual weave points,\n  \t            //    so we just need to check that the list of content terminates.\n  \t            const hasLooseEnds = this.looseEnds !== null && this.looseEnds.length > 0;\n  \t            if (hasLooseEnds) {\n  \t                for (const looseEnd of this.looseEnds) {\n  \t                    const looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);\n  \t                    this.ValidateFlowOfObjectsTerminates(looseEndFlow, looseEnd, badTerminationHandler);\n  \t                }\n  \t            }\n  \t            else {\n  \t                // No loose ends... is there any inner weaving at all?\n  \t                // If not, make sure the single content stream is terminated correctly\n  \t                //\n  \t                // If there's any actual weaving, assume that content is\n  \t                // terminated correctly since we would've had a loose end otherwise\n  \t                for (const obj of this.content) {\n  \t                    if (obj instanceof Choice_1.Choice || obj instanceof Divert_1.Divert) {\n  \t                        return;\n  \t                    }\n  \t                }\n  \t                // Straight linear flow? Check it terminates\n  \t                this.ValidateFlowOfObjectsTerminates(this.content, this, badTerminationHandler);\n  \t            }\n  \t        };\n  \t        this.BadNestedTerminationHandler = (terminatingObj) => {\n  \t            let conditional = null;\n  \t            for (let ancestor = terminatingObj.parent; ancestor !== null; ancestor = ancestor.parent) {\n  \t                if (ancestor instanceof Sequence_1.Sequence || ancestor instanceof Conditional_1.Conditional) {\n  \t                    conditional = (0, TypeAssertion_1.asOrNull)(ancestor, Conditional_1.Conditional);\n  \t                    break;\n  \t                }\n  \t            }\n  \t            let errorMsg = \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";\n  \t            // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.\n  \t            // { condition:\n  \t            //      * choice\n  \t            // }\n  \t            if (conditional !== null) {\n  \t                let numChoices = conditional.FindAll(Choice_1.Choice)().length;\n  \t                if (numChoices === 1) {\n  \t                    errorMsg = `Choices with conditions should be written: '* {condition} choice'. Otherwise, ${errorMsg.toLowerCase()}`;\n  \t                }\n  \t            }\n  \t            this.Error(errorMsg, terminatingObj);\n  \t        };\n  \t        this.ValidateFlowOfObjectsTerminates = (objFlow, defaultObj, badTerminationHandler) => {\n  \t            let terminated = false;\n  \t            let terminatingObj = defaultObj;\n  \t            for (const flowObj of objFlow) {\n  \t                const divert = flowObj.Find(Divert_1.Divert)((d) => !d.isThread &&\n  \t                    !d.isTunnel &&\n  \t                    !d.isFunctionCall &&\n  \t                    !(d.parent instanceof DivertTarget_1.DivertTarget));\n  \t                if (divert !== null) {\n  \t                    terminated = true;\n  \t                }\n  \t                if (flowObj.Find(TunnelOnwards_1.TunnelOnwards)() != null) {\n  \t                    terminated = true;\n  \t                    break;\n  \t                }\n  \t                terminatingObj = flowObj;\n  \t            }\n  \t            if (!terminated) {\n  \t                // Author has left a note to self here - clearly we don't need\n  \t                // to leave them with another warning since they know what they're doing.\n  \t                if (terminatingObj instanceof AuthorWarning_1.AuthorWarning) {\n  \t                    return;\n  \t                }\n  \t                badTerminationHandler(terminatingObj);\n  \t            }\n  \t        };\n  \t        this.WeavePointHasLooseEnd = (weavePoint) => {\n  \t            // No content, must be a loose end.\n  \t            if (weavePoint.content === null) {\n  \t                return true;\n  \t            }\n  \t            // If a weave point is diverted from, it doesn't have a loose end.\n  \t            // Detect a divert object within a weavePoint's main content\n  \t            // Work backwards since we're really interested in the end,\n  \t            // although it doesn't actually make a difference!\n  \t            // (content after a divert will simply be inaccessible)\n  \t            for (let ii = weavePoint.content.length - 1; ii >= 0; --ii) {\n  \t                let innerDivert = (0, TypeAssertion_1.asOrNull)(weavePoint.content[ii], Divert_1.Divert);\n  \t                if (innerDivert) {\n  \t                    const willReturn = innerDivert.isThread ||\n  \t                        innerDivert.isTunnel ||\n  \t                        innerDivert.isFunctionCall;\n  \t                    if (!willReturn) {\n  \t                        return false;\n  \t                    }\n  \t                }\n  \t            }\n  \t            return true;\n  \t        };\n  \t        // Enforce rule that weave points must not have the same\n  \t        // name as any stitches or knots upwards in the hierarchy\n  \t        this.CheckForWeavePointNamingCollisions = () => {\n  \t            if (!this.namedWeavePoints) {\n  \t                return;\n  \t            }\n  \t            const ancestorFlows = [];\n  \t            for (const obj of this.ancestry) {\n  \t                const flow = (0, TypeAssertion_1.asOrNull)(obj, FlowBase_1.FlowBase);\n  \t                if (flow) {\n  \t                    ancestorFlows.push(flow);\n  \t                }\n  \t                else {\n  \t                    break;\n  \t                }\n  \t            }\n  \t            for (const [weavePointName, weavePoint] of this.namedWeavePoints) {\n  \t                for (const flow of ancestorFlows) {\n  \t                    // Shallow search\n  \t                    const otherContentWithName = flow.ContentWithNameAtLevel(weavePointName);\n  \t                    if (otherContentWithName && otherContentWithName !== weavePoint) {\n  \t                        const errorMsg = `${weavePoint.GetType()} '${weavePointName}' has the same label name as a ${otherContentWithName.GetType()} (on ${otherContentWithName.debugMetadata})`;\n  \t                        this.Error(errorMsg, weavePoint);\n  \t                    }\n  \t                }\n  \t            }\n  \t        };\n  \t        if (indentIndex == -1) {\n  \t            this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);\n  \t        }\n  \t        else {\n  \t            this.baseIndentIndex = indentIndex;\n  \t        }\n  \t        this.AddContent(cont);\n  \t        this.ConstructWeaveHierarchyFromIndentation();\n  \t    }\n  \t    get typeName() {\n  \t        return \"Weave\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        // Check that choices nested within conditionals and sequences are terminated\n  \t        if (this.looseEnds !== null && this.looseEnds.length > 0) {\n  \t            let isNestedWeave = false;\n  \t            for (let ancestor = this.parent; ancestor !== null; ancestor = ancestor.parent) {\n  \t                if (ancestor instanceof Sequence_1.Sequence || ancestor instanceof Conditional_1.Conditional) {\n  \t                    isNestedWeave = true;\n  \t                    break;\n  \t                }\n  \t            }\n  \t            if (isNestedWeave) {\n  \t                this.ValidateTermination(this.BadNestedTerminationHandler);\n  \t            }\n  \t        }\n  \t        for (const gatherPoint of this.gatherPointsToResolve) {\n  \t            gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;\n  \t        }\n  \t        this.CheckForWeavePointNamingCollisions();\n  \t    }\n  \t};\n  \tWeave.Weave = Weave$1;\n  \t\n  \treturn Weave;\n  }\n\n  var hasRequiredConditionalSingleBranch;\n\n  function requireConditionalSingleBranch () {\n  \tif (hasRequiredConditionalSingleBranch) return ConditionalSingleBranch;\n  \thasRequiredConditionalSingleBranch = 1;\n  \tObject.defineProperty(ConditionalSingleBranch, \"__esModule\", { value: true });\n  \tConditionalSingleBranch.ConditionalSingleBranch = void 0;\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Divert_1 = requireDivert$1();\n  \tconst Object_1 = require_Object();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst Value_1 = requireValue();\n  \tconst Text_1 = requireText();\n  \tconst Weave_1 = requireWeave();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet ConditionalSingleBranch$1 = class ConditionalSingleBranch extends Object_1.ParsedObject {\n  \t    // When each branch has its own expression like a switch statement,\n  \t    // this is non-null. e.g.\n  \t    // { x:\n  \t    //    - 4: the value of x is four (ownExpression is the value 4)\n  \t    //    - 3: the value of x is three\n  \t    // }\n  \t    get ownExpression() {\n  \t        return this._ownExpression;\n  \t    }\n  \t    set ownExpression(value) {\n  \t        this._ownExpression = value;\n  \t        if (this._ownExpression) {\n  \t            this.AddContent(this._ownExpression);\n  \t        }\n  \t    }\n  \t    constructor(content) {\n  \t        super();\n  \t        this._contentContainer = null;\n  \t        this._conditionalDivert = null;\n  \t        this._ownExpression = null;\n  \t        this._innerWeave = null;\n  \t        // bool condition, e.g.:\n  \t        // { 5 == 4:\n  \t        //   - the true branch\n  \t        //   - the false branch\n  \t        // }\n  \t        this.isTrueBranch = false;\n  \t        // In the above example, match equality of x with 4 for the first branch.\n  \t        // This is as opposed to simply evaluating boolean equality for each branch,\n  \t        // example when shouldMatchEquality is FALSE:\n  \t        // {\n  \t        //    3 > 2:  This will happen\n  \t        //    2 > 3:  This won't happen\n  \t        // }\n  \t        this.matchingEquality = false;\n  \t        this.isElse = false;\n  \t        this.isInline = false;\n  \t        this.returnDivert = null;\n  \t        // Runtime content can be summarised as follows:\n  \t        //  - Evaluate an expression if necessary to branch on\n  \t        //  - Branch to a named container if true\n  \t        //       - Divert back to main flow\n  \t        //         (owner Conditional is in control of this target point)\n  \t        this.GenerateRuntimeObject = () => {\n  \t            // Check for common mistake, of putting \"else:\" instead of \"- else:\"\n  \t            if (this._innerWeave) {\n  \t                for (const c of this._innerWeave.content) {\n  \t                    const text = (0, TypeAssertion_1.asOrNull)(c, Text_1.Text);\n  \t                    if (text) {\n  \t                        // Don't need to trim at the start since the parser handles that already\n  \t                        if (text.text.startsWith(\"else:\")) {\n  \t                            this.Warning(\"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\", text);\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t            const container = new Container_1.Container();\n  \t            // Are we testing against a condition that's used for more than just this\n  \t            // branch? If so, the first thing we need to do is replicate the value that's\n  \t            // on the evaluation stack so that we don't fully consume it, in case other\n  \t            // branches need to use it.\n  \t            const duplicatesStackValue = this.matchingEquality && !this.isElse;\n  \t            if (duplicatesStackValue) {\n  \t                container.AddContent(ControlCommand_1.ControlCommand.Duplicate());\n  \t            }\n  \t            this._conditionalDivert = new Divert_1.Divert();\n  \t            // else clause is unconditional catch-all, otherwise the divert is conditional\n  \t            this._conditionalDivert.isConditional = !this.isElse;\n  \t            // Need extra evaluation?\n  \t            if (!this.isTrueBranch && !this.isElse) {\n  \t                const needsEval = this.ownExpression !== null;\n  \t                if (needsEval) {\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t                }\n  \t                if (this.ownExpression) {\n  \t                    this.ownExpression.GenerateIntoContainer(container);\n  \t                }\n  \t                // Uses existing duplicated value\n  \t                if (this.matchingEquality) {\n  \t                    container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"==\"));\n  \t                }\n  \t                if (needsEval) {\n  \t                    container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t                }\n  \t            }\n  \t            // Will pop from stack if conditional\n  \t            container.AddContent(this._conditionalDivert);\n  \t            this._contentContainer = this.GenerateRuntimeForContent();\n  \t            this._contentContainer.name = \"b\";\n  \t            // Multi-line conditionals get a newline at the start of each branch\n  \t            // (as opposed to the start of the multi-line conditional since the condition\n  \t            //  may evaluate to false.)\n  \t            if (!this.isInline) {\n  \t                this._contentContainer.InsertContent(new Value_1.StringValue(\"\\n\"), 0);\n  \t            }\n  \t            if (duplicatesStackValue || (this.isElse && this.matchingEquality)) {\n  \t                this._contentContainer.InsertContent(ControlCommand_1.ControlCommand.PopEvaluatedValue(), 0);\n  \t            }\n  \t            container.AddToNamedContentOnly(this._contentContainer);\n  \t            this.returnDivert = new Divert_1.Divert();\n  \t            this._contentContainer.AddContent(this.returnDivert);\n  \t            return container;\n  \t        };\n  \t        this.GenerateRuntimeForContent = () => {\n  \t            // Empty branch - create empty container\n  \t            if (this._innerWeave === null) {\n  \t                return new Container_1.Container();\n  \t            }\n  \t            return this._innerWeave.rootContainer;\n  \t        };\n  \t        // Branches are allowed to be empty\n  \t        if (content) {\n  \t            this._innerWeave = new Weave_1.Weave(content);\n  \t            this.AddContent(this._innerWeave);\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"ConditionalSingleBranch\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        if (!this._conditionalDivert || !this._contentContainer) {\n  \t            throw new Error();\n  \t        }\n  \t        this._conditionalDivert.targetPath = this._contentContainer.path;\n  \t        super.ResolveReferences(context);\n  \t    }\n  \t};\n  \tConditionalSingleBranch.ConditionalSingleBranch = ConditionalSingleBranch$1;\n  \t\n  \treturn ConditionalSingleBranch;\n  }\n\n  var CustomFlags = {};\n\n  var hasRequiredCustomFlags;\n\n  function requireCustomFlags () {\n  \tif (hasRequiredCustomFlags) return CustomFlags;\n  \thasRequiredCustomFlags = 1;\n  \tObject.defineProperty(CustomFlags, \"__esModule\", { value: true });\n  \tCustomFlags.CustomFlags = void 0;\n  \tvar CustomFlags$1;\n  \t(function (CustomFlags) {\n  \t    CustomFlags[CustomFlags[\"ParsingString\"] = 1] = \"ParsingString\";\n  \t    CustomFlags[CustomFlags[\"TagActive\"] = 2] = \"TagActive\";\n  \t})(CustomFlags$1 || (CustomFlags.CustomFlags = CustomFlags$1 = {}));\n  \t\n  \treturn CustomFlags;\n  }\n\n  var DebugMetadata = {};\n\n  var hasRequiredDebugMetadata;\n\n  function requireDebugMetadata () {\n  \tif (hasRequiredDebugMetadata) return DebugMetadata;\n  \thasRequiredDebugMetadata = 1;\n  \tObject.defineProperty(DebugMetadata, \"__esModule\", { value: true });\n  \tDebugMetadata.DebugMetadata = void 0;\n  \tlet DebugMetadata$1 = class DebugMetadata {\n  \t    constructor() {\n  \t        this.startLineNumber = 0;\n  \t        this.endLineNumber = 0;\n  \t        this.startCharacterNumber = 0;\n  \t        this.endCharacterNumber = 0;\n  \t        this.fileName = null;\n  \t        this.sourceName = null;\n  \t    }\n  \t    Merge(dm) {\n  \t        let newDebugMetadata = new DebugMetadata();\n  \t        newDebugMetadata.fileName = this.fileName;\n  \t        newDebugMetadata.sourceName = this.sourceName;\n  \t        if (this.startLineNumber < dm.startLineNumber) {\n  \t            newDebugMetadata.startLineNumber = this.startLineNumber;\n  \t            newDebugMetadata.startCharacterNumber = this.startCharacterNumber;\n  \t        }\n  \t        else if (this.startLineNumber > dm.startLineNumber) {\n  \t            newDebugMetadata.startLineNumber = dm.startLineNumber;\n  \t            newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;\n  \t        }\n  \t        else {\n  \t            newDebugMetadata.startLineNumber = this.startLineNumber;\n  \t            newDebugMetadata.startCharacterNumber = Math.min(this.startCharacterNumber, dm.startCharacterNumber);\n  \t        }\n  \t        if (this.endLineNumber > dm.endLineNumber) {\n  \t            newDebugMetadata.endLineNumber = this.endLineNumber;\n  \t            newDebugMetadata.endCharacterNumber = this.endCharacterNumber;\n  \t        }\n  \t        else if (this.endLineNumber < dm.endLineNumber) {\n  \t            newDebugMetadata.endLineNumber = dm.endLineNumber;\n  \t            newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;\n  \t        }\n  \t        else {\n  \t            newDebugMetadata.endLineNumber = this.endLineNumber;\n  \t            newDebugMetadata.endCharacterNumber = Math.max(this.endCharacterNumber, dm.endCharacterNumber);\n  \t        }\n  \t        return newDebugMetadata;\n  \t    }\n  \t    toString() {\n  \t        if (this.fileName !== null) {\n  \t            return `line ${this.startLineNumber} of ${this.fileName}\"`;\n  \t        }\n  \t        else {\n  \t            return \"line \" + this.startLineNumber;\n  \t        }\n  \t    }\n  \t};\n  \tDebugMetadata.DebugMetadata = DebugMetadata$1;\n  \t\n  \treturn DebugMetadata;\n  }\n\n  var ExternalDeclaration = {};\n\n  var hasRequiredExternalDeclaration;\n\n  function requireExternalDeclaration () {\n  \tif (hasRequiredExternalDeclaration) return ExternalDeclaration;\n  \thasRequiredExternalDeclaration = 1;\n  \tObject.defineProperty(ExternalDeclaration, \"__esModule\", { value: true });\n  \tExternalDeclaration.ExternalDeclaration = void 0;\n  \tconst Object_1 = require_Object();\n  \tlet ExternalDeclaration$1 = class ExternalDeclaration extends Object_1.ParsedObject {\n  \t    get name() {\n  \t        var _a;\n  \t        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n  \t    }\n  \t    constructor(identifier, argumentNames) {\n  \t        super();\n  \t        this.identifier = identifier;\n  \t        this.argumentNames = argumentNames;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            this.story.AddExternal(this);\n  \t            // No runtime code exists for an external, only metadata\n  \t            return null;\n  \t        };\n  \t    }\n  \t    get typeName() {\n  \t        return \"EXTERNAL\";\n  \t    }\n  \t    toString() {\n  \t        var _a;\n  \t        return `EXTERNAL ${(_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name}`;\n  \t    }\n  \t};\n  \tExternalDeclaration.ExternalDeclaration = ExternalDeclaration$1;\n  \t\n  \treturn ExternalDeclaration;\n  }\n\n  var FlowDecl = {};\n\n  var hasRequiredFlowDecl;\n\n  function requireFlowDecl () {\n  \tif (hasRequiredFlowDecl) return FlowDecl;\n  \thasRequiredFlowDecl = 1;\n  \tObject.defineProperty(FlowDecl, \"__esModule\", { value: true });\n  \tFlowDecl.FlowDecl = void 0;\n  \tlet FlowDecl$1 = class FlowDecl {\n  \t    constructor(name, args, isFunction) {\n  \t        this.name = name;\n  \t        this.args = args;\n  \t        this.isFunction = isFunction;\n  \t    }\n  \t};\n  \tFlowDecl.FlowDecl = FlowDecl$1;\n  \t\n  \treturn FlowDecl;\n  }\n\n  var Glue = {};\n\n  var Wrap = {};\n\n  var hasRequiredWrap;\n\n  function requireWrap () {\n  \tif (hasRequiredWrap) return Wrap;\n  \thasRequiredWrap = 1;\n  \tObject.defineProperty(Wrap, \"__esModule\", { value: true });\n  \tWrap.Wrap = void 0;\n  \tconst Object_1 = require_Object();\n  \tlet Wrap$1 = class Wrap extends Object_1.ParsedObject {\n  \t    constructor(_objToWrap) {\n  \t        super();\n  \t        this._objToWrap = _objToWrap;\n  \t        this.GenerateRuntimeObject = () => this._objToWrap;\n  \t    }\n  \t};\n  \tWrap.Wrap = Wrap$1;\n  \t\n  \treturn Wrap;\n  }\n\n  var hasRequiredGlue;\n\n  function requireGlue () {\n  \tif (hasRequiredGlue) return Glue;\n  \thasRequiredGlue = 1;\n  \tObject.defineProperty(Glue, \"__esModule\", { value: true });\n  \tGlue.Glue = void 0;\n  \tconst Wrap_1 = requireWrap();\n  \tlet Glue$1 = class Glue extends Wrap_1.Wrap {\n  \t    constructor(glue) {\n  \t        super(glue);\n  \t    }\n  \t    get typeName() {\n  \t        return \"Glue\";\n  \t    }\n  \t};\n  \tGlue.Glue = Glue$1;\n  \t\n  \treturn Glue;\n  }\n\n  var IncDecExpression = {};\n\n  var hasRequiredIncDecExpression;\n\n  function requireIncDecExpression () {\n  \tif (hasRequiredIncDecExpression) return IncDecExpression;\n  \thasRequiredIncDecExpression = 1;\n  \tObject.defineProperty(IncDecExpression, \"__esModule\", { value: true });\n  \tIncDecExpression.IncDecExpression = void 0;\n  \tconst ContentList_1 = requireContentList();\n  \tconst Expression_1 = requireExpression();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst NativeFunctionCall_1 = requireNativeFunctionCall();\n  \tconst Value_1 = requireValue();\n  \tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \tconst VariableReference_1 = requireVariableReference$1();\n  \tconst Weave_1 = requireWeave();\n  \tlet IncDecExpression$1 = class IncDecExpression extends Expression_1.Expression {\n  \t    constructor(varIdentifier, isIncOrExpression, isInc) {\n  \t        super();\n  \t        this.varIdentifier = varIdentifier;\n  \t        this._runtimeAssignment = null;\n  \t        this.expression = null;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            // x = x + y\n  \t            // ^^^ ^ ^ ^\n  \t            //  4  1 3 2\n  \t            // Reverse polish notation: (x 1 +) (assign to x)\n  \t            var _a, _b;\n  \t            // 1.\n  \t            container.AddContent(new VariableReference_1.VariableReference(((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name) || null));\n  \t            // 2.\n  \t            // - Expression used in the form ~ x += y\n  \t            // - Simple version: ~ x++\n  \t            if (this.expression) {\n  \t                this.expression.GenerateIntoContainer(container);\n  \t            }\n  \t            else {\n  \t                container.AddContent(new Value_1.IntValue(1));\n  \t            }\n  \t            // 3.\n  \t            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\"));\n  \t            // 4.\n  \t            this._runtimeAssignment = new VariableAssignment_1.VariableAssignment(((_b = this.varIdentifier) === null || _b === void 0 ? void 0 : _b.name) || null, false);\n  \t            container.AddContent(this._runtimeAssignment);\n  \t        };\n  \t        this.toString = () => {\n  \t            var _a, _b;\n  \t            if (this.expression) {\n  \t                return `${(_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name}${this.isInc ? \" += \" : \" -= \"}${this.expression}`;\n  \t            }\n  \t            return `${(_b = this.varIdentifier) === null || _b === void 0 ? void 0 : _b.name}` + (this.isInc ? \"++\" : \"--\");\n  \t        };\n  \t        if (isIncOrExpression instanceof Expression_1.Expression) {\n  \t            this.expression = isIncOrExpression;\n  \t            this.AddContent(this.expression);\n  \t            this.isInc = Boolean(isInc);\n  \t        }\n  \t        else {\n  \t            this.isInc = isIncOrExpression;\n  \t        }\n  \t    }\n  \t    get typeName() {\n  \t        return \"IncDecExpression\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        var _a;\n  \t        super.ResolveReferences(context);\n  \t        const varResolveResult = context.ResolveVariableWithName(((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name) || \"\", this);\n  \t        if (!varResolveResult.found) {\n  \t            this.Error(`variable for ${this.incrementDecrementWord} could not be found: '${this.varIdentifier}' after searching: {this.descriptionOfScope}`);\n  \t        }\n  \t        if (!this._runtimeAssignment) {\n  \t            throw new Error();\n  \t        }\n  \t        this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;\n  \t        if (!(this.parent instanceof Weave_1.Weave) &&\n  \t            !(this.parent instanceof FlowBase_1.FlowBase) &&\n  \t            !(this.parent instanceof ContentList_1.ContentList)) {\n  \t            this.Error(`Can't use ${this.incrementDecrementWord} as sub-expression`);\n  \t        }\n  \t    }\n  \t    get incrementDecrementWord() {\n  \t        if (this.isInc) {\n  \t            return \"increment\";\n  \t        }\n  \t        return \"decrement\";\n  \t    }\n  \t};\n  \tIncDecExpression.IncDecExpression = IncDecExpression$1;\n  \t\n  \treturn IncDecExpression;\n  }\n\n  var IncludedFile = {};\n\n  var hasRequiredIncludedFile;\n\n  function requireIncludedFile () {\n  \tif (hasRequiredIncludedFile) return IncludedFile;\n  \thasRequiredIncludedFile = 1;\n  \tObject.defineProperty(IncludedFile, \"__esModule\", { value: true });\n  \tIncludedFile.IncludedFile = void 0;\n  \tconst Object_1 = require_Object();\n  \tlet IncludedFile$1 = class IncludedFile extends Object_1.ParsedObject {\n  \t    constructor(includedStory) {\n  \t        super();\n  \t        this.includedStory = includedStory;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            // Left to the main story to process\n  \t            return null;\n  \t        };\n  \t    }\n  \t    get typeName() {\n  \t        return \"IncludedFile\";\n  \t    }\n  \t};\n  \tIncludedFile.IncludedFile = IncludedFile$1;\n  \t\n  \treturn IncludedFile;\n  }\n\n  var InfixOperator = {};\n\n  var hasRequiredInfixOperator;\n\n  function requireInfixOperator () {\n  \tif (hasRequiredInfixOperator) return InfixOperator;\n  \thasRequiredInfixOperator = 1;\n  \tObject.defineProperty(InfixOperator, \"__esModule\", { value: true });\n  \tInfixOperator.InfixOperator = void 0;\n  \tlet InfixOperator$1 = class InfixOperator {\n  \t    constructor(type, precedence, requireWhitespace) {\n  \t        this.type = type;\n  \t        this.precedence = precedence;\n  \t        this.requireWhitespace = requireWhitespace;\n  \t        this.toString = () => this.type;\n  \t    }\n  \t};\n  \tInfixOperator.InfixOperator = InfixOperator$1;\n  \t\n  \treturn InfixOperator;\n  }\n\n  var Knot = {};\n\n  var hasRequiredKnot;\n\n  function requireKnot () {\n  \tif (hasRequiredKnot) return Knot;\n  \thasRequiredKnot = 1;\n  \tObject.defineProperty(Knot, \"__esModule\", { value: true });\n  \tKnot.Knot = void 0;\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst FlowLevel_1 = requireFlowLevel();\n  \tlet Knot$1 = class Knot extends FlowBase_1.FlowBase {\n  \t    get flowLevel() {\n  \t        return FlowLevel_1.FlowLevel.Knot;\n  \t    }\n  \t    constructor(name, topLevelObjects, args, isFunction) {\n  \t        super(name, topLevelObjects, args, isFunction);\n  \t    }\n  \t    get typeName() {\n  \t        return this.isFunction ? \"Function\" : \"Knot\";\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        let parentStory = this.story;\n  \t        // Enforce rule that stitches must not have the same\n  \t        // name as any knots that exist in the story\n  \t        for (const stitchName in this.subFlowsByName) {\n  \t            const knotWithStitchName = parentStory.ContentWithNameAtLevel(stitchName, FlowLevel_1.FlowLevel.Knot, false);\n  \t            if (knotWithStitchName) {\n  \t                const stitch = this.subFlowsByName.get(stitchName);\n  \t                const errorMsg = `Stitch '${stitch ? stitch.name : \"NO STITCH FOUND\"}' has the same name as a knot (on ${knotWithStitchName.debugMetadata})`;\n  \t                this.Error(errorMsg, stitch);\n  \t            }\n  \t        }\n  \t    }\n  \t};\n  \tKnot.Knot = Knot$1;\n  \t\n  \treturn Knot;\n  }\n\n  var List = {};\n\n  var hasRequiredList;\n\n  function requireList () {\n  \tif (hasRequiredList) return List;\n  \thasRequiredList = 1;\n  \tObject.defineProperty(List, \"__esModule\", { value: true });\n  \tList.List = void 0;\n  \tconst Expression_1 = requireExpression();\n  \tconst InkList_1 = requireInkList();\n  \tconst InkList_2 = requireInkList();\n  \tconst Value_1 = requireValue();\n  \tlet List$1 = class List extends Expression_1.Expression {\n  \t    constructor(itemIdentifierList) {\n  \t        super();\n  \t        this.itemIdentifierList = itemIdentifierList;\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            var _a, _b;\n  \t            const runtimeRawList = new InkList_1.InkList();\n  \t            if (this.itemIdentifierList != null) {\n  \t                for (const itemIdentifier of this.itemIdentifierList) {\n  \t                    const nameParts = ((_a = itemIdentifier === null || itemIdentifier === void 0 ? void 0 : itemIdentifier.name) === null || _a === void 0 ? void 0 : _a.split(\".\")) || [];\n  \t                    let listName = null;\n  \t                    let listItemName = \"\";\n  \t                    if (nameParts.length > 1) {\n  \t                        listName = nameParts[0];\n  \t                        listItemName = nameParts[1];\n  \t                    }\n  \t                    else {\n  \t                        listItemName = nameParts[0];\n  \t                    }\n  \t                    const listItem = this.story.ResolveListItem(listName, listItemName, this);\n  \t                    if (listItem === null) {\n  \t                        if (listName === null) {\n  \t                            this.Error(`Could not find list definition that contains item '${itemIdentifier}'`);\n  \t                        }\n  \t                        else {\n  \t                            this.Error(`Could not find list item ${itemIdentifier}`);\n  \t                        }\n  \t                    }\n  \t                    else {\n  \t                        if (listItem.parent == null) {\n  \t                            this.Error(`Could not find list definition for item ${itemIdentifier}`);\n  \t                            return;\n  \t                        }\n  \t                        if (!listName) {\n  \t                            listName = ((_b = listItem.parent.identifier) === null || _b === void 0 ? void 0 : _b.name) || null;\n  \t                        }\n  \t                        const item = new InkList_2.InkListItem(listName, listItem.name || null);\n  \t                        if (runtimeRawList.has(item.serialized())) {\n  \t                            this.Warning(`Duplicate of item '${itemIdentifier}' in list.`);\n  \t                        }\n  \t                        else {\n  \t                            runtimeRawList.Add(item, listItem.seriesValue);\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t            container.AddContent(new Value_1.ListValue(runtimeRawList));\n  \t        };\n  \t    }\n  \t    get typeName() {\n  \t        return \"List\";\n  \t    }\n  \t};\n  \tList.List = List$1;\n  \t\n  \treturn List;\n  }\n\n  var ListElementDefinition = {};\n\n  var hasRequiredListElementDefinition;\n\n  function requireListElementDefinition () {\n  \tif (hasRequiredListElementDefinition) return ListElementDefinition;\n  \thasRequiredListElementDefinition = 1;\n  \tObject.defineProperty(ListElementDefinition, \"__esModule\", { value: true });\n  \tListElementDefinition.ListElementDefinition = void 0;\n  \tconst Object_1 = require_Object();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tlet ListElementDefinition$1 = class ListElementDefinition extends Object_1.ParsedObject {\n  \t    get fullName() {\n  \t        var _a;\n  \t        const parentList = this.parent;\n  \t        if (parentList === null) {\n  \t            throw new Error(\"Can't get full name without a parent list.\");\n  \t        }\n  \t        return `${(_a = parentList.identifier) === null || _a === void 0 ? void 0 : _a.name}.${this.name}`;\n  \t    }\n  \t    get typeName() {\n  \t        return \"ListElement\";\n  \t    }\n  \t    get name() {\n  \t        var _a;\n  \t        return ((_a = this.indentifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n  \t    }\n  \t    constructor(indentifier, inInitialList, explicitValue = null) {\n  \t        super();\n  \t        this.indentifier = indentifier;\n  \t        this.inInitialList = inInitialList;\n  \t        this.explicitValue = explicitValue;\n  \t        this.seriesValue = 0;\n  \t        this.parent = null;\n  \t        this.GenerateRuntimeObject = () => {\n  \t            throw new Error(\"Not implemented.\");\n  \t        };\n  \t        this.toString = () => this.fullName;\n  \t        this.parent = this.parent;\n  \t    }\n  \t    ResolveReferences(context) {\n  \t        super.ResolveReferences(context);\n  \t        context.CheckForNamingCollisions(this, this.indentifier, SymbolType_1.SymbolType.ListItem);\n  \t    }\n  \t};\n  \tListElementDefinition.ListElementDefinition = ListElementDefinition$1;\n  \t\n  \treturn ListElementDefinition;\n  }\n\n  var StatementLevel = {};\n\n  var hasRequiredStatementLevel;\n\n  function requireStatementLevel () {\n  \tif (hasRequiredStatementLevel) return StatementLevel;\n  \thasRequiredStatementLevel = 1;\n  \tObject.defineProperty(StatementLevel, \"__esModule\", { value: true });\n  \tStatementLevel.StatementLevel = void 0;\n  \tvar StatementLevel$1;\n  \t(function (StatementLevel) {\n  \t    StatementLevel[StatementLevel[\"InnerBlock\"] = 0] = \"InnerBlock\";\n  \t    StatementLevel[StatementLevel[\"Stitch\"] = 1] = \"Stitch\";\n  \t    StatementLevel[StatementLevel[\"Knot\"] = 2] = \"Knot\";\n  \t    StatementLevel[StatementLevel[\"Top\"] = 3] = \"Top\";\n  \t})(StatementLevel$1 || (StatementLevel.StatementLevel = StatementLevel$1 = {}));\n  \t\n  \treturn StatementLevel;\n  }\n\n  var Stitch = {};\n\n  var hasRequiredStitch;\n\n  function requireStitch () {\n  \tif (hasRequiredStitch) return Stitch;\n  \thasRequiredStitch = 1;\n  \tObject.defineProperty(Stitch, \"__esModule\", { value: true });\n  \tStitch.Stitch = void 0;\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst FlowLevel_1 = requireFlowLevel();\n  \tlet Stitch$1 = class Stitch extends FlowBase_1.FlowBase {\n  \t    get flowLevel() {\n  \t        return FlowLevel_1.FlowLevel.Stitch;\n  \t    }\n  \t    constructor(name, topLevelObjects, args, isFunction) {\n  \t        super(name, topLevelObjects, args, isFunction);\n  \t        // Fixes TS issue with not being able to access the prototype via `super` in functions\n  \t        // attached to the class as properties.\n  \t        this.baseToString = this.toString;\n  \t        this.toString = () => {\n  \t            return `${this.parent !== null ? this.parent + \" > \" : \"\"}${this.baseToString()}`;\n  \t        };\n  \t    }\n  \t    get typeName() {\n  \t        return \"Stitch\";\n  \t    }\n  \t};\n  \tStitch.Stitch = Stitch$1;\n  \t\n  \treturn Stitch;\n  }\n\n  var Story$1 = {};\n\n  var hasRequiredStory;\n\n  function requireStory () {\n  \tif (hasRequiredStory) return Story$1;\n  \thasRequiredStory = 1;\n  \tObject.defineProperty(Story$1, \"__esModule\", { value: true });\n  \tStory$1.Story = void 0;\n  \tconst AuthorWarning_1 = requireAuthorWarning();\n  \tconst ConstantDeclaration_1 = requireConstantDeclaration();\n  \tconst Container_1 = requireContainer();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst ErrorType_1 = requireErrorType();\n  \tconst FlowBase_1 = requireFlowBase();\n  \tconst FlowLevel_1 = requireFlowLevel();\n  \tconst IncludedFile_1 = requireIncludedFile();\n  \tconst ListDefinition_1 = requireListDefinition();\n  \tconst ListElementDefinition_1 = requireListElementDefinition();\n  \tconst Story_1 = requireStory$1();\n  \tconst SymbolType_1 = requireSymbolType();\n  \tconst Text_1 = requireText();\n  \tconst VariableAssignment_1 = requireVariableAssignment$1();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst ClosestFlowBase_1 = requireClosestFlowBase();\n  \tconst FunctionCall_1 = requireFunctionCall();\n  \tconst Path_1 = requirePath();\n  \tclass Story extends FlowBase_1.FlowBase {\n  \t    get flowLevel() {\n  \t        return FlowLevel_1.FlowLevel.Story;\n  \t    }\n  \t    get hadError() {\n  \t        return this._hadError;\n  \t    }\n  \t    get hadWarning() {\n  \t        return this._hadWarning;\n  \t    }\n  \t    constructor(toplevelObjects, isInclude = false) {\n  \t        // Don't do anything much on construction, leave it lightweight until\n  \t        // the ExportRuntime method is called.\n  \t        super(null, toplevelObjects, null, false, isInclude);\n  \t        this._errorHandler = null;\n  \t        this._hadError = false;\n  \t        this._hadWarning = false;\n  \t        this._dontFlattenContainers = new Set();\n  \t        this._listDefs = new Map();\n  \t        this.constants = new Map();\n  \t        this.externals = new Map();\n  \t        // Build setting for exporting:\n  \t        // When true, the visit count for *all* knots, stitches, choices,\n  \t        // and gathers is counted. When false, only those that are direclty\n  \t        // referenced by the ink are recorded. Use this flag to allow game-side\n  \t        // querying of  arbitrary knots/stitches etc.\n  \t        // Storing all counts is more robust and future proof (updates to the story file\n  \t        // that reference previously uncounted visits are possible, but generates a much\n  \t        // larger safe file, with a lot of potentially redundant counts.\n  \t        this.countAllVisits = false;\n  \t        this.ExportRuntime = (errorHandler = null) => {\n  \t            var _a, _b;\n  \t            this._errorHandler = errorHandler;\n  \t            // Find all constants before main export begins, so that VariableReferences know\n  \t            // whether to generate a runtime variable reference or the literal value\n  \t            this.constants = new Map();\n  \t            for (const constDecl of this.FindAll(ConstantDeclaration_1.ConstantDeclaration)()) {\n  \t                // Check for duplicate definitions\n  \t                const existingDefinition = this.constants.get(constDecl.constantName);\n  \t                if (existingDefinition) {\n  \t                    if (!existingDefinition.Equals(constDecl.expression)) {\n  \t                        const errorMsg = `CONST '${constDecl.constantName}' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on ${existingDefinition.debugMetadata}.`;\n  \t                        this.Error(errorMsg, constDecl, false);\n  \t                    }\n  \t                }\n  \t                this.constants.set(constDecl.constantName, constDecl.expression);\n  \t            }\n  \t            // List definitions are treated like constants too - they should be usable\n  \t            // from other variable declarations.\n  \t            this._listDefs = new Map();\n  \t            for (const listDef of this.FindAll(ListDefinition_1.ListDefinition)()) {\n  \t                if ((_a = listDef.identifier) === null || _a === void 0 ? void 0 : _a.name) {\n  \t                    this._listDefs.set((_b = listDef.identifier) === null || _b === void 0 ? void 0 : _b.name, listDef);\n  \t                }\n  \t            }\n  \t            this.externals = new Map();\n  \t            // Resolution of weave point names has to come first, before any runtime code generation\n  \t            // since names have to be ready before diverts start getting created.\n  \t            // (It used to be done in the constructor for a weave, but didn't allow us to generate\n  \t            // errors when name resolution failed.)\n  \t            this.ResolveWeavePointNaming();\n  \t            // Get default implementation of runtimeObject, which calls ContainerBase's generation method\n  \t            const rootContainer = this.runtimeObject;\n  \t            // Export initialisation of global variables\n  \t            // TODO: We *could* add this as a declarative block to the story itself...\n  \t            const variableInitialisation = new Container_1.Container();\n  \t            variableInitialisation.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n  \t            // Global variables are those that are local to the story and marked as global\n  \t            const runtimeLists = [];\n  \t            for (const [key, value] of this.variableDeclarations) {\n  \t                if (value.isGlobalDeclaration) {\n  \t                    if (value.listDefinition) {\n  \t                        this._listDefs.set(key, value.listDefinition);\n  \t                        variableInitialisation.AddContent(value.listDefinition.runtimeObject);\n  \t                        runtimeLists.push(value.listDefinition.runtimeListDefinition);\n  \t                    }\n  \t                    else {\n  \t                        if (!value.expression) {\n  \t                            throw new Error();\n  \t                        }\n  \t                        value.expression.GenerateIntoContainer(variableInitialisation);\n  \t                    }\n  \t                    const runtimeVarAss = new VariableAssignment_1.VariableAssignment(key, true);\n  \t                    runtimeVarAss.isGlobal = true;\n  \t                    variableInitialisation.AddContent(runtimeVarAss);\n  \t                }\n  \t            }\n  \t            variableInitialisation.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n  \t            variableInitialisation.AddContent(ControlCommand_1.ControlCommand.End());\n  \t            if (this.variableDeclarations.size > 0) {\n  \t                variableInitialisation.name = \"global decl\";\n  \t                rootContainer.AddToNamedContentOnly(variableInitialisation);\n  \t            }\n  \t            // Signal that it's safe to exit without error, even if there are no choices generated\n  \t            // (this only happens at the end of top level content that isn't in any particular knot)\n  \t            rootContainer.AddContent(ControlCommand_1.ControlCommand.Done());\n  \t            // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase\n  \t            const runtimeStory = new Story_1.Story(rootContainer, runtimeLists);\n  \t            this.runtimeObject = runtimeStory;\n  \t            if (this.hadError) {\n  \t                return null;\n  \t            }\n  \t            // Optimisation step - inline containers that can be\n  \t            this.FlattenContainersIn(rootContainer);\n  \t            // Now that the story has been fulled parsed into a hierarchy,\n  \t            // and the derived runtime hierarchy has been built, we can\n  \t            // resolve referenced symbols such as variables and paths.\n  \t            // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)\n  \t            // We don't make any assumptions that the INKPath follows the same\n  \t            // conventions as the script format, so we resolve to actual objects before\n  \t            // translating into an INKPath. (This also allows us to choose whether\n  \t            // we want the paths to be absolute)\n  \t            this.ResolveReferences(this);\n  \t            if (this.hadError) {\n  \t                return null;\n  \t            }\n  \t            runtimeStory.ResetState();\n  \t            return runtimeStory;\n  \t        };\n  \t        this.ResolveList = (listName) => {\n  \t            let list = this._listDefs.get(listName);\n  \t            if (!list) {\n  \t                return null;\n  \t            }\n  \t            return list;\n  \t        };\n  \t        this.ResolveListItem = (listName, itemName, source = null) => {\n  \t            let listDef = null;\n  \t            // Search a specific list if we know its name (i.e. the form listName.itemName)\n  \t            if (listName) {\n  \t                if (!(listDef = this._listDefs.get(listName))) {\n  \t                    return null;\n  \t                }\n  \t                return listDef.ItemNamed(itemName);\n  \t            }\n  \t            else {\n  \t                // Otherwise, try to search all lists\n  \t                let foundItem = null;\n  \t                let originalFoundList = null;\n  \t                for (const [, value] of this._listDefs.entries()) {\n  \t                    const itemInThisList = value.ItemNamed(itemName);\n  \t                    if (itemInThisList) {\n  \t                        if (foundItem) {\n  \t                            this.Error(`Ambiguous item name '${itemName}' found in multiple sets, including ${originalFoundList.identifier} and ${value.identifier}`, source, false);\n  \t                        }\n  \t                        else {\n  \t                            foundItem = itemInThisList;\n  \t                            originalFoundList = value;\n  \t                        }\n  \t                    }\n  \t                }\n  \t                return foundItem;\n  \t            }\n  \t        };\n  \t        this.FlattenContainersIn = (container) => {\n  \t            // Need to create a collection to hold the inner containers\n  \t            // because otherwise we'd end up modifying during iteration\n  \t            const innerContainers = new Set();\n  \t            if (container.content) {\n  \t                for (const c of container.content) {\n  \t                    const innerContainer = (0, TypeAssertion_1.asOrNull)(c, Container_1.Container);\n  \t                    if (innerContainer) {\n  \t                        innerContainers.add(innerContainer);\n  \t                    }\n  \t                }\n  \t            }\n  \t            // Can't flatten the named inner containers, but we can at least\n  \t            // iterate through their children\n  \t            if (container.namedContent) {\n  \t                for (const [, value] of container.namedContent) {\n  \t                    const namedInnerContainer = (0, TypeAssertion_1.asOrNull)(value, Container_1.Container);\n  \t                    if (namedInnerContainer) {\n  \t                        innerContainers.add(namedInnerContainer);\n  \t                    }\n  \t                }\n  \t            }\n  \t            for (const innerContainer of innerContainers) {\n  \t                this.TryFlattenContainer(innerContainer);\n  \t                this.FlattenContainersIn(innerContainer);\n  \t            }\n  \t        };\n  \t        this.TryFlattenContainer = (container) => {\n  \t            if ((container.namedContent && container.namedContent.size > 0) ||\n  \t                container.hasValidName ||\n  \t                this._dontFlattenContainers.has(container)) {\n  \t                return;\n  \t            }\n  \t            // Inline all the content in container into the parent\n  \t            const parentContainer = (0, TypeAssertion_1.asOrNull)(container.parent, Container_1.Container);\n  \t            if (parentContainer) {\n  \t                let contentIdx = parentContainer.content.indexOf(container);\n  \t                parentContainer.content.splice(contentIdx, 1);\n  \t                const dm = container.ownDebugMetadata;\n  \t                if (container.content) {\n  \t                    for (const innerContent of container.content) {\n  \t                        innerContent.parent = null;\n  \t                        if (dm !== null && innerContent.ownDebugMetadata === null) {\n  \t                            innerContent.debugMetadata = dm;\n  \t                        }\n  \t                        parentContainer.InsertContent(innerContent, contentIdx);\n  \t                        contentIdx += 1;\n  \t                    }\n  \t                }\n  \t            }\n  \t        };\n  \t        this.Error = (message, source, isWarning) => {\n  \t            let errorType = isWarning ? ErrorType_1.ErrorType.Warning : ErrorType_1.ErrorType.Error;\n  \t            let sb = \"\";\n  \t            if (source instanceof AuthorWarning_1.AuthorWarning) {\n  \t                sb += \"TODO: \";\n  \t                errorType = ErrorType_1.ErrorType.Author;\n  \t            }\n  \t            else if (isWarning) {\n  \t                sb += \"WARNING: \";\n  \t            }\n  \t            else {\n  \t                sb += \"ERROR: \";\n  \t            }\n  \t            if (source &&\n  \t                source.debugMetadata !== null &&\n  \t                source.debugMetadata.startLineNumber >= 1) {\n  \t                if (source.debugMetadata.fileName != null) {\n  \t                    sb += `'${source.debugMetadata.fileName}' `;\n  \t                }\n  \t                sb += `line ${source.debugMetadata.startLineNumber}: `;\n  \t            }\n  \t            sb += message;\n  \t            message = sb;\n  \t            if (this._errorHandler !== null) {\n  \t                this._errorHandler(message, errorType);\n  \t            }\n  \t            else {\n  \t                throw new Error(message);\n  \t            }\n  \t            this._hadError = errorType === ErrorType_1.ErrorType.Error;\n  \t            this._hadWarning = errorType === ErrorType_1.ErrorType.Warning;\n  \t        };\n  \t        this.ResetError = () => {\n  \t            this._hadError = false;\n  \t            this._hadWarning = false;\n  \t        };\n  \t        this.IsExternal = (namedFuncTarget) => this.externals.has(namedFuncTarget);\n  \t        this.AddExternal = (decl) => {\n  \t            if (this.externals.has(decl.name)) {\n  \t                this.Error(`Duplicate EXTERNAL definition of '${decl.name}'`, decl, false);\n  \t            }\n  \t            else if (decl.name) {\n  \t                this.externals.set(decl.name, decl);\n  \t            }\n  \t        };\n  \t        this.DontFlattenContainer = (container) => {\n  \t            this._dontFlattenContainers.add(container);\n  \t        };\n  \t        this.NameConflictError = (obj, name, existingObj, typeNameToPrint) => {\n  \t            obj.Error(`${typeNameToPrint} '${name}': name has already been used for a ${existingObj.typeName.toLowerCase()} on ${existingObj.debugMetadata}`);\n  \t        };\n  \t        // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).\n  \t        // When the given symbol type level is reached, we early-out / return.\n  \t        this.CheckForNamingCollisions = (obj, identifier, symbolType, typeNameOverride = \"\") => {\n  \t            var _a;\n  \t            const typeNameToPrint = typeNameOverride || obj.typeName;\n  \t            if (Story.IsReservedKeyword(identifier === null || identifier === void 0 ? void 0 : identifier.name)) {\n  \t                obj.Error(`'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a reserved keyword`);\n  \t                return;\n  \t            }\n  \t            else if (FunctionCall_1.FunctionCall.IsBuiltIn((identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\")) {\n  \t                obj.Error(`'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a built in function`);\n  \t                return;\n  \t            }\n  \t            // Top level knots\n  \t            const maybeKnotOrFunction = this.ContentWithNameAtLevel((identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", FlowLevel_1.FlowLevel.Knot);\n  \t            const knotOrFunction = (0, TypeAssertion_1.asOrNull)(maybeKnotOrFunction, FlowBase_1.FlowBase);\n  \t            if (knotOrFunction &&\n  \t                (knotOrFunction !== obj || symbolType === SymbolType_1.SymbolType.Arg)) {\n  \t                this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", knotOrFunction, typeNameToPrint);\n  \t                return;\n  \t            }\n  \t            if (symbolType < SymbolType_1.SymbolType.List) {\n  \t                return;\n  \t            }\n  \t            // Lists\n  \t            for (const [key, value] of this._listDefs) {\n  \t                if ((identifier === null || identifier === void 0 ? void 0 : identifier.name) === key &&\n  \t                    obj !== value &&\n  \t                    value.variableAssignment !== obj) {\n  \t                    this.NameConflictError(obj, identifier === null || identifier === void 0 ? void 0 : identifier.name, value, typeNameToPrint);\n  \t                }\n  \t                // We don't check for conflicts between individual elements in\n  \t                // different lists because they are namespaced.\n  \t                if (!(obj instanceof ListElementDefinition_1.ListElementDefinition)) {\n  \t                    for (const item of value.itemDefinitions) {\n  \t                        if ((identifier === null || identifier === void 0 ? void 0 : identifier.name) === item.name) {\n  \t                            this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", item, typeNameToPrint);\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t            // Don't check for VAR->VAR conflicts because that's handled separately\n  \t            // (necessary since checking looks up in a dictionary)\n  \t            if (symbolType <= SymbolType_1.SymbolType.Var) {\n  \t                return;\n  \t            }\n  \t            // Global variable collision\n  \t            const varDecl = ((identifier === null || identifier === void 0 ? void 0 : identifier.name) && this.variableDeclarations.get(identifier === null || identifier === void 0 ? void 0 : identifier.name)) ||\n  \t                null;\n  \t            if (varDecl &&\n  \t                varDecl !== obj &&\n  \t                varDecl.isGlobalDeclaration &&\n  \t                varDecl.listDefinition == null) {\n  \t                this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", varDecl, typeNameToPrint);\n  \t            }\n  \t            if (symbolType < SymbolType_1.SymbolType.SubFlowAndWeave) {\n  \t                return;\n  \t            }\n  \t            // Stitches, Choices and Gathers\n  \t            const path = new Path_1.Path(identifier);\n  \t            const targetContent = path.ResolveFromContext(obj);\n  \t            if (targetContent && targetContent !== obj) {\n  \t                this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", targetContent, typeNameToPrint);\n  \t                return;\n  \t            }\n  \t            if (symbolType < SymbolType_1.SymbolType.Arg) {\n  \t                return;\n  \t            }\n  \t            // Arguments to the current flow\n  \t            if (symbolType !== SymbolType_1.SymbolType.Arg) {\n  \t                let flow = (0, TypeAssertion_1.asOrNull)(obj, FlowBase_1.FlowBase);\n  \t                if (!flow) {\n  \t                    flow = (0, ClosestFlowBase_1.ClosestFlowBase)(obj);\n  \t                }\n  \t                if (flow && flow.hasParameters && flow.args) {\n  \t                    for (const arg of flow.args) {\n  \t                        if (((_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name) === (identifier === null || identifier === void 0 ? void 0 : identifier.name)) {\n  \t                            obj.Error(`${typeNameToPrint} '${identifier}': name has already been used for a argument to ${flow.identifier} on ${flow.debugMetadata}`);\n  \t                            return;\n  \t                        }\n  \t                    }\n  \t                }\n  \t            }\n  \t        };\n  \t    }\n  \t    get typeName() {\n  \t        return \"Story\";\n  \t    }\n  \t    // Before this function is called, we have IncludedFile objects interspersed\n  \t    // in our content wherever an include statement was.\n  \t    // So that the include statement can be added in a sensible place (e.g. the\n  \t    // top of the file) without side-effects of jumping into a knot that was\n  \t    // defined in that include, we separate knots and stitches from anything\n  \t    // else defined at the top scope of the included file.\n  \t    //\n  \t    // Algorithm: For each IncludedFile we find, split its contents into\n  \t    // knots/stiches and any other content. Insert the normal content wherever\n  \t    // the include statement was, and append the knots/stitches to the very\n  \t    // end of the main story.\n  \t    PreProcessTopLevelObjects(topLevelContent) {\n  \t        super.PreProcessTopLevelObjects(topLevelContent);\n  \t        const flowsFromOtherFiles = [];\n  \t        // Inject included files\n  \t        for (let obj of topLevelContent) {\n  \t            if (obj instanceof IncludedFile_1.IncludedFile) {\n  \t                const file = obj;\n  \t                // Remove the IncludedFile itself\n  \t                const posOfObj = topLevelContent.indexOf(obj);\n  \t                topLevelContent.splice(posOfObj, 1);\n  \t                // When an included story fails to load, the include\n  \t                // line itself is still valid, so we have to handle it here\n  \t                if (file.includedStory) {\n  \t                    const nonFlowContent = [];\n  \t                    const subStory = file.includedStory;\n  \t                    // Allow empty file\n  \t                    if (subStory.content != null) {\n  \t                        for (const subStoryObj of subStory.content) {\n  \t                            if (subStoryObj instanceof FlowBase_1.FlowBase) {\n  \t                                flowsFromOtherFiles.push(subStoryObj);\n  \t                            }\n  \t                            else {\n  \t                                nonFlowContent.push(subStoryObj);\n  \t                            }\n  \t                        }\n  \t                        // Add newline on the end of the include\n  \t                        nonFlowContent.push(new Text_1.Text(\"\\n\"));\n  \t                        // Add contents of the file in its place\n  \t                        topLevelContent.splice(posOfObj, 0, ...nonFlowContent);\n  \t                        // Skip past the content of this sub story\n  \t                        // (since it will already have recursively included\n  \t                        //  any lines from other files)\n  \t                    }\n  \t                }\n  \t                // Include object has been removed, with possible content inserted,\n  \t                // and position of 'i' will have been determined already.\n  \t                continue;\n  \t            }\n  \t        }\n  \t        // Add the flows we collected from the included files to the\n  \t        // end of our list of our content\n  \t        topLevelContent.splice(0, 0, ...flowsFromOtherFiles);\n  \t    }\n  \t}\n  \tStory$1.Story = Story;\n  \tStory.IsReservedKeyword = (name) => {\n  \t    switch (name) {\n  \t        case \"true\":\n  \t        case \"false\":\n  \t        case \"not\":\n  \t        case \"return\":\n  \t        case \"else\":\n  \t        case \"VAR\":\n  \t        case \"CONST\":\n  \t        case \"temp\":\n  \t        case \"LIST\":\n  \t        case \"function\":\n  \t            return true;\n  \t    }\n  \t    return false;\n  \t};\n  \t\n  \treturn Story$1;\n  }\n\n  var StringExpression = {};\n\n  var hasRequiredStringExpression;\n\n  function requireStringExpression () {\n  \tif (hasRequiredStringExpression) return StringExpression;\n  \thasRequiredStringExpression = 1;\n  \tObject.defineProperty(StringExpression, \"__esModule\", { value: true });\n  \tStringExpression.StringExpression = void 0;\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tconst Expression_1 = requireExpression();\n  \tconst Text_1 = requireText();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tlet StringExpression$1 = class StringExpression extends Expression_1.Expression {\n  \t    get isSingleString() {\n  \t        if (this.content.length !== 1) {\n  \t            return false;\n  \t        }\n  \t        const c = this.content[0];\n  \t        if (!(c instanceof Text_1.Text)) {\n  \t            return false;\n  \t        }\n  \t        return true;\n  \t    }\n  \t    constructor(content) {\n  \t        super();\n  \t        this.GenerateIntoContainer = (container) => {\n  \t            container.AddContent(ControlCommand_1.ControlCommand.BeginString());\n  \t            for (const c of this.content) {\n  \t                container.AddContent(c.runtimeObject);\n  \t            }\n  \t            container.AddContent(ControlCommand_1.ControlCommand.EndString());\n  \t        };\n  \t        this.toString = () => {\n  \t            let sb = \"\";\n  \t            for (const c of this.content) {\n  \t                sb += c;\n  \t            }\n  \t            return sb;\n  \t        };\n  \t        this.AddContent(content);\n  \t    }\n  \t    get typeName() {\n  \t        return \"String\";\n  \t    }\n  \t    // Equals override necessary in order to check for CONST multiple definition equality\n  \t    Equals(obj) {\n  \t        const otherStr = (0, TypeAssertion_1.asOrNull)(obj, StringExpression);\n  \t        if (otherStr === null) {\n  \t            return false;\n  \t        }\n  \t        // Can only compare direct equality on single strings rather than\n  \t        // complex string expressions that contain dynamic logic\n  \t        if (!this.isSingleString || !otherStr.isSingleString) {\n  \t            return false;\n  \t        }\n  \t        const thisTxt = this.toString();\n  \t        const otherTxt = otherStr.toString();\n  \t        return thisTxt === otherTxt;\n  \t    }\n  \t};\n  \tStringExpression.StringExpression = StringExpression$1;\n  \t\n  \treturn StringExpression;\n  }\n\n  var Tag = {};\n\n  var hasRequiredTag;\n\n  function requireTag () {\n  \tif (hasRequiredTag) return Tag;\n  \thasRequiredTag = 1;\n  \tObject.defineProperty(Tag, \"__esModule\", { value: true });\n  \tTag.LegacyTag = Tag.Tag = void 0;\n  \tconst Object_1 = require_Object();\n  \tconst ControlCommand_1 = requireControlCommand();\n  \tlet Tag$1 = class Tag extends Object_1.ParsedObject {\n  \t    constructor(isStart, inChoice = false) {\n  \t        super();\n  \t        this.GenerateRuntimeObject = () => {\n  \t            if (this.isStart) {\n  \t                return ControlCommand_1.ControlCommand.BeginTag();\n  \t            }\n  \t            else {\n  \t                return ControlCommand_1.ControlCommand.EndTag();\n  \t            }\n  \t        };\n  \t        this.toString = () => {\n  \t            if (this.isStart) {\n  \t                return \"#StartTag\";\n  \t            }\n  \t            else {\n  \t                return \"#EndTag\";\n  \t            }\n  \t        };\n  \t        this.isStart = isStart;\n  \t        this.inChoice = inChoice;\n  \t    }\n  \t    get typeName() {\n  \t        return \"Tag\";\n  \t    }\n  \t};\n  \tTag.Tag = Tag$1;\n  \tconst Wrap_1 = requireWrap();\n  \tclass LegacyTag extends Wrap_1.Wrap {\n  \t    constructor(tag) {\n  \t        super(tag);\n  \t    }\n  \t    get typeName() {\n  \t        return \"Tag\";\n  \t    }\n  \t}\n  \tTag.LegacyTag = LegacyTag;\n  \t\n  \treturn Tag;\n  }\n\n  var DefaultFileHandler = {};\n\n  var hasRequiredDefaultFileHandler;\n\n  function requireDefaultFileHandler () {\n  \tif (hasRequiredDefaultFileHandler) return DefaultFileHandler;\n  \thasRequiredDefaultFileHandler = 1;\n  \tObject.defineProperty(DefaultFileHandler, \"__esModule\", { value: true });\n  \tDefaultFileHandler.DefaultFileHandler = void 0;\n  \t// This class replaces upstream's DefaultFileHandler. It doesn't perform any\n  \t// resolution and warns the user about providing a proper file handler when\n  \t// INCLUDE statements are parsed. Since the JavaScript parser can be executed in\n  \t// different environments, we let the user decide which FileHandler is best for\n  \t// their use-case. See PosixFileHandler and JsonFileHandler.\n  \tlet DefaultFileHandler$1 = class DefaultFileHandler {\n  \t    constructor(rootPath) {\n  \t        this.rootPath = rootPath;\n  \t        this.ResolveInkFilename = () => {\n  \t            throw Error(\"Can't resolve filename because no FileHandler was provided when instantiating the parser / compiler.\");\n  \t        };\n  \t        this.LoadInkFileContents = () => {\n  \t            throw Error(\"Can't load ink content because no FileHandler was provided when instantiating the parser / compiler.\");\n  \t        };\n  \t    }\n  \t};\n  \tDefaultFileHandler.DefaultFileHandler = DefaultFileHandler$1;\n  \t\n  \treturn DefaultFileHandler;\n  }\n\n  var hasRequiredInkParser;\n\n  function requireInkParser () {\n  \tif (hasRequiredInkParser) return InkParser;\n  \thasRequiredInkParser = 1;\n  \tObject.defineProperty(InkParser, \"__esModule\", { value: true });\n  \tInkParser.InkParser = void 0;\n  \tconst Argument_1 = requireArgument();\n  \tconst AuthorWarning_1 = requireAuthorWarning();\n  \tconst BinaryExpression_1 = requireBinaryExpression();\n  \tconst CharacterRange_1 = requireCharacterRange();\n  \tconst CharacterSet_1 = requireCharacterSet();\n  \tconst Choice_1 = requireChoice();\n  \tconst CommentEliminator_1 = requireCommentEliminator();\n  \tconst Conditional_1 = requireConditional();\n  \tconst ConditionalSingleBranch_1 = requireConditionalSingleBranch();\n  \tconst ContentList_1 = requireContentList();\n  \tconst ConstantDeclaration_1 = requireConstantDeclaration();\n  \tconst CustomFlags_1 = requireCustomFlags();\n  \tconst DebugMetadata_1 = requireDebugMetadata();\n  \tconst Divert_1 = requireDivert();\n  \tconst DivertTarget_1 = requireDivertTarget();\n  \tconst Expression_1 = requireExpression();\n  \tconst ExternalDeclaration_1 = requireExternalDeclaration();\n  \tconst FlowDecl_1 = requireFlowDecl();\n  \tconst FunctionCall_1 = requireFunctionCall();\n  \tconst Gather_1 = requireGather();\n  \tconst Glue_1 = requireGlue();\n  \tconst Glue_2 = requireGlue$1();\n  \tconst IncDecExpression_1 = requireIncDecExpression();\n  \tconst IncludedFile_1 = requireIncludedFile();\n  \tconst InfixOperator_1 = requireInfixOperator();\n  \tconst Knot_1 = requireKnot();\n  \tconst List_1 = requireList();\n  \tconst ListDefinition_1 = requireListDefinition();\n  \tconst ListElementDefinition_1 = requireListElementDefinition();\n  \tconst MultipleConditionExpression_1 = requireMultipleConditionExpression();\n  \tconst Object_1 = require_Object();\n  \tconst Path_1 = requirePath();\n  \tconst ReturnType_1 = requireReturnType();\n  \tconst Sequence_1 = requireSequence();\n  \tconst SequenceType_1 = requireSequenceType();\n  \tconst StatementLevel_1 = requireStatementLevel();\n  \tconst Stitch_1 = requireStitch();\n  \tconst Story_1 = requireStory();\n  \tconst StringExpression_1 = requireStringExpression();\n  \tconst StringParser_1 = requireStringParser();\n  \tconst Tag_1 = requireTag();\n  \tconst Text_1 = requireText();\n  \tconst TunnelOnwards_1 = requireTunnelOnwards();\n  \tconst VariableAssignment_1 = requireVariableAssignment();\n  \tconst VariableReference_1 = requireVariableReference();\n  \tconst UnaryExpression_1 = requireUnaryExpression();\n  \tconst TypeAssertion_1 = requireTypeAssertion();\n  \tconst Identifier_1 = requireIdentifier();\n  \tconst NumberExpression_1 = requireNumberExpression();\n  \tconst ErrorType_1 = requireErrorType();\n  \tconst DefaultFileHandler_1 = requireDefaultFileHandler();\n  \tlet InkParser$1 = class InkParser extends StringParser_1.StringParser {\n  \t    /**\n  \t     * Begin base InkParser section.\n  \t     */\n  \t    get fileHandler() {\n  \t        if (!this._fileHandler) {\n  \t            throw new Error(\"No FileHandler defined\");\n  \t        }\n  \t        return this._fileHandler;\n  \t    }\n  \t    set fileHandler(value) {\n  \t        this._fileHandler = value;\n  \t    }\n  \t    constructor(str, filename = null, externalErrorHandler = null, rootParser = null, fileHandler = null) {\n  \t        super(str);\n  \t        // Main entry point\n  \t        // NOTE: This method is named Parse() in upstream.\n  \t        this.ParseStory = () => {\n  \t            const topLevelContent = this.StatementsAtLevel(StatementLevel_1.StatementLevel.Top);\n  \t            // Note we used to return null if there were any errors, but this would mean\n  \t            // that include files would return completely empty rather than attempting to\n  \t            // continue with errors. Returning an empty include files meant that anything\n  \t            // that *did* compile successfully would otherwise be ignored, generating way\n  \t            // more errors than necessary.\n  \t            return new Story_1.Story(topLevelContent, this._rootParser !== this);\n  \t        };\n  \t        this.SeparatedList = (mainRule, separatorRule) => {\n  \t            const firstElement = this.Parse(mainRule);\n  \t            if (firstElement === null) {\n  \t                return null;\n  \t            }\n  \t            const allElements = [];\n  \t            allElements.push(firstElement);\n  \t            do {\n  \t                const nextElementRuleId = this.BeginRule();\n  \t                let sep = separatorRule();\n  \t                if (sep === null) {\n  \t                    this.FailRule(nextElementRuleId);\n  \t                    break;\n  \t                }\n  \t                const nextElement = this.Parse(mainRule);\n  \t                if (nextElement === null) {\n  \t                    this.FailRule(nextElementRuleId);\n  \t                    break;\n  \t                }\n  \t                this.SucceedRule(nextElementRuleId);\n  \t                allElements.push(nextElement);\n  \t            } while (true);\n  \t            return allElements;\n  \t        };\n  \t        this.CreateDebugMetadata = (stateAtStart, stateAtEnd) => {\n  \t            const md = new DebugMetadata_1.DebugMetadata();\n  \t            md.startLineNumber = ((stateAtStart === null || stateAtStart === void 0 ? void 0 : stateAtStart.lineIndex) || 0) + 1;\n  \t            md.endLineNumber = stateAtEnd.lineIndex + 1;\n  \t            md.startCharacterNumber = ((stateAtStart === null || stateAtStart === void 0 ? void 0 : stateAtStart.characterInLineIndex) || 0) + 1;\n  \t            md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;\n  \t            md.fileName = this._filename;\n  \t            return md;\n  \t        };\n  \t        this.RuleDidSucceed = (result, stateAtStart, stateAtEnd) => {\n  \t            // Apply DebugMetadata based on the state at the start of the rule\n  \t            // (i.e. use line number as it was at the start of the rule)\n  \t            const parsedObj = (0, TypeAssertion_1.asOrNull)(result, Object_1.ParsedObject);\n  \t            if (parsedObj) {\n  \t                parsedObj.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n  \t            }\n  \t            // A list of objects that doesn't already have metadata?\n  \t            const parsedListObjs = Array.isArray(result)\n  \t                ? result\n  \t                : null;\n  \t            if (parsedListObjs !== null) {\n  \t                for (const parsedListObj of parsedListObjs) {\n  \t                    const singleObj = (0, TypeAssertion_1.asOrNull)(parsedListObj, Object_1.ParsedObject);\n  \t                    if (!singleObj)\n  \t                        continue;\n  \t                    if (!parsedListObj.hasOwnDebugMetadata) {\n  \t                        parsedListObj.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n  \t                    }\n  \t                }\n  \t            }\n  \t            const id = (0, TypeAssertion_1.asOrNull)(result, Identifier_1.Identifier);\n  \t            if (id != null) {\n  \t                id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n  \t            }\n  \t        };\n  \t        this.OnStringParserError = (message, index, lineIndex = 0, isWarning = false) => {\n  \t            const warningType = isWarning ? \"WARNING:\" : \"ERROR:\";\n  \t            let fullMessage = warningType;\n  \t            if (this._filename !== null) {\n  \t                fullMessage += ` '${this._filename}'`;\n  \t            }\n  \t            fullMessage += ` line ${lineIndex + 1}: ${message}`;\n  \t            if (this._externalErrorHandler !== null) {\n  \t                this._externalErrorHandler(fullMessage, isWarning ? ErrorType_1.ErrorType.Warning : ErrorType_1.ErrorType.Error);\n  \t            }\n  \t            else {\n  \t                throw new Error(fullMessage);\n  \t            }\n  \t        };\n  \t        this.AuthorWarning = () => {\n  \t            this.Whitespace();\n  \t            const identifier = this.Parse(this.IdentifierWithMetadata);\n  \t            if (identifier === null || identifier.name !== \"TODO\") {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            this.ParseString(\":\");\n  \t            this.Whitespace();\n  \t            const message = this.ParseUntilCharactersFromString(\"\\n\\r\");\n  \t            if (message) {\n  \t                return new AuthorWarning_1.AuthorWarning(message);\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ExtendIdentifierCharacterRanges = (identifierCharSet) => {\n  \t            const characterRanges = InkParser.ListAllCharacterRanges();\n  \t            for (const charRange of characterRanges) {\n  \t                identifierCharSet.AddCharacters(charRange.ToCharacterSet());\n  \t            }\n  \t        };\n  \t        /**\n  \t         * End CharacterRanges section.\n  \t         */\n  \t        /**\n  \t         * Begin Choices section.\n  \t         */\n  \t        this._parsingChoice = false;\n  \t        this.Choice = () => {\n  \t            let onceOnlyChoice = true;\n  \t            let bullets = this.Interleave(this.OptionalExclude(this.Whitespace), this.String(\"*\"));\n  \t            if (!bullets) {\n  \t                bullets = this.Interleave(this.OptionalExclude(this.Whitespace), this.String(\"+\"));\n  \t                if (bullets === null) {\n  \t                    return null;\n  \t                }\n  \t                onceOnlyChoice = false;\n  \t            }\n  \t            // Optional name for the choice\n  \t            const optionalName = this.Parse(this.BracketedName);\n  \t            this.Whitespace();\n  \t            // Allow optional newline right after a choice name\n  \t            if (optionalName != null)\n  \t                this.Newline();\n  \t            // Optional condition for whether the choice should be shown to the player\n  \t            const conditionExpr = this.Parse(this.ChoiceCondition);\n  \t            this.Whitespace();\n  \t            // Ordinarily we avoid parser state variables like these, since\n  \t            // nesting would require us to store them in a stack. But since you should\n  \t            // never be able to nest choices within choice content, it's fine here.\n  \t            if (this._parsingChoice) {\n  \t                throw new Error(\"Already parsing a choice - shouldn't have nested choices\");\n  \t            }\n  \t            this._parsingChoice = true;\n  \t            let startContent = null;\n  \t            const startTextAndLogic = this.Parse(this.MixedTextAndLogic);\n  \t            if (startTextAndLogic) {\n  \t                startContent = new ContentList_1.ContentList(startTextAndLogic);\n  \t            }\n  \t            let optionOnlyContent = null;\n  \t            let innerContent = null;\n  \t            // Check for a the weave style format:\n  \t            //   * \"Hello[.\"],\" he said.\n  \t            const hasWeaveStyleInlineBrackets = this.ParseString(\"[\") !== null;\n  \t            if (hasWeaveStyleInlineBrackets) {\n  \t                this.EndTagIfNecessary(startContent);\n  \t                const optionOnlyTextAndLogic = this.Parse(this.MixedTextAndLogic);\n  \t                if (optionOnlyTextAndLogic !== null) {\n  \t                    optionOnlyContent = new ContentList_1.ContentList(optionOnlyTextAndLogic);\n  \t                }\n  \t                this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");\n  \t                this.EndTagIfNecessary(optionOnlyContent);\n  \t                let innerTextAndLogic = this.Parse(this.MixedTextAndLogic);\n  \t                if (innerTextAndLogic !== null) {\n  \t                    innerContent = new ContentList_1.ContentList(innerTextAndLogic);\n  \t                }\n  \t            }\n  \t            this.Whitespace();\n  \t            this.EndTagIfNecessary(innerContent !== null && innerContent !== void 0 ? innerContent : startContent);\n  \t            // Finally, now we know we're at the end of the main choice body, parse\n  \t            // any diverts separately.\n  \t            const diverts = this.Parse(this.MultiDivert);\n  \t            this._parsingChoice = false;\n  \t            this.Whitespace();\n  \t            // Completely empty choice without even an empty divert?\n  \t            const emptyContent = !startContent && !innerContent && !optionOnlyContent;\n  \t            if (emptyContent && diverts === null) {\n  \t                this.Warning(\"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\");\n  \t            }\n  \t            if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {\n  \t                // * [] some text\n  \t                this.Warning(\"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\");\n  \t            }\n  \t            if (!innerContent) {\n  \t                innerContent = new ContentList_1.ContentList();\n  \t            }\n  \t            this.EndTagIfNecessary(innerContent);\n  \t            // Normal diverts on the end of a choice - simply add to the normal content\n  \t            if (diverts !== null) {\n  \t                for (const divObj of diverts) {\n  \t                    // may be TunnelOnwards\n  \t                    const div = (0, TypeAssertion_1.asOrNull)(divObj, Divert_1.Divert);\n  \t                    // Empty divert serves no purpose other than to say\n  \t                    // \"this choice is intentionally left blank\"\n  \t                    // (as an invisible default choice)\n  \t                    if (div && div.isEmpty) {\n  \t                        continue;\n  \t                    }\n  \t                    innerContent.AddContent(divObj);\n  \t                }\n  \t            }\n  \t            // Terminate main content with a newline since this is the end of the line\n  \t            // Note that this will be redundant if the diverts above definitely take\n  \t            // the flow away permanently.\n  \t            innerContent.AddContent(new Text_1.Text(\"\\n\"));\n  \t            const choice = new Choice_1.Choice(startContent, optionOnlyContent, innerContent);\n  \t            if (optionalName)\n  \t                choice.identifier = optionalName;\n  \t            choice.indentationDepth = bullets.length;\n  \t            choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;\n  \t            choice.condition = conditionExpr;\n  \t            choice.onceOnly = onceOnlyChoice;\n  \t            choice.isInvisibleDefault = emptyContent;\n  \t            return choice;\n  \t        };\n  \t        this.ChoiceCondition = () => {\n  \t            const conditions = this.Interleave(this.ChoiceSingleCondition, this.ChoiceConditionsSpace);\n  \t            if (conditions === null) {\n  \t                return null;\n  \t            }\n  \t            else if (conditions.length === 1) {\n  \t                return conditions[0];\n  \t            }\n  \t            return new MultipleConditionExpression_1.MultipleConditionExpression(conditions);\n  \t        };\n  \t        this.ChoiceConditionsSpace = () => {\n  \t            // Both optional\n  \t            // Newline includes initial end of line whitespace\n  \t            this.Newline();\n  \t            this.Whitespace();\n  \t            return StringParser_1.ParseSuccess;\n  \t        };\n  \t        this.ChoiceSingleCondition = () => {\n  \t            if (this.ParseString(\"{\") === null) {\n  \t                return null;\n  \t            }\n  \t            const condExpr = this.Expect(this.Expression, \"choice condition inside { }\");\n  \t            this.DisallowIncrement(condExpr);\n  \t            this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");\n  \t            return condExpr;\n  \t        };\n  \t        this.Gather = () => {\n  \t            const gatherDashCountObj = this.Parse(this.GatherDashes);\n  \t            if (gatherDashCountObj === null) {\n  \t                return null;\n  \t            }\n  \t            const gatherDashCount = Number(gatherDashCountObj);\n  \t            // Optional name for the gather\n  \t            const optionalName = this.Parse(this.BracketedName);\n  \t            const gather = new Gather_1.Gather(optionalName, gatherDashCount);\n  \t            // Optional newline before gather's content begins\n  \t            this.Newline();\n  \t            return gather;\n  \t        };\n  \t        this.GatherDashes = () => {\n  \t            this.Whitespace();\n  \t            let gatherDashCount = 0;\n  \t            while (this.ParseDashNotArrow() !== null) {\n  \t                gatherDashCount += 1;\n  \t                this.Whitespace();\n  \t            }\n  \t            if (gatherDashCount === 0) {\n  \t                return null;\n  \t            }\n  \t            return gatherDashCount;\n  \t        };\n  \t        this.ParseDashNotArrow = () => {\n  \t            const ruleId = this.BeginRule();\n  \t            if (this.ParseString(\"->\") === null &&\n  \t                this.ParseSingleCharacter() === \"-\") {\n  \t                return this.SucceedRule(ruleId);\n  \t            }\n  \t            return this.FailRule(ruleId);\n  \t        };\n  \t        this.BracketedName = () => {\n  \t            if (this.ParseString(\"(\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const name = this.Parse(this.IdentifierWithMetadata);\n  \t            if (name === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");\n  \t            return name;\n  \t        };\n  \t        /**\n  \t         * End Choices section.\n  \t         */\n  \t        /**\n  \t         * Begin Conditional section.\n  \t         */\n  \t        this.InnerConditionalContent = (initialQueryExpression) => {\n  \t            if (initialQueryExpression === undefined) {\n  \t                const initialQueryExpression = this.Parse(this.ConditionExpression);\n  \t                const conditional = this.Parse(() => this.InnerConditionalContent(initialQueryExpression));\n  \t                if (conditional === null) {\n  \t                    return null;\n  \t                }\n  \t                return conditional;\n  \t            }\n  \t            let alternatives;\n  \t            const canBeInline = initialQueryExpression !== null;\n  \t            const isInline = this.Parse(this.Newline) === null;\n  \t            if (isInline && !canBeInline) {\n  \t                return null;\n  \t            }\n  \t            if (isInline) {\n  \t                // Inline innards\n  \t                alternatives = this.InlineConditionalBranches();\n  \t            }\n  \t            else {\n  \t                // Multiline innards\n  \t                alternatives = this.MultilineConditionalBranches();\n  \t                if (alternatives === null) {\n  \t                    // Allow single piece of content within multi-line expression, e.g.:\n  \t                    // { true:\n  \t                    //    Some content that isn't preceded by '-'\n  \t                    // }\n  \t                    if (initialQueryExpression) {\n  \t                        let soleContent = this.StatementsAtLevel(StatementLevel_1.StatementLevel.InnerBlock);\n  \t                        if (soleContent !== null) {\n  \t                            const soleBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(soleContent);\n  \t                            alternatives = [soleBranch];\n  \t                            // Also allow a final \"- else:\" clause\n  \t                            const elseBranch = this.Parse(this.SingleMultilineCondition);\n  \t                            if (elseBranch) {\n  \t                                if (!elseBranch.isElse) {\n  \t                                    this.ErrorWithParsedObject(\"Expected an '- else:' clause here rather than an extra condition\", elseBranch);\n  \t                                    elseBranch.isElse = true;\n  \t                                }\n  \t                                alternatives.push(elseBranch);\n  \t                            }\n  \t                        }\n  \t                    }\n  \t                    // Still null?\n  \t                    if (alternatives === null) {\n  \t                        return null;\n  \t                    }\n  \t                }\n  \t                else if (alternatives.length === 1 &&\n  \t                    alternatives[0].isElse &&\n  \t                    initialQueryExpression) {\n  \t                    // Empty true branch - didn't get parsed, but should insert one for semantic correctness,\n  \t                    // and to make sure that any evaluation stack values get tidied up correctly.\n  \t                    const emptyTrueBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(null);\n  \t                    emptyTrueBranch.isTrueBranch = true;\n  \t                    alternatives.unshift(emptyTrueBranch);\n  \t                }\n  \t                // Like a switch statement\n  \t                // { initialQueryExpression:\n  \t                //    ... match the expression\n  \t                // }\n  \t                if (initialQueryExpression) {\n  \t                    let earlierBranchesHaveOwnExpression = false;\n  \t                    for (let ii = 0; ii < alternatives.length; ++ii) {\n  \t                        const branch = alternatives[ii];\n  \t                        const isLast = ii === alternatives.length - 1;\n  \t                        // Matching equality with initial query expression\n  \t                        // We set this flag even for the \"else\" clause so that\n  \t                        // it knows to tidy up the evaluation stack at the end\n  \t                        // Match query\n  \t                        if (branch.ownExpression) {\n  \t                            branch.matchingEquality = true;\n  \t                            earlierBranchesHaveOwnExpression = true;\n  \t                        }\n  \t                        else if (earlierBranchesHaveOwnExpression && isLast) {\n  \t                            // Else (final branch)\n  \t                            branch.matchingEquality = true;\n  \t                            branch.isElse = true;\n  \t                        }\n  \t                        else {\n  \t                            // Binary condition:\n  \t                            // { trueOrFalse:\n  \t                            //    - when true\n  \t                            //    - when false\n  \t                            // }\n  \t                            if (!isLast && alternatives.length > 2) {\n  \t                                this.ErrorWithParsedObject(\"Only final branch can be an 'else'. Did you miss a ':'?\", branch);\n  \t                            }\n  \t                            else {\n  \t                                if (ii === 0) {\n  \t                                    branch.isTrueBranch = true;\n  \t                                }\n  \t                                else {\n  \t                                    branch.isElse = true;\n  \t                                }\n  \t                            }\n  \t                        }\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    // No initial query, so just a multi-line conditional. e.g.:\n  \t                    // {\n  \t                    //   - x > 3:  greater than three\n  \t                    //   - x == 3: equal to three\n  \t                    //   - x < 3:  less than three\n  \t                    // }\n  \t                    for (let ii = 0; ii < alternatives.length; ++ii) {\n  \t                        const alt = alternatives[ii];\n  \t                        const isLast = ii === alternatives.length - 1;\n  \t                        if (alt.ownExpression === null) {\n  \t                            if (isLast) {\n  \t                                alt.isElse = true;\n  \t                            }\n  \t                            else {\n  \t                                if (alt.isElse) {\n  \t                                    // Do we ALSO have a valid \"else\" at the end? Let's report the error there.\n  \t                                    const finalClause = alternatives[alternatives.length - 1];\n  \t                                    if (finalClause.isElse) {\n  \t                                        this.ErrorWithParsedObject(\"Multiple 'else' cases. Can have a maximum of one, at the end.\", finalClause);\n  \t                                    }\n  \t                                    else {\n  \t                                        this.ErrorWithParsedObject(\"'else' case in conditional should always be the final one\", alt);\n  \t                                    }\n  \t                                }\n  \t                                else {\n  \t                                    this.ErrorWithParsedObject(\"Branch doesn't have condition. Are you missing a ':'? \", alt);\n  \t                                }\n  \t                            }\n  \t                        }\n  \t                    }\n  \t                    if (alternatives.length === 1 &&\n  \t                        alternatives[0].ownExpression === null) {\n  \t                        this.ErrorWithParsedObject(\"Condition block with no conditions\", alternatives[0]);\n  \t                    }\n  \t                }\n  \t            }\n  \t            // TODO: Come up with water-tight error conditions... it's quite a flexible system!\n  \t            // e.g.\n  \t            //   - inline conditionals must have exactly 1 or 2 alternatives\n  \t            //   - multiline expression shouldn't have mixed existence of branch-conditions?\n  \t            if (alternatives === null) {\n  \t                return null;\n  \t            }\n  \t            for (const branch of alternatives) {\n  \t                branch.isInline = isInline;\n  \t            }\n  \t            const cond = new Conditional_1.Conditional(initialQueryExpression, alternatives);\n  \t            return cond;\n  \t        };\n  \t        this.InlineConditionalBranches = () => {\n  \t            const listOfLists = this.Interleave(this.MixedTextAndLogic, this.Exclude(this.String(\"|\")), null, false);\n  \t            if (listOfLists === null || listOfLists.length === 0) {\n  \t                return null;\n  \t            }\n  \t            const result = [];\n  \t            if (listOfLists.length > 2) {\n  \t                this.Error(\"Expected one or two alternatives separated by '|' in inline conditional\");\n  \t            }\n  \t            else {\n  \t                const trueBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(listOfLists[0]);\n  \t                trueBranch.isTrueBranch = true;\n  \t                result.push(trueBranch);\n  \t                if (listOfLists.length > 1) {\n  \t                    const elseBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(listOfLists[1]);\n  \t                    elseBranch.isElse = true;\n  \t                    result.push(elseBranch);\n  \t                }\n  \t            }\n  \t            return result;\n  \t        };\n  \t        this.MultilineConditionalBranches = () => {\n  \t            this.MultilineWhitespace();\n  \t            const multipleConditions = this.OneOrMore(this.SingleMultilineCondition);\n  \t            if (multipleConditions === null) {\n  \t                return null;\n  \t            }\n  \t            this.MultilineWhitespace();\n  \t            return multipleConditions;\n  \t        };\n  \t        this.SingleMultilineCondition = () => {\n  \t            this.Whitespace();\n  \t            if (\n  \t            // Make sure we're not accidentally parsing a divert\n  \t            this.ParseString(\"->\") !== null ||\n  \t                this.ParseString(\"-\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            let expr = null;\n  \t            const isElse = this.Parse(this.ElseExpression) !== null;\n  \t            if (!isElse) {\n  \t                expr = this.Parse(this.ConditionExpression);\n  \t            }\n  \t            let content = this.StatementsAtLevel(StatementLevel_1.StatementLevel.InnerBlock);\n  \t            if (expr === null && content === null) {\n  \t                this.Error(\"expected content for the conditional branch following '-'\");\n  \t                // Recover\n  \t                content = [new Text_1.Text(\"\")];\n  \t            }\n  \t            // Allow additional multiline whitespace, if the statements were empty (valid)\n  \t            // then their surrounding multiline whitespacce needs to be handled manually.\n  \t            // e.g.\n  \t            // { x:\n  \t            //   - 1:    // intentionally left blank, but newline needs to be parsed\n  \t            //   - 2: etc\n  \t            // }\n  \t            this.MultilineWhitespace();\n  \t            const branch = new ConditionalSingleBranch_1.ConditionalSingleBranch(content);\n  \t            branch.ownExpression = expr;\n  \t            branch.isElse = isElse;\n  \t            return branch;\n  \t        };\n  \t        this.ConditionExpression = () => {\n  \t            const expr = this.Parse(this.Expression);\n  \t            if (expr === null) {\n  \t                return null;\n  \t            }\n  \t            this.DisallowIncrement(expr);\n  \t            this.Whitespace();\n  \t            if (this.ParseString(\":\") === null) {\n  \t                return null;\n  \t            }\n  \t            return expr;\n  \t        };\n  \t        this.ElseExpression = () => {\n  \t            if (this.ParseString(\"else\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            if (this.ParseString(\":\") === null) {\n  \t                return null;\n  \t            }\n  \t            return StringParser_1.ParseSuccess;\n  \t        };\n  \t        /**\n  \t         * End Conditional section.\n  \t         */\n  \t        /**\n  \t         * Begin Content section.\n  \t         */\n  \t        this._nonTextPauseCharacters = null;\n  \t        this._nonTextEndCharacters = null;\n  \t        this._notTextEndCharactersChoice = null;\n  \t        this._notTextEndCharactersString = null;\n  \t        this.TrimEndWhitespace = (mixedTextAndLogicResults, terminateWithSpace) => {\n  \t            // Trim whitespace from end\n  \t            if (mixedTextAndLogicResults.length > 0) {\n  \t                const lastObjIdx = mixedTextAndLogicResults.length - 1;\n  \t                const lastObj = mixedTextAndLogicResults[lastObjIdx];\n  \t                if (lastObj instanceof Text_1.Text) {\n  \t                    const textObj = lastObj;\n  \t                    textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");\n  \t                    if (terminateWithSpace) {\n  \t                        textObj.text += \" \";\n  \t                    }\n  \t                    else if (textObj.text.length === 0) {\n  \t                        // No content left at all? trim the whole object\n  \t                        mixedTextAndLogicResults.splice(lastObjIdx, 1);\n  \t                        // Recurse in case there's more whitespace\n  \t                        this.TrimEndWhitespace(mixedTextAndLogicResults, false);\n  \t                    }\n  \t                }\n  \t            }\n  \t        };\n  \t        this.LineOfMixedTextAndLogic = () => {\n  \t            // Consume any whitespace at the start of the line\n  \t            // (Except for escaped whitespace)\n  \t            this.Parse(this.Whitespace);\n  \t            let result = this.Parse(this.MixedTextAndLogic);\n  \t            if (!result || !result.length) {\n  \t                return null;\n  \t            }\n  \t            // Warn about accidentally writing \"return\" without \"~\"\n  \t            const firstText = result[0];\n  \t            if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {\n  \t                this.Warning(\"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\");\n  \t            }\n  \t            if (result.length === 0) {\n  \t                return null;\n  \t            }\n  \t            const lastObj = result[result.length - 1];\n  \t            if (!(lastObj instanceof Divert_1.Divert)) {\n  \t                this.TrimEndWhitespace(result, false);\n  \t            }\n  \t            this.EndTagIfNecessary(result);\n  \t            // If the line doens't actually contain any normal text content\n  \t            // but is in fact entirely a tag, then let's not append\n  \t            // a newline, since we want the tag (or tags) to be associated\n  \t            // with the line below rather than being completely independent.\n  \t            let lineIsPureTag = result.length > 0 && result[0] instanceof Tag_1.Tag && result[0].isStart;\n  \t            if (!lineIsPureTag) {\n  \t                result.push(new Text_1.Text(\"\\n\"));\n  \t            }\n  \t            this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n  \t            return result;\n  \t        };\n  \t        this.MixedTextAndLogic = () => {\n  \t            // Check for disallowed \"~\" within this context\n  \t            const disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));\n  \t            if (disallowedTilde !== null) {\n  \t                this.Error(\"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\");\n  \t            }\n  \t            // Either, or both interleaved\n  \t            let results = this.Interleave(this.Optional(this.ContentText), this.Optional(this.InlineLogicOrGlueOrStartTag));\n  \t            // Terminating divert?\n  \t            // (When parsing content for the text of a choice, diverts aren't allowed.\n  \t            //  The divert on the end of the body of a choice is handled specially.)\n  \t            if (!this._parsingChoice) {\n  \t                const diverts = this.Parse(this.MultiDivert);\n  \t                if (diverts !== null) {\n  \t                    // May not have had any results at all if there's *only* a divert!\n  \t                    if (results === null) {\n  \t                        results = [];\n  \t                    }\n  \t                    // End previously active tag if necessary\n  \t                    this.EndTagIfNecessary(results);\n  \t                    this.TrimEndWhitespace(results, true);\n  \t                    results.push(...diverts);\n  \t                }\n  \t            }\n  \t            if (!results) {\n  \t                return null;\n  \t            }\n  \t            return results;\n  \t        };\n  \t        this.ContentText = () => {\n  \t            return this.ContentTextAllowingEscapeChar();\n  \t        };\n  \t        this.ContentTextAllowingEscapeChar = () => {\n  \t            let sb = null;\n  \t            do {\n  \t                let str = this.Parse(this.ContentTextNoEscape);\n  \t                const gotEscapeChar = this.ParseString(\"\\\\\") !== null;\n  \t                if (gotEscapeChar || str !== null) {\n  \t                    if (sb === null) {\n  \t                        sb = \"\";\n  \t                    }\n  \t                    if (str !== null) {\n  \t                        sb += String(str);\n  \t                    }\n  \t                    if (gotEscapeChar) {\n  \t                        const c = this.ParseSingleCharacter();\n  \t                        sb += c;\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    break;\n  \t                }\n  \t            } while (true);\n  \t            if (sb !== null) {\n  \t                return new Text_1.Text(sb);\n  \t            }\n  \t            return null;\n  \t        };\n  \t        // Content text is an unusual parse rule compared with most since it's\n  \t        // less about saying \"this is is the small selection of stuff that we parse\"\n  \t        // and more \"we parse ANYTHING except this small selection of stuff\".\n  \t        this.ContentTextNoEscape = () => {\n  \t            // Eat through text, pausing at the following characters, and\n  \t            // attempt to parse the nonTextRule.\n  \t            // \"-\": possible start of divert or start of gather\n  \t            // \"<\": possible start of glue\n  \t            if (this._nonTextPauseCharacters === null) {\n  \t                this._nonTextPauseCharacters = new CharacterSet_1.CharacterSet(\"-<\");\n  \t            }\n  \t            // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule\n  \t            // \"{\" for start of logic\n  \t            // \"|\" for mid logic branch\n  \t            if (this._nonTextEndCharacters === null) {\n  \t                this._nonTextEndCharacters = new CharacterSet_1.CharacterSet(\"{}|\\n\\r\\\\#\");\n  \t                this._notTextEndCharactersChoice = new CharacterSet_1.CharacterSet(this._nonTextEndCharacters);\n  \t                this._notTextEndCharactersChoice.AddCharacters(\"[]\");\n  \t                this._notTextEndCharactersString = new CharacterSet_1.CharacterSet(this._nonTextEndCharacters);\n  \t                this._notTextEndCharactersString.AddCharacters('\"');\n  \t            }\n  \t            // When the ParseUntil pauses, check these rules in case they evaluate successfully\n  \t            const nonTextRule = () => this.OneOf([\n  \t                this.ParseDivertArrow,\n  \t                this.ParseThreadArrow,\n  \t                this.EndOfLine,\n  \t                this.Glue,\n  \t            ]);\n  \t            let endChars = null;\n  \t            if (this.parsingStringExpression) {\n  \t                endChars = this._notTextEndCharactersString;\n  \t            }\n  \t            else if (this._parsingChoice) {\n  \t                endChars = this._notTextEndCharactersChoice;\n  \t            }\n  \t            else {\n  \t                endChars = this._nonTextEndCharacters;\n  \t            }\n  \t            const pureTextContent = this.ParseUntil(nonTextRule, this._nonTextPauseCharacters, endChars);\n  \t            if (pureTextContent !== null) {\n  \t                return pureTextContent;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        /**\n  \t         * End Content section.\n  \t         */\n  \t        /**\n  \t         * Begin Divert section.\n  \t         */\n  \t        this.MultiDivert = () => {\n  \t            this.Whitespace();\n  \t            let diverts = [];\n  \t            // Try single thread first\n  \t            const threadDivert = this.Parse(this.StartThread);\n  \t            if (threadDivert) {\n  \t                diverts = [threadDivert];\n  \t                return diverts;\n  \t            }\n  \t            // Normal diverts and tunnels\n  \t            const arrowsAndDiverts = this.Interleave(this.ParseDivertArrowOrTunnelOnwards, this.DivertIdentifierWithArguments);\n  \t            if (!arrowsAndDiverts) {\n  \t                return null;\n  \t            }\n  \t            diverts = [];\n  \t            this.EndTagIfNecessary(diverts);\n  \t            // Possible patterns:\n  \t            //  ->                   -- explicit gather\n  \t            //  ->->                 -- tunnel onwards\n  \t            //  -> div               -- normal divert\n  \t            //  ->-> div             -- tunnel onwards, followed by override divert\n  \t            //  -> div ->            -- normal tunnel\n  \t            //  -> div ->->          -- tunnel then tunnel continue\n  \t            //  -> div -> div        -- tunnel then divert\n  \t            //  -> div -> div ->     -- tunnel then tunnel\n  \t            //  -> div -> div ->->\n  \t            //  -> div -> div ->-> div    (etc)\n  \t            // Look at the arrows and diverts\n  \t            for (let ii = 0; ii < arrowsAndDiverts.length; ++ii) {\n  \t                const isArrow = ii % 2 === 0;\n  \t                // Arrow string\n  \t                if (isArrow) {\n  \t                    // Tunnel onwards\n  \t                    if (arrowsAndDiverts[ii] === \"->->\") {\n  \t                        const tunnelOnwardsPlacementValid = ii === 0 ||\n  \t                            ii === arrowsAndDiverts.length - 1 ||\n  \t                            ii === arrowsAndDiverts.length - 2;\n  \t                        if (!tunnelOnwardsPlacementValid) {\n  \t                            this.Error(\"Tunnel onwards '->->' must only come at the begining or the start of a divert\");\n  \t                        }\n  \t                        const tunnelOnwards = new TunnelOnwards_1.TunnelOnwards();\n  \t                        if (ii < arrowsAndDiverts.length - 1) {\n  \t                            const tunnelOnwardDivert = (0, TypeAssertion_1.asOrNull)(arrowsAndDiverts[ii + 1], Divert_1.Divert);\n  \t                            tunnelOnwards.divertAfter = tunnelOnwardDivert;\n  \t                        }\n  \t                        diverts.push(tunnelOnwards);\n  \t                        // Not allowed to do anything after a tunnel onwards.\n  \t                        // If we had anything left it would be caused in the above Error for\n  \t                        // the positioning of a ->->\n  \t                        break;\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    // Divert\n  \t                    const divert = arrowsAndDiverts[ii];\n  \t                    // More to come? (further arrows) Must be tunnelling.\n  \t                    if (ii < arrowsAndDiverts.length - 1) {\n  \t                        divert.isTunnel = true;\n  \t                    }\n  \t                    diverts.push(divert);\n  \t                }\n  \t            }\n  \t            // Single -> (used for default choices)\n  \t            if (diverts.length === 0 && arrowsAndDiverts.length === 1) {\n  \t                const gatherDivert = new Divert_1.Divert(null);\n  \t                gatherDivert.isEmpty = true;\n  \t                diverts.push(gatherDivert);\n  \t                if (!this._parsingChoice) {\n  \t                    this.Error(\"Empty diverts (->) are only valid on choices\");\n  \t                }\n  \t            }\n  \t            return diverts;\n  \t        };\n  \t        this.StartThread = () => {\n  \t            this.Whitespace();\n  \t            if (this.ParseThreadArrow() === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const divert = this.Expect(this.DivertIdentifierWithArguments, \"target for new thread\", () => new Divert_1.Divert(null));\n  \t            divert.isThread = true;\n  \t            return divert;\n  \t        };\n  \t        this.DivertIdentifierWithArguments = () => {\n  \t            this.Whitespace();\n  \t            const targetComponents = this.Parse(this.DotSeparatedDivertPathComponents);\n  \t            if (!targetComponents) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const optionalArguments = this.Parse(this.ExpressionFunctionCallArguments);\n  \t            this.Whitespace();\n  \t            const targetPath = new Path_1.Path(targetComponents);\n  \t            return new Divert_1.Divert(targetPath, optionalArguments);\n  \t        };\n  \t        this.SingleDivert = () => {\n  \t            const diverts = this.Parse(this.MultiDivert);\n  \t            if (!diverts) {\n  \t                return null;\n  \t            }\n  \t            // Ideally we'd report errors if we get the\n  \t            // wrong kind of divert, but unfortunately we\n  \t            // have to hack around the fact that sequences use\n  \t            // a very similar syntax.\n  \t            // i.e. if you have a multi-divert at the start\n  \t            // of a sequence, it initially tries to parse it\n  \t            // as a divert target (part of an expression of\n  \t            // a conditional) and gives errors. So instead\n  \t            // we just have to blindly reject it as a single\n  \t            // divert, and give a slightly less nice error\n  \t            // when you DO use a multi divert as a divert taret.\n  \t            if (diverts.length !== 1) {\n  \t                return null;\n  \t            }\n  \t            const singleDivert = diverts[0];\n  \t            if (singleDivert instanceof TunnelOnwards_1.TunnelOnwards) {\n  \t                return null;\n  \t            }\n  \t            const divert = diverts[0];\n  \t            if (divert.isTunnel) {\n  \t                return null;\n  \t            }\n  \t            return divert;\n  \t        };\n  \t        this.DotSeparatedDivertPathComponents = () => this.Interleave(this.Spaced(this.IdentifierWithMetadata), this.Exclude(this.String(\".\")));\n  \t        this.ParseDivertArrowOrTunnelOnwards = () => {\n  \t            let numArrows = 0;\n  \t            while (this.ParseString(\"->\") !== null) {\n  \t                numArrows += 1;\n  \t            }\n  \t            if (numArrows === 0) {\n  \t                return null;\n  \t            }\n  \t            else if (numArrows === 1) {\n  \t                return \"->\";\n  \t            }\n  \t            else if (numArrows === 2) {\n  \t                return \"->->\";\n  \t            }\n  \t            this.Error(\"Unexpected number of arrows in divert. Should only have '->' or '->->'\");\n  \t            return \"->->\";\n  \t        };\n  \t        this.ParseDivertArrow = () => this.ParseString(\"->\");\n  \t        this.ParseThreadArrow = () => this.ParseString(\"<-\");\n  \t        /**\n  \t         * End Divert section.\n  \t         */\n  \t        /**\n  \t         * Begin Expressions section.\n  \t         */\n  \t        this._binaryOperators = [];\n  \t        this._maxBinaryOpLength = 0;\n  \t        this.TempDeclarationOrAssignment = () => {\n  \t            this.Whitespace();\n  \t            const isNewDeclaration = this.ParseTempKeyword();\n  \t            this.Whitespace();\n  \t            let varIdentifier = null;\n  \t            if (isNewDeclaration) {\n  \t                varIdentifier = this.Expect(this.IdentifierWithMetadata, \"variable name\");\n  \t            }\n  \t            else {\n  \t                varIdentifier = this.Parse(this.IdentifierWithMetadata);\n  \t            }\n  \t            if (varIdentifier === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            // += -=\n  \t            const isIncrement = this.ParseString(\"+\") !== null;\n  \t            const isDecrement = this.ParseString(\"-\") !== null;\n  \t            if (isIncrement && isDecrement) {\n  \t                this.Error(\"Unexpected sequence '+-'\");\n  \t            }\n  \t            if (this.ParseString(\"=\") === null) {\n  \t                // Definitely in an assignment expression?\n  \t                if (isNewDeclaration) {\n  \t                    this.Error(\"Expected '='\");\n  \t                }\n  \t                return null;\n  \t            }\n  \t            const assignedExpression = this.Expect(this.Expression, \"value expression to be assigned\");\n  \t            if (isIncrement || isDecrement) {\n  \t                const result = new IncDecExpression_1.IncDecExpression(varIdentifier, assignedExpression, isIncrement);\n  \t                return result;\n  \t            }\n  \t            const result = new VariableAssignment_1.VariableAssignment({\n  \t                variableIdentifier: varIdentifier,\n  \t                assignedExpression,\n  \t                isTemporaryNewDeclaration: isNewDeclaration,\n  \t            });\n  \t            return result;\n  \t        };\n  \t        this.DisallowIncrement = (expr) => {\n  \t            if (expr instanceof IncDecExpression_1.IncDecExpression) {\n  \t                this.Error(\"Can't use increment/decrement here. It can only be used on a ~ line\");\n  \t            }\n  \t        };\n  \t        this.ParseTempKeyword = () => {\n  \t            const ruleId = this.BeginRule();\n  \t            if (this.Parse(this.Identifier) === \"temp\") {\n  \t                this.SucceedRule(ruleId);\n  \t                return true;\n  \t            }\n  \t            this.FailRule(ruleId);\n  \t            return false;\n  \t        };\n  \t        this.ReturnStatement = () => {\n  \t            this.Whitespace();\n  \t            const returnOrDone = this.Parse(this.Identifier);\n  \t            if (returnOrDone !== \"return\") {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const expr = this.Parse(this.Expression);\n  \t            const returnObj = new ReturnType_1.ReturnType(expr);\n  \t            return returnObj;\n  \t        };\n  \t        // Pratt Parser\n  \t        // aka \"Top down operator precedence parser\"\n  \t        // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  \t        // Algorithm overview:\n  \t        // The two types of precedence are handled in two different ways:\n  \t        //   ((((a . b) . c) . d) . e)\t\t\t#1\n  \t        //   (a . (b . (c . (d . e))))\t\t\t#2\n  \t        // Where #1 is automatically handled by successive loops within the main 'while' in this function,\n  \t        // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.\n  \t        // ...and #2 is handled by recursion of the right hand term in the binary expression parser.\n  \t        // (see link for advice on how to extend for postfix and mixfix operators)\n  \t        this.Expression = (minimumPrecedence = 0) => {\n  \t            this.Whitespace();\n  \t            // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"\n  \t            let expr = this.ExpressionUnary();\n  \t            if (expr === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)\n  \t            while (true) {\n  \t                const ruleId = this.BeginRule();\n  \t                // Operator\n  \t                const infixOp = this.ParseInfixOperator();\n  \t                if (infixOp !== null && infixOp.precedence > minimumPrecedence) {\n  \t                    // Expect right hand side of operator\n  \t                    const expectationMessage = `right side of '${infixOp.type}' expression`;\n  \t                    const multiaryExpr = this.Expect(() => this.ExpressionInfixRight(expr, infixOp), expectationMessage);\n  \t                    if (multiaryExpr === null) {\n  \t                        // Fail for operator and right-hand side of multiary expression\n  \t                        this.FailRule(ruleId);\n  \t                        return null;\n  \t                    }\n  \t                    expr = this.SucceedRule(ruleId, multiaryExpr);\n  \t                    continue;\n  \t                }\n  \t                this.FailRule(ruleId);\n  \t                break;\n  \t            }\n  \t            this.Whitespace();\n  \t            return expr;\n  \t        };\n  \t        this.ExpressionUnary = () => {\n  \t            // Divert target is a special case - it can't have any other operators\n  \t            // applied to it, and we also want to check for it first so that we don't\n  \t            // confuse \"->\" for subtraction.\n  \t            const divertTarget = this.Parse(this.ExpressionDivertTarget);\n  \t            if (divertTarget !== null) {\n  \t                return divertTarget;\n  \t            }\n  \t            let prefixOp = this.OneOf([\n  \t                this.String(\"-\"),\n  \t                this.String(\"!\"),\n  \t            ]);\n  \t            // Don't parse like the string rules above, in case its actually\n  \t            // a variable that simply starts with \"not\", e.g. \"notable\".\n  \t            // This rule uses the Identifier rule, which will scan as much text\n  \t            // as possible before returning.\n  \t            if (prefixOp === null) {\n  \t                prefixOp = this.Parse(this.ExpressionNot);\n  \t            }\n  \t            this.Whitespace();\n  \t            // - Since we allow numbers at the start of variable names, variable names are checked before literals\n  \t            // - Function calls before variable names in case we see parentheses\n  \t            let expr = this.OneOf([\n  \t                this.ExpressionList,\n  \t                this.ExpressionParen,\n  \t                this.ExpressionFunctionCall,\n  \t                this.ExpressionVariableName,\n  \t                this.ExpressionLiteral,\n  \t            ]);\n  \t            // Only recurse immediately if we have one of the (usually optional) unary ops\n  \t            if (expr === null && prefixOp !== null) {\n  \t                expr = this.ExpressionUnary();\n  \t            }\n  \t            if (expr === null) {\n  \t                return null;\n  \t            }\n  \t            else if (prefixOp !== null) {\n  \t                expr = UnaryExpression_1.UnaryExpression.WithInner(expr, prefixOp);\n  \t            }\n  \t            this.Whitespace();\n  \t            const postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);\n  \t            if (postfixOp !== null) {\n  \t                const isInc = postfixOp === \"++\";\n  \t                if (!(expr instanceof VariableReference_1.VariableReference)) {\n  \t                    this.Error(`can only increment and decrement variables, but saw '${expr}'.`);\n  \t                    // Drop down and succeed without the increment after reporting error\n  \t                }\n  \t                else {\n  \t                    const varRef = expr;\n  \t                    expr = new IncDecExpression_1.IncDecExpression(varRef.identifier, isInc);\n  \t                }\n  \t            }\n  \t            return expr;\n  \t        };\n  \t        this.ExpressionNot = () => {\n  \t            const id = this.Identifier();\n  \t            if (id === \"not\") {\n  \t                return id;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ExpressionLiteral = () => this.OneOf([\n  \t            this.ExpressionFloat,\n  \t            this.ExpressionInt,\n  \t            this.ExpressionBool,\n  \t            this.ExpressionString,\n  \t        ]);\n  \t        this.ExpressionDivertTarget = () => {\n  \t            this.Whitespace();\n  \t            const divert = this.Parse(this.SingleDivert);\n  \t            if (!divert || (divert && divert.isThread)) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            return new DivertTarget_1.DivertTarget(divert);\n  \t        };\n  \t        this.ExpressionInt = () => {\n  \t            const intOrNull = this.ParseInt();\n  \t            if (intOrNull === null) {\n  \t                return null;\n  \t            }\n  \t            return new NumberExpression_1.NumberExpression(intOrNull, \"int\");\n  \t        };\n  \t        this.ExpressionFloat = () => {\n  \t            const floatOrNull = this.ParseFloat();\n  \t            if (floatOrNull === null) {\n  \t                return null;\n  \t            }\n  \t            return new NumberExpression_1.NumberExpression(floatOrNull, \"float\");\n  \t        };\n  \t        this.ExpressionString = () => {\n  \t            const openQuote = this.ParseString('\"');\n  \t            if (openQuote === null) {\n  \t                return null;\n  \t            }\n  \t            // Set custom parser state flag so that within the text parser,\n  \t            // it knows to treat the quote character (\") as an end character\n  \t            this.parsingStringExpression = true;\n  \t            let textAndLogic = this.Parse(this.MixedTextAndLogic);\n  \t            this.Expect(this.String('\"'), \"close quote for string expression\");\n  \t            this.parsingStringExpression = false;\n  \t            if (textAndLogic === null) {\n  \t                textAndLogic = [new Text_1.Text(\"\")];\n  \t            }\n  \t            else if (textAndLogic.find((c) => c instanceof Divert_1.Divert)) {\n  \t                this.Error(\"String expressions cannot contain diverts (->)\");\n  \t            }\n  \t            return new StringExpression_1.StringExpression(textAndLogic);\n  \t        };\n  \t        this.ExpressionBool = () => {\n  \t            const id = this.Parse(this.Identifier);\n  \t            if (id === \"true\") {\n  \t                return new NumberExpression_1.NumberExpression(true, \"bool\");\n  \t            }\n  \t            else if (id === \"false\") {\n  \t                return new NumberExpression_1.NumberExpression(false, \"bool\");\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ExpressionFunctionCall = () => {\n  \t            const iden = this.Parse(this.IdentifierWithMetadata);\n  \t            if (iden === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const args = this.Parse(this.ExpressionFunctionCallArguments);\n  \t            if (args === null) {\n  \t                return null;\n  \t            }\n  \t            return new FunctionCall_1.FunctionCall(iden, args);\n  \t        };\n  \t        this.ExpressionFunctionCallArguments = () => {\n  \t            if (this.ParseString(\"(\") === null) {\n  \t                return null;\n  \t            }\n  \t            // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results\n  \t            const commas = this.Exclude(this.String(\",\"));\n  \t            let args = this.Interleave(this.Expression, commas);\n  \t            if (args === null) {\n  \t                args = [];\n  \t            }\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\")\"), \"closing ')' for function call\");\n  \t            return args;\n  \t        };\n  \t        this.ExpressionVariableName = () => {\n  \t            const path = this.Interleave(this.IdentifierWithMetadata, this.Exclude(this.Spaced(this.String(\".\"))));\n  \t            if (path === null || Story_1.Story.IsReservedKeyword(path[0].name)) {\n  \t                return null;\n  \t            }\n  \t            return new VariableReference_1.VariableReference(path);\n  \t        };\n  \t        this.ExpressionParen = () => {\n  \t            if (this.ParseString(\"(\") === null) {\n  \t                return null;\n  \t            }\n  \t            const innerExpr = this.Parse(this.Expression);\n  \t            if (innerExpr === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");\n  \t            return innerExpr;\n  \t        };\n  \t        this.ExpressionInfixRight = (left, op) => {\n  \t            if (!left) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const right = this.Parse(() => this.Expression(op.precedence));\n  \t            if (right) {\n  \t                // We assume that the character we use for the operator's type is the same\n  \t                // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc\n  \t                const expr = new BinaryExpression_1.BinaryExpression(left, right, op.type);\n  \t                return expr;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ParseInfixOperator = () => {\n  \t            for (const op of this._binaryOperators) {\n  \t                const ruleId = this.BeginRule();\n  \t                if (this.ParseString(op.type) !== null) {\n  \t                    if (op.requireWhitespace) {\n  \t                        if (this.Whitespace() === null) {\n  \t                            this.FailRule(ruleId);\n  \t                            continue;\n  \t                        }\n  \t                    }\n  \t                    return this.SucceedRule(ruleId, op);\n  \t                }\n  \t                this.FailRule(ruleId);\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ExpressionList = () => {\n  \t            this.Whitespace();\n  \t            if (this.ParseString(\"(\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            // When list has:\n  \t            //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"\n  \t            //  - 1 element - it could be confused for a single non-list related\n  \t            //    identifier expression in brackets, but this is a useless thing\n  \t            //    to do, so we reserve that syntax for a list with one item.\n  \t            //  - 2 or more elements - normal!\n  \t            const memberNames = this.SeparatedList(this.ListMember, this.Spaced(this.String(\",\")));\n  \t            this.Whitespace();\n  \t            // May have failed to parse the inner list - the parentheses may\n  \t            // be for a normal expression\n  \t            if (this.ParseString(\")\") === null) {\n  \t                return null;\n  \t            }\n  \t            return new List_1.List(memberNames);\n  \t        };\n  \t        this.ListMember = () => {\n  \t            this.Whitespace();\n  \t            let identifier = this.Parse(this.IdentifierWithMetadata);\n  \t            if (identifier === null) {\n  \t                return null;\n  \t            }\n  \t            const dot = this.ParseString(\".\");\n  \t            if (dot !== null) {\n  \t                const identifier2 = this.Expect(this.IdentifierWithMetadata, `element name within the set ${identifier}`);\n  \t                identifier.name += `.${identifier2 === null || identifier2 === void 0 ? void 0 : identifier2.name}`;\n  \t            }\n  \t            this.Whitespace();\n  \t            return identifier;\n  \t        };\n  \t        this.RegisterExpressionOperators = () => {\n  \t            // These will be tried in order, so we need \"<=\" before \"<\"\n  \t            // for correctness\n  \t            this.RegisterBinaryOperator(\"&&\", 1);\n  \t            this.RegisterBinaryOperator(\"||\", 1);\n  \t            this.RegisterBinaryOperator(\"and\", 1, true);\n  \t            this.RegisterBinaryOperator(\"or\", 1, true);\n  \t            this.RegisterBinaryOperator(\"==\", 2);\n  \t            this.RegisterBinaryOperator(\">=\", 2);\n  \t            this.RegisterBinaryOperator(\"<=\", 2);\n  \t            this.RegisterBinaryOperator(\"<\", 2);\n  \t            this.RegisterBinaryOperator(\">\", 2);\n  \t            this.RegisterBinaryOperator(\"!=\", 2);\n  \t            // (apples, oranges) + cabbages has (oranges, cabbages) === true\n  \t            this.RegisterBinaryOperator(\"?\", 3);\n  \t            this.RegisterBinaryOperator(\"has\", 3, true);\n  \t            this.RegisterBinaryOperator(\"!?\", 3);\n  \t            this.RegisterBinaryOperator(\"hasnt\", 3, true);\n  \t            this.RegisterBinaryOperator(\"^\", 3);\n  \t            this.RegisterBinaryOperator(\"+\", 4);\n  \t            this.RegisterBinaryOperator(\"-\", 5);\n  \t            this.RegisterBinaryOperator(\"*\", 6);\n  \t            this.RegisterBinaryOperator(\"/\", 7);\n  \t            this.RegisterBinaryOperator(\"%\", 8);\n  \t            this.RegisterBinaryOperator(\"mod\", 8, true);\n  \t        };\n  \t        this.RegisterBinaryOperator = (op, precedence, requireWhitespace = false) => {\n  \t            const infix = new InfixOperator_1.InfixOperator(op, precedence, requireWhitespace);\n  \t            this._binaryOperators.push(infix);\n  \t            this._maxBinaryOpLength = Math.max(this._maxBinaryOpLength, op.length);\n  \t        };\n  \t        this._openFilenames = [];\n  \t        this.IncludeStatement = () => {\n  \t            this.Whitespace();\n  \t            if (this.ParseString(\"INCLUDE\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            let filename = this.Expect(() => this.ParseUntilCharactersFromString(\"\\n\\r\"), \"filename for include statement\");\n  \t            filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");\n  \t            // Working directory should already have been set up relative to the root ink file.\n  \t            const fullFilename = this.fileHandler.ResolveInkFilename(filename);\n  \t            if (this.FilenameIsAlreadyOpen(fullFilename)) {\n  \t                this.Error(`Recursive INCLUDE detected: '${fullFilename}' is already open.`);\n  \t                this.ParseUntilCharactersFromString(\"\\r\\n\");\n  \t                return new IncludedFile_1.IncludedFile(null);\n  \t            }\n  \t            else {\n  \t                this.AddOpenFilename(fullFilename);\n  \t            }\n  \t            let includedStory = null;\n  \t            let includedString = \"\";\n  \t            try {\n  \t                includedString =\n  \t                    this._rootParser.fileHandler.LoadInkFileContents(fullFilename);\n  \t            }\n  \t            catch (err) {\n  \t                this.Error(`Failed to load: '${filename}'.\\nError:${err}`);\n  \t            }\n  \t            if (includedString != null) {\n  \t                const parser = new InkParser(includedString, filename, this._externalErrorHandler, this._rootParser, this.fileHandler);\n  \t                includedStory = parser.ParseStory();\n  \t            }\n  \t            this.RemoveOpenFilename(fullFilename);\n  \t            // Return valid IncludedFile object even if there were errors when parsing.\n  \t            // We don't want to attempt to re-parse the include line as something else,\n  \t            // and we want to include the bits that *are* valid, so we don't generate\n  \t            // more errors than necessary.\n  \t            return new IncludedFile_1.IncludedFile(includedStory);\n  \t        };\n  \t        this.FilenameIsAlreadyOpen = (fullFilename) => this._rootParser._openFilenames.includes(fullFilename);\n  \t        this.AddOpenFilename = (fullFilename) => {\n  \t            this._rootParser._openFilenames.push(fullFilename);\n  \t        };\n  \t        this.RemoveOpenFilename = (fullFilename) => {\n  \t            this._rootParser._openFilenames.splice(this._rootParser._openFilenames.indexOf(fullFilename), 1);\n  \t        };\n  \t        /**\n  \t         * End Include section.\n  \t         */\n  \t        /**\n  \t         * Begin Knot section.\n  \t         */\n  \t        this.KnotDefinition = () => {\n  \t            const knotDecl = this.Parse(this.KnotDeclaration);\n  \t            if (knotDecl === null) {\n  \t                return null;\n  \t            }\n  \t            this.Expect(this.EndOfLine, \"end of line after knot name definition\", this.SkipToNextLine);\n  \t            const innerKnotStatements = () => this.StatementsAtLevel(StatementLevel_1.StatementLevel.Knot);\n  \t            const content = this.Expect(innerKnotStatements, \"at least one line within the knot\", this.KnotStitchNoContentRecoveryRule);\n  \t            return new Knot_1.Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);\n  \t        };\n  \t        this.KnotDeclaration = () => {\n  \t            this.Whitespace();\n  \t            if (this.KnotTitleEquals() === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const identifier = this.Parse(this.IdentifierWithMetadata);\n  \t            let knotName;\n  \t            const isFunc = (identifier === null || identifier === void 0 ? void 0 : identifier.name) === \"function\";\n  \t            if (isFunc) {\n  \t                this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");\n  \t                knotName = this.Parse(this.IdentifierWithMetadata);\n  \t            }\n  \t            else {\n  \t                knotName = identifier;\n  \t            }\n  \t            if (knotName === null) {\n  \t                this.Error(`Expected the name of the ${isFunc ? \"function\" : \"knot\"}`);\n  \t                knotName = new Identifier_1.Identifier(\"\"); // prevent later null ref\n  \t            }\n  \t            this.Whitespace();\n  \t            const parameterNames = this.Parse(this.BracketedKnotDeclArguments);\n  \t            this.Whitespace();\n  \t            // Optional equals after name\n  \t            this.Parse(this.KnotTitleEquals);\n  \t            return new FlowDecl_1.FlowDecl(knotName, parameterNames, isFunc);\n  \t        };\n  \t        this.KnotTitleEquals = () => {\n  \t            // 2+ \"=\" starts a knot\n  \t            const multiEquals = this.ParseCharactersFromString(\"=\");\n  \t            if (multiEquals === null || multiEquals.length <= 1) {\n  \t                return null;\n  \t            }\n  \t            return multiEquals;\n  \t        };\n  \t        this.StitchDefinition = () => {\n  \t            const decl = this.Parse(this.StitchDeclaration);\n  \t            if (decl === null) {\n  \t                return null;\n  \t            }\n  \t            this.Expect(this.EndOfLine, \"end of line after stitch name\", this.SkipToNextLine);\n  \t            const innerStitchStatements = () => this.StatementsAtLevel(StatementLevel_1.StatementLevel.Stitch);\n  \t            const content = this.Expect(innerStitchStatements, \"at least one line within the stitch\", this.KnotStitchNoContentRecoveryRule);\n  \t            return new Stitch_1.Stitch(decl.name, content, decl.args, decl.isFunction);\n  \t        };\n  \t        this.StitchDeclaration = () => {\n  \t            this.Whitespace();\n  \t            // Single \"=\" to define a stitch\n  \t            if (this.ParseString(\"=\") === null) {\n  \t                return null;\n  \t            }\n  \t            // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail\n  \t            if (this.ParseString(\"=\") !== null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            // Stitches aren't allowed to be functions, but we parse it anyway and report the error later\n  \t            const isFunc = this.ParseString(\"function\") !== null;\n  \t            if (isFunc) {\n  \t                this.Whitespace();\n  \t            }\n  \t            const stitchName = this.Parse(this.IdentifierWithMetadata);\n  \t            if (stitchName === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const flowArgs = this.Parse(this.BracketedKnotDeclArguments);\n  \t            this.Whitespace();\n  \t            return new FlowDecl_1.FlowDecl(stitchName, flowArgs, isFunc);\n  \t        };\n  \t        this.KnotStitchNoContentRecoveryRule = () => {\n  \t            // Jump ahead to the next knot or the end of the file\n  \t            this.ParseUntil(this.KnotDeclaration, new CharacterSet_1.CharacterSet(\"=\"), null);\n  \t            const recoveredFlowContent = [new Text_1.Text(\"<ERROR IN FLOW>\")];\n  \t            return recoveredFlowContent;\n  \t        };\n  \t        this.BracketedKnotDeclArguments = () => {\n  \t            if (this.ParseString(\"(\") === null) {\n  \t                return null;\n  \t            }\n  \t            let flowArguments = this.Interleave(this.Spaced(this.FlowDeclArgument), this.Exclude(this.String(\",\")));\n  \t            this.Expect(this.String(\")\"), \"closing ')' for parameter list\");\n  \t            // If no parameters, create an empty list so that this method is type safe and\n  \t            // doesn't attempt to return the ParseSuccess object\n  \t            if (flowArguments === null) {\n  \t                flowArguments = [];\n  \t            }\n  \t            return flowArguments;\n  \t        };\n  \t        this.FlowDeclArgument = () => {\n  \t            // Possible forms:\n  \t            //  name\n  \t            //  -> name      (variable divert target argument\n  \t            //  ref name\n  \t            //  ref -> name  (variable divert target by reference)\n  \t            const firstIden = this.Parse(this.IdentifierWithMetadata);\n  \t            this.Whitespace();\n  \t            const divertArrow = this.ParseDivertArrow();\n  \t            this.Whitespace();\n  \t            const secondIden = this.Parse(this.IdentifierWithMetadata);\n  \t            if (firstIden == null && secondIden === null) {\n  \t                return null;\n  \t            }\n  \t            const flowArg = new Argument_1.Argument();\n  \t            if (divertArrow !== null) {\n  \t                flowArg.isDivertTarget = true;\n  \t            }\n  \t            // Passing by reference\n  \t            if (firstIden !== null && firstIden.name === \"ref\") {\n  \t                if (secondIden === null) {\n  \t                    this.Error(\"Expected an parameter name after 'ref'\");\n  \t                }\n  \t                flowArg.identifier = secondIden;\n  \t                flowArg.isByReference = true;\n  \t            }\n  \t            else {\n  \t                // Simple argument name\n  \t                if (flowArg.isDivertTarget) {\n  \t                    flowArg.identifier = secondIden;\n  \t                }\n  \t                else {\n  \t                    flowArg.identifier = firstIden;\n  \t                }\n  \t                if (flowArg.identifier === null) {\n  \t                    this.Error(\"Expected an parameter name\");\n  \t                }\n  \t                flowArg.isByReference = false;\n  \t            }\n  \t            return flowArg;\n  \t        };\n  \t        this.ExternalDeclaration = () => {\n  \t            this.Whitespace();\n  \t            const external = this.Parse(this.IdentifierWithMetadata);\n  \t            if (external === null || external.name != \"EXTERNAL\") {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const funcIdentifier = this.Expect(this.IdentifierWithMetadata, \"name of external function\") || new Identifier_1.Identifier(\"\");\n  \t            this.Whitespace();\n  \t            let parameterNames = this.Expect(this.BracketedKnotDeclArguments, `declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL ${funcIdentifier}()'`);\n  \t            if (parameterNames === null) {\n  \t                parameterNames = [];\n  \t            }\n  \t            const argNames = parameterNames\n  \t                .map((arg) => { var _a; return (_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name; })\n  \t                .filter(TypeAssertion_1.filterUndef);\n  \t            return new ExternalDeclaration_1.ExternalDeclaration(funcIdentifier, argNames);\n  \t        };\n  \t        /**\n  \t         * End Knot section.\n  \t         */\n  \t        /**\n  \t         * Start Logic section.\n  \t         */\n  \t        this._identifierCharSet = null;\n  \t        this.LogicLine = () => {\n  \t            this.Whitespace();\n  \t            if (this.ParseString(\"~\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            // Some example lines we need to be able to distinguish between:\n  \t            // ~ temp x = 5  -- var decl + assign\n  \t            // ~ temp x      -- var decl\n  \t            // ~ x = 5       -- var assign\n  \t            // ~ x           -- expr (not var decl or assign)\n  \t            // ~ f()         -- expr\n  \t            // We don't treat variable decl/assign as an expression since we don't want an assignment\n  \t            // to have a return value, or to be used in compound expressions.\n  \t            const afterTilde = () => this.OneOf([\n  \t                this.ReturnStatement,\n  \t                this.TempDeclarationOrAssignment,\n  \t                this.Expression,\n  \t            ]);\n  \t            let result = this.Expect(afterTilde, \"expression after '~'\", this.SkipToNextLine);\n  \t            // Prevent further errors, already reported expected expression and have skipped to next line.\n  \t            if (result === null) {\n  \t                return new ContentList_1.ContentList();\n  \t            }\n  \t            // Parse all expressions, but tell the writer off if they did something useless like:\n  \t            //  ~ 5 + 4\n  \t            // And even:\n  \t            //  ~ false && myFunction()\n  \t            // ...since it's bad practice, and won't do what they expect if\n  \t            // they're expecting C's lazy evaluation.\n  \t            if (result instanceof Expression_1.Expression &&\n  \t                !(result instanceof FunctionCall_1.FunctionCall || result instanceof IncDecExpression_1.IncDecExpression)) {\n  \t                this.Error(\"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\");\n  \t            }\n  \t            // Line is pure function call? e.g.\n  \t            //  ~ f()\n  \t            // Add extra pop to make sure we tidy up after ourselves.\n  \t            // We no longer need anything on the evaluation stack.\n  \t            const funCall = (0, TypeAssertion_1.asOrNull)(result, FunctionCall_1.FunctionCall);\n  \t            if (funCall) {\n  \t                funCall.shouldPopReturnedValue = true;\n  \t            }\n  \t            // If the expression contains a function call, then it could produce a text side effect,\n  \t            // in which case it needs a newline on the end. e.g.\n  \t            //  ~ printMyName()\n  \t            //  ~ x = 1 + returnAValueAndAlsoPrintStuff()\n  \t            // If no text gets printed, then the extra newline will have to be culled later.\n  \t            // Multiple newlines on the output will be removed, so there will be no \"leak\" for\n  \t            // long running calculations. It's disappointingly messy though :-/\n  \t            if (result.Find(FunctionCall_1.FunctionCall)() !== null) {\n  \t                result = new ContentList_1.ContentList(result, new Text_1.Text(\"\\n\"));\n  \t            }\n  \t            this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n  \t            return result;\n  \t        };\n  \t        this.VariableDeclaration = () => {\n  \t            this.Whitespace();\n  \t            const id = this.Parse(this.Identifier);\n  \t            if (id !== \"VAR\") {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const varName = this.Expect(this.IdentifierWithMetadata, \"variable name\");\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\"=\"), \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\");\n  \t            this.Whitespace();\n  \t            const definition = this.Expect(this.Expression, \"initial value for \");\n  \t            const expr = definition;\n  \t            if (expr) {\n  \t                const check = expr instanceof NumberExpression_1.NumberExpression ||\n  \t                    expr instanceof StringExpression_1.StringExpression ||\n  \t                    expr instanceof DivertTarget_1.DivertTarget ||\n  \t                    expr instanceof VariableReference_1.VariableReference ||\n  \t                    expr instanceof List_1.List;\n  \t                if (!check) {\n  \t                    this.Error(\"initial value for a variable must be a number, constant, list or divert target\");\n  \t                }\n  \t                if (this.Parse(this.ListElementDefinitionSeparator) !== null) {\n  \t                    this.Error(\"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\");\n  \t                }\n  \t                else if (expr instanceof StringExpression_1.StringExpression) {\n  \t                    // Ensure string expressions are simple\n  \t                    const strExpr = expr;\n  \t                    if (!strExpr.isSingleString) {\n  \t                        this.Error(\"Constant strings cannot contain any logic.\");\n  \t                    }\n  \t                }\n  \t                const result = new VariableAssignment_1.VariableAssignment({\n  \t                    assignedExpression: expr,\n  \t                    isGlobalDeclaration: true,\n  \t                    variableIdentifier: varName,\n  \t                });\n  \t                return result;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ListDeclaration = () => {\n  \t            this.Whitespace();\n  \t            const id = this.Parse(this.Identifier);\n  \t            if (id != \"LIST\") {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const varName = this.Expect(this.IdentifierWithMetadata, \"list name\");\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\"=\"), \"the '=' for an assignment of the list definition\");\n  \t            this.Whitespace();\n  \t            const definition = this.Expect(this.ListDefinition, \"list item names\");\n  \t            if (definition) {\n  \t                definition.identifier = new Identifier_1.Identifier(varName.name);\n  \t                return new VariableAssignment_1.VariableAssignment({\n  \t                    variableIdentifier: varName,\n  \t                    listDef: definition,\n  \t                });\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.ListDefinition = () => {\n  \t            this.AnyWhitespace();\n  \t            const allElements = this.SeparatedList(this.ListElementDefinition, this.ListElementDefinitionSeparator);\n  \t            if (allElements === null) {\n  \t                return null;\n  \t            }\n  \t            return new ListDefinition_1.ListDefinition(allElements);\n  \t        };\n  \t        this.ListElementDefinitionSeparator = () => {\n  \t            this.AnyWhitespace();\n  \t            if (this.ParseString(\",\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.AnyWhitespace();\n  \t            return \",\";\n  \t        };\n  \t        this.ListElementDefinition = () => {\n  \t            const inInitialList = this.ParseString(\"(\") !== null;\n  \t            let needsToCloseParen = inInitialList;\n  \t            this.Whitespace();\n  \t            const name = this.Parse(this.IdentifierWithMetadata);\n  \t            if (name === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            if (inInitialList) {\n  \t                if (this.ParseString(\")\") != null) {\n  \t                    needsToCloseParen = false;\n  \t                    this.Whitespace();\n  \t                }\n  \t            }\n  \t            let elementValue = null;\n  \t            if (this.ParseString(\"=\") !== null) {\n  \t                this.Whitespace();\n  \t                const elementValueNum = this.Expect(this.ExpressionInt, \"value to be assigned to list item\");\n  \t                if (elementValueNum !== null) {\n  \t                    elementValue = elementValueNum.value;\n  \t                }\n  \t                if (needsToCloseParen) {\n  \t                    this.Whitespace();\n  \t                    if (this.ParseString(\")\") !== null) {\n  \t                        needsToCloseParen = false;\n  \t                    }\n  \t                }\n  \t            }\n  \t            if (needsToCloseParen) {\n  \t                this.Error(\"Expected closing ')'\");\n  \t            }\n  \t            return new ListElementDefinition_1.ListElementDefinition(name, inInitialList, elementValue);\n  \t        };\n  \t        this.ConstDeclaration = () => {\n  \t            this.Whitespace();\n  \t            const id = this.Parse(this.Identifier);\n  \t            if (id !== \"CONST\") {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const varName = this.Expect(this.IdentifierWithMetadata, \"constant name\");\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\"=\"), \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\");\n  \t            this.Whitespace();\n  \t            const expr = this.Expect(this.Expression, \"initial value for \");\n  \t            const check = expr instanceof NumberExpression_1.NumberExpression ||\n  \t                expr instanceof DivertTarget_1.DivertTarget ||\n  \t                expr instanceof StringExpression_1.StringExpression;\n  \t            if (!check) {\n  \t                this.Error(\"initial value for a constant must be a number or divert target\");\n  \t            }\n  \t            else if (expr instanceof StringExpression_1.StringExpression) {\n  \t                // Ensure string expressions are simple\n  \t                const strExpr = expr;\n  \t                if (!strExpr.isSingleString) {\n  \t                    this.Error(\"Constant strings cannot contain any logic.\");\n  \t                }\n  \t            }\n  \t            const result = new ConstantDeclaration_1.ConstantDeclaration(varName, expr);\n  \t            return result;\n  \t        };\n  \t        this.InlineLogicOrGlueOrStartTag = () => this.OneOf([this.InlineLogic, this.Glue, this.StartTag]);\n  \t        this.Glue = () => {\n  \t            // Don't want to parse whitespace, since it might be important\n  \t            // surrounding the glue.\n  \t            const glueStr = this.ParseString(\"<>\");\n  \t            if (glueStr !== null) {\n  \t                return new Glue_1.Glue(new Glue_2.Glue());\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.InlineLogic = () => {\n  \t            if (this.ParseString(\"{\") === null) {\n  \t                return null;\n  \t            }\n  \t            let wasParsingString = this.parsingStringExpression;\n  \t            let wasTagActive = this.tagActive;\n  \t            this.Whitespace();\n  \t            const logic = this.Expect(this.InnerLogic, \"some kind of logic, conditional or sequence within braces: { ... }\");\n  \t            if (logic === null) {\n  \t                this.parsingStringExpression = wasParsingString;\n  \t                return null;\n  \t            }\n  \t            this.DisallowIncrement(logic);\n  \t            let contentList = (0, TypeAssertion_1.asOrNull)(logic, ContentList_1.ContentList);\n  \t            if (!contentList) {\n  \t                contentList = new ContentList_1.ContentList(logic);\n  \t            }\n  \t            this.Whitespace();\n  \t            this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");\n  \t            // Allow nested strings and logic\n  \t            this.parsingStringExpression = wasParsingString;\n  \t            // Difference between:\n  \t            //\n  \t            //     1) A thing # {image}.jpg\n  \t            //     2) A {red #red|blue #blue} sequence.\n  \t            //\n  \t            //  When logic ends in (1) we still want tag to continue.\n  \t            //  When logic ends in (2) we want to auto-end the tag.\n  \t            //  Side note: we simply disallow tags within strings.\n  \t            if (!wasTagActive)\n  \t                this.EndTagIfNecessary(contentList);\n  \t            return contentList;\n  \t        };\n  \t        this.InnerLogic = () => {\n  \t            this.Whitespace();\n  \t            // Explicitly try the combinations of inner logic\n  \t            // that could potentially have conflicts first.\n  \t            // Explicit sequence annotation?\n  \t            const explicitSeqType = this.ParseObject(this.SequenceTypeAnnotation);\n  \t            if (explicitSeqType !== null) {\n  \t                const contentLists = this.Expect(this.InnerSequenceObjects, \"sequence elements (for cycle/stoping etc)\");\n  \t                if (contentLists === null) {\n  \t                    return null;\n  \t                }\n  \t                return new Sequence_1.Sequence(contentLists, explicitSeqType);\n  \t            }\n  \t            // Conditional with expression?\n  \t            const initialQueryExpression = this.Parse(this.ConditionExpression);\n  \t            if (initialQueryExpression) {\n  \t                const conditional = this.Expect(() => this.InnerConditionalContent(initialQueryExpression), \"conditional content following query\");\n  \t                return conditional;\n  \t            }\n  \t            // Now try to evaluate each of the \"full\" rules in turn\n  \t            const rules = [\n  \t                // Conditional still necessary, since you can have a multi-line conditional\n  \t                // without an initial query expression:\n  \t                // {\n  \t                //   - true:  this is true\n  \t                //   - false: this is false\n  \t                // }\n  \t                this.InnerConditionalContent,\n  \t                this.InnerSequence,\n  \t                this.InnerExpression,\n  \t            ];\n  \t            //let wasTagActiveAtStartOfScope = this.tagActive;\n  \t            // Adapted from \"OneOf\" structuring rule except that in\n  \t            // order for the rule to succeed, it has to maximally\n  \t            // cover the entire string within the { }. Used to\n  \t            // differentiate between:\n  \t            //  {myVar}                 -- Expression (try first)\n  \t            //  {my content is jolly}   -- sequence with single element\n  \t            for (const rule of rules) {\n  \t                const ruleId = this.BeginRule();\n  \t                const result = this.ParseObject(rule);\n  \t                if (result) {\n  \t                    // Not yet at end?\n  \t                    if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {\n  \t                        this.FailRule(ruleId);\n  \t                    }\n  \t                    else {\n  \t                        // Full parse of content within braces\n  \t                        return this.SucceedRule(ruleId, result);\n  \t                    }\n  \t                }\n  \t                else {\n  \t                    this.FailRule(ruleId);\n  \t                }\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.InnerExpression = () => {\n  \t            const expr = this.Parse(this.Expression);\n  \t            if (expr) {\n  \t                expr.outputWhenComplete = true;\n  \t            }\n  \t            return expr;\n  \t        };\n  \t        this.IdentifierWithMetadata = () => {\n  \t            const id = this.Identifier();\n  \t            if (id === null) {\n  \t                return null;\n  \t            }\n  \t            return new Identifier_1.Identifier(id);\n  \t        };\n  \t        // Note: we allow identifiers that start with a number,\n  \t        // but not if they *only* comprise numbers\n  \t        this.Identifier = () => {\n  \t            // Parse remaining characters (if any)\n  \t            const name = this.ParseCharactersFromCharSet(this.identifierCharSet);\n  \t            if (name === null) {\n  \t                return null;\n  \t            }\n  \t            // Reject if it's just a number\n  \t            let isNumberCharsOnly = true;\n  \t            for (let c of name) {\n  \t                if (!(c >= \"0\" && c <= \"9\")) {\n  \t                    isNumberCharsOnly = false;\n  \t                    break;\n  \t                }\n  \t            }\n  \t            if (isNumberCharsOnly) {\n  \t                return null;\n  \t            }\n  \t            return name;\n  \t        };\n  \t        /**\n  \t         * End Logic section.\n  \t         */\n  \t        /**\n  \t         * Begin Sequences section.\n  \t         */\n  \t        this._sequenceTypeSymbols = new CharacterSet_1.CharacterSet(\"!&~$\");\n  \t        this.InnerSequence = () => {\n  \t            this.Whitespace();\n  \t            // Default sequence type\n  \t            let seqType = SequenceType_1.SequenceType.Stopping;\n  \t            // Optional explicit sequence type\n  \t            const parsedSeqType = this.Parse(this.SequenceTypeAnnotation);\n  \t            if (parsedSeqType !== null) {\n  \t                seqType = parsedSeqType;\n  \t            }\n  \t            const contentLists = this.Parse(this.InnerSequenceObjects);\n  \t            if (contentLists === null || contentLists.length <= 1) {\n  \t                return null;\n  \t            }\n  \t            return new Sequence_1.Sequence(contentLists, seqType);\n  \t        };\n  \t        this.SequenceTypeAnnotation = () => {\n  \t            let annotation = this.Parse(this.SequenceTypeSymbolAnnotation);\n  \t            if (annotation === null) {\n  \t                annotation = this.Parse(this.SequenceTypeWordAnnotation);\n  \t            }\n  \t            if (annotation === null) {\n  \t                return null;\n  \t            }\n  \t            switch (annotation) {\n  \t                case SequenceType_1.SequenceType.Once:\n  \t                case SequenceType_1.SequenceType.Cycle:\n  \t                case SequenceType_1.SequenceType.Stopping:\n  \t                case SequenceType_1.SequenceType.Shuffle:\n  \t                // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n  \t                case SequenceType_1.SequenceType.Shuffle | SequenceType_1.SequenceType.Stopping:\n  \t                // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n  \t                case SequenceType_1.SequenceType.Shuffle | SequenceType_1.SequenceType.Once:\n  \t                    break;\n  \t                default:\n  \t                    this.Error(`Sequence type combination not supported: ${annotation}`);\n  \t                    return SequenceType_1.SequenceType.Stopping;\n  \t            }\n  \t            return annotation;\n  \t        };\n  \t        this.SequenceTypeSymbolAnnotation = () => {\n  \t            if (this._sequenceTypeSymbols === null) {\n  \t                this._sequenceTypeSymbols = new CharacterSet_1.CharacterSet(\"!&~$ \");\n  \t            }\n  \t            let sequenceType = 0;\n  \t            const sequenceAnnotations = this.ParseCharactersFromCharSet(this._sequenceTypeSymbols);\n  \t            if (sequenceAnnotations === null) {\n  \t                return null;\n  \t            }\n  \t            for (const symbolChar of sequenceAnnotations) {\n  \t                switch (symbolChar) {\n  \t                    case \"!\":\n  \t                        sequenceType |= SequenceType_1.SequenceType.Once;\n  \t                        break;\n  \t                    case \"&\":\n  \t                        sequenceType |= SequenceType_1.SequenceType.Cycle;\n  \t                        break;\n  \t                    case \"~\":\n  \t                        sequenceType |= SequenceType_1.SequenceType.Shuffle;\n  \t                        break;\n  \t                    case \"$\":\n  \t                        sequenceType |= SequenceType_1.SequenceType.Stopping;\n  \t                        break;\n  \t                }\n  \t            }\n  \t            if (sequenceType === 0) {\n  \t                return null;\n  \t            }\n  \t            return sequenceType;\n  \t        };\n  \t        this.SequenceTypeWordAnnotation = () => {\n  \t            const sequenceTypes = this.Interleave(this.SequenceTypeSingleWord, this.Exclude(this.Whitespace));\n  \t            if (sequenceTypes === null || sequenceTypes.length === 0) {\n  \t                return null;\n  \t            }\n  \t            if (this.ParseString(\":\") === null) {\n  \t                return null;\n  \t            }\n  \t            let combinedSequenceType = 0;\n  \t            for (const seqType of sequenceTypes) {\n  \t                combinedSequenceType |= seqType;\n  \t            }\n  \t            return combinedSequenceType;\n  \t        };\n  \t        this.SequenceTypeSingleWord = () => {\n  \t            let seqType = null;\n  \t            const word = this.Parse(this.IdentifierWithMetadata);\n  \t            if (word !== null) {\n  \t                switch (word.name) {\n  \t                    case \"once\":\n  \t                        seqType = SequenceType_1.SequenceType.Once;\n  \t                        break;\n  \t                    case \"cycle\":\n  \t                        seqType = SequenceType_1.SequenceType.Cycle;\n  \t                        break;\n  \t                    case \"shuffle\":\n  \t                        seqType = SequenceType_1.SequenceType.Shuffle;\n  \t                        break;\n  \t                    case \"stopping\":\n  \t                        seqType = SequenceType_1.SequenceType.Stopping;\n  \t                        break;\n  \t                }\n  \t            }\n  \t            if (seqType === null) {\n  \t                return null;\n  \t            }\n  \t            return seqType;\n  \t        };\n  \t        this.InnerSequenceObjects = () => {\n  \t            const multiline = this.Parse(this.Newline) !== null;\n  \t            let result = null;\n  \t            if (multiline) {\n  \t                result = this.Parse(this.InnerMultilineSequenceObjects);\n  \t            }\n  \t            else {\n  \t                result = this.Parse(this.InnerInlineSequenceObjects);\n  \t            }\n  \t            return result;\n  \t        };\n  \t        this.InnerInlineSequenceObjects = () => {\n  \t            const interleavedContentAndPipes = this.Interleave(this.Optional(this.MixedTextAndLogic), this.String(\"|\"), null, false);\n  \t            if (interleavedContentAndPipes === null) {\n  \t                return null;\n  \t            }\n  \t            const result = [];\n  \t            // The content and pipes won't necessarily be perfectly interleaved in the sense that\n  \t            // the content can be missing, but in that case it's intended that there's blank content.\n  \t            let justHadContent = false;\n  \t            for (const contentOrPipe of interleavedContentAndPipes) {\n  \t                // Pipe/separator\n  \t                if (contentOrPipe === \"|\") {\n  \t                    // Expected content, saw pipe - need blank content now\n  \t                    if (!justHadContent) {\n  \t                        // Add blank content\n  \t                        result.push(new ContentList_1.ContentList());\n  \t                    }\n  \t                    justHadContent = false;\n  \t                }\n  \t                else {\n  \t                    // Real content\n  \t                    const content = contentOrPipe;\n  \t                    if (content === null) {\n  \t                        this.Error(`Expected content, but got ${contentOrPipe} (this is an ink compiler bug!)`);\n  \t                    }\n  \t                    else {\n  \t                        result.push(new ContentList_1.ContentList(content));\n  \t                    }\n  \t                    justHadContent = true;\n  \t                }\n  \t            }\n  \t            // Ended in a pipe? Need to insert final blank content\n  \t            if (!justHadContent) {\n  \t                result.push(new ContentList_1.ContentList());\n  \t            }\n  \t            return result;\n  \t        };\n  \t        this.InnerMultilineSequenceObjects = () => {\n  \t            this.MultilineWhitespace();\n  \t            const contentLists = this.OneOrMore(this.SingleMultilineSequenceElement);\n  \t            if (contentLists === null) {\n  \t                return null;\n  \t            }\n  \t            return contentLists;\n  \t        };\n  \t        this.SingleMultilineSequenceElement = () => {\n  \t            this.Whitespace();\n  \t            // Make sure we're not accidentally parsing a divert\n  \t            if (this.ParseString(\"->\") !== null) {\n  \t                return null;\n  \t            }\n  \t            if (this.ParseString(\"-\") === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            const content = this.StatementsAtLevel(StatementLevel_1.StatementLevel.InnerBlock);\n  \t            if (content === null) {\n  \t                this.MultilineWhitespace();\n  \t            }\n  \t            else {\n  \t                // Add newline at the start of each branch\n  \t                content.unshift(new Text_1.Text(\"\\n\"));\n  \t            }\n  \t            return new ContentList_1.ContentList(content);\n  \t        };\n  \t        /**\n  \t         * End Sequences section.\n  \t         */\n  \t        /**\n  \t         * Begin Statements section.\n  \t         */\n  \t        this._statementRulesAtLevel = [];\n  \t        this._statementBreakRulesAtLevel = [];\n  \t        this.StatementsAtLevel = (level) => {\n  \t            // Check for error: Should not be allowed gather dashes within an inner block\n  \t            if (level === StatementLevel_1.StatementLevel.InnerBlock) {\n  \t                const badGatherDashCount = this.Parse(this.GatherDashes);\n  \t                if (badGatherDashCount !== null) {\n  \t                    this.Error(\"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\");\n  \t                }\n  \t            }\n  \t            return this.Interleave(this.Optional(this.MultilineWhitespace), () => this.StatementAtLevel(level), () => this.StatementsBreakForLevel(level));\n  \t        };\n  \t        this.StatementAtLevel = (level) => {\n  \t            const rulesAtLevel = this._statementRulesAtLevel[level];\n  \t            const statement = this.OneOf(rulesAtLevel);\n  \t            // For some statements, allow them to parse, but create errors, since\n  \t            // writers may think they can use the statement, so it's useful to have\n  \t            // the error message.\n  \t            if (level === StatementLevel_1.StatementLevel.Top) {\n  \t                if (statement instanceof ReturnType_1.ReturnType) {\n  \t                    this.Error(\"should not have return statement outside of a knot\");\n  \t                }\n  \t            }\n  \t            return statement;\n  \t        };\n  \t        this.StatementsBreakForLevel = (level) => {\n  \t            this.Whitespace();\n  \t            const breakRules = this._statementBreakRulesAtLevel[level];\n  \t            const breakRuleResult = this.OneOf(breakRules);\n  \t            if (breakRuleResult === null) {\n  \t                return null;\n  \t            }\n  \t            return breakRuleResult;\n  \t        };\n  \t        this.GenerateStatementLevelRules = () => {\n  \t            const levels = Object.values(StatementLevel_1.StatementLevel);\n  \t            this._statementRulesAtLevel = \"f\"\n  \t                .repeat(levels.length)\n  \t                .split(\"f\")\n  \t                .map(() => []);\n  \t            this._statementBreakRulesAtLevel = \"f\"\n  \t                .repeat(levels.length)\n  \t                .split(\"f\")\n  \t                .map(() => []);\n  \t            for (const level of levels) {\n  \t                const rulesAtLevel = [];\n  \t                const breakingRules = [];\n  \t                // Diverts can go anywhere\n  \t                rulesAtLevel.push(this.Line(this.MultiDivert));\n  \t                // Knots can only be parsed at Top/Global scope\n  \t                if (level >= StatementLevel_1.StatementLevel.Top) {\n  \t                    rulesAtLevel.push(this.KnotDefinition);\n  \t                }\n  \t                rulesAtLevel.push(this.Line(this.Choice));\n  \t                rulesAtLevel.push(this.Line(this.AuthorWarning));\n  \t                // Gather lines would be confused with multi-line block separators, like\n  \t                // within a multi-line if statement\n  \t                if (level > StatementLevel_1.StatementLevel.InnerBlock) {\n  \t                    rulesAtLevel.push(this.Gather);\n  \t                }\n  \t                // Stitches (and gathers) can (currently) only go in Knots and top level\n  \t                if (level >= StatementLevel_1.StatementLevel.Knot) {\n  \t                    rulesAtLevel.push(this.StitchDefinition);\n  \t                }\n  \t                // Global variable declarations can go anywhere\n  \t                rulesAtLevel.push(this.Line(this.ListDeclaration));\n  \t                rulesAtLevel.push(this.Line(this.VariableDeclaration));\n  \t                rulesAtLevel.push(this.Line(this.ConstDeclaration));\n  \t                rulesAtLevel.push(this.Line(this.ExternalDeclaration));\n  \t                // Global include can go anywhere\n  \t                rulesAtLevel.push(this.Line(this.IncludeStatement));\n  \t                // Normal logic / text can go anywhere\n  \t                rulesAtLevel.push(this.LogicLine);\n  \t                rulesAtLevel.push(this.LineOfMixedTextAndLogic);\n  \t                // --------\n  \t                // Breaking rules\n  \t                // Break current knot with a new knot\n  \t                if (level <= StatementLevel_1.StatementLevel.Knot) {\n  \t                    breakingRules.push(this.KnotDeclaration);\n  \t                }\n  \t                // Break current stitch with a new stitch\n  \t                if (level <= StatementLevel_1.StatementLevel.Stitch) {\n  \t                    breakingRules.push(this.StitchDeclaration);\n  \t                }\n  \t                // Breaking an inner block (like a multi-line condition statement)\n  \t                if (level <= StatementLevel_1.StatementLevel.InnerBlock) {\n  \t                    breakingRules.push(this.ParseDashNotArrow);\n  \t                    breakingRules.push(this.String(\"}\"));\n  \t                }\n  \t                this._statementRulesAtLevel[level] = rulesAtLevel;\n  \t                this._statementBreakRulesAtLevel[level] = breakingRules;\n  \t            }\n  \t        };\n  \t        this.SkipToNextLine = () => {\n  \t            this.ParseUntilCharactersFromString(\"\\n\\r\");\n  \t            this.ParseNewline();\n  \t            return StringParser_1.ParseSuccess;\n  \t        };\n  \t        // Modifier to turn a rule into one that expects a newline on the end.\n  \t        // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use\n  \t        // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.\n  \t        this.Line = (inlineRule) => () => {\n  \t            const result = this.ParseObject(inlineRule);\n  \t            if (result === null) {\n  \t                return null;\n  \t            }\n  \t            this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n  \t            return result;\n  \t        };\n  \t        /**\n  \t         * End Statements section.\n  \t         */\n  \t        /**\n  \t         * Begin Tags section.\n  \t         */\n  \t        this.StartTag = () => {\n  \t            this.Whitespace();\n  \t            if (this.ParseString(\"#\") === null) {\n  \t                return null;\n  \t            }\n  \t            if (this.parsingStringExpression) {\n  \t                this.Error(\"Tags aren't allowed inside of strings. Please use \\\\# if you want a hash symbol.\");\n  \t            }\n  \t            let result = null;\n  \t            if (this.tagActive) {\n  \t                let contentList = new ContentList_1.ContentList();\n  \t                contentList.AddContent(new Tag_1.Tag(/*isStart:*/ false));\n  \t                contentList.AddContent(new Tag_1.Tag(/*isStart:*/ true));\n  \t                result = contentList;\n  \t            }\n  \t            else {\n  \t                result = new Tag_1.Tag(/*isStart:*/ true);\n  \t            }\n  \t            this.tagActive = true;\n  \t            this.Whitespace();\n  \t            return result;\n  \t        };\n  \t        /**\n  \t         * End Tags section.\n  \t         */\n  \t        /**\n  \t         * Begin Whitespace section.\n  \t         */\n  \t        this._inlineWhitespaceChars = new CharacterSet_1.CharacterSet(\" \\t\");\n  \t        // Handles both newline and endOfFile\n  \t        this.EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);\n  \t        // Allow whitespace before the actual newline\n  \t        this.Newline = () => {\n  \t            this.Whitespace();\n  \t            const gotNewline = this.ParseNewline() !== null;\n  \t            // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n  \t            if (!gotNewline) {\n  \t                return null;\n  \t            }\n  \t            return StringParser_1.ParseSuccess;\n  \t        };\n  \t        this.EndOfFile = () => {\n  \t            this.Whitespace();\n  \t            if (!this.endOfInput)\n  \t                return null;\n  \t            return StringParser_1.ParseSuccess;\n  \t        };\n  \t        // General purpose space, returns N-count newlines (fails if no newlines)\n  \t        this.MultilineWhitespace = () => {\n  \t            let newlines = this.OneOrMore(this.Newline);\n  \t            if (newlines === null) {\n  \t                return null;\n  \t            }\n  \t            // Use content field of Token to say how many newlines there were\n  \t            // (in most circumstances it's unimportant)\n  \t            const numNewlines = newlines.length;\n  \t            if (numNewlines >= 1) {\n  \t                return StringParser_1.ParseSuccess;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.Whitespace = () => {\n  \t            const doneParsed = this.ParseCharactersFromCharSet(this._inlineWhitespaceChars);\n  \t            if (doneParsed !== null) {\n  \t                return StringParser_1.ParseSuccess;\n  \t            }\n  \t            return null;\n  \t        };\n  \t        this.Spaced = (rule) => () => {\n  \t            this.Whitespace();\n  \t            const result = this.ParseObject(rule);\n  \t            if (result === null) {\n  \t                return null;\n  \t            }\n  \t            this.Whitespace();\n  \t            return result;\n  \t        };\n  \t        this.AnyWhitespace = () => {\n  \t            let anyWhitespace = false;\n  \t            while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {\n  \t                anyWhitespace = true;\n  \t            }\n  \t            return anyWhitespace ? StringParser_1.ParseSuccess : null;\n  \t        };\n  \t        this.MultiSpaced = (rule) => () => {\n  \t            this.AnyWhitespace();\n  \t            const result = this.ParseObject(rule);\n  \t            if (result === null) {\n  \t                return null;\n  \t            }\n  \t            this.AnyWhitespace();\n  \t            return result;\n  \t        };\n  \t        this._filename = null;\n  \t        this._externalErrorHandler = null;\n  \t        this._fileHandler = null;\n  \t        this._filename = filename;\n  \t        this.RegisterExpressionOperators();\n  \t        this.GenerateStatementLevelRules();\n  \t        this.errorHandler = this.OnStringParserError;\n  \t        this._externalErrorHandler = externalErrorHandler;\n  \t        if (fileHandler === null) {\n  \t            this._fileHandler = new DefaultFileHandler_1.DefaultFileHandler();\n  \t        }\n  \t        else {\n  \t            this._fileHandler = fileHandler;\n  \t        }\n  \t        if (rootParser === null) {\n  \t            this._rootParser = this;\n  \t            this._openFilenames = [];\n  \t            if (this._filename !== null) {\n  \t                const fullRootInkPath = this.fileHandler.ResolveInkFilename(this._filename);\n  \t                this._openFilenames.push(fullRootInkPath);\n  \t            }\n  \t        }\n  \t        else {\n  \t            this._rootParser = rootParser;\n  \t        }\n  \t    }\n  \t    PreProcessInputString(str) {\n  \t        const commentEliminator = new CommentEliminator_1.CommentEliminator(str);\n  \t        return commentEliminator.Process();\n  \t    }\n  \t    get parsingStringExpression() {\n  \t        return this.GetFlag(Number(CustomFlags_1.CustomFlags.ParsingString));\n  \t    }\n  \t    set parsingStringExpression(value) {\n  \t        this.SetFlag(Number(CustomFlags_1.CustomFlags.ParsingString), value);\n  \t    }\n  \t    get tagActive() {\n  \t        return this.GetFlag(Number(CustomFlags_1.CustomFlags.TagActive));\n  \t    }\n  \t    set tagActive(value) {\n  \t        this.SetFlag(Number(CustomFlags_1.CustomFlags.TagActive), value);\n  \t    }\n  \t    get identifierCharSet() {\n  \t        if (this._identifierCharSet === null) {\n  \t            (this._identifierCharSet = new CharacterSet_1.CharacterSet())\n  \t                .AddRange(\"A\", \"Z\")\n  \t                .AddRange(\"a\", \"z\")\n  \t                .AddRange(\"0\", \"9\")\n  \t                .Add(\"_\");\n  \t            // Enable non-ASCII characters for story identifiers.\n  \t            this.ExtendIdentifierCharacterRanges(this._identifierCharSet);\n  \t        }\n  \t        return this._identifierCharSet;\n  \t    }\n  \t    EndTagIfNecessary(outputContentList) {\n  \t        if (this.tagActive) {\n  \t            if (outputContentList != null) {\n  \t                if (outputContentList instanceof ContentList_1.ContentList) {\n  \t                    outputContentList.AddContent(new Tag_1.Tag(/*isStart:*/ false));\n  \t                }\n  \t                else {\n  \t                    outputContentList.push(new Tag_1.Tag(/*isStart:*/ false));\n  \t                }\n  \t            }\n  \t            this.tagActive = false;\n  \t        }\n  \t    }\n  \t};\n  \tInkParser.InkParser = InkParser$1;\n  \t/**\n  \t * End base InkParser section.\n  \t */\n  \t/**\n  \t * Begin CharacterRanges section.\n  \t */\n  \tInkParser$1.LatinBasic = CharacterRange_1.CharacterRange.Define(\"\\u0041\", \"\\u007A\", new CharacterSet_1.CharacterSet().AddRange(\"\\u005B\", \"\\u0060\"));\n  \tInkParser$1.LatinExtendedA = CharacterRange_1.CharacterRange.Define(\"\\u0100\", \"\\u017F\"\n  \t// no excludes here\n  \t);\n  \tInkParser$1.LatinExtendedB = CharacterRange_1.CharacterRange.Define(\"\\u0180\", \"\\u024F\"\n  \t// no excludes here\n  \t);\n  \tInkParser$1.Greek = CharacterRange_1.CharacterRange.Define(\"\\u0370\", \"\\u03FF\", new CharacterSet_1.CharacterSet()\n  \t    .AddRange(\"\\u0378\", \"\\u0385\")\n  \t    .AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\"));\n  \tInkParser$1.Cyrillic = CharacterRange_1.CharacterRange.Define(\"\\u0400\", \"\\u04FF\", new CharacterSet_1.CharacterSet().AddRange(\"\\u0482\", \"\\u0489\"));\n  \tInkParser$1.Armenian = CharacterRange_1.CharacterRange.Define(\"\\u0530\", \"\\u058F\", new CharacterSet_1.CharacterSet()\n  \t    .AddCharacters(\"\\u0530\")\n  \t    .AddRange(\"\\u0557\", \"\\u0560\")\n  \t    .AddRange(\"\\u0588\", \"\\u058E\"));\n  \tInkParser$1.Hebrew = CharacterRange_1.CharacterRange.Define(\"\\u0590\", \"\\u05FF\", new CharacterSet_1.CharacterSet());\n  \tInkParser$1.Arabic = CharacterRange_1.CharacterRange.Define(\"\\u0600\", \"\\u06FF\", new CharacterSet_1.CharacterSet());\n  \tInkParser$1.Korean = CharacterRange_1.CharacterRange.Define(\"\\uAC00\", \"\\uD7AF\", new CharacterSet_1.CharacterSet());\n  \tInkParser$1.Latin1Supplement = CharacterRange_1.CharacterRange.Define(\"\\u0080\", \"\\u00FF\", new CharacterSet_1.CharacterSet());\n  \tInkParser$1.Chinese = CharacterRange_1.CharacterRange.Define(\"\\u4E00\", \"\\u9FFF\", new CharacterSet_1.CharacterSet());\n  \t/// <summary>\n  \t/// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  \t/// non-ASCII character ranges that can be used in identifier names.\n  \t/// </summary>\n  \t/// <returns>\n  \t/// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  \t/// non-ASCII character ranges that can be used in identifier names.\n  \t/// </returns>\n  \tInkParser$1.ListAllCharacterRanges = () => [\n  \t    InkParser$1.LatinBasic,\n  \t    InkParser$1.LatinExtendedA,\n  \t    InkParser$1.LatinExtendedB,\n  \t    InkParser$1.Arabic,\n  \t    InkParser$1.Armenian,\n  \t    InkParser$1.Cyrillic,\n  \t    InkParser$1.Greek,\n  \t    InkParser$1.Hebrew,\n  \t    InkParser$1.Korean,\n  \t    InkParser$1.Latin1Supplement,\n  \t    InkParser$1.Chinese,\n  \t];\n  \t\n  \treturn InkParser;\n  }\n\n  var Stats = {};\n\n  var hasRequiredStats;\n\n  function requireStats () {\n  \tif (hasRequiredStats) return Stats;\n  \thasRequiredStats = 1;\n  \tObject.defineProperty(Stats, \"__esModule\", { value: true });\n  \tStats.GenerateStoryStats = void 0;\n  \tconst Choice_1 = requireChoice();\n  \tconst Divert_1 = requireDivert();\n  \tconst Gather_1 = requireGather();\n  \tconst Knot_1 = requireKnot();\n  \tconst Stitch_1 = requireStitch();\n  \tconst Text_1 = requireText();\n  \tfunction GenerateStoryStats(story) {\n  \t    let allText = story.FindAll(Text_1.Text)();\n  \t    let words = 0;\n  \t    for (const text of allText) {\n  \t        let wordsInThisStr = 0;\n  \t        let wasWhiteSpace = true;\n  \t        for (const c of text.text) {\n  \t            if (c == \" \" || c == \"\\t\" || c == \"\\n\" || c == \"\\r\") {\n  \t                wasWhiteSpace = true;\n  \t            }\n  \t            else if (wasWhiteSpace) {\n  \t                wordsInThisStr++;\n  \t                wasWhiteSpace = false;\n  \t            }\n  \t        }\n  \t        words += wordsInThisStr;\n  \t    }\n  \t    const knots = story.FindAll(Knot_1.Knot)();\n  \t    const stitches = story.FindAll(Stitch_1.Stitch)();\n  \t    const choices = story.FindAll(Choice_1.Choice)();\n  \t    const gathers = story.FindAll(Gather_1.Gather)((g) => g.debugMetadata != null);\n  \t    const diverts = story.FindAll(Divert_1.Divert)();\n  \t    return {\n  \t        words,\n  \t        knots: knots.length,\n  \t        functions: knots.filter((k) => k.isFunction).length,\n  \t        stitches: stitches.length,\n  \t        gathers: gathers.length,\n  \t        diverts: diverts.length - 1,\n  \t        choices: choices.length,\n  \t    };\n  \t}\n  \tStats.GenerateStoryStats = GenerateStoryStats;\n  \t\n  \treturn Stats;\n  }\n\n  var JsonFileHandler = {};\n\n  var hasRequiredJsonFileHandler;\n\n  function requireJsonFileHandler () {\n  \tif (hasRequiredJsonFileHandler) return JsonFileHandler;\n  \thasRequiredJsonFileHandler = 1;\n  \tObject.defineProperty(JsonFileHandler, \"__esModule\", { value: true });\n  \tJsonFileHandler.JsonFileHandler = void 0;\n  \tlet JsonFileHandler$1 = class JsonFileHandler {\n  \t    constructor(fileHierarchy) {\n  \t        this.fileHierarchy = fileHierarchy;\n  \t        this.ResolveInkFilename = (filename) => {\n  \t            if (Object.keys(this.fileHierarchy).includes(filename))\n  \t                return filename;\n  \t            throw new Error(`Cannot locate ${filename}. Are you trying a relative import ? This is not yet implemented.`);\n  \t        };\n  \t        this.LoadInkFileContents = (filename) => {\n  \t            if (Object.keys(this.fileHierarchy).includes(filename)) {\n  \t                return this.fileHierarchy[filename];\n  \t            }\n  \t            else {\n  \t                throw new Error(`Cannot open ${filename}.`);\n  \t            }\n  \t        };\n  \t    }\n  \t};\n  \tJsonFileHandler.JsonFileHandler = JsonFileHandler$1;\n  \t\n  \treturn JsonFileHandler;\n  }\n\n  var hasRequiredCompiler;\n\n  function requireCompiler () {\n  \tif (hasRequiredCompiler) return Compiler;\n  \thasRequiredCompiler = 1;\n  \t(function (exports) {\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.Compiler = exports.Story = exports.InkList = exports.JsonFileHandler = exports.StatementLevel = exports.InkParser = exports.CompilerOptions = void 0;\n  \t\tconst CompilerOptions_1 = requireCompilerOptions();\n  \t\tconst DebugSourceRange_1 = requireDebugSourceRange();\n  \t\tconst ErrorType_1 = requireErrorType();\n  \t\tconst InkParser_1 = requireInkParser();\n  \t\tconst Value_1 = requireValue();\n  \t\tconst TypeAssertion_1 = requireTypeAssertion();\n  \t\tconst Stats_1 = requireStats();\n  \t\tvar CompilerOptions_2 = requireCompilerOptions();\n  \t\tObject.defineProperty(exports, \"CompilerOptions\", { enumerable: true, get: function () { return CompilerOptions_2.CompilerOptions; } });\n  \t\tvar InkParser_2 = requireInkParser();\n  \t\tObject.defineProperty(exports, \"InkParser\", { enumerable: true, get: function () { return InkParser_2.InkParser; } });\n  \t\tvar StatementLevel_1 = requireStatementLevel();\n  \t\tObject.defineProperty(exports, \"StatementLevel\", { enumerable: true, get: function () { return StatementLevel_1.StatementLevel; } });\n  \t\tvar JsonFileHandler_1 = requireJsonFileHandler();\n  \t\tObject.defineProperty(exports, \"JsonFileHandler\", { enumerable: true, get: function () { return JsonFileHandler_1.JsonFileHandler; } });\n  \t\tvar Story_1 = requireStory$1();\n  \t\tObject.defineProperty(exports, \"InkList\", { enumerable: true, get: function () { return Story_1.InkList; } });\n  \t\tObject.defineProperty(exports, \"Story\", { enumerable: true, get: function () { return Story_1.Story; } });\n  \t\tclass Compiler {\n  \t\t    get errors() {\n  \t\t        return this._errors;\n  \t\t    }\n  \t\t    get warnings() {\n  \t\t        return this._warnings;\n  \t\t    }\n  \t\t    get authorMessages() {\n  \t\t        return this._authorMessages;\n  \t\t    }\n  \t\t    get inputString() {\n  \t\t        return this._inputString;\n  \t\t    }\n  \t\t    get options() {\n  \t\t        return this._options;\n  \t\t    }\n  \t\t    get parsedStory() {\n  \t\t        if (!this._parsedStory) {\n  \t\t            throw new Error();\n  \t\t        }\n  \t\t        return this._parsedStory;\n  \t\t    }\n  \t\t    get runtimeStory() {\n  \t\t        if (!this._runtimeStory) {\n  \t\t            throw new Error(\"Compilation failed.\");\n  \t\t        }\n  \t\t        return this._runtimeStory;\n  \t\t    }\n  \t\t    get parser() {\n  \t\t        if (!this._parser) {\n  \t\t            throw new Error();\n  \t\t        }\n  \t\t        return this._parser;\n  \t\t    }\n  \t\t    get debugSourceRanges() {\n  \t\t        return this._debugSourceRanges;\n  \t\t    }\n  \t\t    constructor(inkSource, options = null) {\n  \t\t        this._errors = [];\n  \t\t        this._warnings = [];\n  \t\t        this._authorMessages = [];\n  \t\t        this._parsedStory = null;\n  \t\t        this._runtimeStory = null;\n  \t\t        this._parser = null;\n  \t\t        this._debugSourceRanges = [];\n  \t\t        this.Compile = () => {\n  \t\t            this._parser = new InkParser_1.InkParser(this.inputString, this.options.sourceFilename || null, this.OnError, null, this.options.fileHandler);\n  \t\t            this._parsedStory = this.parser.ParseStory();\n  \t\t            if (this.errors.length === 0) {\n  \t\t                this.parsedStory.countAllVisits = this.options.countAllVisits;\n  \t\t                this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);\n  \t\t            }\n  \t\t            else {\n  \t\t                this._runtimeStory = null;\n  \t\t            }\n  \t\t            return this.runtimeStory;\n  \t\t        };\n  \t\t        this.RetrieveDebugSourceForLatestContent = () => {\n  \t\t            var _a;\n  \t\t            for (const outputObj of this.runtimeStory.state.outputStream) {\n  \t\t                const textContent = (0, TypeAssertion_1.asOrNull)(outputObj, Value_1.StringValue);\n  \t\t                if (textContent !== null) {\n  \t\t                    const range = new DebugSourceRange_1.DebugSourceRange(((_a = textContent.value) === null || _a === void 0 ? void 0 : _a.length) || 0, textContent.debugMetadata, textContent.value || \"unknown\");\n  \t\t                    this.debugSourceRanges.push(range);\n  \t\t                }\n  \t\t            }\n  \t\t        };\n  \t\t        this.GenerateStats = () => {\n  \t\t            if (this._parsedStory === null) {\n  \t\t                return null;\n  \t\t            }\n  \t\t            return (0, Stats_1.GenerateStoryStats)(this._parsedStory);\n  \t\t        };\n  \t\t        this.DebugMetadataForContentAtOffset = (offset) => {\n  \t\t            let currOffset = 0;\n  \t\t            let lastValidMetadata = null;\n  \t\t            for (const range of this.debugSourceRanges) {\n  \t\t                if (range.debugMetadata !== null) {\n  \t\t                    lastValidMetadata = range.debugMetadata;\n  \t\t                }\n  \t\t                if (offset >= currOffset && offset < currOffset + range.length) {\n  \t\t                    return lastValidMetadata;\n  \t\t                }\n  \t\t                currOffset += range.length;\n  \t\t            }\n  \t\t            return null;\n  \t\t        };\n  \t\t        this.OnError = (message, errorType) => {\n  \t\t            switch (errorType) {\n  \t\t                case ErrorType_1.ErrorType.Author:\n  \t\t                    this._authorMessages.push(message);\n  \t\t                    break;\n  \t\t                case ErrorType_1.ErrorType.Warning:\n  \t\t                    this._warnings.push(message);\n  \t\t                    break;\n  \t\t                case ErrorType_1.ErrorType.Error:\n  \t\t                    this._errors.push(message);\n  \t\t                    break;\n  \t\t            }\n  \t\t            if (this.options.errorHandler !== null) {\n  \t\t                this.options.errorHandler(message, errorType);\n  \t\t            }\n  \t\t        };\n  \t\t        this._inputString = inkSource;\n  \t\t        this._options = options || new CompilerOptions_1.CompilerOptions();\n  \t\t    }\n  \t\t}\n  \t\texports.Compiler = Compiler;\n  \t\t\n  \t} (Compiler));\n  \treturn Compiler;\n  }\n\n  var PosixFileHandler = {};\n\n  var hasRequiredPosixFileHandler;\n\n  function requirePosixFileHandler () {\n  \tif (hasRequiredPosixFileHandler) return PosixFileHandler;\n  \thasRequiredPosixFileHandler = 1;\n  \tObject.defineProperty(PosixFileHandler, \"__esModule\", { value: true });\n  \tPosixFileHandler.PosixFileHandler = void 0;\n  \tconst path = require$$0;\n  \tconst fs = require$$1;\n  \t// This class replaces upstream's DefaultFileHandler.\n  \tlet PosixFileHandler$1 = class PosixFileHandler {\n  \t    constructor(rootPath = \"\") {\n  \t        this.rootPath = rootPath;\n  \t        this.ResolveInkFilename = (filename) => {\n  \t            return path.resolve(process.cwd(), this.rootPath, filename);\n  \t        };\n  \t        this.LoadInkFileContents = (filename) => {\n  \t            return fs.readFileSync(filename, \"utf-8\");\n  \t        };\n  \t    }\n  \t};\n  \tPosixFileHandler.PosixFileHandler = PosixFileHandler$1;\n  \t\n  \treturn PosixFileHandler;\n  }\n\n  var hasRequiredInk;\n\n  function requireInk () {\n  \tif (hasRequiredInk) return ink;\n  \thasRequiredInk = 1;\n  \t(function (exports) {\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.JsonFileHandler = exports.PosixFileHandler = exports.CompilerOptions = exports.Compiler = exports.InkList = exports.Story = void 0;\n  \t\tvar Story_1 = requireStory$1();\n  \t\tObject.defineProperty(exports, \"Story\", { enumerable: true, get: function () { return Story_1.Story; } });\n  \t\tObject.defineProperty(exports, \"InkList\", { enumerable: true, get: function () { return Story_1.InkList; } });\n  \t\tvar Compiler_1 = requireCompiler();\n  \t\tObject.defineProperty(exports, \"Compiler\", { enumerable: true, get: function () { return Compiler_1.Compiler; } });\n  \t\tObject.defineProperty(exports, \"CompilerOptions\", { enumerable: true, get: function () { return Compiler_1.CompilerOptions; } });\n  \t\tvar PosixFileHandler_1 = requirePosixFileHandler();\n  \t\tObject.defineProperty(exports, \"PosixFileHandler\", { enumerable: true, get: function () { return PosixFileHandler_1.PosixFileHandler; } });\n  \t\tvar JsonFileHandler_1 = requireJsonFileHandler();\n  \t\tObject.defineProperty(exports, \"JsonFileHandler\", { enumerable: true, get: function () { return JsonFileHandler_1.JsonFileHandler; } });\n  \t\t\n  \t} (ink));\n  \treturn ink;\n  }\n\n  var inkExports = requireInk();\n\n  var Story = (function () {\n      function Story() {\n          var _this = this;\n          var storydataElement = document.querySelector('tw-storydata');\n          if (storydataElement === null) {\n              throw new Error(\"Could not find '<tw-storydata>' element!\");\n          }\n          this.storyData = storydataElement;\n          this.name = this.storyData.getAttribute('name');\n          this.passages = [];\n          this.storyData.querySelectorAll('tw-passagedata').forEach(function (element) {\n              var tagsValue = element.getAttribute('tags');\n              var tags;\n              if (tagsValue !== '' && tagsValue) {\n                  tags = tagsValue.split(' ');\n              }\n              else {\n                  tags = [];\n              }\n              _this.passages.push(new Passage(element.getAttribute('name'), tags, element.innerHTML));\n          });\n          var workingPassage;\n          if (!(workingPassage = document.querySelector('tw-passage'))) {\n              throw new Error(\"Unable to locate <tw-passage>!\");\n          }\n          this.workingPassage = workingPassage;\n          this.currentPassage = null;\n          this.currentInkStory = null;\n          this.inkBlock = null;\n      }\n      Story.prototype.start = function () {\n          var _this = this;\n          var passageIDStr = this.storyData.getAttribute('startnode');\n          if (!passageIDStr) {\n              throw new Error('Unable to fetch startnode value!');\n          }\n          var startingPassageID = parseInt(passageIDStr);\n          var startingPassage;\n          var startPassageName;\n          if (!(startingPassage = document.querySelector(\"[pid=\\\"\".concat(startingPassageID, \"\\\"]\")))\n              || !(startPassageName = startingPassage.getAttribute('name'))) {\n              throw new Error('Unable to fetch starting passage name!');\n          }\n          var passage = this.getPassageByName(startPassageName);\n          if (passage === null) {\n              throw new Error('Starting passage does not exist!');\n          }\n          this.currentPassage = passage;\n          this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n          var passageTemplate = this.include(passage.name);\n          this.workingPassage.innerHTML = \"\";\n          this.workingPassage.appendChild(passageTemplate.content.cloneNode(true));\n          if (passage.inkSource.length > 0) {\n              this.currentInkStory = new inkExports.Compiler(passage.inkSource).Compile();\n              this.inkBlock = document.querySelector(\"#ink_block\");\n              console.log(this.currentInkStory);\n              this.updateInk();\n          }\n          else {\n              this.currentInkStory = null;\n          }\n          Utils.addEventListener('click', function (event) {\n              if (event.target instanceof Element) {\n                  var passageName = event.target.getAttribute('data-passage');\n                  _this.show(passageName);\n              }\n          }, 'tw-link[data-passage]');\n          Utils.addEventListener('click', function () {\n              console.log(\"ink block clicked\");\n              if (_this.currentInkStory) {\n                  _this.updateInk();\n              }\n          }, 'div#ink_block');\n          Utils.addEventListener('click', function (event) {\n              console.log(\"ink choice clicked\");\n              if (event.target instanceof HTMLAnchorElement) {\n                  var choiceIndex = event.target.getAttribute('choiceIndex');\n                  _this.updateInk(parseInt(choiceIndex));\n              }\n          }, 'a.ink_choice');\n          if (this.currentInkStory) {\n              this.updateInk();\n          }\n      };\n      Story.prototype.getPassagesByTag = function (tag) {\n          return this.passages.filter(function (p) {\n              return p.tags.includes(tag);\n          });\n      };\n      Story.prototype.getPassageByName = function (name) {\n          var passage = null;\n          var result = this.passages.filter(function (p) { return p.name === name; });\n          if (result.length !== 0) {\n              passage = result[0];\n          }\n          return passage;\n      };\n      Story.prototype.show = function (name) {\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error(\"There is no passage with the name \".concat(name));\n          }\n          this.currentPassage = passage;\n          this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n          var passageTemplate = this.include(passage.name);\n          this.workingPassage.innerHTML = \"\";\n          this.workingPassage.appendChild(passageTemplate.content.cloneNode(true));\n          if (passage.inkSource.length > 0) {\n              this.currentInkStory = new inkExports.Compiler(passage.inkSource).Compile();\n              this.inkBlock = document.querySelector(\"#ink_block\");\n              console.log(this.currentInkStory);\n              this.updateInk();\n          }\n          else {\n              this.currentInkStory = null;\n          }\n      };\n      Story.prototype.update = function () {\n      };\n      Story.prototype.updateInk = function (choiceIndex) {\n          if (choiceIndex === void 0) { choiceIndex = -1; }\n          if (this.currentInkStory === null || !this.inkBlock === null) {\n              return;\n          }\n          var inkContent = this.inkBlock.querySelector(\"div#ink_content\");\n          var inkChoices = this.inkBlock.querySelector(\"div#ink_choices\");\n          var changeMade = false;\n          if (inkContent === null) {\n              inkContent = document.createElement(\"div\");\n              inkContent.id = \"ink_content\";\n              this.inkBlock.appendChild(inkContent);\n              changeMade = true;\n          }\n          if (choiceIndex >= 0) {\n              if (inkChoices === null) {\n                  throw Error(\"Unable to find ink_choices div, even though a choice was provided!\");\n              }\n              this.currentInkStory.ChooseChoiceIndex(choiceIndex);\n              this.inkBlock.removeChild(inkChoices);\n              changeMade = true;\n          }\n          if (this.currentInkStory.canContinue) {\n              var element = document.createElement(\"p\");\n              element.innerHTML = this.currentInkStory.Continue();\n              inkContent.appendChild(element);\n              changeMade = true;\n          }\n          if (inkChoices === null && this.currentInkStory.currentChoices.length > 0) {\n              inkChoices = document.createElement(\"div\");\n              inkChoices.id = \"ink_choices\";\n              this.currentInkStory.currentChoices.forEach(function (choice, index) {\n                  var choiceElement = document.createElement(\"a\");\n                  choiceElement.setAttribute(\"class\", \"ink_choice\");\n                  choiceElement.setAttribute(\"choiceIndex\", \"\".concat(index));\n                  choiceElement.href = \"javascript:void(0)\";\n                  choiceElement.innerText = \"\".concat(index, \". \").concat(choice.text);\n                  inkChoices.appendChild(choiceElement);\n                  inkChoices.appendChild(document.createElement(\"br\"));\n              });\n              this.inkBlock.appendChild(inkChoices);\n              changeMade = true;\n          }\n          if (changeMade) {\n              this.inkBlock.scroll(0, this.inkBlock.scrollHeight);\n          }\n      };\n      Story.prototype.include = function (name) {\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error('There is no passage with name ' + name);\n          }\n          var passageSource = passage.renderStaticElements();\n          return passageSource;\n      };\n      Story.prototype.renderPassageToSelector = function (passageName, selector) {\n          var passageTemplate = this.include(passageName);\n          var element = document.querySelector(selector);\n          if (element) {\n              element.innerHTML = \"\";\n              element.appendChild(passageTemplate.content.cloneNode(true));\n          }\n      };\n      Story.prototype.addPassage = function (name, tags, source) {\n          if (name === void 0) { name = ''; }\n          if (tags === void 0) { tags = []; }\n          if (source === void 0) { source = ''; }\n          var nameSearch = this.getPassageByName(name);\n          if (nameSearch !== null) {\n              throw new Error('Cannot add two passages with the same name!');\n          }\n          if (!Array.isArray(tags)) {\n              tags = [];\n          }\n          if (Object.prototype.toString.call(source) !== '[object String]') {\n              source = '';\n          }\n          this.passages.push(new Passage(name, tags, source));\n      };\n      Story.prototype.removePassage = function (name) {\n          if (name === void 0) { name = ''; }\n          this.passages = this.passages.filter(function (passage) {\n              return passage.name !== name;\n          });\n      };\n      Story.prototype.goto = function (name) {\n          if (name === void 0) { name = ''; }\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error(\"There is no passage with the name \".concat(name));\n          }\n          this.show(name);\n      };\n      return Story;\n  }());\n\n  window._story = new Story();\n  window._story.start();\n\n}));\n       </script>\n    \n</body></html>"});