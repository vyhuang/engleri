window.storyFormat({"name":"Engleri","version":"0.1.2","description":"A Twine story format that uses Inkle's Ink language","proofing":false,"license":"MIT","setup":"","source":"<!DOCTYPE html><html><head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta charset=\"utf-8\">\n        <title>{{STORY_NAME}}</title>\n        <style>\n/* Give ourselves some decent defaults. */\n\nbody {\n\tfont: 1.5em \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\tcolor: hsl(0, 0%, 13%);\n    text-align: center;\n}\n\ntw-icon {\n\tfont-size: 2em;\n\tcursor: pointer;\n}\n\ntw-story {\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tmin-height: 100%;\n\tfont-size: 1.5em;\n\tline-height: 1.5em;\n\tdisplay: flex;\n\tflex-direction: row;\n\tmargin-top: 1em;\n}\n\ntw-passage {\n\twidth: 90%;\n\tdisplay: block;\n}\n\ntw-link, a {\n\tcolor: #00a;\n\ttext-decoration-color: #00a;\n\tcursor: pointer;\n\ttext-decoration: underline;\n}\n\ntw-link:hover, tw-icon:hover, a:hover {\n\tcolor: #44f;\n\ttext-decoration-color: #44f;\n\ttext-decoration: underline;\n}\n\ntw-storydata {\n\tdisplay: none;\n}\n        </style>\n    </head>\n    <body>\n        {{STORY_DATA}}\n\t\t<tw-story>\n\t\t\t<tw-passage class=\"passage\"></tw-passage>\n\t\t</tw-story>\n        <script>\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) :\n  factory();\n})((function () { 'use strict';\n\n  var passage;\n  var hasRequiredPassage;\n\n  function requirePassage () {\n  \tif (hasRequiredPassage) return passage;\n  \thasRequiredPassage = 1;\n\n\n  \tclass ParsedObject {\n  \t\t// typeName: \tstring\n  \t\t// values: \t\t(ParsedObject | string)[]\n  \t\t// reduceToHtml:(ParsedObject | string)[] => string\n  \t\tconstructor(typeName, values, reduceToHtml) {\n  \t\t\ttypeName ??= \"\";\n  \t\t\tvalues ??= [];\n  \t\t\treduceToHtml ??= function(parsedObjects) {\n\n  \t\t\t\tlet values = parsedObjects.map(function(object) {\n  \t\t\t\t\t\treturn (typeof object === \"string\") ? object : object.render();\n  \t\t\t\t\t});\n\n  \t\t\t\treturn values.join(\"\");\n  \t\t\t};\n\n  \t\t\tthis.typeName = typeName;\n  \t\t\tthis.values = values;\n  \t\t\tthis.reduceToHtml = reduceToHtml;\n  \t\t}\n\n  \t\trender() {\n  \t\t\treturn this.reduceToHtml(this.values);\n  \t\t}\n  \t}\n\n  \tclass Link extends ParsedObject {\n  \t\tconstructor(values) {\n  \t    \tsuper(\n  \t\t\t\t\"Link\", \n  \t\t\t\tvalues, \n  \t\t\t\tfunction (textValues) {\n  \t\t\t\t\t// we know these values are text objects.\n  \t\t\t\t\tlet renderedTextValues = textValues.map((value) => value.render());\n  \t\t\t\t\tlet label = renderedTextValues[0];\n  \t\t\t\t\tlet dest = renderedTextValues[1];\n\n  \t\t\t\t\treturn `<tw-link data-passage=\"${dest}\">${label}</tw-link>`;\n  \t\t\t\t});\n  \t    }\n  \t}\n\n\n  \tclass peg$SyntaxError extends SyntaxError {\n  \t  constructor(message, expected, found, location) {\n  \t    super(message);\n  \t    this.expected = expected;\n  \t    this.found = found;\n  \t    this.location = location;\n  \t    this.name = \"SyntaxError\";\n  \t  }\n\n  \t  format(sources) {\n  \t    let str = \"Error: \" + this.message;\n  \t    if (this.location) {\n  \t      let src = null;\n  \t      const st = sources.find(s => s.source === this.location.source);\n  \t      if (st) {\n  \t        src = st.text.split(/\\r\\n|\\n|\\r/g);\n  \t      }\n  \t      const s = this.location.start;\n  \t      const offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n  \t        ? this.location.source.offset(s)\n  \t        : s;\n  \t      const loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n  \t      if (src) {\n  \t        const e = this.location.end;\n  \t        const filler = \"\".padEnd(offset_s.line.toString().length, \" \");\n  \t        const line = src[s.line - 1];\n  \t        const last = s.line === e.line ? e.column : line.length + 1;\n  \t        const hatLen = (last - s.column) || 1;\n  \t        str += \"\\n --> \" + loc + \"\\n\"\n  \t            + filler + \" |\\n\"\n  \t            + offset_s.line + \" | \" + line + \"\\n\"\n  \t            + filler + \" | \" + \"\".padEnd(s.column - 1, \" \")\n  \t            + \"\".padEnd(hatLen, \"^\");\n  \t      } else {\n  \t        str += \"\\n at \" + loc;\n  \t      }\n  \t    }\n  \t    return str;\n  \t  }\n\n  \t  static buildMessage(expected, found) {\n  \t    function hex(ch) {\n  \t      return ch.codePointAt(0).toString(16).toUpperCase();\n  \t    }\n\n  \t    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \"unicode\")\n  \t      ? new RegExp(\"[\\\\p{C}\\\\p{Mn}\\\\p{Mc}]\", \"gu\")\n  \t      : null;\n  \t    function unicodeEscape(s) {\n  \t      if (nonPrintable) {\n  \t        return s.replace(nonPrintable,  ch => \"\\\\u{\" + hex(ch) + \"}\");\n  \t      }\n  \t      return s;\n  \t    }\n\n  \t    function literalEscape(s) {\n  \t      return unicodeEscape(s\n  \t        .replace(/\\\\/g, \"\\\\\\\\\")\n  \t        .replace(/\"/g,  \"\\\\\\\"\")\n  \t        .replace(/\\0/g, \"\\\\0\")\n  \t        .replace(/\\t/g, \"\\\\t\")\n  \t        .replace(/\\n/g, \"\\\\n\")\n  \t        .replace(/\\r/g, \"\\\\r\")\n  \t        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n  \t        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n  \t    }\n\n  \t    function classEscape(s) {\n  \t      return unicodeEscape(s\n  \t        .replace(/\\\\/g, \"\\\\\\\\\")\n  \t        .replace(/\\]/g, \"\\\\]\")\n  \t        .replace(/\\^/g, \"\\\\^\")\n  \t        .replace(/-/g,  \"\\\\-\")\n  \t        .replace(/\\0/g, \"\\\\0\")\n  \t        .replace(/\\t/g, \"\\\\t\")\n  \t        .replace(/\\n/g, \"\\\\n\")\n  \t        .replace(/\\r/g, \"\\\\r\")\n  \t        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n  \t        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n  \t    }\n\n  \t    const DESCRIBE_EXPECTATION_FNS = {\n  \t      literal(expectation) {\n  \t        return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n  \t      },\n\n  \t      class(expectation) {\n  \t        const escapedParts = expectation.parts.map(\n  \t          part => (Array.isArray(part)\n  \t            ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n  \t            : classEscape(part))\n  \t        );\n\n  \t        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\" + (expectation.unicode ? \"u\" : \"\");\n  \t      },\n\n  \t      any() {\n  \t        return \"any character\";\n  \t      },\n\n  \t      end() {\n  \t        return \"end of input\";\n  \t      },\n\n  \t      other(expectation) {\n  \t        return expectation.description;\n  \t      },\n  \t    };\n\n  \t    function describeExpectation(expectation) {\n  \t      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  \t    }\n\n  \t    function describeExpected(expected) {\n  \t      const descriptions = expected.map(describeExpectation);\n  \t      descriptions.sort();\n\n  \t      if (descriptions.length > 0) {\n  \t        let j = 1;\n  \t        for (let i = 1; i < descriptions.length; i++) {\n  \t          if (descriptions[i - 1] !== descriptions[i]) {\n  \t            descriptions[j] = descriptions[i];\n  \t            j++;\n  \t          }\n  \t        }\n  \t        descriptions.length = j;\n  \t      }\n\n  \t      switch (descriptions.length) {\n  \t        case 1:\n  \t          return descriptions[0];\n\n  \t        case 2:\n  \t          return descriptions[0] + \" or \" + descriptions[1];\n\n  \t        default:\n  \t          return descriptions.slice(0, -1).join(\", \")\n  \t            + \", or \"\n  \t            + descriptions[descriptions.length - 1];\n  \t      }\n  \t    }\n\n  \t    function describeFound(found) {\n  \t      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  \t    }\n\n  \t    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  \t  }\n  \t}\n\n  \tfunction peg$parse(input, options) {\n  \t  options = options !== undefined ? options : {};\n\n  \t  const peg$FAILED = {};\n  \t  const peg$source = options.grammarSource;\n\n  \t  const peg$startRuleFunctions = {\n  \t    Expression: peg$parseExpression,\n  \t  };\n  \t  let peg$startRuleFunction = peg$parseExpression;\n\n  \t  const peg$c0 = \"[[\";\n  \t  const peg$c1 = \"]]\";\n  \t  const peg$c2 = \"<[[\";\n  \t  const peg$c3 = \"|\";\n  \t  const peg$c4 = \"]]>\";\n  \t  const peg$c5 = \"->\";\n  \t  const peg$c6 = \"-&gt;\";\n  \t  const peg$c7 = \"<-\";\n  \t  const peg$c8 = \"&lt;-\";\n  \t  const peg$c9 = \"\\\\\";\n  \t  const peg$c10 = \"&lt;\";\n  \t  const peg$c11 = \"<\";\n  \t  const peg$c12 = \"&gt;\";\n  \t  const peg$c13 = \">\";\n\n  \t  const peg$r0 = /^[^\\n]/;\n  \t  const peg$r1 = /^[|[\\]\\r\\n_\\\\]/;\n  \t  const peg$r2 = /^[\\r]/;\n  \t  const peg$r3 = /^[\\n]/;\n  \t  const peg$r4 = /^[ \\t]/;\n\n  \t  const peg$e0 = peg$literalExpectation(\"[[\", false);\n  \t  const peg$e1 = peg$literalExpectation(\"]]\", false);\n  \t  const peg$e2 = peg$literalExpectation(\"<[[\", false);\n  \t  const peg$e3 = peg$literalExpectation(\"|\", false);\n  \t  const peg$e4 = peg$literalExpectation(\"]]>\", false);\n  \t  const peg$e5 = peg$otherExpectation(\"->\");\n  \t  const peg$e6 = peg$literalExpectation(\"->\", false);\n  \t  const peg$e7 = peg$literalExpectation(\"-&gt;\", false);\n  \t  const peg$e8 = peg$otherExpectation(\"<-\");\n  \t  const peg$e9 = peg$literalExpectation(\"<-\", false);\n  \t  const peg$e10 = peg$literalExpectation(\"&lt;-\", false);\n  \t  const peg$e11 = peg$anyExpectation();\n  \t  const peg$e12 = peg$literalExpectation(\"\\\\\", false);\n  \t  const peg$e13 = peg$classExpectation([\"\\n\"], true, false, false);\n  \t  const peg$e14 = peg$classExpectation([\"|\", \"[\", \"]\", \"\\r\", \"\\n\", \"_\", \"\\\\\"], false, false, false);\n  \t  const peg$e15 = peg$otherExpectation(\"<\");\n  \t  const peg$e16 = peg$literalExpectation(\"&lt;\", false);\n  \t  const peg$e17 = peg$literalExpectation(\"<\", false);\n  \t  const peg$e18 = peg$otherExpectation(\">\");\n  \t  const peg$e19 = peg$literalExpectation(\"&gt;\", false);\n  \t  const peg$e20 = peg$literalExpectation(\">\", false);\n  \t  const peg$e21 = peg$otherExpectation(\"endOfLine\");\n  \t  const peg$e22 = peg$otherExpectation(\"newLine\");\n  \t  const peg$e23 = peg$classExpectation([\"\\r\"], false, false, false);\n  \t  const peg$e24 = peg$classExpectation([\"\\n\"], false, false, false);\n  \t  const peg$e25 = peg$otherExpectation(\"endOfFile\");\n  \t  const peg$e26 = peg$classExpectation([\" \", \"\\t\"], false, false, false);\n\n  \t  function peg$f0(lines) {    \n  \t\t\treturn new ParsedObject(\"lines\", lines);\n  \t  }\n  \t  function peg$f1(contents, nls) {    \n  \t\t\tconst toHtml = function (values) {\n  \t\t\t\tlet contents = values[0];\n  \t\t\t\tlet newlines = values[1];\n\n  \t\t\t\tlet pText =  `<p>${contents.map((o)=>o.render()).join(\"\")}</p>`;\n  \t\t\t\tlet brText = `${newlines.map((o)=>o.render()).join(\"\")}`;\n\n  \t\t\t\treturn `${pText}${brText}`\n  \t\t\t};\n\n  \t\t\treturn new ParsedObject(\"line\", [contents, [nls]], toHtml)\n  \t  }\n  \t  function peg$f2(value) {    return new Link(value);  }\n  \t  function peg$f3(label, destination) {    return new Link([label, destination]);  }\n  \t  function peg$f4(label, destination) {    return [label, destination];  }\n  \t  function peg$f5(destination, label) {    return [label, destination];  }\n  \t  function peg$f6(chars) {    \n  \t\t\treturn new ParsedObject(\"text\", chars, (values) => values.join(\"\").trimStart()); \n  \t  }\n  \t  function peg$f7(char) {    return char;  }\n  \t  function peg$f8(char) {    return char;  }\n  \t  function peg$f9(lines) {    \n  \t\t\tconst toHtml = (values) => {\n  \t\t\t\tlet count = values.length - 2;\n\n  \t\t\t\tif (count > 0) {\n  \t\t\t\t\treturn \"<br> \".repeat(count);\n  \t\t\t\t} else {\n  \t\t\t\t\treturn \"\";\n  \t\t\t\t}\n\n  \t\t\t};\n  \t\t\treturn new ParsedObject(\"newlines\", lines, toHtml); \n  \t  }\n  \t  let peg$currPos = options.peg$currPos | 0;\n  \t  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  \t  let peg$maxFailPos = peg$currPos;\n  \t  let peg$maxFailExpected = options.peg$maxFailExpected || [];\n  \t  let peg$silentFails = options.peg$silentFails | 0;\n\n  \t  let peg$result;\n\n  \t  if (options.startRule) {\n  \t    if (!(options.startRule in peg$startRuleFunctions)) {\n  \t      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n  \t    }\n\n  \t    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  \t  }\n\n  \t  function peg$getUnicode(pos = peg$currPos) {\n  \t    const cp = input.codePointAt(pos);\n  \t    if (cp === undefined) {\n  \t      return \"\";\n  \t    }\n  \t    return String.fromCodePoint(cp);\n  \t  }\n\n  \t  function peg$literalExpectation(text, ignoreCase) {\n  \t    return { type: \"literal\", text, ignoreCase };\n  \t  }\n\n  \t  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\n  \t    return { type: \"class\", parts, inverted, ignoreCase, unicode };\n  \t  }\n\n  \t  function peg$anyExpectation() {\n  \t    return { type: \"any\" };\n  \t  }\n\n  \t  function peg$endExpectation() {\n  \t    return { type: \"end\" };\n  \t  }\n\n  \t  function peg$otherExpectation(description) {\n  \t    return { type: \"other\", description };\n  \t  }\n\n  \t  function peg$computePosDetails(pos) {\n  \t    let details = peg$posDetailsCache[pos];\n  \t    let p;\n\n  \t    if (details) {\n  \t      return details;\n  \t    } else {\n  \t      if (pos >= peg$posDetailsCache.length) {\n  \t        p = peg$posDetailsCache.length - 1;\n  \t      } else {\n  \t        p = pos;\n  \t        while (!peg$posDetailsCache[--p]) {}\n  \t      }\n\n  \t      details = peg$posDetailsCache[p];\n  \t      details = {\n  \t        line: details.line,\n  \t        column: details.column,\n  \t      };\n\n  \t      while (p < pos) {\n  \t        if (input.charCodeAt(p) === 10) {\n  \t          details.line++;\n  \t          details.column = 1;\n  \t        } else {\n  \t          details.column++;\n  \t        }\n\n  \t        p++;\n  \t      }\n\n  \t      peg$posDetailsCache[pos] = details;\n\n  \t      return details;\n  \t    }\n  \t  }\n\n  \t  function peg$computeLocation(startPos, endPos, offset) {\n  \t    const startPosDetails = peg$computePosDetails(startPos);\n  \t    const endPosDetails = peg$computePosDetails(endPos);\n\n  \t    const res = {\n  \t      source: peg$source,\n  \t      start: {\n  \t        offset: startPos,\n  \t        line: startPosDetails.line,\n  \t        column: startPosDetails.column,\n  \t      },\n  \t      end: {\n  \t        offset: endPos,\n  \t        line: endPosDetails.line,\n  \t        column: endPosDetails.column,\n  \t      },\n  \t    };\n  \t    return res;\n  \t  }\n\n  \t  function peg$fail(expected) {\n  \t    if (peg$currPos < peg$maxFailPos) { return; }\n\n  \t    if (peg$currPos > peg$maxFailPos) {\n  \t      peg$maxFailPos = peg$currPos;\n  \t      peg$maxFailExpected = [];\n  \t    }\n\n  \t    peg$maxFailExpected.push(expected);\n  \t  }\n\n  \t  function peg$buildStructuredError(expected, found, location) {\n  \t    return new peg$SyntaxError(\n  \t      peg$SyntaxError.buildMessage(expected, found),\n  \t      expected,\n  \t      found,\n  \t      location\n  \t    );\n  \t  }\n\n  \t  function peg$parseExpression() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parsetextLinkLine();\n  \t    if (s2 !== peg$FAILED) {\n  \t      while (s2 !== peg$FAILED) {\n  \t        s1.push(s2);\n  \t        s2 = peg$parsetextLinkLine();\n  \t      }\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_eol();\n  \t      if (s2 !== peg$FAILED) {\n  \t        s0 = peg$f0(s1);\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parsetextLinkLine() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parsepureText();\n  \t    if (s2 === peg$FAILED) {\n  \t      s2 = peg$parselink();\n  \t    }\n  \t    if (s2 !== peg$FAILED) {\n  \t      while (s2 !== peg$FAILED) {\n  \t        s1.push(s2);\n  \t        s2 = peg$parsepureText();\n  \t        if (s2 === peg$FAILED) {\n  \t          s2 = peg$parselink();\n  \t        }\n  \t      }\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_nls();\n  \t      s0 = peg$f1(s1, s2);\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parselink() {\n  \t    let s0;\n\n  \t    s0 = peg$parse_wrappedLink();\n  \t    if (s0 === peg$FAILED) {\n  \t      s0 = peg$parse_twLink();\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_twLink() {\n  \t    let s0, s1, s2, s3;\n\n  \t    s0 = peg$currPos;\n  \t    if (input.substr(peg$currPos, 2) === peg$c0) {\n  \t      s1 = peg$c0;\n  \t      peg$currPos += 2;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_inner_link_lr();\n  \t      if (s2 === peg$FAILED) {\n  \t        s2 = peg$parse_inner_link_rl();\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        if (input.substr(peg$currPos, 2) === peg$c1) {\n  \t          s3 = peg$c1;\n  \t          peg$currPos += 2;\n  \t        } else {\n  \t          s3 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e1); }\n  \t        }\n  \t        if (s3 !== peg$FAILED) {\n  \t          s0 = peg$f2(s2);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_wrappedLink() {\n  \t    let s0, s1, s2, s3, s4, s5;\n\n  \t    s0 = peg$currPos;\n  \t    if (input.substr(peg$currPos, 3) === peg$c2) {\n  \t      s1 = peg$c2;\n  \t      peg$currPos += 3;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parsepureText();\n  \t      if (s2 !== peg$FAILED) {\n  \t        if (input.charCodeAt(peg$currPos) === 124) {\n  \t          s3 = peg$c3;\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s3 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n  \t        }\n  \t        if (s3 !== peg$FAILED) {\n  \t          s4 = peg$parsepureText();\n  \t          if (s4 !== peg$FAILED) {\n  \t            if (input.substr(peg$currPos, 3) === peg$c4) {\n  \t              s5 = peg$c4;\n  \t              peg$currPos += 3;\n  \t            } else {\n  \t              s5 = peg$FAILED;\n  \t              if (peg$silentFails === 0) { peg$fail(peg$e4); }\n  \t            }\n  \t            if (s5 !== peg$FAILED) {\n  \t              s0 = peg$f3(s2, s4);\n  \t            } else {\n  \t              peg$currPos = s0;\n  \t              s0 = peg$FAILED;\n  \t            }\n  \t          } else {\n  \t            peg$currPos = s0;\n  \t            s0 = peg$FAILED;\n  \t          }\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inner_link_lr() {\n  \t    let s0, s1, s2, s3;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parsepureText();\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_linkArrowRight();\n  \t      if (s2 === peg$FAILED) {\n  \t        if (input.charCodeAt(peg$currPos) === 124) {\n  \t          s2 = peg$c3;\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s2 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n  \t        }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        s3 = peg$parsepureText();\n  \t        if (s3 !== peg$FAILED) {\n  \t          s0 = peg$f4(s1, s3);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_inner_link_rl() {\n  \t    let s0, s1, s2, s3;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parsepureText();\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_linkArrowLeft();\n  \t      if (s2 !== peg$FAILED) {\n  \t        s3 = peg$parsepureText();\n  \t        if (s3 !== peg$FAILED) {\n  \t          s0 = peg$f5(s1, s3);\n  \t        } else {\n  \t          peg$currPos = s0;\n  \t          s0 = peg$FAILED;\n  \t        }\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_linkArrowRight() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    if (input.substr(peg$currPos, 2) === peg$c5) {\n  \t      s0 = peg$c5;\n  \t      peg$currPos += 2;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n  \t    }\n  \t    if (s0 === peg$FAILED) {\n  \t      if (input.substr(peg$currPos, 5) === peg$c6) {\n  \t        s0 = peg$c6;\n  \t        peg$currPos += 5;\n  \t      } else {\n  \t        s0 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n  \t      }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_linkArrowLeft() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    if (input.substr(peg$currPos, 2) === peg$c7) {\n  \t      s0 = peg$c7;\n  \t      peg$currPos += 2;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n  \t    }\n  \t    if (s0 === peg$FAILED) {\n  \t      if (input.substr(peg$currPos, 5) === peg$c8) {\n  \t        s0 = peg$c8;\n  \t        peg$currPos += 5;\n  \t      } else {\n  \t        s0 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n  \t      }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parsepureText() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parse_charUnescaped();\n  \t    if (s2 === peg$FAILED) {\n  \t      s2 = peg$parse_charEscaped();\n  \t    }\n  \t    if (s2 !== peg$FAILED) {\n  \t      while (s2 !== peg$FAILED) {\n  \t        s1.push(s2);\n  \t        s2 = peg$parse_charUnescaped();\n  \t        if (s2 === peg$FAILED) {\n  \t          s2 = peg$parse_charEscaped();\n  \t        }\n  \t      }\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s1 = peg$f6(s1);\n  \t    }\n  \t    s0 = s1;\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_charUnescaped() {\n  \t    let s0, s1, s2, s3, s4, s5;\n\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$currPos;\n  \t    peg$silentFails++;\n  \t    s2 = peg$currPos;\n  \t    s3 = peg$currPos;\n  \t    peg$silentFails++;\n  \t    s4 = peg$parse_nonTextCharUnescaped();\n  \t    peg$silentFails--;\n  \t    if (s4 === peg$FAILED) {\n  \t      s3 = undefined;\n  \t    } else {\n  \t      peg$currPos = s3;\n  \t      s3 = peg$FAILED;\n  \t    }\n  \t    if (s3 !== peg$FAILED) {\n  \t      s4 = peg$currPos;\n  \t      peg$silentFails++;\n  \t      s5 = peg$parse_linkArrowRight();\n  \t      peg$silentFails--;\n  \t      if (s5 === peg$FAILED) {\n  \t        s4 = undefined;\n  \t      } else {\n  \t        peg$currPos = s4;\n  \t        s4 = peg$FAILED;\n  \t      }\n  \t      if (s4 !== peg$FAILED) {\n  \t        s3 = [s3, s4];\n  \t        s2 = s3;\n  \t      } else {\n  \t        peg$currPos = s2;\n  \t        s2 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s2;\n  \t      s2 = peg$FAILED;\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s2 !== peg$FAILED) {\n  \t      peg$currPos = s1;\n  \t      s1 = undefined;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      if (input.length > peg$currPos) {\n  \t        s2 = input.charAt(peg$currPos);\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s2 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        s0 = peg$f7(s2);\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_charEscaped() {\n  \t    let s0, s1, s2;\n\n  \t    s0 = peg$currPos;\n  \t    if (input.charCodeAt(peg$currPos) === 92) {\n  \t      s1 = peg$c9;\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n  \t    }\n  \t    if (s1 !== peg$FAILED) {\n  \t      s2 = peg$parse_angleBracketLeft();\n  \t      if (s2 === peg$FAILED) {\n  \t        s2 = peg$parse_angleBracketRight();\n  \t        if (s2 === peg$FAILED) {\n  \t          s2 = input.charAt(peg$currPos);\n  \t          if (peg$r0.test(s2)) {\n  \t            peg$currPos++;\n  \t          } else {\n  \t            s2 = peg$FAILED;\n  \t            if (peg$silentFails === 0) { peg$fail(peg$e13); }\n  \t          }\n  \t        }\n  \t      }\n  \t      if (s2 !== peg$FAILED) {\n  \t        s0 = peg$f8(s2);\n  \t      } else {\n  \t        peg$currPos = s0;\n  \t        s0 = peg$FAILED;\n  \t      }\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_nonTextCharUnescaped() {\n  \t    let s0;\n\n  \t    s0 = peg$parse_angleBracketLeft();\n  \t    if (s0 === peg$FAILED) {\n  \t      s0 = peg$parse_angleBracketRight();\n  \t      if (s0 === peg$FAILED) {\n  \t        s0 = input.charAt(peg$currPos);\n  \t        if (peg$r1.test(s0)) {\n  \t          peg$currPos++;\n  \t        } else {\n  \t          s0 = peg$FAILED;\n  \t          if (peg$silentFails === 0) { peg$fail(peg$e14); }\n  \t        }\n  \t      }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_angleBracketLeft() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    if (input.substr(peg$currPos, 4) === peg$c10) {\n  \t      s0 = peg$c10;\n  \t      peg$currPos += 4;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n  \t    }\n  \t    if (s0 === peg$FAILED) {\n  \t      if (input.charCodeAt(peg$currPos) === 60) {\n  \t        s0 = peg$c11;\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s0 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e17); }\n  \t      }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_angleBracketRight() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    if (input.substr(peg$currPos, 4) === peg$c12) {\n  \t      s0 = peg$c12;\n  \t      peg$currPos += 4;\n  \t    } else {\n  \t      s0 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n  \t    }\n  \t    if (s0 === peg$FAILED) {\n  \t      if (input.charCodeAt(peg$currPos) === 62) {\n  \t        s0 = peg$c13;\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s0 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n  \t      }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e18); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_eol() {\n  \t    let s0;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$parse_nl();\n  \t    if (s0 === peg$FAILED) {\n  \t      s0 = peg$parse_eof();\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_nl() {\n  \t    let s0, s1, s2, s3;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$currPos;\n  \t    s1 = peg$parse_();\n  \t    s2 = input.charAt(peg$currPos);\n  \t    if (peg$r2.test(s2)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s2 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n  \t    }\n  \t    if (s2 === peg$FAILED) {\n  \t      s2 = null;\n  \t    }\n  \t    s3 = input.charAt(peg$currPos);\n  \t    if (peg$r3.test(s3)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s3 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n  \t    }\n  \t    if (s3 !== peg$FAILED) {\n  \t      s1 = [s1, s2, s3];\n  \t      s0 = s1;\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_nls() {\n  \t    let s0, s1, s2;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$currPos;\n  \t    s1 = [];\n  \t    s2 = peg$parse_nl();\n  \t    while (s2 !== peg$FAILED) {\n  \t      s1.push(s2);\n  \t      s2 = peg$parse_nl();\n  \t    }\n  \t    s1 = peg$f9(s1);\n  \t    s0 = s1;\n  \t    peg$silentFails--;\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_eof() {\n  \t    let s0, s1;\n\n  \t    peg$silentFails++;\n  \t    s0 = peg$currPos;\n  \t    peg$silentFails++;\n  \t    if (input.length > peg$currPos) {\n  \t      s1 = input.charAt(peg$currPos);\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s1 === peg$FAILED) {\n  \t      s0 = undefined;\n  \t    } else {\n  \t      peg$currPos = s0;\n  \t      s0 = peg$FAILED;\n  \t    }\n  \t    peg$silentFails--;\n  \t    if (s0 === peg$FAILED) {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e25); }\n  \t    }\n\n  \t    return s0;\n  \t  }\n\n  \t  function peg$parse_() {\n  \t    let s0, s1;\n\n  \t    peg$silentFails++;\n  \t    s0 = [];\n  \t    s1 = input.charAt(peg$currPos);\n  \t    if (peg$r4.test(s1)) {\n  \t      peg$currPos++;\n  \t    } else {\n  \t      s1 = peg$FAILED;\n  \t      if (peg$silentFails === 0) { peg$fail(peg$e26); }\n  \t    }\n  \t    while (s1 !== peg$FAILED) {\n  \t      s0.push(s1);\n  \t      s1 = input.charAt(peg$currPos);\n  \t      if (peg$r4.test(s1)) {\n  \t        peg$currPos++;\n  \t      } else {\n  \t        s1 = peg$FAILED;\n  \t        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n  \t      }\n  \t    }\n  \t    peg$silentFails--;\n\n  \t    return s0;\n  \t  }\n\n  \t  peg$result = peg$startRuleFunction();\n\n  \t  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);\n  \t  function peg$throw() {\n  \t    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n  \t      peg$fail(peg$endExpectation());\n  \t    }\n\n  \t    throw peg$buildStructuredError(\n  \t      peg$maxFailExpected,\n  \t      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,\n  \t      peg$maxFailPos < input.length\n  \t        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n  \t        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n  \t    );\n  \t  }\n  \t  if (options.peg$library) {\n  \t    return /** @type {any} */ ({\n  \t      peg$result,\n  \t      peg$currPos,\n  \t      peg$FAILED,\n  \t      peg$maxFailExpected,\n  \t      peg$maxFailPos,\n  \t      peg$success,\n  \t      peg$throw: peg$success ? undefined : peg$throw,\n  \t    });\n  \t  }\n  \t  if (peg$success) {\n  \t    return peg$result;\n  \t  } else {\n  \t    peg$throw();\n  \t  }\n  \t}\n\n  \tpassage = {\n  \t  StartRules: [\"Expression\"],\n  \t  SyntaxError: peg$SyntaxError,\n  \t  parse: peg$parse,\n  \t};\n  \treturn passage;\n  }\n\n  var passageExports = requirePassage();\n\n  var Passage = (function () {\n      function Passage(name, tags, source) {\n          name !== null && name !== void 0 ? name : (name = 'Default');\n          tags !== null && tags !== void 0 ? tags : (tags = []);\n          source !== null && source !== void 0 ? source : (source = '');\n          this.name = name;\n          this.tags = tags;\n          this.source = source;\n      }\n      Passage.prototype.renderTemplate = function () {\n          var parsedSource = passageExports.parse(this.source);\n          var template = document.createElement(\"template\");\n          template.innerHTML = parsedSource.render();\n          return template;\n      };\n      Passage.prototype.renderLinks = function () {\n          var rules = [\n              [/\\[\\[(.+)(\\||-\\&gt;)(.+)\\]\\]/g, '<tw-link data-passage=\"$3\">$1</tw-link>'],\n              [/\\[\\[(.+)\\&lt;-(.+)?\\]\\]/g, '<tw-link data-passage=\"$1\">$2</tw-link>']\n          ];\n          var text = this.source;\n          rules.forEach(function (_a) {\n              var rule = _a[0], template = _a[1];\n              text = text.replaceAll(rule, template);\n          });\n          return text;\n      };\n      return Passage;\n  }());\n\n  var Utils = (function () {\n      function Utils() {\n      }\n      Utils.generateElements = function (html) {\n          var template = document.createElement('template');\n          template.innerHTML = html.trim();\n          return template.content.children;\n      };\n      Utils.addEventListener = function (eventName, eventHandler, selector) {\n          var wrappedHandler = function (e) {\n              if (!e.target || !(e.target instanceof Element))\n                  return;\n              var el = e.target.closest(selector);\n              if (el) {\n                  eventHandler.call(el, e);\n              }\n          };\n          document.addEventListener(eventName, wrappedHandler);\n          return wrappedHandler;\n      };\n      return Utils;\n  }());\n\n  var Story = (function () {\n      function Story() {\n          var _this = this;\n          var storydataElement = document.querySelector('tw-storydata');\n          if (storydataElement === null) {\n              throw new Error(\"Could not find '<tw-storydata>' element!\");\n          }\n          this.storyData = storydataElement;\n          this.name = this.storyData.getAttribute('name');\n          this.passages = [];\n          this.storyData.querySelectorAll('tw-passagedata').forEach(function (element) {\n              var tagsValue = element.getAttribute('tags');\n              var tags;\n              if (tagsValue !== '' && tagsValue) {\n                  tags = tagsValue.split(' ');\n              }\n              else {\n                  tags = [];\n              }\n              _this.passages.push(new Passage(element.getAttribute('name'), tags, element.innerHTML));\n          });\n          var workingPassage;\n          if (!(workingPassage = document.querySelector('tw-passage'))) {\n              throw new Error(\"Unable to locate <tw-passage>!\");\n          }\n          this.workingPassage = workingPassage;\n          this.currentPassage = null;\n      }\n      Story.prototype.start = function () {\n          var _this = this;\n          var passageIDStr = this.storyData.getAttribute('startnode');\n          if (!passageIDStr) {\n              throw new Error('Unable to fetch startnode value!');\n          }\n          var startingPassageID = parseInt(passageIDStr);\n          var startingPassage;\n          var startPassageName;\n          if (!(startingPassage = document.querySelector(\"[pid=\\\"\".concat(startingPassageID, \"\\\"]\")))\n              || !(startPassageName = startingPassage.getAttribute('name'))) {\n              throw new Error('Unable to fetch starting passage name!');\n          }\n          var passage = this.getPassageByName(startPassageName);\n          if (passage === null) {\n              throw new Error('Starting passage does not exist!');\n          }\n          this.currentPassage = passage;\n          this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n          var passageTemplate = this.include(passage.name);\n          this.workingPassage.innerHTML = \"\";\n          this.workingPassage.appendChild(passageTemplate.content);\n          Utils.addEventListener('click', function (event) {\n              if (event.target instanceof Element) {\n                  var passageName = event.target.getAttribute('data-passage');\n                  _this.show(passageName);\n              }\n          }, 'tw-link[data-passage]');\n      };\n      Story.prototype.getPassagesByTag = function (tag) {\n          return this.passages.filter(function (p) {\n              return p.tags.includes(tag);\n          });\n      };\n      Story.prototype.getPassageByName = function (name) {\n          var passage = null;\n          var result = this.passages.filter(function (p) { return p.name === name; });\n          if (result.length !== 0) {\n              passage = result[0];\n          }\n          return passage;\n      };\n      Story.prototype.show = function (name) {\n          var _this = this;\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error(\"There is no passage with the name \".concat(name));\n          }\n          this.currentPassage = passage;\n          this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n          var passageTemplate = this.include(passage.name);\n          this.workingPassage.innerHTML = \"\";\n          this.workingPassage.appendChild(passageTemplate.content);\n          Utils.addEventListener('click', function (event) {\n              if (event.target instanceof Element) {\n                  var passageName = event.target.getAttribute('data-passage');\n                  _this.show(passageName);\n              }\n          }, 'tw-link[data-passage]');\n      };\n      Story.prototype.include = function (name) {\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error('There is no passage with name ' + name);\n          }\n          var passageSource = passage.renderTemplate();\n          return passageSource;\n      };\n      Story.prototype.renderPassageToSelector = function (passageName, selector) {\n          var passageTemplate = this.include(passageName);\n          var element = document.querySelector(selector);\n          if (element) {\n              element.innerHTML = \"\";\n              element.appendChild(passageTemplate.content);\n          }\n      };\n      Story.prototype.addPassage = function (name, tags, source) {\n          if (name === void 0) { name = ''; }\n          if (tags === void 0) { tags = []; }\n          if (source === void 0) { source = ''; }\n          var nameSearch = this.getPassageByName(name);\n          if (nameSearch !== null) {\n              throw new Error('Cannot add two passages with the same name!');\n          }\n          if (!Array.isArray(tags)) {\n              tags = [];\n          }\n          if (Object.prototype.toString.call(source) !== '[object String]') {\n              source = '';\n          }\n          this.passages.push(new Passage(name, tags, source));\n      };\n      Story.prototype.removePassage = function (name) {\n          if (name === void 0) { name = ''; }\n          this.passages = this.passages.filter(function (passage) {\n              return passage.name !== name;\n          });\n      };\n      Story.prototype.goto = function (name) {\n          if (name === void 0) { name = ''; }\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error(\"There is no passage with the name \".concat(name));\n          }\n          this.show(name);\n      };\n      return Story;\n  }());\n\n  window._story = new Story();\n  window._story.start();\n\n}));\n       </script>\n    \n</body></html>"});