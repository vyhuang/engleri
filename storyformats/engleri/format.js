window.storyFormat({"name":"Engleri","version":"0.1.0","description":"A Twine story format that uses Inkle's Ink language","proofing":false,"license":"MIT","setup":"","source":"<!DOCTYPE html><html><head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta charset=\"utf-8\">\n        <title>{{STORY_NAME}}</title>\n        <style>\n/* Give ourselves some decent defaults. */\n\nbody {\n\tfont: 1.5em \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\tcolor: hsl(0, 0%, 13%);\n    text-align: center;\n}\n\ntw-icon {\n\tfont-size: 2em;\n\tcursor: pointer;\n}\n\ntw-story {\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tmin-height: 100%;\n\tfont-size: 1.5em;\n\tline-height: 1.5em;\n\tdisplay: flex;\n\tflex-direction: row;\n\tmargin-top: 1em;\n}\n\ntw-passage {\n\twidth: 90%;\n\tdisplay: block;\n}\n\ntw-link, a {\n\tcolor: #00a;\n\ttext-decoration-color: #00a;\n\tcursor: pointer;\n\ttext-decoration: underline;\n}\n\ntw-link:hover, tw-icon:hover, a:hover {\n\tcolor: #44f;\n\ttext-decoration-color: #44f;\n\ttext-decoration: underline;\n}\n\ntw-storydata {\n\tdisplay: none;\n}\n        </style>\n    </head>\n    <body>\n        {{STORY_DATA}}\n\t\t<tw-story>\n\t\t\t<tw-passage class=\"passage\"></tw-passage>\n\t\t</tw-story>\n        <script>\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n    factory();\n})((function () { 'use strict';\n\n    var Passage = (function () {\n        function Passage(name, tags, source) {\n            name !== null && name !== void 0 ? name : (name = 'Default');\n            tags !== null && tags !== void 0 ? tags : (tags = []);\n            source !== null && source !== void 0 ? source : (source = '');\n            this.name = name;\n            this.tags = tags;\n            this.source = source;\n            console.log(\"Passage '\".concat(this.name, \" source:\").concat(this.source));\n        }\n        Passage.prototype.renderLinks = function () {\n            var rules = [\n                [/\\[\\[(.+)(\\||-\\&gt;)(.+)\\]\\]/g, '<tw-link data-passage=\"$3\">$1</tw-link>'],\n                [/\\[\\[(.+)\\&lt;-(.+)?\\]\\]/g, '<tw-link data-passage=\"$1\">$2</tw-link>']\n            ];\n            var text = this.source;\n            rules.forEach(function (_a) {\n                var rule = _a[0], template = _a[1];\n                text = text.replaceAll(rule, template);\n            });\n            return text;\n        };\n        return Passage;\n    }());\n\n    var Utils = (function () {\n        function Utils() {\n        }\n        Utils.generateElements = function (html) {\n            var template = document.createElement('template');\n            template.innerHTML = html.trim();\n            return template.content.children;\n        };\n        Utils.addEventListener = function (eventName, eventHandler, selector) {\n            var wrappedHandler = function (e) {\n                if (!e.target || !(e.target instanceof Element))\n                    return;\n                var el = e.target.closest(selector);\n                if (el) {\n                    eventHandler.call(el, e);\n                }\n            };\n            document.addEventListener(eventName, wrappedHandler);\n            return wrappedHandler;\n        };\n        return Utils;\n    }());\n\n    var Story = (function () {\n        function Story() {\n            var _this = this;\n            var storydataElement = document.querySelector('tw-storydata');\n            if (storydataElement === null) {\n                throw new Error(\"Could not find '<tw-storydata>' element!\");\n            }\n            this.storyData = storydataElement;\n            this.name = this.storyData.getAttribute('name');\n            this.passages = [];\n            this.storyData.querySelectorAll('tw-passagedata').forEach(function (element) {\n                var tagsValue = element.getAttribute('tags');\n                var tags;\n                if (tagsValue !== '' && tagsValue) {\n                    tags = tagsValue.split(' ');\n                }\n                else {\n                    tags = [];\n                }\n                _this.passages.push(new Passage(element.getAttribute('name'), tags, element.innerHTML));\n            });\n            var workingPassage;\n            if (!(workingPassage = document.querySelector('tw-passage'))) {\n                throw new Error(\"Unable to locate <tw-passage>!\");\n            }\n            this.workingPassage = workingPassage;\n            this.currentPassage = null;\n        }\n        Story.prototype.start = function () {\n            var _this = this;\n            var passageIDStr = this.storyData.getAttribute('startnode');\n            if (!passageIDStr) {\n                throw new Error('Unable to fetch startnode value!');\n            }\n            var startingPassageID = parseInt(passageIDStr);\n            var startingPassage;\n            var startPassageName;\n            if (!(startingPassage = document.querySelector(\"[pid=\\\"\".concat(startingPassageID, \"\\\"]\")))\n                || !(startPassageName = startingPassage.getAttribute('name'))) {\n                throw new Error('Unable to fetch starting passage name!');\n            }\n            var passage = this.getPassageByName(startPassageName);\n            if (passage === null) {\n                throw new Error('Starting passage does not exist!');\n            }\n            this.currentPassage = passage;\n            this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n            var passageSource = this.include(passage.name);\n            this.workingPassage.innerHTML = passageSource;\n            Utils.addEventListener('click', function (event) {\n                if (event.target instanceof Element) {\n                    var passageName = event.target.getAttribute('data-passage');\n                    _this.show(passageName);\n                }\n            }, 'tw-link[data-passage]');\n        };\n        Story.prototype.getPassagesByTag = function (tag) {\n            return this.passages.filter(function (p) {\n                return p.tags.includes(tag);\n            });\n        };\n        Story.prototype.getPassageByName = function (name) {\n            var passage = null;\n            var result = this.passages.filter(function (p) { return p.name === name; });\n            if (result.length !== 0) {\n                passage = result[0];\n            }\n            return passage;\n        };\n        Story.prototype.show = function (name) {\n            var _this = this;\n            var passage = this.getPassageByName(name);\n            if (passage === null) {\n                throw new Error(\"There is no passage with the name \".concat(name));\n            }\n            this.currentPassage = passage;\n            this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n            var passageSource = this.include(passage.name);\n            this.workingPassage.innerHTML = passageSource;\n            Utils.addEventListener('click', function (event) {\n                if (event.target instanceof Element) {\n                    var passageName = event.target.getAttribute('data-passage');\n                    _this.show(passageName);\n                }\n            }, 'tw-link[data-passage]');\n        };\n        Story.prototype.include = function (name) {\n            var passage = this.getPassageByName(name);\n            if (passage === null) {\n                throw new Error('There is no passage with name ' + name);\n            }\n            var passageSource = passage.renderLinks();\n            return passageSource;\n        };\n        Story.prototype.renderPassageToSelector = function (passageName, selector) {\n            var passageSource = this.include(passageName);\n            var element = document.querySelector(selector);\n            if (element) {\n                element.innerHTML = passageSource;\n            }\n        };\n        Story.prototype.addPassage = function (name, tags, source) {\n            if (name === void 0) { name = ''; }\n            if (tags === void 0) { tags = []; }\n            if (source === void 0) { source = ''; }\n            var nameSearch = this.getPassageByName(name);\n            if (nameSearch !== null) {\n                throw new Error('Cannot add two passages with the same name!');\n            }\n            if (!Array.isArray(tags)) {\n                tags = [];\n            }\n            if (Object.prototype.toString.call(source) !== '[object String]') {\n                source = '';\n            }\n            this.passages.push(new Passage(name, tags, source));\n        };\n        Story.prototype.removePassage = function (name) {\n            if (name === void 0) { name = ''; }\n            this.passages = this.passages.filter(function (passage) {\n                return passage.name !== name;\n            });\n        };\n        Story.prototype.goto = function (name) {\n            if (name === void 0) { name = ''; }\n            var passage = this.getPassageByName(name);\n            if (passage === null) {\n                throw new Error(\"There is no passage with the name \".concat(name));\n            }\n            this.show(name);\n        };\n        return Story;\n    }());\n\n    var passage;\n    var hasRequiredPassage;\n\n    function requirePassage () {\n    \tif (hasRequiredPassage) return passage;\n    \thasRequiredPassage = 1;\n\n    \tclass peg$SyntaxError extends SyntaxError {\n    \t  constructor(message, expected, found, location) {\n    \t    super(message);\n    \t    this.expected = expected;\n    \t    this.found = found;\n    \t    this.location = location;\n    \t    this.name = \"SyntaxError\";\n    \t  }\n\n    \t  format(sources) {\n    \t    let str = \"Error: \" + this.message;\n    \t    if (this.location) {\n    \t      let src = null;\n    \t      const st = sources.find(s => s.source === this.location.source);\n    \t      if (st) {\n    \t        src = st.text.split(/\\r\\n|\\n|\\r/g);\n    \t      }\n    \t      const s = this.location.start;\n    \t      const offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n    \t        ? this.location.source.offset(s)\n    \t        : s;\n    \t      const loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    \t      if (src) {\n    \t        const e = this.location.end;\n    \t        const filler = \"\".padEnd(offset_s.line.toString().length, \" \");\n    \t        const line = src[s.line - 1];\n    \t        const last = s.line === e.line ? e.column : line.length + 1;\n    \t        const hatLen = (last - s.column) || 1;\n    \t        str += \"\\n --> \" + loc + \"\\n\"\n    \t            + filler + \" |\\n\"\n    \t            + offset_s.line + \" | \" + line + \"\\n\"\n    \t            + filler + \" | \" + \"\".padEnd(s.column - 1, \" \")\n    \t            + \"\".padEnd(hatLen, \"^\");\n    \t      } else {\n    \t        str += \"\\n at \" + loc;\n    \t      }\n    \t    }\n    \t    return str;\n    \t  }\n\n    \t  static buildMessage(expected, found) {\n    \t    function hex(ch) {\n    \t      return ch.codePointAt(0).toString(16).toUpperCase();\n    \t    }\n\n    \t    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \"unicode\")\n    \t      ? new RegExp(\"[\\\\p{C}\\\\p{Mn}\\\\p{Mc}]\", \"gu\")\n    \t      : null;\n    \t    function unicodeEscape(s) {\n    \t      if (nonPrintable) {\n    \t        return s.replace(nonPrintable,  ch => \"\\\\u{\" + hex(ch) + \"}\");\n    \t      }\n    \t      return s;\n    \t    }\n\n    \t    function literalEscape(s) {\n    \t      return unicodeEscape(s\n    \t        .replace(/\\\\/g, \"\\\\\\\\\")\n    \t        .replace(/\"/g,  \"\\\\\\\"\")\n    \t        .replace(/\\0/g, \"\\\\0\")\n    \t        .replace(/\\t/g, \"\\\\t\")\n    \t        .replace(/\\n/g, \"\\\\n\")\n    \t        .replace(/\\r/g, \"\\\\r\")\n    \t        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n    \t        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n    \t    }\n\n    \t    function classEscape(s) {\n    \t      return unicodeEscape(s\n    \t        .replace(/\\\\/g, \"\\\\\\\\\")\n    \t        .replace(/\\]/g, \"\\\\]\")\n    \t        .replace(/\\^/g, \"\\\\^\")\n    \t        .replace(/-/g,  \"\\\\-\")\n    \t        .replace(/\\0/g, \"\\\\0\")\n    \t        .replace(/\\t/g, \"\\\\t\")\n    \t        .replace(/\\n/g, \"\\\\n\")\n    \t        .replace(/\\r/g, \"\\\\r\")\n    \t        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n    \t        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n    \t    }\n\n    \t    const DESCRIBE_EXPECTATION_FNS = {\n    \t      literal(expectation) {\n    \t        return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    \t      },\n\n    \t      class(expectation) {\n    \t        const escapedParts = expectation.parts.map(\n    \t          part => (Array.isArray(part)\n    \t            ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n    \t            : classEscape(part))\n    \t        );\n\n    \t        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\" + (expectation.unicode ? \"u\" : \"\");\n    \t      },\n\n    \t      any() {\n    \t        return \"any character\";\n    \t      },\n\n    \t      end() {\n    \t        return \"end of input\";\n    \t      },\n\n    \t      other(expectation) {\n    \t        return expectation.description;\n    \t      },\n    \t    };\n\n    \t    function describeExpectation(expectation) {\n    \t      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    \t    }\n\n    \t    function describeExpected(expected) {\n    \t      const descriptions = expected.map(describeExpectation);\n    \t      descriptions.sort();\n\n    \t      if (descriptions.length > 0) {\n    \t        let j = 1;\n    \t        for (let i = 1; i < descriptions.length; i++) {\n    \t          if (descriptions[i - 1] !== descriptions[i]) {\n    \t            descriptions[j] = descriptions[i];\n    \t            j++;\n    \t          }\n    \t        }\n    \t        descriptions.length = j;\n    \t      }\n\n    \t      switch (descriptions.length) {\n    \t        case 1:\n    \t          return descriptions[0];\n\n    \t        case 2:\n    \t          return descriptions[0] + \" or \" + descriptions[1];\n\n    \t        default:\n    \t          return descriptions.slice(0, -1).join(\", \")\n    \t            + \", or \"\n    \t            + descriptions[descriptions.length - 1];\n    \t      }\n    \t    }\n\n    \t    function describeFound(found) {\n    \t      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    \t    }\n\n    \t    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    \t  }\n    \t}\n\n    \tfunction peg$parse(input, options) {\n    \t  options = options !== undefined ? options : {};\n\n    \t  const peg$FAILED = {};\n    \t  const peg$source = options.grammarSource;\n\n    \t  const peg$startRuleFunctions = {\n    \t    Expression: peg$parseExpression,\n    \t  };\n    \t  let peg$startRuleFunction = peg$parseExpression;\n\n    \t  const peg$c0 = \"(\";\n    \t  const peg$c1 = \")\";\n\n    \t  const peg$r0 = /^[+\\-]/;\n    \t  const peg$r1 = /^[*\\/]/;\n    \t  const peg$r2 = /^[0-9]/;\n    \t  const peg$r3 = /^[ \\t\\n\\r]/;\n\n    \t  const peg$e0 = peg$classExpectation([\"+\", \"-\"], false, false, false);\n    \t  const peg$e1 = peg$classExpectation([\"*\", \"/\"], false, false, false);\n    \t  const peg$e2 = peg$literalExpectation(\"(\", false);\n    \t  const peg$e3 = peg$literalExpectation(\")\", false);\n    \t  const peg$e4 = peg$otherExpectation(\"integer\");\n    \t  const peg$e5 = peg$classExpectation([[\"0\", \"9\"]], false, false, false);\n    \t  const peg$e6 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false, false);\n\n    \t  function peg$f0(head, tail) {\n    \t    return tail.reduce(function(result, element) {\n    \t      if (element[1] === \"+\") { return result + element[3]; }\n    \t      if (element[1] === \"-\") { return result - element[3]; }\n    \t    }, head);\n    \t  }\n    \t  function peg$f1(head, tail) {\n    \t    return tail.reduce(function(result, element) {\n    \t      if (element[1] === \"*\") { return result * element[3]; }\n    \t      if (element[1] === \"/\") { return result / element[3]; }\n    \t    }, head);\n    \t  }\n    \t  function peg$f2(expr) {    return expr;  }\n    \t  function peg$f3() {    return parseInt(text(), 10);  }\n    \t  let peg$currPos = options.peg$currPos | 0;\n    \t  let peg$savedPos = peg$currPos;\n    \t  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n    \t  let peg$maxFailPos = peg$currPos;\n    \t  let peg$maxFailExpected = options.peg$maxFailExpected || [];\n    \t  let peg$silentFails = options.peg$silentFails | 0;\n\n    \t  let peg$result;\n\n    \t  if (options.startRule) {\n    \t    if (!(options.startRule in peg$startRuleFunctions)) {\n    \t      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    \t    }\n\n    \t    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    \t  }\n\n    \t  function text() {\n    \t    return input.substring(peg$savedPos, peg$currPos);\n    \t  }\n\n    \t  function peg$getUnicode(pos = peg$currPos) {\n    \t    const cp = input.codePointAt(pos);\n    \t    if (cp === undefined) {\n    \t      return \"\";\n    \t    }\n    \t    return String.fromCodePoint(cp);\n    \t  }\n\n    \t  function peg$literalExpectation(text, ignoreCase) {\n    \t    return { type: \"literal\", text, ignoreCase };\n    \t  }\n\n    \t  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\n    \t    return { type: \"class\", parts, inverted, ignoreCase, unicode };\n    \t  }\n\n    \t  function peg$endExpectation() {\n    \t    return { type: \"end\" };\n    \t  }\n\n    \t  function peg$otherExpectation(description) {\n    \t    return { type: \"other\", description };\n    \t  }\n\n    \t  function peg$computePosDetails(pos) {\n    \t    let details = peg$posDetailsCache[pos];\n    \t    let p;\n\n    \t    if (details) {\n    \t      return details;\n    \t    } else {\n    \t      if (pos >= peg$posDetailsCache.length) {\n    \t        p = peg$posDetailsCache.length - 1;\n    \t      } else {\n    \t        p = pos;\n    \t        while (!peg$posDetailsCache[--p]) {}\n    \t      }\n\n    \t      details = peg$posDetailsCache[p];\n    \t      details = {\n    \t        line: details.line,\n    \t        column: details.column,\n    \t      };\n\n    \t      while (p < pos) {\n    \t        if (input.charCodeAt(p) === 10) {\n    \t          details.line++;\n    \t          details.column = 1;\n    \t        } else {\n    \t          details.column++;\n    \t        }\n\n    \t        p++;\n    \t      }\n\n    \t      peg$posDetailsCache[pos] = details;\n\n    \t      return details;\n    \t    }\n    \t  }\n\n    \t  function peg$computeLocation(startPos, endPos, offset) {\n    \t    const startPosDetails = peg$computePosDetails(startPos);\n    \t    const endPosDetails = peg$computePosDetails(endPos);\n\n    \t    const res = {\n    \t      source: peg$source,\n    \t      start: {\n    \t        offset: startPos,\n    \t        line: startPosDetails.line,\n    \t        column: startPosDetails.column,\n    \t      },\n    \t      end: {\n    \t        offset: endPos,\n    \t        line: endPosDetails.line,\n    \t        column: endPosDetails.column,\n    \t      },\n    \t    };\n    \t    return res;\n    \t  }\n\n    \t  function peg$fail(expected) {\n    \t    if (peg$currPos < peg$maxFailPos) { return; }\n\n    \t    if (peg$currPos > peg$maxFailPos) {\n    \t      peg$maxFailPos = peg$currPos;\n    \t      peg$maxFailExpected = [];\n    \t    }\n\n    \t    peg$maxFailExpected.push(expected);\n    \t  }\n\n    \t  function peg$buildStructuredError(expected, found, location) {\n    \t    return new peg$SyntaxError(\n    \t      peg$SyntaxError.buildMessage(expected, found),\n    \t      expected,\n    \t      found,\n    \t      location\n    \t    );\n    \t  }\n\n    \t  function peg$parseExpression() {\n    \t    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    \t    s0 = peg$currPos;\n    \t    s1 = peg$parseTerm();\n    \t    if (s1 !== peg$FAILED) {\n    \t      s2 = [];\n    \t      s3 = peg$currPos;\n    \t      s4 = peg$parse_();\n    \t      s5 = input.charAt(peg$currPos);\n    \t      if (peg$r0.test(s5)) {\n    \t        peg$currPos++;\n    \t      } else {\n    \t        s5 = peg$FAILED;\n    \t        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    \t      }\n    \t      if (s5 !== peg$FAILED) {\n    \t        s6 = peg$parse_();\n    \t        s7 = peg$parseTerm();\n    \t        if (s7 !== peg$FAILED) {\n    \t          s4 = [s4, s5, s6, s7];\n    \t          s3 = s4;\n    \t        } else {\n    \t          peg$currPos = s3;\n    \t          s3 = peg$FAILED;\n    \t        }\n    \t      } else {\n    \t        peg$currPos = s3;\n    \t        s3 = peg$FAILED;\n    \t      }\n    \t      while (s3 !== peg$FAILED) {\n    \t        s2.push(s3);\n    \t        s3 = peg$currPos;\n    \t        s4 = peg$parse_();\n    \t        s5 = input.charAt(peg$currPos);\n    \t        if (peg$r0.test(s5)) {\n    \t          peg$currPos++;\n    \t        } else {\n    \t          s5 = peg$FAILED;\n    \t          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    \t        }\n    \t        if (s5 !== peg$FAILED) {\n    \t          s6 = peg$parse_();\n    \t          s7 = peg$parseTerm();\n    \t          if (s7 !== peg$FAILED) {\n    \t            s4 = [s4, s5, s6, s7];\n    \t            s3 = s4;\n    \t          } else {\n    \t            peg$currPos = s3;\n    \t            s3 = peg$FAILED;\n    \t          }\n    \t        } else {\n    \t          peg$currPos = s3;\n    \t          s3 = peg$FAILED;\n    \t        }\n    \t      }\n    \t      peg$savedPos = s0;\n    \t      s0 = peg$f0(s1, s2);\n    \t    } else {\n    \t      peg$currPos = s0;\n    \t      s0 = peg$FAILED;\n    \t    }\n\n    \t    return s0;\n    \t  }\n\n    \t  function peg$parseTerm() {\n    \t    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    \t    s0 = peg$currPos;\n    \t    s1 = peg$parseFactor();\n    \t    if (s1 !== peg$FAILED) {\n    \t      s2 = [];\n    \t      s3 = peg$currPos;\n    \t      s4 = peg$parse_();\n    \t      s5 = input.charAt(peg$currPos);\n    \t      if (peg$r1.test(s5)) {\n    \t        peg$currPos++;\n    \t      } else {\n    \t        s5 = peg$FAILED;\n    \t        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    \t      }\n    \t      if (s5 !== peg$FAILED) {\n    \t        s6 = peg$parse_();\n    \t        s7 = peg$parseFactor();\n    \t        if (s7 !== peg$FAILED) {\n    \t          s4 = [s4, s5, s6, s7];\n    \t          s3 = s4;\n    \t        } else {\n    \t          peg$currPos = s3;\n    \t          s3 = peg$FAILED;\n    \t        }\n    \t      } else {\n    \t        peg$currPos = s3;\n    \t        s3 = peg$FAILED;\n    \t      }\n    \t      while (s3 !== peg$FAILED) {\n    \t        s2.push(s3);\n    \t        s3 = peg$currPos;\n    \t        s4 = peg$parse_();\n    \t        s5 = input.charAt(peg$currPos);\n    \t        if (peg$r1.test(s5)) {\n    \t          peg$currPos++;\n    \t        } else {\n    \t          s5 = peg$FAILED;\n    \t          if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    \t        }\n    \t        if (s5 !== peg$FAILED) {\n    \t          s6 = peg$parse_();\n    \t          s7 = peg$parseFactor();\n    \t          if (s7 !== peg$FAILED) {\n    \t            s4 = [s4, s5, s6, s7];\n    \t            s3 = s4;\n    \t          } else {\n    \t            peg$currPos = s3;\n    \t            s3 = peg$FAILED;\n    \t          }\n    \t        } else {\n    \t          peg$currPos = s3;\n    \t          s3 = peg$FAILED;\n    \t        }\n    \t      }\n    \t      peg$savedPos = s0;\n    \t      s0 = peg$f1(s1, s2);\n    \t    } else {\n    \t      peg$currPos = s0;\n    \t      s0 = peg$FAILED;\n    \t    }\n\n    \t    return s0;\n    \t  }\n\n    \t  function peg$parseFactor() {\n    \t    let s0, s1, s3, s5;\n\n    \t    s0 = peg$currPos;\n    \t    if (input.charCodeAt(peg$currPos) === 40) {\n    \t      s1 = peg$c0;\n    \t      peg$currPos++;\n    \t    } else {\n    \t      s1 = peg$FAILED;\n    \t      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    \t    }\n    \t    if (s1 !== peg$FAILED) {\n    \t      peg$parse_();\n    \t      s3 = peg$parseExpression();\n    \t      if (s3 !== peg$FAILED) {\n    \t        peg$parse_();\n    \t        if (input.charCodeAt(peg$currPos) === 41) {\n    \t          s5 = peg$c1;\n    \t          peg$currPos++;\n    \t        } else {\n    \t          s5 = peg$FAILED;\n    \t          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    \t        }\n    \t        if (s5 !== peg$FAILED) {\n    \t          peg$savedPos = s0;\n    \t          s0 = peg$f2(s3);\n    \t        } else {\n    \t          peg$currPos = s0;\n    \t          s0 = peg$FAILED;\n    \t        }\n    \t      } else {\n    \t        peg$currPos = s0;\n    \t        s0 = peg$FAILED;\n    \t      }\n    \t    } else {\n    \t      peg$currPos = s0;\n    \t      s0 = peg$FAILED;\n    \t    }\n    \t    if (s0 === peg$FAILED) {\n    \t      s0 = peg$parseInteger();\n    \t    }\n\n    \t    return s0;\n    \t  }\n\n    \t  function peg$parseInteger() {\n    \t    let s0, s2, s3;\n\n    \t    peg$silentFails++;\n    \t    s0 = peg$currPos;\n    \t    peg$parse_();\n    \t    s2 = [];\n    \t    s3 = input.charAt(peg$currPos);\n    \t    if (peg$r2.test(s3)) {\n    \t      peg$currPos++;\n    \t    } else {\n    \t      s3 = peg$FAILED;\n    \t      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    \t    }\n    \t    if (s3 !== peg$FAILED) {\n    \t      while (s3 !== peg$FAILED) {\n    \t        s2.push(s3);\n    \t        s3 = input.charAt(peg$currPos);\n    \t        if (peg$r2.test(s3)) {\n    \t          peg$currPos++;\n    \t        } else {\n    \t          s3 = peg$FAILED;\n    \t          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    \t        }\n    \t      }\n    \t    } else {\n    \t      s2 = peg$FAILED;\n    \t    }\n    \t    if (s2 !== peg$FAILED) {\n    \t      peg$savedPos = s0;\n    \t      s0 = peg$f3();\n    \t    } else {\n    \t      peg$currPos = s0;\n    \t      s0 = peg$FAILED;\n    \t    }\n    \t    peg$silentFails--;\n    \t    if (s0 === peg$FAILED) {\n    \t      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    \t    }\n\n    \t    return s0;\n    \t  }\n\n    \t  function peg$parse_() {\n    \t    let s0, s1;\n\n    \t    peg$silentFails++;\n    \t    s0 = [];\n    \t    s1 = input.charAt(peg$currPos);\n    \t    if (peg$r3.test(s1)) {\n    \t      peg$currPos++;\n    \t    } else {\n    \t      s1 = peg$FAILED;\n    \t      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    \t    }\n    \t    while (s1 !== peg$FAILED) {\n    \t      s0.push(s1);\n    \t      s1 = input.charAt(peg$currPos);\n    \t      if (peg$r3.test(s1)) {\n    \t        peg$currPos++;\n    \t      } else {\n    \t        s1 = peg$FAILED;\n    \t        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    \t      }\n    \t    }\n    \t    peg$silentFails--;\n\n    \t    return s0;\n    \t  }\n\n    \t  peg$result = peg$startRuleFunction();\n\n    \t  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);\n    \t  function peg$throw() {\n    \t    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n    \t      peg$fail(peg$endExpectation());\n    \t    }\n\n    \t    throw peg$buildStructuredError(\n    \t      peg$maxFailExpected,\n    \t      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,\n    \t      peg$maxFailPos < input.length\n    \t        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n    \t        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    \t    );\n    \t  }\n    \t  if (options.peg$library) {\n    \t    return /** @type {any} */ ({\n    \t      peg$result,\n    \t      peg$currPos,\n    \t      peg$FAILED,\n    \t      peg$maxFailExpected,\n    \t      peg$maxFailPos,\n    \t      peg$success,\n    \t      peg$throw: peg$success ? undefined : peg$throw,\n    \t    });\n    \t  }\n    \t  if (peg$success) {\n    \t    return peg$result;\n    \t  } else {\n    \t    peg$throw();\n    \t  }\n    \t}\n\n    \tpassage = {\n    \t  StartRules: [\"Expression\"],\n    \t  SyntaxError: peg$SyntaxError,\n    \t  parse: peg$parse,\n    \t};\n    \treturn passage;\n    }\n\n    var passageExports = requirePassage();\n\n    window._story = new Story();\n    window._story.start();\n    console.log(passageExports.parse(\"3 * (3 - 1)\"));\n\n}));\n       </script>\n    \n</body></html>"});