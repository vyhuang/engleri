window.storyFormat({"name":"Engleri","version":"0.1.2","description":"A Twine story format that uses Inkle's Ink language","proofing":false,"license":"MIT","setup":"","source":"<!DOCTYPE html><html><head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta charset=\"utf-8\">\n        <title>{{STORY_NAME}}</title>\n        <style>\n/* The MIT License (MIT) Copyright (c) 2019 Chris Klimas, 2022 Dan Cox, 2025 Vincent H. */\n\n/* Give ourselves some decent defaults. */\n\nbody {\n\tfont: 1.5em \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\tcolor: hsl(0, 0%, 13%);\n    text-align: center;\n}\n\ndiv#ink_block {\n\theight: 70vh;\n\toverflow-y: scroll;\n}\n\ndiv#tap_reminder {\n    opacity: 1;\n    animation: tapFade;\n\tanimation-duration: 4s;\n\tanimation-iteration-count: infinite;\n}\n\n@keyframes tapFade {\n  0%,100% { opacity: 0 }\n  50% { opacity: 1 }\n}\n\ntw-icon {\n\tfont-size: 2em;\n\tcursor: pointer;\n}\n\ntw-story {\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tmin-height: 100%;\n\tfont-size: 1.5em;\n\tline-height: 1.5em;\n\tdisplay: flex;\n\tflex-direction: row;\n\tmargin-top: 1em;\n}\n\ntw-passage {\n\twidth: 90%;\n\tdisplay: block;\n}\n\ntw-link, a {\n\tcolor: #00a;\n\ttext-decoration-color: #00a;\n\tcursor: pointer;\n\ttext-decoration: underline;\n}\n\ntw-link:hover, tw-icon:hover, a:hover {\n\tcolor: #44f;\n\ttext-decoration-color: #44f;\n\ttext-decoration: underline;\n}\n\ntw-storydata {\n\tdisplay: none;\n}\n        </style>\n    </head>\n    <body>\n        {{STORY_DATA}}\n\t\t<tw-story>\n\t\t\t<tw-passage class=\"passage\"></tw-passage>\n\t\t</tw-story>\n        <script>\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('path'), require('fs')) :\n  typeof define === 'function' && define.amd ? define(['path', 'fs'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.require$$0, global.require$$1));\n})(this, (function (require$$0, require$$1) { 'use strict';\n\n  var passage;\n  var hasRequiredPassage;\n  function requirePassage() {\n    if (hasRequiredPassage) return passage;\n    hasRequiredPassage = 1;\n    class ParsedPassage {\n      // includes:\tstring[]\n      // contents:\t\tParsedObject[]\n      constructor(includes, contents) {\n        includes !== null && includes !== void 0 ? includes : includes = [];\n        contents !== null && contents !== void 0 ? contents : contents = [];\n        this.includes = includes;\n        this.contents = contents;\n        this.typeName = \"ParsedPassage\";\n      }\n    }\n    class ParsedObject {\n      // typeName: \tstring\n      // values: \t\t(ParsedObject | string)[]\n      // reduce:\t\t(arg: (ParsedObject | string)[]) => string\n      constructor(typeName, values, reduce) {\n        typeName !== null && typeName !== void 0 ? typeName : typeName = \"\";\n        values !== null && values !== void 0 ? values : values = [];\n        reduce !== null && reduce !== void 0 ? reduce : reduce = function reduce(parsedObjects) {\n          var values = parsedObjects.map(function (object) {\n            return typeof object === \"string\" ? object : object.render();\n          });\n          return values.join(\"\");\n        };\n        this.typeName = typeName;\n        this.values = values;\n        this.reduce = reduce;\n      }\n      render() {\n        return this.reduce(this.values);\n      }\n    }\n    class Link extends ParsedObject {\n      constructor(values) {\n        super(\"link\", values, function (textValues) {\n          // we know these values are text objects.\n          var renderedTextValues = textValues.map(value => value.render());\n          var label = renderedTextValues[0];\n          var dest = renderedTextValues[1];\n          return \"<tw-link data-passage=\\\"\".concat(dest.trim(), \"\\\">\").concat(label.trim(), \"</tw-link>\");\n        });\n      }\n    }\n    class peg$SyntaxError extends SyntaxError {\n      constructor(message, expected, found, location) {\n        super(message);\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n      }\n      format(sources) {\n        var str = \"Error: \" + this.message;\n        if (this.location) {\n          var src = null;\n          var st = sources.find(s => s.source === this.location.source);\n          if (st) {\n            src = st.text.split(/\\r\\n|\\n|\\r/g);\n          }\n          var s = this.location.start;\n          var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n          var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n          if (src) {\n            var e = this.location.end;\n            var filler = \"\".padEnd(offset_s.line.toString().length, \" \");\n            var line = src[s.line - 1];\n            var last = s.line === e.line ? e.column : line.length + 1;\n            var hatLen = last - s.column || 1;\n            str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + \"\".padEnd(s.column - 1, \" \") + \"\".padEnd(hatLen, \"^\");\n          } else {\n            str += \"\\n at \" + loc;\n          }\n        }\n        return str;\n      }\n      static buildMessage(expected, found) {\n        function hex(ch) {\n          return ch.codePointAt(0).toString(16).toUpperCase();\n        }\n        var nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \"unicode\") ? new RegExp(\"[\\\\p{C}\\\\p{Mn}\\\\p{Mc}]\", \"gu\") : null;\n        function unicodeEscape(s) {\n          if (nonPrintable) {\n            return s.replace(nonPrintable, ch => \"\\\\u{\" + hex(ch) + \"}\");\n          }\n          return s;\n        }\n        function literalEscape(s) {\n          return unicodeEscape(s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, ch => \"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\" + hex(ch)));\n        }\n        function classEscape(s) {\n          return unicodeEscape(s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, ch => \"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\" + hex(ch)));\n        }\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          class(expectation) {\n            var escapedParts = expectation.parts.map(part => Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part));\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\" + (expectation.unicode ? \"u\" : \"\");\n          },\n          any() {\n            return \"any character\";\n          },\n          end() {\n            return \"end of input\";\n          },\n          other(expectation) {\n            return expectation.description;\n          }\n        };\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n        function describeExpected(expected) {\n          var descriptions = expected.map(describeExpectation);\n          descriptions.sort();\n          if (descriptions.length > 0) {\n            var j = 1;\n            for (var i = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n            descriptions.length = j;\n          }\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      }\n    }\n    function peg$parse(input, options) {\n      options = options !== undefined ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = {\n        Expression: peg$parseExpression\n      };\n      var peg$startRuleFunction = peg$parseExpression;\n      var peg$c0 = \"<==text==>\";\n      var peg$c1 = \"<==text>\";\n      var peg$c2 = \"<==t==>\";\n      var peg$c3 = \"<==t>\";\n      var peg$c4 = \"<==>\";\n      var peg$c5 = \"<[[\";\n      var peg$c6 = \"|\";\n      var peg$c7 = \"]]>\";\n      var peg$c8 = \"[[\";\n      var peg$c9 = \"]]\";\n      var peg$c10 = \"->\";\n      var peg$c11 = \"<-\";\n      var peg$c12 = \"\\\\\";\n      var peg$r0 = /^[<>]/;\n      var peg$r1 = /^[^\\n\\r]/;\n      var peg$r2 = /^[<>|[\\]{}\\r\\n_\\\\]/;\n      var peg$r3 = /^[\\r]/;\n      var peg$r4 = /^[\\n]/;\n      var peg$r5 = /^[ \\t]/;\n      var peg$e0 = peg$anyExpectation();\n      var peg$e1 = peg$literalExpectation(\"<==text==>\", false);\n      var peg$e2 = peg$literalExpectation(\"<==text>\", false);\n      var peg$e3 = peg$literalExpectation(\"<==t==>\", false);\n      var peg$e4 = peg$literalExpectation(\"<==t>\", false);\n      var peg$e5 = peg$literalExpectation(\"<==>\", false);\n      var peg$e6 = peg$literalExpectation(\"<[[\", false);\n      var peg$e7 = peg$literalExpectation(\"|\", false);\n      var peg$e8 = peg$literalExpectation(\"]]>\", false);\n      var peg$e9 = peg$literalExpectation(\"[[\", false);\n      var peg$e10 = peg$literalExpectation(\"]]\", false);\n      var peg$e11 = peg$otherExpectation(\"->\");\n      var peg$e12 = peg$literalExpectation(\"->\", false);\n      var peg$e13 = peg$otherExpectation(\"<-\");\n      var peg$e14 = peg$literalExpectation(\"<-\", false);\n      var peg$e15 = peg$literalExpectation(\"\\\\\", false);\n      var peg$e16 = peg$classExpectation([\"<\", \">\"], false, false, false);\n      var peg$e17 = peg$classExpectation([\"\\n\", \"\\r\"], true, false, false);\n      var peg$e18 = peg$classExpectation([\"<\", \">\", \"|\", \"[\", \"]\", \"{\", \"}\", \"\\r\", \"\\n\", \"_\", \"\\\\\"], false, false, false);\n      var peg$e19 = peg$otherExpectation(\"endOfLine\");\n      var peg$e20 = peg$otherExpectation(\"newLine\");\n      var peg$e21 = peg$classExpectation([\"\\r\"], false, false, false);\n      var peg$e22 = peg$classExpectation([\"\\n\"], false, false, false);\n      var peg$e23 = peg$otherExpectation(\"endOfFile\");\n      var peg$e24 = peg$classExpectation([\" \", \"\\t\"], false, false, false);\n      function peg$f0(chunks) {\n        var inkTextCount = 0;\n        chunks.forEach(chunk => {\n          if (chunk.typeName === \"InkText\") {\n            inkTextCount += 1;\n          }\n        });\n        if (inkTextCount > 1) {\n          throw new Error(\"There shouldn't be more than one InkText block in a passage!\");\n        }\n        return new ParsedPassage([], chunks);\n      }\n      function peg$f1(char) {\n        return char;\n      }\n      function peg$f2(inkTextChars) {\n        var toHtml = () => \"<div id='ink_block'></div>\\n\";\n        return new ParsedObject(\"InkText\", inkTextChars, toHtml);\n      }\n      function peg$f3(contents, nls) {\n        var toHtml = function toHtml(values) {\n          var contents = values[0];\n          var newlines = values[1];\n          var pText = \"<p>\".concat(contents.map(o => o.render()).join(\"\"), \"</p>\");\n          var brText = \"\".concat(newlines.map(o => o.render()).join(\"\"));\n          return \"\".concat(pText, \"\\n\").concat(brText);\n        };\n        return new ParsedObject(\"mixedLine\", [contents, [nls]], toHtml);\n      }\n      function peg$f4(label, dest) {\n        return dest;\n      }\n      function peg$f5(label, destination) {\n        var dest = destination ? destination : label;\n        return new Link([label, dest]);\n      }\n      function peg$f6(value) {\n        return new Link(value);\n      }\n      function peg$f7(labelAndDest) {\n        return [labelAndDest, labelAndDest];\n      }\n      function peg$f8(label, destination) {\n        return [label, destination];\n      }\n      function peg$f9(destination, label) {\n        return [label, destination];\n      }\n      function peg$f10(chars) {\n        return new ParsedObject(\"text\", chars, values => values.join(\"\").trimStart());\n      }\n      function peg$f11(char) {\n        return char;\n      }\n      function peg$f12(char) {\n        return char;\n      }\n      function peg$f13(lines) {\n        var toHtml = values => {\n          var count = values.length - 2;\n          if (count > 0) {\n            return \"<br> \\n\".repeat(count);\n          } else {\n            return \"\";\n          }\n        };\n        return new ParsedObject(\"newlines\", lines, toHtml);\n      }\n      var peg$currPos = options.peg$currPos | 0;\n      var peg$posDetailsCache = [{\n        line: 1,\n        column: 1\n      }];\n      var peg$maxFailPos = peg$currPos;\n      var peg$maxFailExpected = options.peg$maxFailExpected || [];\n      var peg$silentFails = options.peg$silentFails | 0;\n      var peg$result;\n      if (options.startRule) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function peg$getUnicode() {\n        var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : peg$currPos;\n        var cp = input.codePointAt(pos);\n        if (cp === undefined) {\n          return \"\";\n        }\n        return String.fromCodePoint(cp);\n      }\n      function peg$literalExpectation(text, ignoreCase) {\n        return {\n          type: \"literal\",\n          text,\n          ignoreCase\n        };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\n        return {\n          type: \"class\",\n          parts,\n          inverted,\n          ignoreCase,\n          unicode\n        };\n      }\n      function peg$anyExpectation() {\n        return {\n          type: \"any\"\n        };\n      }\n      function peg$endExpectation() {\n        return {\n          type: \"end\"\n        };\n      }\n      function peg$otherExpectation(description) {\n        return {\n          type: \"other\",\n          description\n        };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          if (pos >= peg$posDetailsCache.length) {\n            p = peg$posDetailsCache.length - 1;\n          } else {\n            p = pos;\n            while (!peg$posDetailsCache[--p]) {}\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        return res;\n      }\n      function peg$fail(expected) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected);\n      }\n      function peg$buildStructuredError(expected, found, location) {\n        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n      }\n      function peg$parseExpression() {\n        var s0, s2, s3, s4;\n        s0 = peg$currPos;\n        peg$parse_nls();\n        s2 = [];\n        s3 = peg$parseInkText();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsemixedLine();\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseInkText();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsemixedLine();\n          }\n        }\n        s3 = peg$parse_nls();\n        s4 = peg$parse_eol();\n        if (s4 !== peg$FAILED) {\n          s0 = peg$f0(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseInkText() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parse_inkTextStart();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parse_inkTextEnd();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s3 = peg$f1(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parse_inkTextEnd();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = undefined;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e0);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s3 = peg$f1(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$parse_inkTextEnd();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_nls();\n            s0 = peg$f2(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_inkTextStart() {\n        var s0;\n        if (input.substr(peg$currPos, 10) === peg$c0) {\n          s0 = peg$c0;\n          peg$currPos += 10;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c1) {\n            s0 = peg$c1;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 7) === peg$c2) {\n              s0 = peg$c2;\n              peg$currPos += 7;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5) === peg$c3) {\n                s0 = peg$c3;\n                peg$currPos += 5;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e4);\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parse_inkTextEnd() {\n        var s0;\n        if (input.substr(peg$currPos, 4) === peg$c4) {\n          s0 = peg$c4;\n          peg$currPos += 4;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        return s0;\n      }\n      function peg$parsemixedLine() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsepureText();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parselink();\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsepureText();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parselink();\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_nls();\n          s0 = peg$f3(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parselink() {\n        var s0;\n        s0 = peg$parse_wrappedLink();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parse_twLink();\n        }\n        return s0;\n      }\n      function peg$parse_wrappedLink() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c5) {\n          s1 = peg$c5;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsepureText();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 124) {\n              s4 = peg$c6;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e7);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsepureText();\n              if (s5 !== peg$FAILED) {\n                s3 = peg$f4(s2, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (input.substr(peg$currPos, 3) === peg$c7) {\n              s4 = peg$c7;\n              peg$currPos += 3;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e8);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s0 = peg$f5(s2, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_twLink() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c8) {\n          s1 = peg$c8;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e9);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_inner_link_lr();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parse_inner_link_rl();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parse_inner_link_simple();\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c9) {\n              s3 = peg$c9;\n              peg$currPos += 2;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e10);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s0 = peg$f6(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_inner_link_simple() {\n        var s0, s1;\n        s0 = peg$currPos;\n        s1 = peg$parsepureText();\n        if (s1 !== peg$FAILED) {\n          s1 = peg$f7(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parse_inner_link_lr() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsepureText();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_linkArrowRight();\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 124) {\n              s2 = peg$c6;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e7);\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsepureText();\n            if (s3 !== peg$FAILED) {\n              s0 = peg$f8(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_inner_link_rl() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsepureText();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_linkArrowLeft();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsepureText();\n            if (s3 !== peg$FAILED) {\n              s0 = peg$f9(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_linkArrowRight() {\n        var s0;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c10) {\n          s0 = peg$c10;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e12);\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e11);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_linkArrowLeft() {\n        var s0;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c11) {\n          s0 = peg$c11;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e14);\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e13);\n          }\n        }\n        return s0;\n      }\n      function peg$parsepureText() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_charUnescaped();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parse_charEscaped();\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parse_charUnescaped();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parse_charEscaped();\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s1 = peg$f10(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parse_charUnescaped() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parse_nonTextCharUnescaped();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = undefined;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parse_linkArrowRight();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s2 !== peg$FAILED) {\n          peg$currPos = s1;\n          s1 = undefined;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s0 = peg$f11(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_charEscaped() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c12;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e15);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = input.charAt(peg$currPos);\n          if (peg$r0.test(s2)) {\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e16);\n            }\n          }\n          if (s2 === peg$FAILED) {\n            s2 = input.charAt(peg$currPos);\n            if (peg$r1.test(s2)) {\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e17);\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s0 = peg$f12(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_nonTextCharUnescaped() {\n        var s0;\n        s0 = input.charAt(peg$currPos);\n        if (peg$r2.test(s0)) {\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e18);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_eol() {\n        var s0;\n        peg$silentFails++;\n        s0 = peg$parse_nl();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parse_eof();\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_nl() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        s2 = input.charAt(peg$currPos);\n        if (peg$r3.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e21);\n          }\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s3 = input.charAt(peg$currPos);\n        if (peg$r4.test(s3)) {\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e22);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_nls() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_nl();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_nl();\n        }\n        s1 = peg$f13(s1);\n        s0 = s1;\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parse_eof() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        s2 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = undefined;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e23);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        s1 = input.charAt(peg$currPos);\n        if (peg$r5.test(s1)) {\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e24);\n          }\n        }\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          s1 = input.charAt(peg$currPos);\n          if (peg$r5.test(s1)) {\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e24);\n            }\n          }\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      peg$result = peg$startRuleFunction();\n      var peg$success = peg$result !== peg$FAILED && peg$currPos === input.length;\n      function peg$throw() {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n      }\n      if (options.peg$library) {\n        return /** @type {any} */{\n          peg$result,\n          peg$currPos,\n          peg$FAILED,\n          peg$maxFailExpected,\n          peg$maxFailPos,\n          peg$success,\n          peg$throw: peg$success ? undefined : peg$throw\n        };\n      }\n      if (peg$success) {\n        return peg$result;\n      } else {\n        peg$throw();\n      }\n    }\n    passage = {\n      StartRules: [\"Expression\"],\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n    return passage;\n  }\n\n  var passageExports = requirePassage();\n\n  var Passage = (function () {\n      function Passage(name, tags, source) {\n          if (name === void 0) { name = 'Default'; }\n          if (tags === void 0) { tags = []; }\n          if (source === void 0) { source = ''; }\n          name !== null && name !== void 0 ? name : (name = 'Default');\n          tags !== null && tags !== void 0 ? tags : (tags = []);\n          source !== null && source !== void 0 ? source : (source = '');\n          this.name = name;\n          this.tags = tags;\n          this.source = source;\n          this.template = document.createElement(\"template\");\n          this.inkSource = \"\";\n          this.parsePassage();\n      }\n      Passage.prototype.parsePassage = function () {\n          this.unescapedSource = Passage.unescapeHtml(this.source);\n          this.parsedSource = passageExports.parse(this.unescapedSource);\n      };\n      Passage.prototype.renderStaticElements = function () {\n          var result = Passage.renderChunks(this.parsedSource.contents);\n          this.renderedChunks = result.chunks;\n          this.inkSource = result.inkSource;\n          this.template.innerHTML = result.chunks.join(\"\");\n          return this.template;\n      };\n      Passage.renderChunks = function (sourceChunks) {\n          var inkSource = \"\";\n          var chunks = sourceChunks.map(function (chunk) {\n              if (chunk.typeName === \"InkText\") {\n                  inkSource = chunk.values.join(\"\");\n              }\n              return chunk.render();\n          });\n          return { chunks: chunks, inkSource: inkSource };\n      };\n      Passage.unescapeHtml = function (source) {\n          var doc = new DOMParser().parseFromString(source, \"text/html\");\n          return doc.documentElement.textContent;\n      };\n      return Passage;\n  }());\n\n  var Utils = (function () {\n      function Utils() {\n      }\n      Utils.generateElements = function (html) {\n          var template = document.createElement('template');\n          template.innerHTML = html.trim();\n          return template.content.children;\n      };\n      Utils.addEventListener = function (eventName, eventHandler, selector) {\n          var wrappedHandler = function (e) {\n              if (!e.target || !(e.target instanceof Element))\n                  return;\n              var el = e.target.closest(selector);\n              if (el) {\n                  eventHandler.call(el, e);\n              }\n          };\n          document.addEventListener(eventName, wrappedHandler);\n          return wrappedHandler;\n      };\n      return Utils;\n  }());\n\n  var ink = {};\n\n  var Story$2 = {};\n\n  var Container = {};\n\n  var Value = {};\n\n  var _Object$1 = {};\n\n  var Path$1 = {};\n\n  var hasRequiredPath$1;\n  function requirePath$1() {\n    if (hasRequiredPath$1) return Path$1;\n    hasRequiredPath$1 = 1;\n    Object.defineProperty(Path$1, \"__esModule\", {\n      value: true\n    });\n    Path$1.Path = void 0;\n    class Path {\n      constructor() {\n        this._components = [];\n        this._componentsString = null;\n        this._isRelative = false;\n        if (typeof arguments[0] == \"string\") {\n          var componentsString = arguments[0];\n          this.componentsString = componentsString;\n        } else if (arguments[0] instanceof Path.Component && arguments[1] instanceof Path) {\n          var head = arguments[0];\n          var tail = arguments[1];\n          this._components.push(head);\n          this._components = this._components.concat(tail._components);\n        } else if (arguments[0] instanceof Array) {\n          var _head = arguments[0];\n          var relative = !!arguments[1];\n          this._components = this._components.concat(_head);\n          this._isRelative = relative;\n        }\n      }\n      get isRelative() {\n        return this._isRelative;\n      }\n      get componentCount() {\n        return this._components.length;\n      }\n      get head() {\n        if (this._components.length > 0) {\n          return this._components[0];\n        } else {\n          return null;\n        }\n      }\n      get tail() {\n        if (this._components.length >= 2) {\n          // careful, the original code uses length-1 here. This is because the second argument of\n          // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n          var tailComps = this._components.slice(1, this._components.length);\n          return new Path(tailComps);\n        } else {\n          return Path.self;\n        }\n      }\n      get length() {\n        return this._components.length;\n      }\n      get lastComponent() {\n        var lastComponentIdx = this._components.length - 1;\n        if (lastComponentIdx >= 0) {\n          return this._components[lastComponentIdx];\n        } else {\n          return null;\n        }\n      }\n      get containsNamedComponent() {\n        for (var i = 0, l = this._components.length; i < l; i++) {\n          if (!this._components[i].isIndex) {\n            return true;\n          }\n        }\n        return false;\n      }\n      static get self() {\n        var path = new Path();\n        path._isRelative = true;\n        return path;\n      }\n      GetComponent(index) {\n        return this._components[index];\n      }\n      PathByAppendingPath(pathToAppend) {\n        var p = new Path();\n        var upwardMoves = 0;\n        for (var i = 0; i < pathToAppend._components.length; ++i) {\n          if (pathToAppend._components[i].isParent) {\n            upwardMoves++;\n          } else {\n            break;\n          }\n        }\n        for (var _i = 0; _i < this._components.length - upwardMoves; ++_i) {\n          p._components.push(this._components[_i]);\n        }\n        for (var _i2 = upwardMoves; _i2 < pathToAppend._components.length; ++_i2) {\n          p._components.push(pathToAppend._components[_i2]);\n        }\n        return p;\n      }\n      get componentsString() {\n        if (this._componentsString == null) {\n          this._componentsString = this._components.join(\".\");\n          if (this.isRelative) this._componentsString = \".\" + this._componentsString;\n        }\n        return this._componentsString;\n      }\n      set componentsString(value) {\n        this._components.length = 0;\n        this._componentsString = value;\n        if (this._componentsString == null || this._componentsString == \"\") return;\n        if (this._componentsString[0] == \".\") {\n          this._isRelative = true;\n          this._componentsString = this._componentsString.substring(1);\n        }\n        var componentStrings = this._componentsString.split(\".\");\n        for (var str of componentStrings) {\n          // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n          // the normal parseInt won't do for the detection because it's too relaxed.\n          // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n          if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n            this._components.push(new Path.Component(parseInt(str)));\n          } else {\n            this._components.push(new Path.Component(str));\n          }\n        }\n      }\n      toString() {\n        return this.componentsString;\n      }\n      Equals(otherPath) {\n        if (otherPath == null) return false;\n        if (otherPath._components.length != this._components.length) return false;\n        if (otherPath.isRelative != this.isRelative) return false;\n        // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n        for (var i = 0, l = otherPath._components.length; i < l; i++) {\n          // it's not quite clear whether this test should use Equals or a simple == operator,\n          // see https://github.com/y-lohse/inkjs/issues/22\n          if (!otherPath._components[i].Equals(this._components[i])) return false;\n        }\n        return true;\n      }\n      PathByAppendingComponent(c) {\n        var p = new Path();\n        p._components.push(...this._components);\n        p._components.push(c);\n        return p;\n      }\n    }\n    Path$1.Path = Path;\n    Path.parentId = \"^\";\n    (function (Path) {\n      class Component {\n        constructor(indexOrName) {\n          this.index = -1;\n          this.name = null;\n          if (typeof indexOrName == \"string\") {\n            this.name = indexOrName;\n          } else {\n            this.index = indexOrName;\n          }\n        }\n        get isIndex() {\n          return this.index >= 0;\n        }\n        get isParent() {\n          return this.name == Path.parentId;\n        }\n        static ToParent() {\n          return new Component(Path.parentId);\n        }\n        toString() {\n          if (this.isIndex) {\n            return this.index.toString();\n          } else {\n            return this.name;\n          }\n        }\n        Equals(otherComp) {\n          if (otherComp != null && otherComp.isIndex == this.isIndex) {\n            if (this.isIndex) {\n              return this.index == otherComp.index;\n            } else {\n              return this.name == otherComp.name;\n            }\n          }\n          return false;\n        }\n      }\n      Path.Component = Component;\n    })(Path || (Path$1.Path = Path = {}));\n    return Path$1;\n  }\n\n  var Debug = {};\n\n  var hasRequiredDebug;\n  function requireDebug() {\n    if (hasRequiredDebug) return Debug;\n    hasRequiredDebug = 1;\n    Object.defineProperty(Debug, \"__esModule\", {\n      value: true\n    });\n    Debug.Debug = void 0;\n    var Debug$1;\n    (function (Debug) {\n      function AssertType(variable, type, message) {\n        Assert(variable instanceof type, message);\n      }\n      Debug.AssertType = AssertType;\n      function Assert(condition, message) {\n        if (!condition) {\n          if (typeof message !== \"undefined\") {\n            console.warn(message);\n          }\n          if (console.trace) {\n            console.trace();\n          }\n          throw new Error(\"\");\n        }\n      }\n      Debug.Assert = Assert;\n    })(Debug$1 || (Debug.Debug = Debug$1 = {}));\n    return Debug;\n  }\n\n  var TypeAssertion = {};\n\n  var hasRequiredTypeAssertion;\n  function requireTypeAssertion() {\n    if (hasRequiredTypeAssertion) return TypeAssertion;\n    hasRequiredTypeAssertion = 1;\n    Object.defineProperty(TypeAssertion, \"__esModule\", {\n      value: true\n    });\n    TypeAssertion.filterUndef = TypeAssertion.isEquatable = TypeAssertion.nullIfUndefined = TypeAssertion.asINamedContentOrNull = TypeAssertion.asBooleanOrThrows = TypeAssertion.asNumberOrThrows = TypeAssertion.asOrThrows = TypeAssertion.asOrNull = void 0;\n    function asOrNull(obj, type) {\n      if (obj instanceof type) {\n        return unsafeTypeAssertion(obj);\n      } else {\n        return null;\n      }\n    }\n    TypeAssertion.asOrNull = asOrNull;\n    function asOrThrows(obj, type) {\n      if (obj instanceof type) {\n        return unsafeTypeAssertion(obj);\n      } else {\n        throw new Error(\"\".concat(obj, \" is not of type \").concat(type));\n      }\n    }\n    TypeAssertion.asOrThrows = asOrThrows;\n    function asNumberOrThrows(obj) {\n      if (typeof obj === \"number\") {\n        return obj;\n      } else {\n        throw new Error(\"\".concat(obj, \" is not a number\"));\n      }\n    }\n    TypeAssertion.asNumberOrThrows = asNumberOrThrows;\n    function asBooleanOrThrows(obj) {\n      if (typeof obj === \"boolean\") {\n        return obj;\n      } else {\n        throw new Error(\"\".concat(obj, \" is not a boolean\"));\n      }\n    }\n    TypeAssertion.asBooleanOrThrows = asBooleanOrThrows;\n    // So here, in the reference implementation, contentObj is casted to an INamedContent\n    // but here we use js-style duck typing: if it implements the same props as the interface,\n    // we treat it as valid.\n    function asINamedContentOrNull(obj) {\n      if (obj.hasValidName && obj.name) {\n        return obj;\n      }\n      return null;\n    }\n    TypeAssertion.asINamedContentOrNull = asINamedContentOrNull;\n    function nullIfUndefined(obj) {\n      if (typeof obj === \"undefined\") {\n        return null;\n      }\n      return obj;\n    }\n    TypeAssertion.nullIfUndefined = nullIfUndefined;\n    function isEquatable(type) {\n      return typeof type === \"object\" && typeof type.Equals === \"function\";\n    }\n    TypeAssertion.isEquatable = isEquatable;\n    function unsafeTypeAssertion(obj,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    type) {\n      return obj;\n    }\n    function filterUndef(element) {\n      return element != undefined;\n    }\n    TypeAssertion.filterUndef = filterUndef;\n    return TypeAssertion;\n  }\n\n  var NullException = {};\n\n  var hasRequiredNullException;\n  function requireNullException() {\n    if (hasRequiredNullException) return NullException;\n    hasRequiredNullException = 1;\n    Object.defineProperty(NullException, \"__esModule\", {\n      value: true\n    });\n    NullException.throwNullException = NullException.NullException = void 0;\n    /**\n     * In the original C# code, a SystemException would be thrown when passing\n     * null to methods expected a valid instance. Javascript has no such\n     * concept, but TypeScript will not allow `null` to be passed to methods\n     * explicitely requiring a valid type.\n     *\n     * Whenever TypeScript complain about the possibility of a `null` value,\n     * check the offending value and it it's null, throw this exception using\n     * `throwNullException(name: string)`.\n     */\n    let NullException$1 = class NullException extends Error {};\n    NullException.NullException = NullException$1;\n    /**\n     * Throw a NullException.\n     *\n     * @param name a short description of the offending value (often its name within the code).\n     */\n    function throwNullException(name) {\n      throw new NullException$1(\"\".concat(name, \" is null or undefined\"));\n    }\n    NullException.throwNullException = throwNullException;\n    return NullException;\n  }\n\n  var hasRequired_Object$1;\n  function require_Object$1() {\n    if (hasRequired_Object$1) return _Object$1;\n    hasRequired_Object$1 = 1;\n    Object.defineProperty(_Object$1, \"__esModule\", {\n      value: true\n    });\n    _Object$1.InkObject = void 0;\n    var Path_1 = requirePath$1();\n    var Container_1 = requireContainer();\n    var Debug_1 = requireDebug();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var NullException_1 = requireNullException();\n    class InkObject {\n      constructor() {\n        this.parent = null;\n        this._debugMetadata = null;\n        this._path = null;\n      }\n      get debugMetadata() {\n        if (this._debugMetadata === null) {\n          if (this.parent) {\n            return this.parent.debugMetadata;\n          }\n        }\n        return this._debugMetadata;\n      }\n      set debugMetadata(value) {\n        this._debugMetadata = value;\n      }\n      get ownDebugMetadata() {\n        return this._debugMetadata;\n      }\n      DebugLineNumberOfPath(path) {\n        if (path === null) return null;\n        // Try to get a line number from debug metadata\n        var root = this.rootContentContainer;\n        if (root) {\n          var targetContent = root.ContentAtPath(path).obj;\n          if (targetContent) {\n            var dm = targetContent.debugMetadata;\n            if (dm !== null) {\n              return dm.startLineNumber;\n            }\n          }\n        }\n        return null;\n      }\n      get path() {\n        if (this._path == null) {\n          if (this.parent == null) {\n            this._path = new Path_1.Path();\n          } else {\n            var comps = [];\n            var child = this;\n            var container = (0, TypeAssertion_1.asOrNull)(child.parent, Container_1.Container);\n            while (container !== null) {\n              var namedChild = (0, TypeAssertion_1.asINamedContentOrNull)(child);\n              if (namedChild != null && namedChild.hasValidName) {\n                if (namedChild.name === null) return (0, NullException_1.throwNullException)(\"namedChild.name\");\n                comps.unshift(new Path_1.Path.Component(namedChild.name));\n              } else {\n                comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));\n              }\n              child = container;\n              container = (0, TypeAssertion_1.asOrNull)(container.parent, Container_1.Container);\n            }\n            this._path = new Path_1.Path(comps);\n          }\n        }\n        return this._path;\n      }\n      ResolvePath(path) {\n        if (path === null) return (0, NullException_1.throwNullException)(\"path\");\n        if (path.isRelative) {\n          var nearestContainer = (0, TypeAssertion_1.asOrNull)(this, Container_1.Container);\n          if (nearestContainer === null) {\n            Debug_1.Debug.Assert(this.parent !== null, \"Can't resolve relative path because we don't have a parent\");\n            nearestContainer = (0, TypeAssertion_1.asOrNull)(this.parent, Container_1.Container);\n            Debug_1.Debug.Assert(nearestContainer !== null, \"Expected parent to be a container\");\n            Debug_1.Debug.Assert(path.GetComponent(0).isParent);\n            path = path.tail;\n          }\n          if (nearestContainer === null) {\n            return (0, NullException_1.throwNullException)(\"nearestContainer\");\n          }\n          return nearestContainer.ContentAtPath(path);\n        } else {\n          var contentContainer = this.rootContentContainer;\n          if (contentContainer === null) {\n            return (0, NullException_1.throwNullException)(\"contentContainer\");\n          }\n          return contentContainer.ContentAtPath(path);\n        }\n      }\n      ConvertPathToRelative(globalPath) {\n        var ownPath = this.path;\n        var minPathLength = Math.min(globalPath.length, ownPath.length);\n        var lastSharedPathCompIndex = -1;\n        for (var i = 0; i < minPathLength; ++i) {\n          var ownComp = ownPath.GetComponent(i);\n          var otherComp = globalPath.GetComponent(i);\n          if (ownComp.Equals(otherComp)) {\n            lastSharedPathCompIndex = i;\n          } else {\n            break;\n          }\n        }\n        // No shared path components, so just use global path\n        if (lastSharedPathCompIndex == -1) return globalPath;\n        var numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n        var newPathComps = [];\n        for (var up = 0; up < numUpwardsMoves; ++up) newPathComps.push(Path_1.Path.Component.ToParent());\n        for (var down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down) newPathComps.push(globalPath.GetComponent(down));\n        var relativePath = new Path_1.Path(newPathComps, true);\n        return relativePath;\n      }\n      CompactPathString(otherPath) {\n        var globalPathStr = null;\n        var relativePathStr = null;\n        if (otherPath.isRelative) {\n          relativePathStr = otherPath.componentsString;\n          globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n        } else {\n          var relativePath = this.ConvertPathToRelative(otherPath);\n          relativePathStr = relativePath.componentsString;\n          globalPathStr = otherPath.componentsString;\n        }\n        if (relativePathStr.length < globalPathStr.length) return relativePathStr;else return globalPathStr;\n      }\n      get rootContentContainer() {\n        var ancestor = this;\n        while (ancestor.parent) {\n          ancestor = ancestor.parent;\n        }\n        return (0, TypeAssertion_1.asOrNull)(ancestor, Container_1.Container);\n      }\n      Copy() {\n        throw Error(\"Not Implemented: Doesn't support copying\");\n      }\n      // SetChild works slightly diferently in the js implementation.\n      // Since we can't pass an objets property by reference, we instead pass\n      // the object and the property string.\n      // TODO: This method can probably be rewritten with type-safety in mind.\n      SetChild(obj, prop, value) {\n        if (obj[prop]) obj[prop] = null;\n        obj[prop] = value;\n        if (obj[prop]) obj[prop].parent = this;\n      }\n      Equals(obj) {\n        return obj === this;\n      }\n    }\n    _Object$1.InkObject = InkObject;\n    return _Object$1;\n  }\n\n  var InkList = {};\n\n  var StringBuilder = {};\n\n  var hasRequiredStringBuilder;\n  function requireStringBuilder() {\n    if (hasRequiredStringBuilder) return StringBuilder;\n    hasRequiredStringBuilder = 1;\n    Object.defineProperty(StringBuilder, \"__esModule\", {\n      value: true\n    });\n    StringBuilder.StringBuilder = void 0;\n    let StringBuilder$1 = class StringBuilder {\n      constructor(str) {\n        str = typeof str !== \"undefined\" ? str.toString() : \"\";\n        this.string = str;\n      }\n      get Length() {\n        return this.string.length;\n      }\n      Append(str) {\n        if (str !== null) {\n          this.string += str;\n        }\n      }\n      AppendLine(str) {\n        if (typeof str !== \"undefined\") this.Append(str);\n        this.string += \"\\n\";\n      }\n      AppendFormat(format) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n        this.string += format.replace(/{(\\d+)}/g, (match, num) => typeof args[num] != \"undefined\" ? args[num] : match);\n      }\n      toString() {\n        return this.string;\n      }\n      Clear() {\n        this.string = \"\";\n      }\n    };\n    StringBuilder.StringBuilder = StringBuilder$1;\n    return StringBuilder;\n  }\n\n  var hasRequiredInkList;\n  function requireInkList() {\n    if (hasRequiredInkList) return InkList;\n    hasRequiredInkList = 1;\n    Object.defineProperty(InkList, \"__esModule\", {\n      value: true\n    });\n    InkList.InkList = InkList.InkListItem = void 0;\n    var NullException_1 = requireNullException();\n    var StringBuilder_1 = requireStringBuilder();\n    class InkListItem {\n      constructor() {\n        // InkListItem is a struct\n        this.originName = null;\n        this.itemName = null;\n        if (typeof arguments[1] !== \"undefined\") {\n          var originName = arguments[0];\n          var itemName = arguments[1];\n          this.originName = originName;\n          this.itemName = itemName;\n        } else if (arguments[0]) {\n          var fullName = arguments[0];\n          var nameParts = fullName.toString().split(\".\");\n          this.originName = nameParts[0];\n          this.itemName = nameParts[1];\n        }\n      }\n      static get Null() {\n        return new InkListItem(null, null);\n      }\n      get isNull() {\n        return this.originName == null && this.itemName == null;\n      }\n      get fullName() {\n        return (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName;\n      }\n      toString() {\n        return this.fullName;\n      }\n      Equals(obj) {\n        if (obj instanceof InkListItem) {\n          var otherItem = obj;\n          return otherItem.itemName == this.itemName && otherItem.originName == this.originName;\n        }\n        return false;\n      }\n      // These methods did not exist in the original C# code. Their purpose is to\n      // make `InkListItem` mimics the value-type semantics of the original\n      // struct. Please refer to the end of this file, for a more in-depth\n      // explanation.\n      /**\n       * Returns a shallow clone of the current instance.\n       */\n      copy() {\n        return new InkListItem(this.originName, this.itemName);\n      }\n      /**\n       * Returns a `SerializedInkListItem` representing the current\n       * instance. The result is intended to be used as a key inside a Map.\n       */\n      serialized() {\n        // We are simply using a JSON representation as a value-typed key.\n        return JSON.stringify({\n          originName: this.originName,\n          itemName: this.itemName\n        });\n      }\n      /**\n       * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n       */\n      static fromSerializedKey(key) {\n        var obj = JSON.parse(key);\n        if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n        var inkListItem = obj;\n        return new InkListItem(inkListItem.originName, inkListItem.itemName);\n      }\n      /**\n       * Determines whether the given item is sufficiently `InkListItem`-like\n       * to be used as a template when reconstructing the InkListItem.\n       */\n      static isLikeInkListItem(item) {\n        if (typeof item !== \"object\") return false;\n        if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\")) return false;\n        if (typeof item.originName !== \"string\" && typeof item.originName !== null) return false;\n        if (typeof item.itemName !== \"string\" && typeof item.itemName !== null) return false;\n        return true;\n      }\n    }\n    InkList.InkListItem = InkListItem;\n    let InkList$1 = class InkList extends Map {\n      constructor() {\n        // Trying to be smart here, this emulates the constructor inheritance found\n        // in the original code, but only if otherList is an InkList. IIFE FTW.\n        super((() => {\n          if (arguments[0] instanceof InkList) {\n            return arguments[0];\n          } else {\n            return [];\n          }\n        })());\n        this.origins = null;\n        this._originNames = [];\n        if (arguments[0] instanceof InkList) {\n          var otherList = arguments[0];\n          var otherOriginNames = otherList.originNames;\n          if (otherOriginNames !== null) this._originNames = otherOriginNames.slice();\n          if (otherList.origins !== null) {\n            this.origins = otherList.origins.slice();\n          }\n        } else if (typeof arguments[0] === \"string\") {\n          var singleOriginListName = arguments[0];\n          var originStory = arguments[1];\n          this.SetInitialOriginName(singleOriginListName);\n          if (originStory.listDefinitions === null) {\n            return (0, NullException_1.throwNullException)(\"originStory.listDefinitions\");\n          }\n          var def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);\n          if (def.exists) {\n            // Throwing now, because if the value is `null` it will\n            // eventually throw down the line.\n            if (def.result === null) {\n              return (0, NullException_1.throwNullException)(\"def.result\");\n            }\n            this.origins = [def.result];\n          } else {\n            throw new Error(\"InkList origin could not be found in story when constructing new list: \" + singleOriginListName);\n          }\n        } else if (typeof arguments[0] === \"object\" && arguments[0].hasOwnProperty(\"Key\") && arguments[0].hasOwnProperty(\"Value\")) {\n          var singleElement = arguments[0];\n          this.Add(singleElement.Key, singleElement.Value);\n        }\n      }\n      static FromString(myListItem, originStory) {\n        var _a;\n        if (myListItem == null || myListItem == \"\") return new InkList();\n        var listValue = (_a = originStory.listDefinitions) === null || _a === void 0 ? void 0 : _a.FindSingleItemListWithName(myListItem);\n        if (listValue) {\n          if (listValue.value === null) {\n            return (0, NullException_1.throwNullException)(\"listValue.value\");\n          }\n          return new InkList(listValue.value);\n        } else {\n          throw new Error(\"Could not find the InkListItem from the string '\" + myListItem + \"' to create an InkList because it doesn't exist in the original list definition in ink.\");\n        }\n      }\n      AddItem(itemOrItemName) {\n        var storyObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        if (itemOrItemName instanceof InkListItem) {\n          var item = itemOrItemName;\n          if (item.originName == null) {\n            this.AddItem(item.itemName);\n            return;\n          }\n          if (this.origins === null) return (0, NullException_1.throwNullException)(\"this.origins\");\n          for (var origin of this.origins) {\n            if (origin.name == item.originName) {\n              var intVal = origin.TryGetValueForItem(item, 0);\n              if (intVal.exists) {\n                this.Add(item, intVal.result);\n                return;\n              } else {\n                throw new Error(\"Could not add the item \" + item + \" to this list because it doesn't exist in the original list definition in ink.\");\n              }\n            }\n          }\n          throw new Error(\"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\");\n        } else if (itemOrItemName !== null) {\n          //itemOrItemName is a string\n          var itemName = itemOrItemName;\n          var foundListDef = null;\n          if (this.origins === null) return (0, NullException_1.throwNullException)(\"this.origins\");\n          for (var _origin of this.origins) {\n            if (itemName === null) return (0, NullException_1.throwNullException)(\"itemName\");\n            if (_origin.ContainsItemWithName(itemName)) {\n              if (foundListDef != null) {\n                throw new Error(\"Could not add the item \" + itemName + \" to this list because it could come from either \" + _origin.name + \" or \" + foundListDef.name);\n              } else {\n                foundListDef = _origin;\n              }\n            }\n          }\n          if (foundListDef == null) {\n            if (storyObject == null) {\n              throw new Error(\"Could not add the item \" + itemName + \" to this list because it isn't known to any list definitions previously associated with this list.\");\n            } else {\n              var newItem = InkList.FromString(itemName, storyObject).orderedItems[0];\n              this.Add(newItem.Key, newItem.Value);\n            }\n          } else {\n            var _item = new InkListItem(foundListDef.name, itemName);\n            var itemVal = foundListDef.ValueForItem(_item);\n            this.Add(_item, itemVal);\n          }\n        }\n      }\n      ContainsItemNamed(itemName) {\n        for (var [key] of this) {\n          var item = InkListItem.fromSerializedKey(key);\n          if (item.itemName == itemName) return true;\n        }\n        return false;\n      }\n      ContainsKey(key) {\n        return this.has(key.serialized());\n      }\n      Add(key, value) {\n        var serializedKey = key.serialized();\n        if (this.has(serializedKey)) {\n          // Throw an exception to match the C# behavior.\n          throw new Error(\"The Map already contains an entry for \".concat(key));\n        }\n        this.set(serializedKey, value);\n      }\n      Remove(key) {\n        return this.delete(key.serialized());\n      }\n      get Count() {\n        return this.size;\n      }\n      get originOfMaxItem() {\n        if (this.origins == null) return null;\n        var maxOriginName = this.maxItem.Key.originName;\n        var result = null;\n        this.origins.every(origin => {\n          if (origin.name == maxOriginName) {\n            result = origin;\n            return false;\n          } else return true;\n        });\n        return result;\n      }\n      get originNames() {\n        if (this.Count > 0) {\n          if (this._originNames == null && this.Count > 0) this._originNames = [];else {\n            if (!this._originNames) this._originNames = [];\n            this._originNames.length = 0;\n          }\n          for (var [key] of this) {\n            var item = InkListItem.fromSerializedKey(key);\n            if (item.originName === null) return (0, NullException_1.throwNullException)(\"item.originName\");\n            this._originNames.push(item.originName);\n          }\n        }\n        return this._originNames;\n      }\n      SetInitialOriginName(initialOriginName) {\n        this._originNames = [initialOriginName];\n      }\n      SetInitialOriginNames(initialOriginNames) {\n        if (initialOriginNames == null) this._originNames = null;else this._originNames = initialOriginNames.slice(); // store a copy\n      }\n      get maxItem() {\n        var max = {\n          Key: InkListItem.Null,\n          Value: 0\n        };\n        for (var [key, value] of this) {\n          var item = InkListItem.fromSerializedKey(key);\n          if (max.Key.isNull || value > max.Value) max = {\n            Key: item,\n            Value: value\n          };\n        }\n        return max;\n      }\n      get minItem() {\n        var min = {\n          Key: InkListItem.Null,\n          Value: 0\n        };\n        for (var [key, value] of this) {\n          var item = InkListItem.fromSerializedKey(key);\n          if (min.Key.isNull || value < min.Value) {\n            min = {\n              Key: item,\n              Value: value\n            };\n          }\n        }\n        return min;\n      }\n      get inverse() {\n        var list = new InkList();\n        if (this.origins != null) {\n          for (var origin of this.origins) {\n            for (var [key, value] of origin.items) {\n              var item = InkListItem.fromSerializedKey(key);\n              if (!this.ContainsKey(item)) list.Add(item, value);\n            }\n          }\n        }\n        return list;\n      }\n      get all() {\n        var list = new InkList();\n        if (this.origins != null) {\n          for (var origin of this.origins) {\n            for (var [key, value] of origin.items) {\n              var item = InkListItem.fromSerializedKey(key);\n              list.set(item.serialized(), value);\n            }\n          }\n        }\n        return list;\n      }\n      Union(otherList) {\n        var union = new InkList(this);\n        for (var [key, value] of otherList) {\n          union.set(key, value);\n        }\n        return union;\n      }\n      Intersect(otherList) {\n        var intersection = new InkList();\n        for (var [key, value] of this) {\n          if (otherList.has(key)) intersection.set(key, value);\n        }\n        return intersection;\n      }\n      HasIntersection(otherList) {\n        for (var [key] of this) {\n          if (otherList.has(key)) return true;\n        }\n        return false;\n      }\n      Without(listToRemove) {\n        var result = new InkList(this);\n        for (var [key] of listToRemove) {\n          result.delete(key);\n        }\n        return result;\n      }\n      Contains(what) {\n        if (typeof what == \"string\") return this.ContainsItemNamed(what);\n        var otherList = what;\n        if (otherList.size == 0 || this.size == 0) return false;\n        for (var [key] of otherList) {\n          if (!this.has(key)) return false;\n        }\n        return true;\n      }\n      GreaterThan(otherList) {\n        if (this.Count == 0) return false;\n        if (otherList.Count == 0) return true;\n        return this.minItem.Value > otherList.maxItem.Value;\n      }\n      GreaterThanOrEquals(otherList) {\n        if (this.Count == 0) return false;\n        if (otherList.Count == 0) return true;\n        return this.minItem.Value >= otherList.minItem.Value && this.maxItem.Value >= otherList.maxItem.Value;\n      }\n      LessThan(otherList) {\n        if (otherList.Count == 0) return false;\n        if (this.Count == 0) return true;\n        return this.maxItem.Value < otherList.minItem.Value;\n      }\n      LessThanOrEquals(otherList) {\n        if (otherList.Count == 0) return false;\n        if (this.Count == 0) return true;\n        return this.maxItem.Value <= otherList.maxItem.Value && this.minItem.Value <= otherList.minItem.Value;\n      }\n      MaxAsList() {\n        if (this.Count > 0) return new InkList(this.maxItem);else return new InkList();\n      }\n      MinAsList() {\n        if (this.Count > 0) return new InkList(this.minItem);else return new InkList();\n      }\n      ListWithSubRange(minBound, maxBound) {\n        if (this.Count == 0) return new InkList();\n        var ordered = this.orderedItems;\n        var minValue = 0;\n        var maxValue = Number.MAX_SAFE_INTEGER;\n        if (Number.isInteger(minBound)) {\n          minValue = minBound;\n        } else {\n          if (minBound instanceof InkList && minBound.Count > 0) minValue = minBound.minItem.Value;\n        }\n        if (Number.isInteger(maxBound)) {\n          maxValue = maxBound;\n        } else {\n          if (maxBound instanceof InkList && maxBound.Count > 0) maxValue = maxBound.maxItem.Value;\n        }\n        var subList = new InkList();\n        subList.SetInitialOriginNames(this.originNames);\n        for (var item of ordered) {\n          if (item.Value >= minValue && item.Value <= maxValue) {\n            subList.Add(item.Key, item.Value);\n          }\n        }\n        return subList;\n      }\n      Equals(otherInkList) {\n        if (otherInkList instanceof InkList === false) return false;\n        if (otherInkList.Count != this.Count) return false;\n        for (var [key] of this) {\n          if (!otherInkList.has(key)) return false;\n        }\n        return true;\n      }\n      // GetHashCode not implemented\n      get orderedItems() {\n        // List<KeyValuePair<InkListItem, int>>\n        var ordered = new Array();\n        for (var [key, value] of this) {\n          var item = InkListItem.fromSerializedKey(key);\n          ordered.push({\n            Key: item,\n            Value: value\n          });\n        }\n        ordered.sort((x, y) => {\n          if (x.Key.originName === null) {\n            return (0, NullException_1.throwNullException)(\"x.Key.originName\");\n          }\n          if (y.Key.originName === null) {\n            return (0, NullException_1.throwNullException)(\"y.Key.originName\");\n          }\n          if (x.Value == y.Value) {\n            return x.Key.originName.localeCompare(y.Key.originName);\n          } else {\n            // TODO: refactor this bit into a numberCompareTo method?\n            if (x.Value < y.Value) return -1;\n            return x.Value > y.Value ? 1 : 0;\n          }\n        });\n        return ordered;\n      }\n      get singleItem() {\n        for (var item of this.orderedItems) {\n          return item.Key;\n        }\n        return null;\n      }\n      toString() {\n        var ordered = this.orderedItems;\n        var sb = new StringBuilder_1.StringBuilder();\n        for (var i = 0; i < ordered.length; i++) {\n          if (i > 0) sb.Append(\", \");\n          var item = ordered[i].Key;\n          if (item.itemName === null) return (0, NullException_1.throwNullException)(\"item.itemName\");\n          sb.Append(item.itemName);\n        }\n        return sb.toString();\n      }\n      // casting a InkList to a Number, for somereason, actually gives a number.\n      // This messes up the type detection when creating a Value from a InkList.\n      // Returning NaN here prevents that.\n      valueOf() {\n        return NaN;\n      }\n    };\n    InkList.InkList = InkList$1;\n    return InkList;\n  }\n\n  var StoryException = {};\n\n  var hasRequiredStoryException;\n  function requireStoryException() {\n    if (hasRequiredStoryException) return StoryException;\n    hasRequiredStoryException = 1;\n    Object.defineProperty(StoryException, \"__esModule\", {\n      value: true\n    });\n    StoryException.StoryException = void 0;\n    let StoryException$1 = class StoryException extends Error {\n      constructor(message) {\n        super(message);\n        this.useEndLineNumber = false;\n        this.message = message;\n        this.name = \"StoryException\";\n      }\n    };\n    StoryException.StoryException = StoryException$1;\n    return StoryException;\n  }\n\n  var TryGetResult = {};\n\n  var hasRequiredTryGetResult;\n  function requireTryGetResult() {\n    if (hasRequiredTryGetResult) return TryGetResult;\n    hasRequiredTryGetResult = 1;\n    Object.defineProperty(TryGetResult, \"__esModule\", {\n      value: true\n    });\n    TryGetResult.tryParseFloat = TryGetResult.tryParseInt = TryGetResult.tryGetValueFromMap = void 0;\n    function tryGetValueFromMap(map, key, /* out */value) {\n      if (map === null) {\n        return {\n          result: value,\n          exists: false\n        };\n      }\n      var val = map.get(key);\n      if (typeof val === \"undefined\") {\n        return {\n          result: value,\n          exists: false\n        };\n      } else {\n        return {\n          result: val,\n          exists: true\n        };\n      }\n    }\n    TryGetResult.tryGetValueFromMap = tryGetValueFromMap;\n    function tryParseInt(value) {\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var val = parseInt(value);\n      if (!Number.isNaN(val)) {\n        return {\n          result: val,\n          exists: true\n        };\n      } else {\n        return {\n          result: defaultValue,\n          exists: false\n        };\n      }\n    }\n    TryGetResult.tryParseInt = tryParseInt;\n    function tryParseFloat(value) {\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var val = parseFloat(value);\n      if (!Number.isNaN(val)) {\n        return {\n          result: val,\n          exists: true\n        };\n      } else {\n        return {\n          result: defaultValue,\n          exists: false\n        };\n      }\n    }\n    TryGetResult.tryParseFloat = tryParseFloat;\n    return TryGetResult;\n  }\n\n  var hasRequiredValue;\n  function requireValue() {\n    if (hasRequiredValue) return Value;\n    hasRequiredValue = 1;\n    Object.defineProperty(Value, \"__esModule\", {\n      value: true\n    });\n    Value.ValueType = Value.ListValue = Value.VariablePointerValue = Value.DivertTargetValue = Value.StringValue = Value.FloatValue = Value.IntValue = Value.BoolValue = Value.Value = Value.AbstractValue = void 0;\n    var Object_1 = require_Object$1();\n    var Path_1 = requirePath$1();\n    var InkList_1 = requireInkList();\n    var StoryException_1 = requireStoryException();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var TryGetResult_1 = requireTryGetResult();\n    var NullException_1 = requireNullException();\n    class AbstractValue extends Object_1.InkObject {\n      static Create(val, preferredNumberType) {\n        // This code doesn't exist in upstream and is simply here to enforce\n        // the creation of the proper number value.\n        // If `preferredNumberType` is not provided or if value doesn't match\n        // `preferredNumberType`, this conditional does nothing.\n        if (preferredNumberType) {\n          if (preferredNumberType === ValueType.Int && Number.isInteger(Number(val))) {\n            return new IntValue(Number(val));\n          } else if (preferredNumberType === ValueType.Float && !isNaN(val)) {\n            return new FloatValue(Number(val));\n          }\n        }\n        if (typeof val === \"boolean\") {\n          return new BoolValue(Boolean(val));\n        }\n        // https://github.com/y-lohse/inkjs/issues/425\n        // Changed condition sequence, because Number('') is\n        // parsed to 0, which made setting string to empty\n        // impossible\n        if (typeof val === \"string\") {\n          return new StringValue(String(val));\n        } else if (Number.isInteger(Number(val))) {\n          return new IntValue(Number(val));\n        } else if (!isNaN(val)) {\n          return new FloatValue(Number(val));\n        } else if (val instanceof Path_1.Path) {\n          return new DivertTargetValue((0, TypeAssertion_1.asOrThrows)(val, Path_1.Path));\n        } else if (val instanceof InkList_1.InkList) {\n          return new ListValue((0, TypeAssertion_1.asOrThrows)(val, InkList_1.InkList));\n        }\n        return null;\n      }\n      Copy() {\n        return (0, TypeAssertion_1.asOrThrows)(AbstractValue.Create(this.valueObject), Object_1.InkObject);\n      }\n      BadCastException(targetType) {\n        return new StoryException_1.StoryException(\"Can't cast \" + this.valueObject + \" from \" + this.valueType + \" to \" + targetType);\n      }\n    }\n    Value.AbstractValue = AbstractValue;\n    let Value$1 = class Value extends AbstractValue {\n      constructor(val) {\n        super();\n        this.value = val;\n      }\n      get valueObject() {\n        return this.value;\n      }\n      toString() {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        return this.value.toString();\n      }\n    };\n    Value.Value = Value$1;\n    class BoolValue extends Value$1 {\n      constructor(val) {\n        super(val || false);\n      }\n      get isTruthy() {\n        return Boolean(this.value);\n      }\n      get valueType() {\n        return ValueType.Bool;\n      }\n      Cast(newType) {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        if (newType == this.valueType) {\n          return this;\n        }\n        if (newType == ValueType.Int) {\n          return new IntValue(this.value ? 1 : 0);\n        }\n        if (newType == ValueType.Float) {\n          return new FloatValue(this.value ? 1.0 : 0.0);\n        }\n        if (newType == ValueType.String) {\n          return new StringValue(this.value ? \"true\" : \"false\");\n        }\n        throw this.BadCastException(newType);\n      }\n      toString() {\n        return this.value ? \"true\" : \"false\";\n      }\n    }\n    Value.BoolValue = BoolValue;\n    class IntValue extends Value$1 {\n      constructor(val) {\n        super(val || 0);\n      }\n      get isTruthy() {\n        return this.value != 0;\n      }\n      get valueType() {\n        return ValueType.Int;\n      }\n      Cast(newType) {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        if (newType == this.valueType) {\n          return this;\n        }\n        if (newType == ValueType.Bool) {\n          return new BoolValue(this.value === 0 ? false : true);\n        }\n        if (newType == ValueType.Float) {\n          return new FloatValue(this.value);\n        }\n        if (newType == ValueType.String) {\n          return new StringValue(\"\" + this.value);\n        }\n        throw this.BadCastException(newType);\n      }\n    }\n    Value.IntValue = IntValue;\n    class FloatValue extends Value$1 {\n      constructor(val) {\n        super(val || 0.0);\n      }\n      get isTruthy() {\n        return this.value != 0.0;\n      }\n      get valueType() {\n        return ValueType.Float;\n      }\n      Cast(newType) {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        if (newType == this.valueType) {\n          return this;\n        }\n        if (newType == ValueType.Bool) {\n          return new BoolValue(this.value === 0.0 ? false : true);\n        }\n        if (newType == ValueType.Int) {\n          return new IntValue(this.value);\n        }\n        if (newType == ValueType.String) {\n          return new StringValue(\"\" + this.value);\n        }\n        throw this.BadCastException(newType);\n      }\n    }\n    Value.FloatValue = FloatValue;\n    class StringValue extends Value$1 {\n      constructor(val) {\n        super(val || \"\");\n        this._isNewline = this.value == \"\\n\";\n        this._isInlineWhitespace = true;\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        if (this.value.length > 0) {\n          this.value.split(\"\").every(c => {\n            if (c != \" \" && c != \"\\t\") {\n              this._isInlineWhitespace = false;\n              return false;\n            }\n            return true;\n          });\n        }\n      }\n      get valueType() {\n        return ValueType.String;\n      }\n      get isTruthy() {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        return this.value.length > 0;\n      }\n      get isNewline() {\n        return this._isNewline;\n      }\n      get isInlineWhitespace() {\n        return this._isInlineWhitespace;\n      }\n      get isNonWhitespace() {\n        return !this.isNewline && !this.isInlineWhitespace;\n      }\n      Cast(newType) {\n        if (newType == this.valueType) {\n          return this;\n        }\n        if (newType == ValueType.Int) {\n          var parsedInt = (0, TryGetResult_1.tryParseInt)(this.value);\n          if (parsedInt.exists) {\n            return new IntValue(parsedInt.result);\n          } else {\n            throw this.BadCastException(newType);\n          }\n        }\n        if (newType == ValueType.Float) {\n          var parsedFloat = (0, TryGetResult_1.tryParseFloat)(this.value);\n          if (parsedFloat.exists) {\n            return new FloatValue(parsedFloat.result);\n          } else {\n            throw this.BadCastException(newType);\n          }\n        }\n        throw this.BadCastException(newType);\n      }\n    }\n    Value.StringValue = StringValue;\n    class DivertTargetValue extends Value$1 {\n      constructor() {\n        var targetPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        super(targetPath);\n      }\n      get valueType() {\n        return ValueType.DivertTarget;\n      }\n      get targetPath() {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        return this.value;\n      }\n      set targetPath(value) {\n        this.value = value;\n      }\n      get isTruthy() {\n        throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n      }\n      Cast(newType) {\n        if (newType == this.valueType) return this;\n        throw this.BadCastException(newType);\n      }\n      toString() {\n        return \"DivertTargetValue(\" + this.targetPath + \")\";\n      }\n    }\n    Value.DivertTargetValue = DivertTargetValue;\n    class VariablePointerValue extends Value$1 {\n      constructor(variableName) {\n        var contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        super(variableName);\n        this._contextIndex = contextIndex;\n      }\n      get contextIndex() {\n        return this._contextIndex;\n      }\n      set contextIndex(value) {\n        this._contextIndex = value;\n      }\n      get variableName() {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        return this.value;\n      }\n      set variableName(value) {\n        this.value = value;\n      }\n      get valueType() {\n        return ValueType.VariablePointer;\n      }\n      get isTruthy() {\n        throw new Error(\"Shouldn't be checking the truthiness of a variable pointer\");\n      }\n      Cast(newType) {\n        if (newType == this.valueType) return this;\n        throw this.BadCastException(newType);\n      }\n      toString() {\n        return \"VariablePointerValue(\" + this.variableName + \")\";\n      }\n      Copy() {\n        return new VariablePointerValue(this.variableName, this.contextIndex);\n      }\n    }\n    Value.VariablePointerValue = VariablePointerValue;\n    class ListValue extends Value$1 {\n      get isTruthy() {\n        if (this.value === null) {\n          return (0, NullException_1.throwNullException)(\"this.value\");\n        }\n        return this.value.Count > 0;\n      }\n      get valueType() {\n        return ValueType.List;\n      }\n      Cast(newType) {\n        if (this.value === null) return (0, NullException_1.throwNullException)(\"Value.value\");\n        if (newType == ValueType.Int) {\n          var max = this.value.maxItem;\n          if (max.Key.isNull) return new IntValue(0);else return new IntValue(max.Value);\n        } else if (newType == ValueType.Float) {\n          var _max = this.value.maxItem;\n          if (_max.Key.isNull) return new FloatValue(0.0);else return new FloatValue(_max.Value);\n        } else if (newType == ValueType.String) {\n          var _max2 = this.value.maxItem;\n          if (_max2.Key.isNull) return new StringValue(\"\");else {\n            return new StringValue(_max2.Key.toString());\n          }\n        }\n        if (newType == this.valueType) return this;\n        throw this.BadCastException(newType);\n      }\n      constructor(listOrSingleItem, singleValue) {\n        super(null);\n        if (!listOrSingleItem && !singleValue) {\n          this.value = new InkList_1.InkList();\n        } else if (listOrSingleItem instanceof InkList_1.InkList) {\n          this.value = new InkList_1.InkList(listOrSingleItem);\n        } else if (listOrSingleItem instanceof InkList_1.InkListItem && typeof singleValue === \"number\") {\n          this.value = new InkList_1.InkList({\n            Key: listOrSingleItem,\n            Value: singleValue\n          });\n        }\n      }\n      static RetainListOriginsForAssignment(oldValue, newValue) {\n        var oldList = (0, TypeAssertion_1.asOrNull)(oldValue, ListValue);\n        var newList = (0, TypeAssertion_1.asOrNull)(newValue, ListValue);\n        if (newList && newList.value === null) return (0, NullException_1.throwNullException)(\"newList.value\");\n        if (oldList && oldList.value === null) return (0, NullException_1.throwNullException)(\"oldList.value\");\n        // When assigning the empty list, try to retain any initial origin names\n        if (oldList && newList && newList.value.Count == 0) newList.value.SetInitialOriginNames(oldList.value.originNames);\n      }\n    }\n    Value.ListValue = ListValue;\n    var ValueType;\n    (function (ValueType) {\n      ValueType[ValueType[\"Bool\"] = -1] = \"Bool\";\n      ValueType[ValueType[\"Int\"] = 0] = \"Int\";\n      ValueType[ValueType[\"Float\"] = 1] = \"Float\";\n      ValueType[ValueType[\"List\"] = 2] = \"List\";\n      ValueType[ValueType[\"String\"] = 3] = \"String\";\n      ValueType[ValueType[\"DivertTarget\"] = 4] = \"DivertTarget\";\n      ValueType[ValueType[\"VariablePointer\"] = 5] = \"VariablePointer\";\n    })(ValueType || (Value.ValueType = ValueType = {}));\n    return Value;\n  }\n\n  var SearchResult = {};\n\n  var hasRequiredSearchResult;\n  function requireSearchResult() {\n    if (hasRequiredSearchResult) return SearchResult;\n    hasRequiredSearchResult = 1;\n    Object.defineProperty(SearchResult, \"__esModule\", {\n      value: true\n    });\n    SearchResult.SearchResult = void 0;\n    var Container_1 = requireContainer();\n    let SearchResult$1 = class SearchResult {\n      constructor() {\n        this.obj = null;\n        this.approximate = false;\n      }\n      get correctObj() {\n        return this.approximate ? null : this.obj;\n      }\n      get container() {\n        return this.obj instanceof Container_1.Container ? this.obj : null;\n      }\n      copy() {\n        var searchResult = new SearchResult();\n        searchResult.obj = this.obj;\n        searchResult.approximate = this.approximate;\n        return searchResult;\n      }\n    };\n    SearchResult.SearchResult = SearchResult$1;\n    return SearchResult;\n  }\n\n  var hasRequiredContainer;\n  function requireContainer() {\n    if (hasRequiredContainer) return Container;\n    hasRequiredContainer = 1;\n    Object.defineProperty(Container, \"__esModule\", {\n      value: true\n    });\n    Container.Container = void 0;\n    var Value_1 = requireValue();\n    var NullException_1 = requireNullException();\n    var StringBuilder_1 = requireStringBuilder();\n    var Object_1 = require_Object$1();\n    var SearchResult_1 = requireSearchResult();\n    var Path_1 = requirePath$1();\n    var Debug_1 = requireDebug();\n    var TryGetResult_1 = requireTryGetResult();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let Container$1 = class Container extends Object_1.InkObject {\n      constructor() {\n        super(...arguments);\n        this.name = null;\n        this._content = [];\n        this.namedContent = new Map();\n        this.visitsShouldBeCounted = false;\n        this.turnIndexShouldBeCounted = false;\n        this.countingAtStartOnly = false;\n        this._pathToFirstLeafContent = null;\n      }\n      get hasValidName() {\n        return this.name != null && this.name.length > 0;\n      }\n      get content() {\n        return this._content;\n      }\n      set content(value) {\n        this.AddContent(value);\n      }\n      get namedOnlyContent() {\n        var namedOnlyContentDict = new Map();\n        for (var [key, value] of this.namedContent) {\n          var inkObject = (0, TypeAssertion_1.asOrThrows)(value, Object_1.InkObject);\n          namedOnlyContentDict.set(key, inkObject);\n        }\n        for (var c of this.content) {\n          var named = (0, TypeAssertion_1.asINamedContentOrNull)(c);\n          if (named != null && named.hasValidName) {\n            namedOnlyContentDict.delete(named.name);\n          }\n        }\n        if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n        return namedOnlyContentDict;\n      }\n      set namedOnlyContent(value) {\n        var existingNamedOnly = this.namedOnlyContent;\n        if (existingNamedOnly != null) {\n          for (var [key] of existingNamedOnly) {\n            this.namedContent.delete(key);\n          }\n        }\n        if (value == null) return;\n        for (var [, val] of value) {\n          var named = (0, TypeAssertion_1.asINamedContentOrNull)(val);\n          if (named != null) this.AddToNamedContentOnly(named);\n        }\n      }\n      get countFlags() {\n        var flags = 0;\n        if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n        if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n        if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n        if (flags == Container.CountFlags.CountStartOnly) {\n          flags = 0;\n        }\n        return flags;\n      }\n      set countFlags(value) {\n        var flag = value;\n        if ((flag & Container.CountFlags.Visits) > 0) this.visitsShouldBeCounted = true;\n        if ((flag & Container.CountFlags.Turns) > 0) this.turnIndexShouldBeCounted = true;\n        if ((flag & Container.CountFlags.CountStartOnly) > 0) this.countingAtStartOnly = true;\n      }\n      get pathToFirstLeafContent() {\n        if (this._pathToFirstLeafContent == null) this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);\n        return this._pathToFirstLeafContent;\n      }\n      get internalPathToFirstLeafContent() {\n        var components = [];\n        var container = this;\n        while (container instanceof Container) {\n          if (container.content.length > 0) {\n            components.push(new Path_1.Path.Component(0));\n            container = container.content[0];\n          }\n        }\n        return new Path_1.Path(components);\n      }\n      AddContent(contentObjOrList) {\n        if (contentObjOrList instanceof Array) {\n          var contentList = contentObjOrList;\n          for (var c of contentList) {\n            this.AddContent(c);\n          }\n        } else {\n          var contentObj = contentObjOrList;\n          this._content.push(contentObj);\n          if (contentObj.parent) {\n            throw new Error(\"content is already in \" + contentObj.parent);\n          }\n          contentObj.parent = this;\n          this.TryAddNamedContent(contentObj);\n        }\n      }\n      TryAddNamedContent(contentObj) {\n        var namedContentObj = (0, TypeAssertion_1.asINamedContentOrNull)(contentObj);\n        if (namedContentObj != null && namedContentObj.hasValidName) {\n          this.AddToNamedContentOnly(namedContentObj);\n        }\n      }\n      AddToNamedContentOnly(namedContentObj) {\n        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, \"Can only add Runtime.Objects to a Runtime.Container\");\n        var runtimeObj = (0, TypeAssertion_1.asOrThrows)(namedContentObj, Object_1.InkObject);\n        runtimeObj.parent = this;\n        if (namedContentObj.name === null) return (0, NullException_1.throwNullException)(\"namedContentObj.name\");\n        this.namedContent.set(namedContentObj.name, namedContentObj);\n      }\n      ContentAtPath(path) {\n        var partialPathStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var partialPathLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n        if (partialPathLength == -1) partialPathLength = path.length;\n        var result = new SearchResult_1.SearchResult();\n        result.approximate = false;\n        var currentContainer = this;\n        var currentObj = this;\n        for (var i = partialPathStart; i < partialPathLength; ++i) {\n          var comp = path.GetComponent(i);\n          if (currentContainer == null) {\n            result.approximate = true;\n            break;\n          }\n          var foundObj = currentContainer.ContentWithPathComponent(comp);\n          // Couldn't resolve entire path?\n          if (foundObj == null) {\n            result.approximate = true;\n            break;\n          }\n          // Are we about to loop into another container?\n          // Is the object a container as expected? It might\n          // no longer be if the content has shuffled around, so what\n          // was originally a container no longer is.\n          var nextContainer = (0, TypeAssertion_1.asOrNull)(foundObj, Container);\n          if (i < partialPathLength - 1 && nextContainer == null) {\n            result.approximate = true;\n            break;\n          }\n          currentObj = foundObj;\n          currentContainer = nextContainer;\n        }\n        result.obj = currentObj;\n        return result;\n      }\n      InsertContent(contentObj, index) {\n        this.content.splice(index, 0, contentObj);\n        if (contentObj.parent) {\n          throw new Error(\"content is already in \" + contentObj.parent);\n        }\n        contentObj.parent = this;\n        this.TryAddNamedContent(contentObj);\n      }\n      AddContentsOfContainer(otherContainer) {\n        this.content.push(...otherContainer.content);\n        for (var obj of otherContainer.content) {\n          obj.parent = this;\n          this.TryAddNamedContent(obj);\n        }\n      }\n      ContentWithPathComponent(component) {\n        if (component.isIndex) {\n          if (component.index >= 0 && component.index < this.content.length) {\n            return this.content[component.index];\n          } else {\n            return null;\n          }\n        } else if (component.isParent) {\n          return this.parent;\n        } else {\n          if (component.name === null) {\n            return (0, NullException_1.throwNullException)(\"component.name\");\n          }\n          var foundContent = (0, TryGetResult_1.tryGetValueFromMap)(this.namedContent, component.name, null);\n          if (foundContent.exists) {\n            return (0, TypeAssertion_1.asOrThrows)(foundContent.result, Object_1.InkObject);\n          } else {\n            return null;\n          }\n        }\n      }\n      BuildStringOfHierarchy() {\n        var sb;\n        if (arguments.length == 0) {\n          sb = new StringBuilder_1.StringBuilder();\n          this.BuildStringOfHierarchy(sb, 0, null);\n          return sb.toString();\n        }\n        sb = arguments[0];\n        var indentation = arguments[1];\n        var pointedObj = arguments[2];\n        function appendIndentation() {\n          var spacesPerIndent = 4; // Truly const in the original code\n          for (var i = 0; i < spacesPerIndent * indentation; ++i) {\n            sb.Append(\" \");\n          }\n        }\n        appendIndentation();\n        sb.Append(\"[\");\n        if (this.hasValidName) {\n          sb.AppendFormat(\" ({0})\", this.name);\n        }\n        if (this == pointedObj) {\n          sb.Append(\"  <---\");\n        }\n        sb.AppendLine();\n        indentation++;\n        for (var i = 0; i < this.content.length; ++i) {\n          var obj = this.content[i];\n          if (obj instanceof Container) {\n            var container = obj;\n            container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n          } else {\n            appendIndentation();\n            if (obj instanceof Value_1.StringValue) {\n              sb.Append('\"');\n              sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n              sb.Append('\"');\n            } else {\n              sb.Append(obj.toString());\n            }\n          }\n          if (i != this.content.length - 1) {\n            sb.Append(\",\");\n          }\n          if (!(obj instanceof Container) && obj == pointedObj) {\n            sb.Append(\"  <---\");\n          }\n          sb.AppendLine();\n        }\n        var onlyNamed = new Map();\n        for (var [key, value] of this.namedContent) {\n          if (this.content.indexOf((0, TypeAssertion_1.asOrThrows)(value, Object_1.InkObject)) >= 0) {\n            continue;\n          } else {\n            onlyNamed.set(key, value);\n          }\n        }\n        if (onlyNamed.size > 0) {\n          appendIndentation();\n          sb.AppendLine(\"-- named: --\");\n          for (var [, _value] of onlyNamed) {\n            Debug_1.Debug.AssertType(_value, Container, \"Can only print out named Containers\");\n            var _container = _value;\n            _container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n            sb.AppendLine();\n          }\n        }\n        indentation--;\n        appendIndentation();\n        sb.Append(\"]\");\n      }\n    };\n    Container.Container = Container$1;\n    (function (Container) {\n      (function (CountFlags) {\n        CountFlags[CountFlags[\"Start\"] = 0] = \"Start\";\n        CountFlags[CountFlags[\"Visits\"] = 1] = \"Visits\";\n        CountFlags[CountFlags[\"Turns\"] = 2] = \"Turns\";\n        CountFlags[CountFlags[\"CountStartOnly\"] = 4] = \"CountStartOnly\";\n      })(Container.CountFlags || (Container.CountFlags = {}));\n    })(Container$1 || (Container.Container = Container$1 = {}));\n    return Container;\n  }\n\n  var JsonSerialisation = {};\n\n  var Glue$1 = {};\n\n  var hasRequiredGlue$1;\n  function requireGlue$1() {\n    if (hasRequiredGlue$1) return Glue$1;\n    hasRequiredGlue$1 = 1;\n    Object.defineProperty(Glue$1, \"__esModule\", {\n      value: true\n    });\n    Glue$1.Glue = void 0;\n    var Object_1 = require_Object$1();\n    class Glue extends Object_1.InkObject {\n      toString() {\n        return \"Glue\";\n      }\n    }\n    Glue$1.Glue = Glue;\n    return Glue$1;\n  }\n\n  var ControlCommand = {};\n\n  var hasRequiredControlCommand;\n  function requireControlCommand() {\n    if (hasRequiredControlCommand) return ControlCommand;\n    hasRequiredControlCommand = 1;\n    Object.defineProperty(ControlCommand, \"__esModule\", {\n      value: true\n    });\n    ControlCommand.ControlCommand = void 0;\n    var Object_1 = require_Object$1();\n    let ControlCommand$1 = class ControlCommand extends Object_1.InkObject {\n      get commandType() {\n        return this._commandType;\n      }\n      constructor() {\n        var commandType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ControlCommand.CommandType.NotSet;\n        super();\n        this._commandType = commandType;\n      }\n      Copy() {\n        return new ControlCommand(this.commandType);\n      }\n      static EvalStart() {\n        return new ControlCommand(ControlCommand.CommandType.EvalStart);\n      }\n      static EvalOutput() {\n        return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n      }\n      static EvalEnd() {\n        return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n      }\n      static Duplicate() {\n        return new ControlCommand(ControlCommand.CommandType.Duplicate);\n      }\n      static PopEvaluatedValue() {\n        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n      }\n      static PopFunction() {\n        return new ControlCommand(ControlCommand.CommandType.PopFunction);\n      }\n      static PopTunnel() {\n        return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n      }\n      static BeginString() {\n        return new ControlCommand(ControlCommand.CommandType.BeginString);\n      }\n      static EndString() {\n        return new ControlCommand(ControlCommand.CommandType.EndString);\n      }\n      static NoOp() {\n        return new ControlCommand(ControlCommand.CommandType.NoOp);\n      }\n      static ChoiceCount() {\n        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n      }\n      static Turns() {\n        return new ControlCommand(ControlCommand.CommandType.Turns);\n      }\n      static TurnsSince() {\n        return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n      }\n      static ReadCount() {\n        return new ControlCommand(ControlCommand.CommandType.ReadCount);\n      }\n      static Random() {\n        return new ControlCommand(ControlCommand.CommandType.Random);\n      }\n      static SeedRandom() {\n        return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n      }\n      static VisitIndex() {\n        return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n      }\n      static SequenceShuffleIndex() {\n        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n      }\n      static StartThread() {\n        return new ControlCommand(ControlCommand.CommandType.StartThread);\n      }\n      static Done() {\n        return new ControlCommand(ControlCommand.CommandType.Done);\n      }\n      static End() {\n        return new ControlCommand(ControlCommand.CommandType.End);\n      }\n      static ListFromInt() {\n        return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n      }\n      static ListRange() {\n        return new ControlCommand(ControlCommand.CommandType.ListRange);\n      }\n      static ListRandom() {\n        return new ControlCommand(ControlCommand.CommandType.ListRandom);\n      }\n      static BeginTag() {\n        return new ControlCommand(ControlCommand.CommandType.BeginTag);\n      }\n      static EndTag() {\n        return new ControlCommand(ControlCommand.CommandType.EndTag);\n      }\n      toString() {\n        return \"ControlCommand \" + this.commandType.toString();\n      }\n    };\n    ControlCommand.ControlCommand = ControlCommand$1;\n    (function (ControlCommand) {\n      (function (CommandType) {\n        CommandType[CommandType[\"NotSet\"] = -1] = \"NotSet\";\n        CommandType[CommandType[\"EvalStart\"] = 0] = \"EvalStart\";\n        CommandType[CommandType[\"EvalOutput\"] = 1] = \"EvalOutput\";\n        CommandType[CommandType[\"EvalEnd\"] = 2] = \"EvalEnd\";\n        CommandType[CommandType[\"Duplicate\"] = 3] = \"Duplicate\";\n        CommandType[CommandType[\"PopEvaluatedValue\"] = 4] = \"PopEvaluatedValue\";\n        CommandType[CommandType[\"PopFunction\"] = 5] = \"PopFunction\";\n        CommandType[CommandType[\"PopTunnel\"] = 6] = \"PopTunnel\";\n        CommandType[CommandType[\"BeginString\"] = 7] = \"BeginString\";\n        CommandType[CommandType[\"EndString\"] = 8] = \"EndString\";\n        CommandType[CommandType[\"NoOp\"] = 9] = \"NoOp\";\n        CommandType[CommandType[\"ChoiceCount\"] = 10] = \"ChoiceCount\";\n        CommandType[CommandType[\"Turns\"] = 11] = \"Turns\";\n        CommandType[CommandType[\"TurnsSince\"] = 12] = \"TurnsSince\";\n        CommandType[CommandType[\"ReadCount\"] = 13] = \"ReadCount\";\n        CommandType[CommandType[\"Random\"] = 14] = \"Random\";\n        CommandType[CommandType[\"SeedRandom\"] = 15] = \"SeedRandom\";\n        CommandType[CommandType[\"VisitIndex\"] = 16] = \"VisitIndex\";\n        CommandType[CommandType[\"SequenceShuffleIndex\"] = 17] = \"SequenceShuffleIndex\";\n        CommandType[CommandType[\"StartThread\"] = 18] = \"StartThread\";\n        CommandType[CommandType[\"Done\"] = 19] = \"Done\";\n        CommandType[CommandType[\"End\"] = 20] = \"End\";\n        CommandType[CommandType[\"ListFromInt\"] = 21] = \"ListFromInt\";\n        CommandType[CommandType[\"ListRange\"] = 22] = \"ListRange\";\n        CommandType[CommandType[\"ListRandom\"] = 23] = \"ListRandom\";\n        CommandType[CommandType[\"BeginTag\"] = 24] = \"BeginTag\";\n        CommandType[CommandType[\"EndTag\"] = 25] = \"EndTag\";\n        CommandType[CommandType[\"TOTAL_VALUES\"] = 26] = \"TOTAL_VALUES\";\n      })(ControlCommand.CommandType || (ControlCommand.CommandType = {}));\n    })(ControlCommand$1 || (ControlCommand.ControlCommand = ControlCommand$1 = {}));\n    return ControlCommand;\n  }\n\n  var PushPop = {};\n\n  var hasRequiredPushPop;\n  function requirePushPop() {\n    if (hasRequiredPushPop) return PushPop;\n    hasRequiredPushPop = 1;\n    Object.defineProperty(PushPop, \"__esModule\", {\n      value: true\n    });\n    PushPop.PushPopType = void 0;\n    var PushPopType;\n    (function (PushPopType) {\n      PushPopType[PushPopType[\"Tunnel\"] = 0] = \"Tunnel\";\n      PushPopType[PushPopType[\"Function\"] = 1] = \"Function\";\n      PushPopType[PushPopType[\"FunctionEvaluationFromGame\"] = 2] = \"FunctionEvaluationFromGame\";\n    })(PushPopType || (PushPop.PushPopType = PushPopType = {}));\n    return PushPop;\n  }\n\n  var Divert$1 = {};\n\n  var Pointer = {};\n\n  var hasRequiredPointer;\n  function requirePointer() {\n    if (hasRequiredPointer) return Pointer;\n    hasRequiredPointer = 1;\n    Object.defineProperty(Pointer, \"__esModule\", {\n      value: true\n    });\n    Pointer.Pointer = void 0;\n    var Path_1 = requirePath$1();\n    let Pointer$1 = class Pointer {\n      constructor() {\n        this.container = null;\n        this.index = -1;\n        if (arguments.length === 2) {\n          this.container = arguments[0];\n          this.index = arguments[1];\n        }\n      }\n      Resolve() {\n        if (this.index < 0) return this.container;\n        if (this.container == null) return null;\n        if (this.container.content.length == 0) return this.container;\n        if (this.index >= this.container.content.length) return null;\n        return this.container.content[this.index];\n      }\n      get isNull() {\n        return this.container == null;\n      }\n      get path() {\n        if (this.isNull) return null;\n        if (this.index >= 0) return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));else return this.container.path;\n      }\n      toString() {\n        if (!this.container) return \"Ink Pointer (null)\";\n        return \"Ink Pointer -> \" + this.container.path.toString() + \" -- index \" + this.index;\n      }\n      // This method does not exist in the original C# code, but is here to maintain the\n      // value semantics of Pointer.\n      copy() {\n        return new Pointer(this.container, this.index);\n      }\n      static StartOf(container) {\n        return new Pointer(container, 0);\n      }\n      static get Null() {\n        return new Pointer(null, -1);\n      }\n    };\n    Pointer.Pointer = Pointer$1;\n    return Pointer;\n  }\n\n  var hasRequiredDivert$1;\n  function requireDivert$1() {\n    if (hasRequiredDivert$1) return Divert$1;\n    hasRequiredDivert$1 = 1;\n    Object.defineProperty(Divert$1, \"__esModule\", {\n      value: true\n    });\n    Divert$1.Divert = void 0;\n    var Path_1 = requirePath$1();\n    var PushPop_1 = requirePushPop();\n    var StringBuilder_1 = requireStringBuilder();\n    var Object_1 = require_Object$1();\n    var Pointer_1 = requirePointer();\n    var Container_1 = requireContainer();\n    var NullException_1 = requireNullException();\n    class Divert extends Object_1.InkObject {\n      get targetPath() {\n        if (this._targetPath != null && this._targetPath.isRelative) {\n          var targetObj = this.targetPointer.Resolve();\n          if (targetObj) {\n            this._targetPath = targetObj.path;\n          }\n        }\n        return this._targetPath;\n      }\n      set targetPath(value) {\n        this._targetPath = value;\n        this._targetPointer = Pointer_1.Pointer.Null;\n      }\n      get targetPointer() {\n        if (this._targetPointer.isNull) {\n          var targetObj = this.ResolvePath(this._targetPath).obj;\n          if (this._targetPath === null) return (0, NullException_1.throwNullException)(\"this._targetPath\");\n          if (this._targetPath.lastComponent === null) return (0, NullException_1.throwNullException)(\"this._targetPath.lastComponent\");\n          if (this._targetPath.lastComponent.isIndex) {\n            if (targetObj === null) return (0, NullException_1.throwNullException)(\"targetObj\");\n            this._targetPointer.container = targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;\n            this._targetPointer.index = this._targetPath.lastComponent.index;\n          } else {\n            this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);\n          }\n        }\n        return this._targetPointer.copy();\n      }\n      get targetPathString() {\n        if (this.targetPath == null) return null;\n        return this.CompactPathString(this.targetPath);\n      }\n      set targetPathString(value) {\n        if (value == null) {\n          this.targetPath = null;\n        } else {\n          this.targetPath = new Path_1.Path(value);\n        }\n      }\n      get hasVariableTarget() {\n        return this.variableDivertName != null;\n      }\n      constructor(stackPushType) {\n        super();\n        this._targetPath = null;\n        this._targetPointer = Pointer_1.Pointer.Null;\n        this.variableDivertName = null;\n        this.pushesToStack = false;\n        this.stackPushType = 0;\n        this.isExternal = false;\n        this.externalArgs = 0;\n        this.isConditional = false;\n        this.pushesToStack = false;\n        if (typeof stackPushType !== \"undefined\") {\n          this.pushesToStack = true;\n          this.stackPushType = stackPushType;\n        }\n      }\n      Equals(obj) {\n        var otherDivert = obj;\n        if (otherDivert instanceof Divert) {\n          if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n            if (this.hasVariableTarget) {\n              return this.variableDivertName == otherDivert.variableDivertName;\n            } else {\n              if (this.targetPath === null) return (0, NullException_1.throwNullException)(\"this.targetPath\");\n              return this.targetPath.Equals(otherDivert.targetPath);\n            }\n          }\n        }\n        return false;\n      }\n      toString() {\n        if (this.hasVariableTarget) {\n          return \"Divert(variable: \" + this.variableDivertName + \")\";\n        } else if (this.targetPath == null) {\n          return \"Divert(null)\";\n        } else {\n          var sb = new StringBuilder_1.StringBuilder();\n          var targetStr = this.targetPath.toString();\n          // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n          var targetLineNum = null;\n          if (targetLineNum != null) {\n            targetStr = \"line \" + targetLineNum;\n          }\n          sb.Append(\"Divert\");\n          if (this.isConditional) sb.Append(\"?\");\n          if (this.pushesToStack) {\n            if (this.stackPushType == PushPop_1.PushPopType.Function) {\n              sb.Append(\" function\");\n            } else {\n              sb.Append(\" tunnel\");\n            }\n          }\n          sb.Append(\" -> \");\n          sb.Append(this.targetPathString);\n          sb.Append(\" (\");\n          sb.Append(targetStr);\n          sb.Append(\")\");\n          return sb.toString();\n        }\n      }\n    }\n    Divert$1.Divert = Divert;\n    return Divert$1;\n  }\n\n  var ChoicePoint = {};\n\n  var hasRequiredChoicePoint;\n  function requireChoicePoint() {\n    if (hasRequiredChoicePoint) return ChoicePoint;\n    hasRequiredChoicePoint = 1;\n    Object.defineProperty(ChoicePoint, \"__esModule\", {\n      value: true\n    });\n    ChoicePoint.ChoicePoint = void 0;\n    var Object_1 = require_Object$1();\n    var Path_1 = requirePath$1();\n    var NullException_1 = requireNullException();\n    let ChoicePoint$1 = class ChoicePoint extends Object_1.InkObject {\n      constructor() {\n        var onceOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        super();\n        this._pathOnChoice = null;\n        this.hasCondition = false;\n        this.hasStartContent = false;\n        this.hasChoiceOnlyContent = false;\n        this.isInvisibleDefault = false;\n        this.onceOnly = true;\n        this.onceOnly = onceOnly;\n      }\n      get pathOnChoice() {\n        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n          var choiceTargetObj = this.choiceTarget;\n          if (choiceTargetObj) {\n            this._pathOnChoice = choiceTargetObj.path;\n          }\n        }\n        return this._pathOnChoice;\n      }\n      set pathOnChoice(value) {\n        this._pathOnChoice = value;\n      }\n      get choiceTarget() {\n        if (this._pathOnChoice === null) return (0, NullException_1.throwNullException)(\"ChoicePoint._pathOnChoice\");\n        return this.ResolvePath(this._pathOnChoice).container;\n      }\n      get pathStringOnChoice() {\n        if (this.pathOnChoice === null) return (0, NullException_1.throwNullException)(\"ChoicePoint.pathOnChoice\");\n        return this.CompactPathString(this.pathOnChoice);\n      }\n      set pathStringOnChoice(value) {\n        this.pathOnChoice = new Path_1.Path(value);\n      }\n      get flags() {\n        var flags = 0;\n        if (this.hasCondition) flags |= 1;\n        if (this.hasStartContent) flags |= 2;\n        if (this.hasChoiceOnlyContent) flags |= 4;\n        if (this.isInvisibleDefault) flags |= 8;\n        if (this.onceOnly) flags |= 16;\n        return flags;\n      }\n      set flags(value) {\n        this.hasCondition = (value & 1) > 0;\n        this.hasStartContent = (value & 2) > 0;\n        this.hasChoiceOnlyContent = (value & 4) > 0;\n        this.isInvisibleDefault = (value & 8) > 0;\n        this.onceOnly = (value & 16) > 0;\n      }\n      toString() {\n        if (this.pathOnChoice === null) return (0, NullException_1.throwNullException)(\"ChoicePoint.pathOnChoice\");\n        var targetString = this.pathOnChoice.toString();\n        return \"Choice: -> \" + targetString;\n      }\n    };\n    ChoicePoint.ChoicePoint = ChoicePoint$1;\n    return ChoicePoint;\n  }\n\n  var VariableReference$1 = {};\n\n  var hasRequiredVariableReference$1;\n  function requireVariableReference$1() {\n    if (hasRequiredVariableReference$1) return VariableReference$1;\n    hasRequiredVariableReference$1 = 1;\n    Object.defineProperty(VariableReference$1, \"__esModule\", {\n      value: true\n    });\n    VariableReference$1.VariableReference = void 0;\n    var Object_1 = require_Object$1();\n    var Path_1 = requirePath$1();\n    class VariableReference extends Object_1.InkObject {\n      get containerForCount() {\n        if (this.pathForCount === null) return null;\n        return this.ResolvePath(this.pathForCount).container;\n      }\n      get pathStringForCount() {\n        if (this.pathForCount === null) return null;\n        return this.CompactPathString(this.pathForCount);\n      }\n      set pathStringForCount(value) {\n        if (value === null) this.pathForCount = null;else this.pathForCount = new Path_1.Path(value);\n      }\n      constructor() {\n        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        super();\n        this.pathForCount = null;\n        this.name = name;\n      }\n      toString() {\n        if (this.name != null) {\n          return \"var(\" + this.name + \")\";\n        } else {\n          var pathStr = this.pathStringForCount;\n          return \"read_count(\" + pathStr + \")\";\n        }\n      }\n    }\n    VariableReference$1.VariableReference = VariableReference;\n    return VariableReference$1;\n  }\n\n  var VariableAssignment$1 = {};\n\n  var hasRequiredVariableAssignment$1;\n  function requireVariableAssignment$1() {\n    if (hasRequiredVariableAssignment$1) return VariableAssignment$1;\n    hasRequiredVariableAssignment$1 = 1;\n    Object.defineProperty(VariableAssignment$1, \"__esModule\", {\n      value: true\n    });\n    VariableAssignment$1.VariableAssignment = void 0;\n    var Object_1 = require_Object$1();\n    class VariableAssignment extends Object_1.InkObject {\n      constructor(variableName, isNewDeclaration) {\n        super();\n        this.variableName = variableName || null;\n        this.isNewDeclaration = !!isNewDeclaration;\n        this.isGlobal = false;\n      }\n      toString() {\n        return \"VarAssign to \" + this.variableName;\n      }\n    }\n    VariableAssignment$1.VariableAssignment = VariableAssignment;\n    return VariableAssignment$1;\n  }\n\n  var NativeFunctionCall = {};\n\n  var Void = {};\n\n  var hasRequiredVoid;\n  function requireVoid() {\n    if (hasRequiredVoid) return Void;\n    hasRequiredVoid = 1;\n    Object.defineProperty(Void, \"__esModule\", {\n      value: true\n    });\n    Void.Void = void 0;\n    var Object_1 = require_Object$1();\n    let Void$1 = class Void extends Object_1.InkObject {\n      toString() {\n        return \"Void\";\n      }\n    };\n    Void.Void = Void$1;\n    return Void;\n  }\n\n  var hasRequiredNativeFunctionCall;\n  function requireNativeFunctionCall() {\n    if (hasRequiredNativeFunctionCall) return NativeFunctionCall;\n    hasRequiredNativeFunctionCall = 1;\n    Object.defineProperty(NativeFunctionCall, \"__esModule\", {\n      value: true\n    });\n    NativeFunctionCall.NativeFunctionCall = void 0;\n    var Value_1 = requireValue();\n    var StoryException_1 = requireStoryException();\n    var Void_1 = requireVoid();\n    var InkList_1 = requireInkList();\n    var Object_1 = require_Object$1();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var NullException_1 = requireNullException();\n    let NativeFunctionCall$1 = class NativeFunctionCall extends Object_1.InkObject {\n      static CallWithName(functionName) {\n        return new NativeFunctionCall(functionName);\n      }\n      static CallExistsWithName(functionName) {\n        this.GenerateNativeFunctionsIfNecessary();\n        return this._nativeFunctions.get(functionName);\n      }\n      get name() {\n        if (this._name === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall._name\");\n        return this._name;\n      }\n      set name(value) {\n        this._name = value;\n        if (!this._isPrototype) {\n          if (NativeFunctionCall._nativeFunctions === null) (0, NullException_1.throwNullException)(\"NativeFunctionCall._nativeFunctions\");else this._prototype = NativeFunctionCall._nativeFunctions.get(this._name) || null;\n        }\n      }\n      get numberOfParameters() {\n        if (this._prototype) {\n          return this._prototype.numberOfParameters;\n        } else {\n          return this._numberOfParameters;\n        }\n      }\n      set numberOfParameters(value) {\n        this._numberOfParameters = value;\n      }\n      Call(parameters) {\n        if (this._prototype) {\n          return this._prototype.Call(parameters);\n        }\n        if (this.numberOfParameters != parameters.length) {\n          throw new Error(\"Unexpected number of parameters\");\n        }\n        var hasList = false;\n        for (var p of parameters) {\n          if (p instanceof Void_1.Void) throw new StoryException_1.StoryException(\"Attempting to perform \" + this.name + ' on a void value. Did you forget to \"return\" a value from a function you called here?');\n          if (p instanceof Value_1.ListValue) hasList = true;\n        }\n        if (parameters.length == 2 && hasList) {\n          return this.CallBinaryListOperation(parameters);\n        }\n        var coercedParams = this.CoerceValuesToSingleType(parameters);\n        var coercedType = coercedParams[0].valueType;\n        if (coercedType == Value_1.ValueType.Int) {\n          return this.CallType(coercedParams);\n        } else if (coercedType == Value_1.ValueType.Float) {\n          return this.CallType(coercedParams);\n        } else if (coercedType == Value_1.ValueType.String) {\n          return this.CallType(coercedParams);\n        } else if (coercedType == Value_1.ValueType.DivertTarget) {\n          return this.CallType(coercedParams);\n        } else if (coercedType == Value_1.ValueType.List) {\n          return this.CallType(coercedParams);\n        }\n        return null;\n      }\n      CallType(parametersOfSingleType) {\n        var param1 = (0, TypeAssertion_1.asOrThrows)(parametersOfSingleType[0], Value_1.Value);\n        var valType = param1.valueType;\n        var val1 = param1;\n        var paramCount = parametersOfSingleType.length;\n        if (paramCount == 2 || paramCount == 1) {\n          if (this._operationFuncs === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall._operationFuncs\");\n          var opForTypeObj = this._operationFuncs.get(valType);\n          if (!opForTypeObj) {\n            var key = Value_1.ValueType[valType];\n            throw new StoryException_1.StoryException(\"Cannot perform operation \" + this.name + \" on \" + key);\n          }\n          if (paramCount == 2) {\n            var param2 = (0, TypeAssertion_1.asOrThrows)(parametersOfSingleType[1], Value_1.Value);\n            var val2 = param2;\n            var opForType = opForTypeObj;\n            if (val1.value === null || val2.value === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.Call BinaryOp values\");\n            var resultVal = opForType(val1.value, val2.value);\n            return Value_1.Value.Create(resultVal);\n          } else {\n            var _opForType = opForTypeObj;\n            if (val1.value === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.Call UnaryOp value\");\n            var _resultVal = _opForType(val1.value);\n            // This code is different from upstream. Since JavaScript treats\n            // integers and floats as the same numbers, it's impossible\n            // to force an number to be either an integer or a float.\n            //\n            // It can be useful to force a specific number type\n            // (especially for divisions), so the result of INT() & FLOAT()\n            // is coerced to the the proper value type.\n            //\n            // Note that we also force all other unary operation to\n            // return the same value type, although this is only\n            // meaningful for numbers. See `Value.Create`.\n            if (this.name === NativeFunctionCall.Int) {\n              return Value_1.Value.Create(_resultVal, Value_1.ValueType.Int);\n            } else if (this.name === NativeFunctionCall.Float) {\n              return Value_1.Value.Create(_resultVal, Value_1.ValueType.Float);\n            } else {\n              return Value_1.Value.Create(_resultVal, param1.valueType);\n            }\n          }\n        } else {\n          throw new Error(\"Unexpected number of parameters to NativeFunctionCall: \" + parametersOfSingleType.length);\n        }\n      }\n      CallBinaryListOperation(parameters) {\n        if ((this.name == \"+\" || this.name == \"-\") && parameters[0] instanceof Value_1.ListValue && parameters[1] instanceof Value_1.IntValue) return this.CallListIncrementOperation(parameters);\n        var v1 = (0, TypeAssertion_1.asOrThrows)(parameters[0], Value_1.Value);\n        var v2 = (0, TypeAssertion_1.asOrThrows)(parameters[1], Value_1.Value);\n        if ((this.name == \"&&\" || this.name == \"||\") && (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {\n          if (this._operationFuncs === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall._operationFuncs\");\n          var op = this._operationFuncs.get(Value_1.ValueType.Int);\n          if (op === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallBinaryListOperation op\");\n          var result = (0, TypeAssertion_1.asBooleanOrThrows)(op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0));\n          return new Value_1.BoolValue(result);\n        }\n        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List) return this.CallType([v1, v2]);\n        throw new StoryException_1.StoryException(\"Can not call use \" + this.name + \" operation on \" + Value_1.ValueType[v1.valueType] + \" and \" + Value_1.ValueType[v2.valueType]);\n      }\n      CallListIncrementOperation(listIntParams) {\n        var listVal = (0, TypeAssertion_1.asOrThrows)(listIntParams[0], Value_1.ListValue);\n        var intVal = (0, TypeAssertion_1.asOrThrows)(listIntParams[1], Value_1.IntValue);\n        var resultInkList = new InkList_1.InkList();\n        if (listVal.value === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallListIncrementOperation listVal.value\");\n        for (var [listItemKey, listItemValue] of listVal.value) {\n          var listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);\n          if (this._operationFuncs === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall._operationFuncs\");\n          var intOp = this._operationFuncs.get(Value_1.ValueType.Int);\n          if (intVal.value === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallListIncrementOperation intVal.value\");\n          var targetInt = intOp(listItemValue, intVal.value);\n          var itemOrigin = null;\n          if (listVal.value.origins === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\");\n          for (var origin of listVal.value.origins) {\n            if (origin.name == listItem.originName) {\n              itemOrigin = origin;\n              break;\n            }\n          }\n          if (itemOrigin != null) {\n            var incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);\n            if (incrementedItem.exists) resultInkList.Add(incrementedItem.result, targetInt);\n          }\n        }\n        return new Value_1.ListValue(resultInkList);\n      }\n      CoerceValuesToSingleType(parametersIn) {\n        var valType = Value_1.ValueType.Int;\n        var specialCaseList = null;\n        for (var obj of parametersIn) {\n          var val = (0, TypeAssertion_1.asOrThrows)(obj, Value_1.Value);\n          if (val.valueType > valType) {\n            valType = val.valueType;\n          }\n          if (val.valueType == Value_1.ValueType.List) {\n            specialCaseList = (0, TypeAssertion_1.asOrNull)(val, Value_1.ListValue);\n          }\n        }\n        var parametersOut = [];\n        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {\n          for (var inkObjectVal of parametersIn) {\n            var _val = (0, TypeAssertion_1.asOrThrows)(inkObjectVal, Value_1.Value);\n            if (_val.valueType == Value_1.ValueType.List) {\n              parametersOut.push(_val);\n            } else if (_val.valueType == Value_1.ValueType.Int) {\n              var intVal = parseInt(_val.valueObject);\n              specialCaseList = (0, TypeAssertion_1.asOrThrows)(specialCaseList, Value_1.ListValue);\n              if (specialCaseList.value === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\");\n              var list = specialCaseList.value.originOfMaxItem;\n              if (list === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall.CoerceValuesToSingleType list\");\n              var item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);\n              if (item.exists) {\n                var castedValue = new Value_1.ListValue(item.result, intVal);\n                parametersOut.push(castedValue);\n              } else throw new StoryException_1.StoryException(\"Could not find List item with the value \" + intVal + \" in \" + list.name);\n            } else {\n              var key = Value_1.ValueType[_val.valueType];\n              throw new StoryException_1.StoryException(\"Cannot mix Lists and \" + key + \" values in this operation\");\n            }\n          }\n        } else {\n          for (var _inkObjectVal of parametersIn) {\n            var _val2 = (0, TypeAssertion_1.asOrThrows)(_inkObjectVal, Value_1.Value);\n            var _castedValue = _val2.Cast(valType);\n            parametersOut.push(_castedValue);\n          }\n        }\n        return parametersOut;\n      }\n      constructor() {\n        super();\n        this._name = null;\n        this._numberOfParameters = 0;\n        this._prototype = null;\n        this._isPrototype = false;\n        this._operationFuncs = null;\n        if (arguments.length === 0) {\n          NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n        } else if (arguments.length === 1) {\n          var name = arguments[0];\n          NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n          this.name = name;\n        } else if (arguments.length === 2) {\n          var _name = arguments[0];\n          var numberOfParameters = arguments[1];\n          this._isPrototype = true;\n          this.name = _name;\n          this.numberOfParameters = numberOfParameters;\n        }\n      }\n      static Identity(t) {\n        return t;\n      }\n      static GenerateNativeFunctionsIfNecessary() {\n        if (this._nativeFunctions == null) {\n          this._nativeFunctions = new Map();\n          // Int operations\n          this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n          this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n          this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n          this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n          this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n          this.AddIntUnaryOp(this.Negate, x => -x);\n          this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n          this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n          this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n          this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n          this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n          this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n          this.AddIntUnaryOp(this.Not, x => x == 0);\n          this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n          this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n          this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n          this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n          this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n          this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n          this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n          this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n          this.AddIntUnaryOp(this.Float, x => x);\n          // Float operations\n          this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n          this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n          this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n          this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n          this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n          this.AddFloatUnaryOp(this.Negate, x => -x);\n          this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n          this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n          this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n          this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n          this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n          this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n          this.AddFloatUnaryOp(this.Not, x => x == 0.0);\n          this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n          this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n          this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n          this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n          this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n          this.AddFloatUnaryOp(this.Floor, x => Math.floor(x));\n          this.AddFloatUnaryOp(this.Ceiling, x => Math.ceil(x));\n          this.AddFloatUnaryOp(this.Int, x => Math.floor(x));\n          this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n          // String operations\n          this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n          this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n          this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n          this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n          this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n          this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n          this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n          this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n          this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n          this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n          this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n          this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n          this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n          this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y));\n          this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y));\n          this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n          this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n          this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n          this.AddListUnaryOp(this.Not, x => x.Count == 0 ? 1 : 0);\n          this.AddListUnaryOp(this.Invert, x => x.inverse);\n          this.AddListUnaryOp(this.All, x => x.all);\n          this.AddListUnaryOp(this.ListMin, x => x.MinAsList());\n          this.AddListUnaryOp(this.ListMax, x => x.MaxAsList());\n          this.AddListUnaryOp(this.Count, x => x.Count);\n          this.AddListUnaryOp(this.ValueOfList, x => x.maxItem.Value);\n          var divertTargetsEqual = (d1, d2) => d1.Equals(d2);\n          var divertTargetsNotEqual = (d1, d2) => !d1.Equals(d2);\n          this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);\n          this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);\n        }\n      }\n      AddOpFuncForType(valType, op) {\n        if (this._operationFuncs == null) {\n          this._operationFuncs = new Map();\n        }\n        this._operationFuncs.set(valType, op);\n      }\n      static AddOpToNativeFunc(name, args, valType, op) {\n        if (this._nativeFunctions === null) return (0, NullException_1.throwNullException)(\"NativeFunctionCall._nativeFunctions\");\n        var nativeFunc = this._nativeFunctions.get(name);\n        if (!nativeFunc) {\n          nativeFunc = new NativeFunctionCall(name, args);\n          this._nativeFunctions.set(name, nativeFunc);\n        }\n        nativeFunc.AddOpFuncForType(valType, op);\n      }\n      static AddIntBinaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);\n      }\n      static AddIntUnaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);\n      }\n      static AddFloatBinaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);\n      }\n      static AddFloatUnaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);\n      }\n      static AddStringBinaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);\n      }\n      static AddListBinaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);\n      }\n      static AddListUnaryOp(name, op) {\n        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);\n      }\n      toString() {\n        return 'Native \"' + this.name + '\"';\n      }\n    };\n    NativeFunctionCall.NativeFunctionCall = NativeFunctionCall$1;\n    NativeFunctionCall$1.Add = \"+\";\n    NativeFunctionCall$1.Subtract = \"-\";\n    NativeFunctionCall$1.Divide = \"/\";\n    NativeFunctionCall$1.Multiply = \"*\";\n    NativeFunctionCall$1.Mod = \"%\";\n    NativeFunctionCall$1.Negate = \"_\";\n    NativeFunctionCall$1.Equal = \"==\";\n    NativeFunctionCall$1.Greater = \">\";\n    NativeFunctionCall$1.Less = \"<\";\n    NativeFunctionCall$1.GreaterThanOrEquals = \">=\";\n    NativeFunctionCall$1.LessThanOrEquals = \"<=\";\n    NativeFunctionCall$1.NotEquals = \"!=\";\n    NativeFunctionCall$1.Not = \"!\";\n    NativeFunctionCall$1.And = \"&&\";\n    NativeFunctionCall$1.Or = \"||\";\n    NativeFunctionCall$1.Min = \"MIN\";\n    NativeFunctionCall$1.Max = \"MAX\";\n    NativeFunctionCall$1.Pow = \"POW\";\n    NativeFunctionCall$1.Floor = \"FLOOR\";\n    NativeFunctionCall$1.Ceiling = \"CEILING\";\n    NativeFunctionCall$1.Int = \"INT\";\n    NativeFunctionCall$1.Float = \"FLOAT\";\n    NativeFunctionCall$1.Has = \"?\";\n    NativeFunctionCall$1.Hasnt = \"!?\";\n    NativeFunctionCall$1.Intersect = \"^\";\n    NativeFunctionCall$1.ListMin = \"LIST_MIN\";\n    NativeFunctionCall$1.ListMax = \"LIST_MAX\";\n    NativeFunctionCall$1.All = \"LIST_ALL\";\n    NativeFunctionCall$1.Count = \"LIST_COUNT\";\n    NativeFunctionCall$1.ValueOfList = \"LIST_VALUE\";\n    NativeFunctionCall$1.Invert = \"LIST_INVERT\";\n    NativeFunctionCall$1._nativeFunctions = null;\n    return NativeFunctionCall;\n  }\n\n  var Tag$1 = {};\n\n  var hasRequiredTag$1;\n  function requireTag$1() {\n    if (hasRequiredTag$1) return Tag$1;\n    hasRequiredTag$1 = 1;\n    Object.defineProperty(Tag$1, \"__esModule\", {\n      value: true\n    });\n    Tag$1.Tag = void 0;\n    var Object_1 = require_Object$1();\n    // New version of tags is dynamic - it constructs the tags\n    // at runtime based on BeginTag and EndTag control commands.\n    // Plain text that's in the output stream is turned into tags\n    // when you do story.currentTags.\n    // The only place this is used is when flattening tags down\n    // to string in advance, during dynamic string generation if\n    // there's a tag embedded in it. See how ControlCommand.EndString\n    // is implemented in Story.cs for more details + comment\n    class Tag extends Object_1.InkObject {\n      constructor(tagText) {\n        super();\n        this.text = tagText.toString() || \"\";\n      }\n      toString() {\n        return \"# \" + this.text;\n      }\n    }\n    Tag$1.Tag = Tag;\n    return Tag$1;\n  }\n\n  var Choice$1 = {};\n\n  var hasRequiredChoice$1;\n  function requireChoice$1() {\n    if (hasRequiredChoice$1) return Choice$1;\n    hasRequiredChoice$1 = 1;\n    Object.defineProperty(Choice$1, \"__esModule\", {\n      value: true\n    });\n    Choice$1.Choice = void 0;\n    var Path_1 = requirePath$1();\n    var NullException_1 = requireNullException();\n    var Object_1 = require_Object$1();\n    class Choice extends Object_1.InkObject {\n      constructor() {\n        super(...arguments);\n        this.text = \"\";\n        this.index = 0;\n        this.threadAtGeneration = null;\n        this.sourcePath = \"\";\n        this.targetPath = null;\n        this.isInvisibleDefault = false;\n        this.tags = null;\n        this.originalThreadIndex = 0;\n      }\n      get pathStringOnChoice() {\n        if (this.targetPath === null) return (0, NullException_1.throwNullException)(\"Choice.targetPath\");\n        return this.targetPath.toString();\n      }\n      set pathStringOnChoice(value) {\n        this.targetPath = new Path_1.Path(value);\n      }\n      Clone() {\n        var copy = new Choice();\n        copy.text = this.text;\n        copy.sourcePath = this.sourcePath;\n        copy.index = this.index;\n        copy.targetPath = this.targetPath;\n        copy.originalThreadIndex = this.originalThreadIndex;\n        copy.isInvisibleDefault = this.isInvisibleDefault;\n        if (this.threadAtGeneration !== null) copy.threadAtGeneration = this.threadAtGeneration.Copy();\n        return copy;\n      }\n    }\n    Choice$1.Choice = Choice;\n    return Choice$1;\n  }\n\n  var ListDefinition$1 = {};\n\n  var hasRequiredListDefinition$1;\n  function requireListDefinition$1() {\n    if (hasRequiredListDefinition$1) return ListDefinition$1;\n    hasRequiredListDefinition$1 = 1;\n    Object.defineProperty(ListDefinition$1, \"__esModule\", {\n      value: true\n    });\n    ListDefinition$1.ListDefinition = void 0;\n    var InkList_1 = requireInkList();\n    class ListDefinition {\n      constructor(name, items) {\n        this._name = name || \"\";\n        this._items = null;\n        this._itemNameToValues = items || new Map();\n      }\n      get name() {\n        return this._name;\n      }\n      get items() {\n        if (this._items == null) {\n          this._items = new Map();\n          for (var [key, value] of this._itemNameToValues) {\n            var item = new InkList_1.InkListItem(this.name, key);\n            this._items.set(item.serialized(), value);\n          }\n        }\n        return this._items;\n      }\n      ValueForItem(item) {\n        if (!item.itemName) return 0;\n        var intVal = this._itemNameToValues.get(item.itemName);\n        if (typeof intVal !== \"undefined\") return intVal;else return 0;\n      }\n      ContainsItem(item) {\n        if (!item.itemName) return false;\n        if (item.originName != this.name) return false;\n        return this._itemNameToValues.has(item.itemName);\n      }\n      ContainsItemWithName(itemName) {\n        return this._itemNameToValues.has(itemName);\n      }\n      TryGetItemWithValue(val, /* out */item) {\n        for (var [key, value] of this._itemNameToValues) {\n          if (value == val) {\n            item = new InkList_1.InkListItem(this.name, key);\n            return {\n              result: item,\n              exists: true\n            };\n          }\n        }\n        item = InkList_1.InkListItem.Null;\n        return {\n          result: item,\n          exists: false\n        };\n      }\n      TryGetValueForItem(item,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      /* out */\n      intVal) {\n        if (!item.itemName) return {\n          result: 0,\n          exists: false\n        };\n        var value = this._itemNameToValues.get(item.itemName);\n        if (!value) return {\n          result: 0,\n          exists: false\n        };\n        return {\n          result: value,\n          exists: true\n        };\n      }\n    }\n    ListDefinition$1.ListDefinition = ListDefinition;\n    return ListDefinition$1;\n  }\n\n  var ListDefinitionsOrigin = {};\n\n  var hasRequiredListDefinitionsOrigin;\n  function requireListDefinitionsOrigin() {\n    if (hasRequiredListDefinitionsOrigin) return ListDefinitionsOrigin;\n    hasRequiredListDefinitionsOrigin = 1;\n    Object.defineProperty(ListDefinitionsOrigin, \"__esModule\", {\n      value: true\n    });\n    ListDefinitionsOrigin.ListDefinitionsOrigin = void 0;\n    var InkList_1 = requireInkList();\n    var Value_1 = requireValue();\n    var NullException_1 = requireNullException();\n    let ListDefinitionsOrigin$1 = class ListDefinitionsOrigin {\n      constructor(lists) {\n        this._lists = new Map();\n        this._allUnambiguousListValueCache = new Map();\n        for (var list of lists) {\n          this._lists.set(list.name, list);\n          for (var [key, val] of list.items) {\n            var item = InkList_1.InkListItem.fromSerializedKey(key);\n            var listValue = new Value_1.ListValue(item, val);\n            if (!item.itemName) {\n              throw new Error(\"item.itemName is null or undefined.\");\n            }\n            this._allUnambiguousListValueCache.set(item.itemName, listValue);\n            this._allUnambiguousListValueCache.set(item.fullName, listValue);\n          }\n        }\n      }\n      get lists() {\n        var listOfLists = [];\n        for (var [, value] of this._lists) {\n          listOfLists.push(value);\n        }\n        return listOfLists;\n      }\n      TryListGetDefinition(name, /* out */def) {\n        if (name === null) {\n          return {\n            result: def,\n            exists: false\n          };\n        }\n        // initially, this function returns a boolean and the second parameter is an out.\n        var definition = this._lists.get(name);\n        if (!definition) return {\n          result: def,\n          exists: false\n        };\n        return {\n          result: definition,\n          exists: true\n        };\n      }\n      FindSingleItemListWithName(name) {\n        if (name === null) {\n          return (0, NullException_1.throwNullException)(\"name\");\n        }\n        var val = this._allUnambiguousListValueCache.get(name);\n        if (typeof val !== \"undefined\") {\n          return val;\n        }\n        return null;\n      }\n    };\n    ListDefinitionsOrigin.ListDefinitionsOrigin = ListDefinitionsOrigin$1;\n    return ListDefinitionsOrigin;\n  }\n\n  var hasRequiredJsonSerialisation;\n  function requireJsonSerialisation() {\n    if (hasRequiredJsonSerialisation) return JsonSerialisation;\n    hasRequiredJsonSerialisation = 1;\n    Object.defineProperty(JsonSerialisation, \"__esModule\", {\n      value: true\n    });\n    JsonSerialisation.JsonSerialisation = void 0;\n    var Container_1 = requireContainer();\n    var Value_1 = requireValue();\n    var Glue_1 = requireGlue$1();\n    var ControlCommand_1 = requireControlCommand();\n    var PushPop_1 = requirePushPop();\n    var Divert_1 = requireDivert$1();\n    var ChoicePoint_1 = requireChoicePoint();\n    var VariableReference_1 = requireVariableReference$1();\n    var VariableAssignment_1 = requireVariableAssignment$1();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var Void_1 = requireVoid();\n    var Tag_1 = requireTag$1();\n    var Path_1 = requirePath$1();\n    var Choice_1 = requireChoice$1();\n    var ListDefinition_1 = requireListDefinition$1();\n    var ListDefinitionsOrigin_1 = requireListDefinitionsOrigin();\n    var InkList_1 = requireInkList();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var NullException_1 = requireNullException();\n    let JsonSerialisation$1 = class JsonSerialisation {\n      static JArrayToRuntimeObjList(jArray) {\n        var skipLast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var count = jArray.length;\n        if (skipLast) count--;\n        var list = [];\n        for (var i = 0; i < count; i++) {\n          var jTok = jArray[i];\n          var runtimeObj = this.JTokenToRuntimeObject(jTok);\n          if (runtimeObj === null) {\n            return (0, NullException_1.throwNullException)(\"runtimeObj\");\n          }\n          list.push(runtimeObj);\n        }\n        return list;\n      }\n      static WriteDictionaryRuntimeObjs(writer, dictionary) {\n        writer.WriteObjectStart();\n        for (var [key, value] of dictionary) {\n          writer.WritePropertyStart(key);\n          this.WriteRuntimeObject(writer, value);\n          writer.WritePropertyEnd();\n        }\n        writer.WriteObjectEnd();\n      }\n      static WriteListRuntimeObjs(writer, list) {\n        writer.WriteArrayStart();\n        for (var value of list) {\n          this.WriteRuntimeObject(writer, value);\n        }\n        writer.WriteArrayEnd();\n      }\n      static WriteIntDictionary(writer, dict) {\n        writer.WriteObjectStart();\n        for (var [key, value] of dict) {\n          writer.WriteIntProperty(key, value);\n        }\n        writer.WriteObjectEnd();\n      }\n      static WriteRuntimeObject(writer, obj) {\n        var container = (0, TypeAssertion_1.asOrNull)(obj, Container_1.Container);\n        if (container) {\n          this.WriteRuntimeContainer(writer, container);\n          return;\n        }\n        var divert = (0, TypeAssertion_1.asOrNull)(obj, Divert_1.Divert);\n        if (divert) {\n          var divTypeKey = \"->\";\n          if (divert.isExternal) {\n            divTypeKey = \"x()\";\n          } else if (divert.pushesToStack) {\n            if (divert.stackPushType == PushPop_1.PushPopType.Function) {\n              divTypeKey = \"f()\";\n            } else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {\n              divTypeKey = \"->t->\";\n            }\n          }\n          var targetStr;\n          if (divert.hasVariableTarget) {\n            targetStr = divert.variableDivertName;\n          } else {\n            targetStr = divert.targetPathString;\n          }\n          writer.WriteObjectStart();\n          writer.WriteProperty(divTypeKey, targetStr);\n          if (divert.hasVariableTarget) {\n            writer.WriteProperty(\"var\", true);\n          }\n          if (divert.isConditional) {\n            writer.WriteProperty(\"c\", true);\n          }\n          if (divert.externalArgs > 0) {\n            writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n          }\n          writer.WriteObjectEnd();\n          return;\n        }\n        var choicePoint = (0, TypeAssertion_1.asOrNull)(obj, ChoicePoint_1.ChoicePoint);\n        if (choicePoint) {\n          writer.WriteObjectStart();\n          writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n          writer.WriteIntProperty(\"flg\", choicePoint.flags);\n          writer.WriteObjectEnd();\n          return;\n        }\n        var boolVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.BoolValue);\n        if (boolVal) {\n          writer.WriteBool(boolVal.value);\n          return;\n        }\n        var intVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.IntValue);\n        if (intVal) {\n          writer.WriteInt(intVal.value);\n          return;\n        }\n        var floatVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.FloatValue);\n        if (floatVal) {\n          writer.WriteFloat(floatVal.value);\n          return;\n        }\n        var strVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n        if (strVal) {\n          if (strVal.isNewline) {\n            writer.Write(\"\\n\", false);\n          } else {\n            writer.WriteStringStart();\n            writer.WriteStringInner(\"^\");\n            writer.WriteStringInner(strVal.value);\n            writer.WriteStringEnd();\n          }\n          return;\n        }\n        var listVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.ListValue);\n        if (listVal) {\n          this.WriteInkList(writer, listVal);\n          return;\n        }\n        var divTargetVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.DivertTargetValue);\n        if (divTargetVal) {\n          writer.WriteObjectStart();\n          if (divTargetVal.value === null) {\n            return (0, NullException_1.throwNullException)(\"divTargetVal.value\");\n          }\n          writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n          writer.WriteObjectEnd();\n          return;\n        }\n        var varPtrVal = (0, TypeAssertion_1.asOrNull)(obj, Value_1.VariablePointerValue);\n        if (varPtrVal) {\n          writer.WriteObjectStart();\n          writer.WriteProperty(\"^var\", varPtrVal.value);\n          writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n          writer.WriteObjectEnd();\n          return;\n        }\n        var glue = (0, TypeAssertion_1.asOrNull)(obj, Glue_1.Glue);\n        if (glue) {\n          writer.Write(\"<>\");\n          return;\n        }\n        var controlCmd = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n        if (controlCmd) {\n          writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);\n          return;\n        }\n        var nativeFunc = (0, TypeAssertion_1.asOrNull)(obj, NativeFunctionCall_1.NativeFunctionCall);\n        if (nativeFunc) {\n          var name = nativeFunc.name;\n          if (name == \"^\") name = \"L^\";\n          writer.Write(name);\n          return;\n        }\n        var varRef = (0, TypeAssertion_1.asOrNull)(obj, VariableReference_1.VariableReference);\n        if (varRef) {\n          writer.WriteObjectStart();\n          var readCountPath = varRef.pathStringForCount;\n          if (readCountPath != null) {\n            writer.WriteProperty(\"CNT?\", readCountPath);\n          } else {\n            writer.WriteProperty(\"VAR?\", varRef.name);\n          }\n          writer.WriteObjectEnd();\n          return;\n        }\n        var varAss = (0, TypeAssertion_1.asOrNull)(obj, VariableAssignment_1.VariableAssignment);\n        if (varAss) {\n          writer.WriteObjectStart();\n          var key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n          writer.WriteProperty(key, varAss.variableName);\n          // Reassignment?\n          if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n          writer.WriteObjectEnd();\n          return;\n        }\n        var voidObj = (0, TypeAssertion_1.asOrNull)(obj, Void_1.Void);\n        if (voidObj) {\n          writer.Write(\"void\");\n          return;\n        }\n        var tag = (0, TypeAssertion_1.asOrNull)(obj, Tag_1.Tag);\n        if (tag) {\n          writer.WriteObjectStart();\n          writer.WriteProperty(\"#\", tag.text);\n          writer.WriteObjectEnd();\n          return;\n        }\n        var choice = (0, TypeAssertion_1.asOrNull)(obj, Choice_1.Choice);\n        if (choice) {\n          this.WriteChoice(writer, choice);\n          return;\n        }\n        throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n      }\n      static JObjectToDictionaryRuntimeObjs(jObject) {\n        var dict = new Map();\n        for (var key in jObject) {\n          if (jObject.hasOwnProperty(key)) {\n            var inkObject = this.JTokenToRuntimeObject(jObject[key]);\n            if (inkObject === null) {\n              return (0, NullException_1.throwNullException)(\"inkObject\");\n            }\n            dict.set(key, inkObject);\n          }\n        }\n        return dict;\n      }\n      static JObjectToIntDictionary(jObject) {\n        var dict = new Map();\n        for (var key in jObject) {\n          if (jObject.hasOwnProperty(key)) {\n            dict.set(key, parseInt(jObject[key]));\n          }\n        }\n        return dict;\n      }\n      static JTokenToRuntimeObject(token) {\n        if (typeof token === \"number\" && !isNaN(token) || typeof token === \"boolean\") {\n          return Value_1.Value.Create(token);\n        }\n        if (typeof token === \"string\") {\n          var str = token.toString();\n          //Explicit float value of the form \"123.00f\"\n          var floatRepresentation = /^([0-9]+.[0-9]+f)$/.exec(str);\n          if (floatRepresentation) {\n            return new Value_1.FloatValue(parseFloat(floatRepresentation[0]));\n          }\n          // String value\n          var firstChar = str[0];\n          if (firstChar == \"^\") return new Value_1.StringValue(str.substring(1));else if (firstChar == \"\\n\" && str.length == 1) return new Value_1.StringValue(\"\\n\");\n          // Glue\n          if (str == \"<>\") return new Glue_1.Glue();\n          // Control commands (would looking up in a hash set be faster?)\n          for (var i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n            var cmdName = JsonSerialisation._controlCommandNames[i];\n            if (str == cmdName) {\n              return new ControlCommand_1.ControlCommand(i);\n            }\n          }\n          // Native functions\n          if (str == \"L^\") str = \"^\";\n          if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str)) return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);\n          // Pop\n          if (str == \"->->\") return ControlCommand_1.ControlCommand.PopTunnel();else if (str == \"~ret\") return ControlCommand_1.ControlCommand.PopFunction();\n          // Void\n          if (str == \"void\") return new Void_1.Void();\n        }\n        if (typeof token === \"object\" && !Array.isArray(token)) {\n          var obj = token;\n          var propValue;\n          // Divert target value to path\n          if (obj[\"^->\"]) {\n            propValue = obj[\"^->\"];\n            return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));\n          }\n          // VariablePointerValue\n          if (obj[\"^var\"]) {\n            propValue = obj[\"^var\"];\n            var varPtr = new Value_1.VariablePointerValue(propValue.toString());\n            if (\"ci\" in obj) {\n              propValue = obj[\"ci\"];\n              varPtr.contextIndex = parseInt(propValue);\n            }\n            return varPtr;\n          }\n          // Divert\n          var isDivert = false;\n          var pushesToStack = false;\n          var divPushType = PushPop_1.PushPopType.Function;\n          var external = false;\n          if (propValue = obj[\"->\"]) {\n            isDivert = true;\n          } else if (propValue = obj[\"f()\"]) {\n            isDivert = true;\n            pushesToStack = true;\n            divPushType = PushPop_1.PushPopType.Function;\n          } else if (propValue = obj[\"->t->\"]) {\n            isDivert = true;\n            pushesToStack = true;\n            divPushType = PushPop_1.PushPopType.Tunnel;\n          } else if (propValue = obj[\"x()\"]) {\n            isDivert = true;\n            external = true;\n            pushesToStack = false;\n            divPushType = PushPop_1.PushPopType.Function;\n          }\n          if (isDivert) {\n            var divert = new Divert_1.Divert();\n            divert.pushesToStack = pushesToStack;\n            divert.stackPushType = divPushType;\n            divert.isExternal = external;\n            var target = propValue.toString();\n            if (propValue = obj[\"var\"]) divert.variableDivertName = target;else divert.targetPathString = target;\n            divert.isConditional = !!obj[\"c\"];\n            if (external) {\n              if (propValue = obj[\"exArgs\"]) divert.externalArgs = parseInt(propValue);\n            }\n            return divert;\n          }\n          // Choice\n          if (propValue = obj[\"*\"]) {\n            var choice = new ChoicePoint_1.ChoicePoint();\n            choice.pathStringOnChoice = propValue.toString();\n            if (propValue = obj[\"flg\"]) choice.flags = parseInt(propValue);\n            return choice;\n          }\n          // Variable reference\n          if (propValue = obj[\"VAR?\"]) {\n            return new VariableReference_1.VariableReference(propValue.toString());\n          } else if (propValue = obj[\"CNT?\"]) {\n            var readCountVarRef = new VariableReference_1.VariableReference();\n            readCountVarRef.pathStringForCount = propValue.toString();\n            return readCountVarRef;\n          }\n          // Variable assignment\n          var isVarAss = false;\n          var isGlobalVar = false;\n          if (propValue = obj[\"VAR=\"]) {\n            isVarAss = true;\n            isGlobalVar = true;\n          } else if (propValue = obj[\"temp=\"]) {\n            isVarAss = true;\n            isGlobalVar = false;\n          }\n          if (isVarAss) {\n            var varName = propValue.toString();\n            var isNewDecl = !obj[\"re\"];\n            var varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);\n            varAss.isGlobal = isGlobalVar;\n            return varAss;\n          }\n          if (obj[\"#\"] !== undefined) {\n            propValue = obj[\"#\"];\n            return new Tag_1.Tag(propValue.toString());\n          }\n          // List value\n          if (propValue = obj[\"list\"]) {\n            // var listContent = (Dictionary<string, object>)propValue;\n            var listContent = propValue;\n            var rawList = new InkList_1.InkList();\n            if (propValue = obj[\"origins\"]) {\n              // var namesAsObjs = (List<object>)propValue;\n              var namesAsObjs = propValue;\n              // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n              rawList.SetInitialOriginNames(namesAsObjs);\n            }\n            for (var key in listContent) {\n              if (listContent.hasOwnProperty(key)) {\n                var nameToVal = listContent[key];\n                var item = new InkList_1.InkListItem(key);\n                var val = parseInt(nameToVal);\n                rawList.Add(item, val);\n              }\n            }\n            return new Value_1.ListValue(rawList);\n          }\n          if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n        }\n        // Array is always a Runtime.Container\n        if (Array.isArray(token)) {\n          return this.JArrayToContainer(token);\n        }\n        if (token === null || token === undefined) return null;\n        throw new Error(\"Failed to convert token to runtime object: \" + this.toJson(token, [\"parent\"]));\n      }\n      static toJson(me, removes, space) {\n        return JSON.stringify(me, (k, v) => (removes === null || removes === void 0 ? void 0 : removes.some(r => r === k)) ? undefined : v, space);\n      }\n      static WriteRuntimeContainer(writer, container) {\n        var withoutName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        writer.WriteArrayStart();\n        if (container === null) {\n          return (0, NullException_1.throwNullException)(\"container\");\n        }\n        for (var c of container.content) this.WriteRuntimeObject(writer, c);\n        var namedOnlyContent = container.namedOnlyContent;\n        var countFlags = container.countFlags;\n        var hasNameProperty = container.name != null && !withoutName;\n        var hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n        if (hasTerminator) {\n          writer.WriteObjectStart();\n        }\n        if (namedOnlyContent != null) {\n          for (var [key, value] of namedOnlyContent) {\n            var name = key;\n            var namedContainer = (0, TypeAssertion_1.asOrNull)(value, Container_1.Container);\n            writer.WritePropertyStart(name);\n            this.WriteRuntimeContainer(writer, namedContainer, true);\n            writer.WritePropertyEnd();\n          }\n        }\n        if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n        if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n        if (hasTerminator) writer.WriteObjectEnd();else writer.WriteNull();\n        writer.WriteArrayEnd();\n      }\n      static JArrayToContainer(jArray) {\n        var container = new Container_1.Container();\n        container.content = this.JArrayToRuntimeObjList(jArray, true);\n        var terminatingObj = jArray[jArray.length - 1];\n        if (terminatingObj != null) {\n          var namedOnlyContent = new Map();\n          for (var key in terminatingObj) {\n            if (key == \"#f\") {\n              container.countFlags = parseInt(terminatingObj[key]);\n            } else if (key == \"#n\") {\n              container.name = terminatingObj[key].toString();\n            } else {\n              var namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);\n              // var namedSubContainer = namedContentItem as Container;\n              var namedSubContainer = (0, TypeAssertion_1.asOrNull)(namedContentItem, Container_1.Container);\n              if (namedSubContainer) namedSubContainer.name = key;\n              namedOnlyContent.set(key, namedContentItem);\n            }\n          }\n          container.namedOnlyContent = namedOnlyContent;\n        }\n        return container;\n      }\n      static JObjectToChoice(jObj) {\n        var choice = new Choice_1.Choice();\n        choice.text = jObj[\"text\"].toString();\n        choice.index = parseInt(jObj[\"index\"]);\n        choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n        choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n        choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n        choice.tags = this.JArrayToTags(jObj);\n        return choice;\n      }\n      static JArrayToTags(jObj) {\n        if (jObj[\"tags\"]) {\n          return jObj[\"tags\"];\n        } else {\n          return null;\n        }\n      }\n      static WriteChoice(writer, choice) {\n        writer.WriteObjectStart();\n        writer.WriteProperty(\"text\", choice.text);\n        writer.WriteIntProperty(\"index\", choice.index);\n        writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n        writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n        writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n        this.WriteChoiceTags(writer, choice);\n        writer.WriteObjectEnd();\n      }\n      static WriteChoiceTags(writer, choice) {\n        if (choice.tags && choice.tags.length > 0) {\n          writer.WritePropertyStart(\"tags\");\n          writer.WriteArrayStart();\n          for (var tag of choice.tags) {\n            writer.Write(tag);\n          }\n          writer.WriteArrayEnd();\n          writer.WritePropertyEnd();\n        }\n      }\n      static WriteInkList(writer, listVal) {\n        var rawList = listVal.value;\n        if (rawList === null) {\n          return (0, NullException_1.throwNullException)(\"rawList\");\n        }\n        writer.WriteObjectStart();\n        writer.WritePropertyStart(\"list\");\n        writer.WriteObjectStart();\n        for (var [key, val] of rawList) {\n          var item = InkList_1.InkListItem.fromSerializedKey(key);\n          var itemVal = val;\n          if (item.itemName === null) {\n            return (0, NullException_1.throwNullException)(\"item.itemName\");\n          }\n          writer.WritePropertyNameStart();\n          writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n          writer.WritePropertyNameInner(\".\");\n          writer.WritePropertyNameInner(item.itemName);\n          writer.WritePropertyNameEnd();\n          writer.Write(itemVal);\n          writer.WritePropertyEnd();\n        }\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n        if (rawList.Count == 0 && rawList.originNames != null && rawList.originNames.length > 0) {\n          writer.WritePropertyStart(\"origins\");\n          writer.WriteArrayStart();\n          for (var name of rawList.originNames) writer.Write(name);\n          writer.WriteArrayEnd();\n          writer.WritePropertyEnd();\n        }\n        writer.WriteObjectEnd();\n      }\n      static ListDefinitionsToJToken(origin) {\n        var result = {};\n        for (var def of origin.lists) {\n          var listDefJson = {};\n          for (var [key, val] of def.items) {\n            var item = InkList_1.InkListItem.fromSerializedKey(key);\n            if (item.itemName === null) {\n              return (0, NullException_1.throwNullException)(\"item.itemName\");\n            }\n            listDefJson[item.itemName] = val;\n          }\n          result[def.name] = listDefJson;\n        }\n        return result;\n      }\n      static JTokenToListDefinitions(obj) {\n        // var defsObj = (Dictionary<string, object>)obj;\n        var defsObj = obj;\n        var allDefs = [];\n        for (var key in defsObj) {\n          if (defsObj.hasOwnProperty(key)) {\n            var name = key.toString();\n            // var listDefJson = (Dictionary<string, object>)kv.Value;\n            var listDefJson = defsObj[key];\n            // Cast (string, object) to (string, int) for items\n            var items = new Map();\n            for (var nameValueKey in listDefJson) {\n              if (defsObj.hasOwnProperty(key)) {\n                var nameValue = listDefJson[nameValueKey];\n                items.set(nameValueKey, parseInt(nameValue));\n              }\n            }\n            var def = new ListDefinition_1.ListDefinition(name, items);\n            allDefs.push(def);\n          }\n        }\n        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);\n      }\n    };\n    JsonSerialisation.JsonSerialisation = JsonSerialisation$1;\n    JsonSerialisation$1._controlCommandNames = (() => {\n      var _controlCommandNames = [];\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = \"ev\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = \"out\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = \"/ev\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = \"du\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = \"~ret\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = \"->->\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = \"str\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = \"/str\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = \"nop\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = \"turn\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = \"turns\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = \"readc\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = \"rnd\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = \"srnd\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = \"visit\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] = \"seq\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = \"thread\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = \"done\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = \"end\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = \"listInt\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = \"range\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = \"lrnd\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginTag] = \"#\";\n      _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndTag] = \"/#\";\n      for (var i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n        if (_controlCommandNames[i] == null) throw new Error(\"Control command not accounted for in serialisation\");\n      }\n      return _controlCommandNames;\n    })();\n    return JsonSerialisation;\n  }\n\n  var StoryState = {};\n\n  var CallStack = {};\n\n  var hasRequiredCallStack;\n  function requireCallStack() {\n    if (hasRequiredCallStack) return CallStack;\n    hasRequiredCallStack = 1;\n    Object.defineProperty(CallStack, \"__esModule\", {\n      value: true\n    });\n    CallStack.CallStack = void 0;\n    var PushPop_1 = requirePushPop();\n    var Path_1 = requirePath$1();\n    var Story_1 = requireStory$1();\n    var JsonSerialisation_1 = requireJsonSerialisation();\n    var Value_1 = requireValue();\n    var StringBuilder_1 = requireStringBuilder();\n    var Pointer_1 = requirePointer();\n    var Debug_1 = requireDebug();\n    var TryGetResult_1 = requireTryGetResult();\n    var NullException_1 = requireNullException();\n    let CallStack$1 = class CallStack {\n      get elements() {\n        return this.callStack;\n      }\n      get depth() {\n        return this.elements.length;\n      }\n      get currentElement() {\n        var thread = this._threads[this._threads.length - 1];\n        var cs = thread.callstack;\n        return cs[cs.length - 1];\n      }\n      get currentElementIndex() {\n        return this.callStack.length - 1;\n      }\n      get currentThread() {\n        return this._threads[this._threads.length - 1];\n      }\n      set currentThread(value) {\n        Debug_1.Debug.Assert(this._threads.length == 1, \"Shouldn't be directly setting the current thread when we have a stack of them\");\n        this._threads.length = 0;\n        this._threads.push(value);\n      }\n      get canPop() {\n        return this.callStack.length > 1;\n      }\n      constructor() {\n        this._threadCounter = 0;\n        this._startOfRoot = Pointer_1.Pointer.Null;\n        if (arguments[0] instanceof Story_1.Story) {\n          var storyContext = arguments[0];\n          this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);\n          this.Reset();\n        } else {\n          var toCopy = arguments[0];\n          this._threads = [];\n          for (var otherThread of toCopy._threads) {\n            this._threads.push(otherThread.Copy());\n          }\n          this._threadCounter = toCopy._threadCounter;\n          this._startOfRoot = toCopy._startOfRoot.copy();\n        }\n      }\n      Reset() {\n        this._threads = [];\n        this._threads.push(new CallStack.Thread());\n        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));\n      }\n      SetJsonToken(jObject, storyContext) {\n        this._threads.length = 0;\n        // TODO: (List<object>) jObject [\"threads\"];\n        var jThreads = jObject[\"threads\"];\n        for (var jThreadTok of jThreads) {\n          // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n          var jThreadObj = jThreadTok;\n          var thread = new CallStack.Thread(jThreadObj, storyContext);\n          this._threads.push(thread);\n        }\n        // TODO: (int)jObject [\"threadCounter\"];\n        this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);\n      }\n      WriteJson(w) {\n        w.WriteObject(writer => {\n          writer.WritePropertyStart(\"threads\");\n          writer.WriteArrayStart();\n          for (var thread of this._threads) {\n            thread.WriteJson(writer);\n          }\n          writer.WriteArrayEnd();\n          writer.WritePropertyEnd();\n          writer.WritePropertyStart(\"threadCounter\");\n          writer.WriteInt(this._threadCounter);\n          writer.WritePropertyEnd();\n        });\n      }\n      PushThread() {\n        var newThread = this.currentThread.Copy();\n        this._threadCounter++;\n        newThread.threadIndex = this._threadCounter;\n        this._threads.push(newThread);\n      }\n      ForkThread() {\n        var forkedThread = this.currentThread.Copy();\n        this._threadCounter++;\n        forkedThread.threadIndex = this._threadCounter;\n        return forkedThread;\n      }\n      PopThread() {\n        if (this.canPopThread) {\n          this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n        } else {\n          throw new Error(\"Can't pop thread\");\n        }\n      }\n      get canPopThread() {\n        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n      }\n      get elementIsEvaluateFromGame() {\n        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;\n      }\n      Push(type) {\n        var externalEvaluationStackHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var outputStreamLengthWithPushed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var element = new CallStack.Element(type, this.currentElement.currentPointer, false);\n        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n        element.functionStartInOutputStream = outputStreamLengthWithPushed;\n        this.callStack.push(element);\n      }\n      CanPop() {\n        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        if (!this.canPop) return false;\n        if (type == null) return true;\n        return this.currentElement.type == type;\n      }\n      Pop() {\n        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        if (this.CanPop(type)) {\n          this.callStack.pop();\n          return;\n        } else {\n          throw new Error(\"Mismatched push/pop in Callstack\");\n        }\n      }\n      GetTemporaryVariableWithName(name) {\n        var contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        // contextIndex 0 means global, so index is actually 1-based\n        if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n        var contextElement = this.callStack[contextIndex - 1];\n        var varValue = (0, TryGetResult_1.tryGetValueFromMap)(contextElement.temporaryVariables, name, null);\n        if (varValue.exists) {\n          return varValue.result;\n        } else {\n          return null;\n        }\n      }\n      SetTemporaryVariable(name, value, declareNew) {\n        var contextIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n        var contextElement = this.callStack[contextIndex - 1];\n        if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n          throw new Error(\"Could not find temporary variable to set: \" + name);\n        }\n        var oldValue = (0, TryGetResult_1.tryGetValueFromMap)(contextElement.temporaryVariables, name, null);\n        if (oldValue.exists) Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n        contextElement.temporaryVariables.set(name, value);\n      }\n      ContextForVariableNamed(name) {\n        if (this.currentElement.temporaryVariables.get(name)) {\n          return this.currentElementIndex + 1;\n        } else {\n          return 0;\n        }\n      }\n      ThreadWithIndex(index) {\n        var filtered = this._threads.filter(t => {\n          if (t.threadIndex == index) return t;\n        });\n        return filtered.length > 0 ? filtered[0] : null;\n      }\n      get callStack() {\n        return this.currentThread.callstack;\n      }\n      get callStackTrace() {\n        var sb = new StringBuilder_1.StringBuilder();\n        for (var t = 0; t < this._threads.length; t++) {\n          var thread = this._threads[t];\n          var isCurrent = t == this._threads.length - 1;\n          sb.AppendFormat(\"=== THREAD {0}/{1} {2}===\\n\", t + 1, this._threads.length, isCurrent ? \"(current) \" : \"\");\n          for (var i = 0; i < thread.callstack.length; i++) {\n            if (thread.callstack[i].type == PushPop_1.PushPopType.Function) sb.Append(\"  [FUNCTION] \");else sb.Append(\"  [TUNNEL] \");\n            var pointer = thread.callstack[i].currentPointer;\n            if (!pointer.isNull) {\n              sb.Append(\"<SOMEWHERE IN \");\n              if (pointer.container === null) {\n                return (0, NullException_1.throwNullException)(\"pointer.container\");\n              }\n              sb.Append(pointer.container.path.toString());\n              sb.AppendLine(\">\");\n            }\n          }\n        }\n        return sb.toString();\n      }\n    };\n    CallStack.CallStack = CallStack$1;\n    (function (CallStack) {\n      class Element {\n        constructor(type, pointer) {\n          var inExpressionEvaluation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          this.evaluationStackHeightWhenPushed = 0;\n          this.functionStartInOutputStream = 0;\n          this.currentPointer = pointer.copy();\n          this.inExpressionEvaluation = inExpressionEvaluation;\n          this.temporaryVariables = new Map();\n          this.type = type;\n        }\n        Copy() {\n          var copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);\n          copy.temporaryVariables = new Map(this.temporaryVariables);\n          copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;\n          copy.functionStartInOutputStream = this.functionStartInOutputStream;\n          return copy;\n        }\n      }\n      CallStack.Element = Element;\n      class Thread {\n        constructor() {\n          this.threadIndex = 0;\n          this.previousPointer = Pointer_1.Pointer.Null;\n          this.callstack = [];\n          if (arguments[0] && arguments[1]) {\n            var jThreadObj = arguments[0];\n            var storyContext = arguments[1];\n            // TODO: (int) jThreadObj['threadIndex'] can raise;\n            this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n            var jThreadCallstack = jThreadObj[\"callstack\"];\n            for (var jElTok of jThreadCallstack) {\n              var jElementObj = jElTok;\n              // TODO: (int) jElementObj['type'] can raise;\n              var pushPopType = parseInt(jElementObj[\"type\"]);\n              var pointer = Pointer_1.Pointer.Null;\n              var currentContainerPathStr = void 0;\n              // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n              var currentContainerPathStrToken = jElementObj[\"cPath\"];\n              if (typeof currentContainerPathStrToken !== \"undefined\") {\n                currentContainerPathStr = currentContainerPathStrToken.toString();\n                var threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));\n                pointer.container = threadPointerResult.container;\n                pointer.index = parseInt(jElementObj[\"idx\"]);\n                if (threadPointerResult.obj == null) throw new Error(\"When loading state, internal story location couldn't be found: \" + currentContainerPathStr + \". Has the story changed since this save data was created?\");else if (threadPointerResult.approximate) {\n                  if (pointer.container !== null) {\n                    storyContext.Warning(\"When loading state, exact internal story location couldn't be found: '\" + currentContainerPathStr + \"', so it was approximated to '\" + pointer.container.path.toString() + \"' to recover. Has the story changed since this save data was created?\");\n                  } else {\n                    storyContext.Warning(\"When loading state, exact internal story location couldn't be found: '\" + currentContainerPathStr + \"' and it may not be recoverable. Has the story changed since this save data was created?\");\n                  }\n                }\n              }\n              var inExpressionEvaluation = !!jElementObj[\"exp\"];\n              var el = new Element(pushPopType, pointer, inExpressionEvaluation);\n              var temps = jElementObj[\"temp\"];\n              if (typeof temps !== \"undefined\") {\n                el.temporaryVariables = JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n              } else {\n                el.temporaryVariables.clear();\n              }\n              this.callstack.push(el);\n            }\n            var prevContentObjPath = jThreadObj[\"previousContentObject\"];\n            if (typeof prevContentObjPath !== \"undefined\") {\n              var prevPath = new Path_1.Path(prevContentObjPath.toString());\n              this.previousPointer = storyContext.PointerAtPath(prevPath);\n            }\n          }\n        }\n        Copy() {\n          var copy = new Thread();\n          copy.threadIndex = this.threadIndex;\n          for (var e of this.callstack) {\n            copy.callstack.push(e.Copy());\n          }\n          copy.previousPointer = this.previousPointer.copy();\n          return copy;\n        }\n        WriteJson(writer) {\n          writer.WriteObjectStart();\n          writer.WritePropertyStart(\"callstack\");\n          writer.WriteArrayStart();\n          for (var el of this.callstack) {\n            writer.WriteObjectStart();\n            if (!el.currentPointer.isNull) {\n              if (el.currentPointer.container === null) {\n                return (0, NullException_1.throwNullException)(\"el.currentPointer.container\");\n              }\n              writer.WriteProperty(\"cPath\", el.currentPointer.container.path.componentsString);\n              writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n            }\n            writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n            writer.WriteIntProperty(\"type\", el.type);\n            if (el.temporaryVariables.size > 0) {\n              writer.WritePropertyStart(\"temp\");\n              JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);\n              writer.WritePropertyEnd();\n            }\n            writer.WriteObjectEnd();\n          }\n          writer.WriteArrayEnd();\n          writer.WritePropertyEnd();\n          writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n          if (!this.previousPointer.isNull) {\n            var resolvedPointer = this.previousPointer.Resolve();\n            if (resolvedPointer === null) {\n              return (0, NullException_1.throwNullException)(\"this.previousPointer.Resolve()\");\n            }\n            writer.WriteProperty(\"previousContentObject\", resolvedPointer.path.toString());\n          }\n          writer.WriteObjectEnd();\n        }\n      }\n      CallStack.Thread = Thread;\n    })(CallStack$1 || (CallStack.CallStack = CallStack$1 = {}));\n    return CallStack;\n  }\n\n  var VariablesState = {};\n\n  var hasRequiredVariablesState;\n  function requireVariablesState() {\n    if (hasRequiredVariablesState) return VariablesState;\n    hasRequiredVariablesState = 1;\n    Object.defineProperty(VariablesState, \"__esModule\", {\n      value: true\n    });\n    VariablesState.VariablesState = void 0;\n    var Value_1 = requireValue();\n    var StoryException_1 = requireStoryException();\n    var JsonSerialisation_1 = requireJsonSerialisation();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var TryGetResult_1 = requireTryGetResult();\n    var NullException_1 = requireNullException();\n    // Fake class wrapper around VariableState to have correct typing\n    // when using the Proxy syntax in typescript\n    function VariablesStateAccessor() {\n      return class {};\n    }\n    let VariablesState$1 = class VariablesState extends VariablesStateAccessor() {\n      variableChangedEvent(variableName, newValue) {\n        for (var callback of this.variableChangedEventCallbacks) {\n          callback(variableName, newValue);\n        }\n      }\n      StartVariableObservation() {\n        this._batchObservingVariableChanges = true;\n        this._changedVariablesForBatchObs = new Set();\n      }\n      CompleteVariableObservation() {\n        this._batchObservingVariableChanges = false;\n        var changedVars = new Map();\n        if (this._changedVariablesForBatchObs != null) {\n          for (var variableName of this._changedVariablesForBatchObs) {\n            var currentValue = this._globalVariables.get(variableName);\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n        // Patch may still be active - e.g. if we were in the middle of a background save\n        if (this.patch != null) {\n          for (var _variableName of this.patch.changedVariables) {\n            var patchedVal = this.patch.TryGetGlobal(_variableName, null);\n            if (patchedVal.exists) changedVars.set(_variableName, patchedVal);\n          }\n        }\n        this._changedVariablesForBatchObs = null;\n        return changedVars;\n      }\n      NotifyObservers(changedVars) {\n        for (var [key, value] of changedVars) {\n          this.variableChangedEvent(key, value);\n        }\n      }\n      get callStack() {\n        return this._callStack;\n      }\n      set callStack(callStack) {\n        this._callStack = callStack;\n      }\n      $(variableName, value) {\n        if (typeof value === \"undefined\") {\n          var varContents = null;\n          if (this.patch !== null) {\n            varContents = this.patch.TryGetGlobal(variableName, null);\n            if (varContents.exists) return varContents.result.valueObject;\n          }\n          varContents = this._globalVariables.get(variableName);\n          if (typeof varContents === \"undefined\") {\n            varContents = this._defaultGlobalVariables.get(variableName);\n          }\n          if (typeof varContents !== \"undefined\") return varContents.valueObject;else return null;\n        } else {\n          if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\") throw new StoryException_1.StoryException(\"Cannot assign to a variable (\" + variableName + \") that hasn't been declared in the story\");\n          var val = Value_1.Value.Create(value);\n          if (val == null) {\n            if (value == null) {\n              throw new Error(\"Cannot pass null to VariableState\");\n            } else {\n              throw new Error(\"Invalid value passed to VariableState: \" + value.toString());\n            }\n          }\n          this.SetGlobal(variableName, val);\n        }\n      }\n      constructor(callStack, listDefsOrigin) {\n        super();\n        // The way variableChangedEvent is a bit different than the reference implementation.\n        // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n        // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n        // special ObserveVariableChange method below.\n        this.variableChangedEventCallbacks = [];\n        this.patch = null;\n        this._defaultGlobalVariables = new Map();\n        this._changedVariablesForBatchObs = new Set();\n        this._batchObservingVariableChanges = false;\n        this._globalVariables = new Map();\n        this._callStack = callStack;\n        this._listDefsOrigin = listDefsOrigin;\n        // if es6 proxies are available, use them.\n        try {\n          // the proxy is used to allow direct manipulation of global variables.\n          // It first tries to access the objects own property, and if none is\n          // found it delegates the call to the $ method, defined below\n          var p = new Proxy(this, {\n            get(target, name) {\n              return name in target ? target[name] : target.$(name);\n            },\n            set(target, name, value) {\n              if (name in target) target[name] = value;else target.$(name, value);\n              return true; // returning a falsy value make the trap fail\n            },\n            ownKeys(target) {\n              return [...new Set([...target._defaultGlobalVariables.keys(), ...target._globalVariables.keys()])];\n            },\n            getOwnPropertyDescriptor(target, name) {\n              // called for every property\n              return {\n                enumerable: true,\n                configurable: true,\n                value: target.$(name)\n              };\n            }\n          });\n          return p;\n        } catch (e) {\n          // the proxy object is not available in this context. we should warn the\n          // dev but writing to the console feels a bit intrusive.\n          // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n        }\n      }\n      ApplyPatch() {\n        if (this.patch === null) {\n          return (0, NullException_1.throwNullException)(\"this.patch\");\n        }\n        for (var [namedVarKey, namedVarValue] of this.patch.globals) {\n          this._globalVariables.set(namedVarKey, namedVarValue);\n        }\n        if (this._changedVariablesForBatchObs !== null) {\n          for (var name of this.patch.changedVariables) {\n            this._changedVariablesForBatchObs.add(name);\n          }\n        }\n        this.patch = null;\n      }\n      SetJsonToken(jToken) {\n        this._globalVariables.clear();\n        for (var [varValKey, varValValue] of this._defaultGlobalVariables) {\n          var loadedToken = jToken[varValKey];\n          if (typeof loadedToken !== \"undefined\") {\n            var tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n            if (tokenInkObject === null) {\n              return (0, NullException_1.throwNullException)(\"tokenInkObject\");\n            }\n            this._globalVariables.set(varValKey, tokenInkObject);\n          } else {\n            this._globalVariables.set(varValKey, varValValue);\n          }\n        }\n      }\n      WriteJson(writer) {\n        writer.WriteObjectStart();\n        for (var [keyValKey, keyValValue] of this._globalVariables) {\n          var name = keyValKey;\n          var val = keyValValue;\n          if (VariablesState.dontSaveDefaultValues) {\n            if (this._defaultGlobalVariables.has(name)) {\n              var defaultVal = this._defaultGlobalVariables.get(name);\n              if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n            }\n          }\n          writer.WritePropertyStart(name);\n          JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);\n          writer.WritePropertyEnd();\n        }\n        writer.WriteObjectEnd();\n      }\n      RuntimeObjectsEqual(obj1, obj2) {\n        if (obj1 === null) {\n          return (0, NullException_1.throwNullException)(\"obj1\");\n        }\n        if (obj2 === null) {\n          return (0, NullException_1.throwNullException)(\"obj2\");\n        }\n        if (obj1.constructor !== obj2.constructor) return false;\n        var boolVal = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.BoolValue);\n        if (boolVal !== null) {\n          return boolVal.value === (0, TypeAssertion_1.asOrThrows)(obj2, Value_1.BoolValue).value;\n        }\n        var intVal = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.IntValue);\n        if (intVal !== null) {\n          return intVal.value === (0, TypeAssertion_1.asOrThrows)(obj2, Value_1.IntValue).value;\n        }\n        var floatVal = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.FloatValue);\n        if (floatVal !== null) {\n          return floatVal.value === (0, TypeAssertion_1.asOrThrows)(obj2, Value_1.FloatValue).value;\n        }\n        var val1 = (0, TypeAssertion_1.asOrNull)(obj1, Value_1.Value);\n        var val2 = (0, TypeAssertion_1.asOrNull)(obj2, Value_1.Value);\n        if (val1 !== null && val2 !== null) {\n          if ((0, TypeAssertion_1.isEquatable)(val1.valueObject) && (0, TypeAssertion_1.isEquatable)(val2.valueObject)) {\n            return val1.valueObject.Equals(val2.valueObject);\n          } else {\n            return val1.valueObject === val2.valueObject;\n          }\n        }\n        throw new Error(\"FastRoughDefinitelyEquals: Unsupported runtime object type: \" + obj1.constructor.name);\n      }\n      GetVariableWithName(name) {\n        var contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        var varValue = this.GetRawVariableWithName(name, contextIndex);\n        // var varPointer = varValue as VariablePointerValue;\n        var varPointer = (0, TypeAssertion_1.asOrNull)(varValue, Value_1.VariablePointerValue);\n        if (varPointer !== null) {\n          varValue = this.ValueAtVariablePointer(varPointer);\n        }\n        return varValue;\n      }\n      TryGetDefaultVariableValue(name) {\n        var val = (0, TryGetResult_1.tryGetValueFromMap)(this._defaultGlobalVariables, name, null);\n        return val.exists ? val.result : null;\n      }\n      GlobalVariableExistsWithName(name) {\n        return this._globalVariables.has(name) || this._defaultGlobalVariables !== null && this._defaultGlobalVariables.has(name);\n      }\n      GetRawVariableWithName(name, contextIndex) {\n        var varValue = null;\n        if (contextIndex == 0 || contextIndex == -1) {\n          var variableValue = null;\n          if (this.patch !== null) {\n            variableValue = this.patch.TryGetGlobal(name, null);\n            if (variableValue.exists) return variableValue.result;\n          }\n          // this is a conditional assignment\n          variableValue = (0, TryGetResult_1.tryGetValueFromMap)(this._globalVariables, name, null);\n          if (variableValue.exists) return variableValue.result;\n          if (this._defaultGlobalVariables !== null) {\n            variableValue = (0, TryGetResult_1.tryGetValueFromMap)(this._defaultGlobalVariables, name, null);\n            if (variableValue.exists) return variableValue.result;\n          }\n          if (this._listDefsOrigin === null) return (0, NullException_1.throwNullException)(\"VariablesState._listDefsOrigin\");\n          var listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n          if (listItemValue) return listItemValue;\n        }\n        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n        return varValue;\n      }\n      ValueAtVariablePointer(pointer) {\n        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n      }\n      Assign(varAss, value) {\n        var name = varAss.variableName;\n        if (name === null) {\n          return (0, NullException_1.throwNullException)(\"name\");\n        }\n        var contextIndex = -1;\n        var setGlobal = false;\n        if (varAss.isNewDeclaration) {\n          setGlobal = varAss.isGlobal;\n        } else {\n          setGlobal = this.GlobalVariableExistsWithName(name);\n        }\n        if (varAss.isNewDeclaration) {\n          // var varPointer = value as VariablePointerValue;\n          var varPointer = (0, TypeAssertion_1.asOrNull)(value, Value_1.VariablePointerValue);\n          if (varPointer !== null) {\n            var fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);\n            value = fullyResolvedVariablePointer;\n          }\n        } else {\n          var existingPointer = null;\n          do {\n            // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n            existingPointer = (0, TypeAssertion_1.asOrNull)(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);\n            if (existingPointer != null) {\n              name = existingPointer.variableName;\n              contextIndex = existingPointer.contextIndex;\n              setGlobal = contextIndex == 0;\n            }\n          } while (existingPointer != null);\n        }\n        if (setGlobal) {\n          this.SetGlobal(name, value);\n        } else {\n          this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);\n        }\n      }\n      SnapshotDefaultGlobals() {\n        this._defaultGlobalVariables = new Map(this._globalVariables);\n      }\n      RetainListOriginsForAssignment(oldValue, newValue) {\n        var oldList = (0, TypeAssertion_1.asOrThrows)(oldValue, Value_1.ListValue);\n        var newList = (0, TypeAssertion_1.asOrThrows)(newValue, Value_1.ListValue);\n        if (oldList.value && newList.value && newList.value.Count == 0) {\n          newList.value.SetInitialOriginNames(oldList.value.originNames);\n        }\n      }\n      SetGlobal(variableName, value) {\n        var oldValue = null;\n        if (this.patch === null) {\n          oldValue = (0, TryGetResult_1.tryGetValueFromMap)(this._globalVariables, variableName, null);\n        }\n        if (this.patch !== null) {\n          oldValue = this.patch.TryGetGlobal(variableName, null);\n          if (!oldValue.exists) {\n            oldValue = (0, TryGetResult_1.tryGetValueFromMap)(this._globalVariables, variableName, null);\n          }\n        }\n        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n        if (variableName === null) {\n          return (0, NullException_1.throwNullException)(\"variableName\");\n        }\n        if (this.patch !== null) {\n          this.patch.SetGlobal(variableName, value);\n        } else {\n          this._globalVariables.set(variableName, value);\n        }\n        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n        if (this.variableChangedEvent !== null && oldValue !== null && value !== oldValue.result) {\n          if (this._batchObservingVariableChanges) {\n            if (this._changedVariablesForBatchObs === null) {\n              return (0, NullException_1.throwNullException)(\"this._changedVariablesForBatchObs\");\n            }\n            if (this.patch !== null) {\n              this.patch.AddChangedVariable(variableName);\n            } else if (this._changedVariablesForBatchObs !== null) {\n              this._changedVariablesForBatchObs.add(variableName);\n            }\n          } else {\n            this.variableChangedEvent(variableName, value);\n          }\n        }\n      }\n      ResolveVariablePointer(varPointer) {\n        var contextIndex = varPointer.contextIndex;\n        if (contextIndex == -1) contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);\n        var valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);\n        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n        var doubleRedirectionPointer = (0, TypeAssertion_1.asOrNull)(valueOfVariablePointedTo, Value_1.VariablePointerValue);\n        if (doubleRedirectionPointer != null) {\n          return doubleRedirectionPointer;\n        } else {\n          return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);\n        }\n      }\n      GetContextIndexOfVariableNamed(varName) {\n        if (this.GlobalVariableExistsWithName(varName)) return 0;\n        return this._callStack.currentElementIndex;\n      }\n      /**\n       * This function is specific to the js version of ink. It allows to register a\n       * callback that will be called when a variable changes. The original code uses\n       * `state.variableChangedEvent += callback` instead.\n       *\n       * @param {function} callback\n       */\n      ObserveVariableChange(callback) {\n        this.variableChangedEventCallbacks.push(callback);\n      }\n    };\n    VariablesState.VariablesState = VariablesState$1;\n    VariablesState$1.dontSaveDefaultValues = true;\n    return VariablesState;\n  }\n\n  var PRNG = {};\n\n  var hasRequiredPRNG;\n  function requirePRNG() {\n    if (hasRequiredPRNG) return PRNG;\n    hasRequiredPRNG = 1;\n    Object.defineProperty(PRNG, \"__esModule\", {\n      value: true\n    });\n    PRNG.PRNG = void 0;\n    // Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n    // Ink uses a seedable PRNG of which there is none in native javascript.\n    let PRNG$1 = class PRNG {\n      constructor(seed) {\n        this.seed = seed % 2147483647;\n        if (this.seed <= 0) this.seed += 2147483646;\n      }\n      next() {\n        return this.seed = this.seed * 48271 % 2147483647;\n      }\n      nextFloat() {\n        return (this.next() - 1) / 2147483646;\n      }\n    };\n    PRNG.PRNG = PRNG$1;\n    return PRNG;\n  }\n\n  var StatePatch = {};\n\n  var hasRequiredStatePatch;\n  function requireStatePatch() {\n    if (hasRequiredStatePatch) return StatePatch;\n    hasRequiredStatePatch = 1;\n    Object.defineProperty(StatePatch, \"__esModule\", {\n      value: true\n    });\n    StatePatch.StatePatch = void 0;\n    let StatePatch$1 = class StatePatch {\n      get globals() {\n        return this._globals;\n      }\n      get changedVariables() {\n        return this._changedVariables;\n      }\n      get visitCounts() {\n        return this._visitCounts;\n      }\n      get turnIndices() {\n        return this._turnIndices;\n      }\n      constructor() {\n        this._changedVariables = new Set();\n        this._visitCounts = new Map();\n        this._turnIndices = new Map();\n        if (arguments.length === 1 && arguments[0] !== null) {\n          var toCopy = arguments[0];\n          this._globals = new Map(toCopy._globals);\n          this._changedVariables = new Set(toCopy._changedVariables);\n          this._visitCounts = new Map(toCopy._visitCounts);\n          this._turnIndices = new Map(toCopy._turnIndices);\n        } else {\n          this._globals = new Map();\n          this._changedVariables = new Set();\n          this._visitCounts = new Map();\n          this._turnIndices = new Map();\n        }\n      }\n      TryGetGlobal(name, /* out */value) {\n        if (name !== null && this._globals.has(name)) {\n          return {\n            result: this._globals.get(name),\n            exists: true\n          };\n        }\n        return {\n          result: value,\n          exists: false\n        };\n      }\n      SetGlobal(name, value) {\n        this._globals.set(name, value);\n      }\n      AddChangedVariable(name) {\n        return this._changedVariables.add(name);\n      }\n      TryGetVisitCount(container, /* out */count) {\n        if (this._visitCounts.has(container)) {\n          return {\n            result: this._visitCounts.get(container),\n            exists: true\n          };\n        }\n        return {\n          result: count,\n          exists: false\n        };\n      }\n      SetVisitCount(container, count) {\n        this._visitCounts.set(container, count);\n      }\n      SetTurnIndex(container, index) {\n        this._turnIndices.set(container, index);\n      }\n      TryGetTurnIndex(container, /* out */index) {\n        if (this._turnIndices.has(container)) {\n          return {\n            result: this._turnIndices.get(container),\n            exists: true\n          };\n        }\n        return {\n          result: index,\n          exists: false\n        };\n      }\n    };\n    StatePatch.StatePatch = StatePatch$1;\n    return StatePatch;\n  }\n\n  var SimpleJson = {};\n\n  var hasRequiredSimpleJson;\n  function requireSimpleJson() {\n    if (hasRequiredSimpleJson) return SimpleJson;\n    hasRequiredSimpleJson = 1;\n    Object.defineProperty(SimpleJson, \"__esModule\", {\n      value: true\n    });\n    SimpleJson.SimpleJson = void 0;\n    let SimpleJson$1 = class SimpleJson {\n      static TextToDictionary(text) {\n        return new SimpleJson.Reader(text).ToDictionary();\n      }\n      static TextToArray(text) {\n        return new SimpleJson.Reader(text).ToArray();\n      }\n    };\n    SimpleJson.SimpleJson = SimpleJson$1;\n    (function (SimpleJson) {\n      class Reader {\n        constructor(text) {\n          // Before parsing the JSON, all floats of the form \"123.0\" are transformed into \"123.0f\"\n          // so that they are recognized as FLOAT in the ink runtime\n          var nativeFloatParsing = JSON.parse(\"0\",\n          // @ts-expect-error : typing\n          (_, __, context) => context != null);\n          if (!nativeFloatParsing) {\n            // When the nativeFloatParsing argument is false,\n            // we aggressively replace using a regexp\n            // At time of writing : only happen for Safari iOS and Mac\n            var jsonWithExplicitFloat = text.replace(/(,\\s*)([0-9]+\\.[0]+)([,]*)/g, '$1\"$2f\"$3');\n            this._rootObject = JSON.parse(jsonWithExplicitFloat);\n          } else {\n            // @ts-expect-error : typing\n            var explicitFloatReviver = (_, value, context) => {\n              // When the nativeFloatParsing argument is true,\n              // we use a custom reviver function\n              //see https://github.com/y-lohse/inkjs/pull/1100#issuecomment-2733148441\n              if (Number.isInteger(value) && context.source.endsWith(\".0\")) {\n                return context.source + \"f\";\n              }\n              return value;\n            };\n            // @ts-expect-error : typing\n            this._rootObject = JSON.parse(text, explicitFloatReviver);\n          }\n        }\n        ToDictionary() {\n          return this._rootObject;\n        }\n        ToArray() {\n          return this._rootObject;\n        }\n      }\n      SimpleJson.Reader = Reader;\n      // In C#, this class writes json tokens directly to a StringWriter or\n      // another stream. Here, a temporary hierarchy is created in the form\n      // of a javascript object, which is serialised in the `toString` method.\n      // See individual methods and properties for more information.\n      class Writer {\n        constructor() {\n          // In addition to `_stateStack` present in the original code,\n          // this implementation of SimpleJson use two other stacks and two\n          // temporary variables holding the current context.\n          // Used to keep track of the current property name being built\n          // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n          // `WritePropertyNameEnd`.\n          this._currentPropertyName = null;\n          // Used to keep track of the current string value being built\n          // with `WriteStringStart`, `WriteStringInner` and\n          // `WriteStringEnd`.\n          this._currentString = null;\n          this._stateStack = [];\n          // Keep track of the current collection being built (either an array\n          // or an object). For instance, at the '?' step during the hiarchy\n          // creation, this hierarchy:\n          // [3, {a: [b, ?]}] will have this corresponding stack:\n          // (bottom) [Array, Object, Array] (top)\n          this._collectionStack = [];\n          // Keep track of the current property being assigned. For instance, at\n          // the '?' step during the hiarchy creation, this hierarchy:\n          // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n          // (bottom) [a, c] (top)\n          this._propertyNameStack = [];\n          // Object containing the entire hiearchy.\n          this._jsonObject = null;\n        }\n        WriteObject(inner) {\n          this.WriteObjectStart();\n          inner(this);\n          this.WriteObjectEnd();\n        }\n        // Add a new object.\n        WriteObjectStart() {\n          this.StartNewObject(true);\n          var newObject = {};\n          if (this.state === SimpleJson.Writer.State.Property) {\n            // This object is created as the value of a property,\n            // inside an other object.\n            this.Assert(this.currentCollection !== null);\n            this.Assert(this.currentPropertyName !== null);\n            var propertyName = this._propertyNameStack.pop();\n            this.currentCollection[propertyName] = newObject;\n            this._collectionStack.push(newObject);\n          } else if (this.state === SimpleJson.Writer.State.Array) {\n            // This object is created as the child of an array.\n            this.Assert(this.currentCollection !== null);\n            this.currentCollection.push(newObject);\n            this._collectionStack.push(newObject);\n          } else {\n            // This object is the root object.\n            this.Assert(this.state === SimpleJson.Writer.State.None);\n            this._jsonObject = newObject;\n            this._collectionStack.push(newObject);\n          }\n          this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));\n        }\n        WriteObjectEnd() {\n          this.Assert(this.state === SimpleJson.Writer.State.Object);\n          this._collectionStack.pop();\n          this._stateStack.pop();\n        }\n        // Write a property name / value pair to the current object.\n        WriteProperty(name,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        innerOrContent) {\n          this.WritePropertyStart(name);\n          if (arguments[1] instanceof Function) {\n            var inner = arguments[1];\n            inner(this);\n          } else {\n            var content = arguments[1];\n            this.Write(content);\n          }\n          this.WritePropertyEnd();\n        }\n        // Int and Float are separate calls, since there both are\n        // numbers in JavaScript, but need to be handled differently.\n        WriteIntProperty(name, content) {\n          this.WritePropertyStart(name);\n          this.WriteInt(content);\n          this.WritePropertyEnd();\n        }\n        WriteFloatProperty(name, content) {\n          this.WritePropertyStart(name);\n          this.WriteFloat(content);\n          this.WritePropertyEnd();\n        }\n        // Prepare a new property name, which will be use to add the\n        // new object when calling _addToCurrentObject() from a Write\n        // method.\n        WritePropertyStart(name) {\n          this.Assert(this.state === SimpleJson.Writer.State.Object);\n          this._propertyNameStack.push(name);\n          this.IncrementChildCount();\n          this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));\n        }\n        WritePropertyEnd() {\n          this.Assert(this.state === SimpleJson.Writer.State.Property);\n          this.Assert(this.childCount === 1);\n          this._stateStack.pop();\n        }\n        // Prepare a new property name, except this time, the property name\n        // will be created by concatenating all the strings passed to\n        // WritePropertyNameInner.\n        WritePropertyNameStart() {\n          this.Assert(this.state === SimpleJson.Writer.State.Object);\n          this.IncrementChildCount();\n          this._currentPropertyName = \"\";\n          this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));\n          this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));\n        }\n        WritePropertyNameEnd() {\n          this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n          this.Assert(this._currentPropertyName !== null);\n          this._propertyNameStack.push(this._currentPropertyName);\n          this._currentPropertyName = null;\n          this._stateStack.pop();\n        }\n        WritePropertyNameInner(str) {\n          this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n          this.Assert(this._currentPropertyName !== null);\n          this._currentPropertyName += str;\n        }\n        // Add a new array.\n        WriteArrayStart() {\n          this.StartNewObject(true);\n          var newObject = [];\n          if (this.state === SimpleJson.Writer.State.Property) {\n            // This array is created as the value of a property,\n            // inside an object.\n            this.Assert(this.currentCollection !== null);\n            this.Assert(this.currentPropertyName !== null);\n            var propertyName = this._propertyNameStack.pop();\n            this.currentCollection[propertyName] = newObject;\n            this._collectionStack.push(newObject);\n          } else if (this.state === SimpleJson.Writer.State.Array) {\n            // This array is created as the child of another array.\n            this.Assert(this.currentCollection !== null);\n            this.currentCollection.push(newObject);\n            this._collectionStack.push(newObject);\n          } else {\n            // This array is the root object.\n            this.Assert(this.state === SimpleJson.Writer.State.None);\n            this._jsonObject = newObject;\n            this._collectionStack.push(newObject);\n          }\n          this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));\n        }\n        WriteArrayEnd() {\n          this.Assert(this.state === SimpleJson.Writer.State.Array);\n          this._collectionStack.pop();\n          this._stateStack.pop();\n        }\n        // Add the value to the appropriate collection (array / object), given the current\n        // context.\n        Write(value) {\n          if (value === null) {\n            console.error(\"Warning: trying to write a null value\");\n            return;\n          }\n          this.StartNewObject(false);\n          this._addToCurrentObject(value);\n        }\n        WriteBool(value) {\n          if (value === null) {\n            return;\n          }\n          this.StartNewObject(false);\n          this._addToCurrentObject(value);\n        }\n        WriteInt(value) {\n          if (value === null) {\n            return;\n          }\n          this.StartNewObject(false);\n          // Math.floor is used as a precaution:\n          //     1. to ensure that the value is written as an integer\n          //        (without a fractional part -> 1 instead of 1.0), even\n          //        though it should be the default behaviour of\n          //        JSON.serialize;\n          //     2. to ensure that if a floating number is passed\n          //        accidentally, it's converted to an integer.\n          //\n          // This guarantees savegame compatibility with the reference\n          // implementation.\n          this._addToCurrentObject(Math.floor(value));\n        }\n        // Since JSON doesn't support NaN and Infinity, these values\n        // are converted here.\n        WriteFloat(value) {\n          if (value === null) {\n            return;\n          }\n          this.StartNewObject(false);\n          if (value == Number.POSITIVE_INFINITY) {\n            this._addToCurrentObject(3.4e38);\n          } else if (value == Number.NEGATIVE_INFINITY) {\n            this._addToCurrentObject(-34e37);\n          } else if (isNaN(value)) {\n            this._addToCurrentObject(0.0);\n          } else {\n            this._addToCurrentObject(value);\n          }\n        }\n        WriteNull() {\n          this.StartNewObject(false);\n          this._addToCurrentObject(null);\n        }\n        // Prepare a string before adding it to the current collection in\n        // WriteStringEnd(). The string will be a concatenation of all the\n        // strings passed to WriteStringInner.\n        WriteStringStart() {\n          this.StartNewObject(false);\n          this._currentString = \"\";\n          this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));\n        }\n        WriteStringEnd() {\n          this.Assert(this.state == SimpleJson.Writer.State.String);\n          this._stateStack.pop();\n          this._addToCurrentObject(this._currentString);\n          this._currentString = null;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        WriteStringInner(str) {\n          this.Assert(this.state === SimpleJson.Writer.State.String);\n          if (str === null) {\n            console.error(\"Warning: trying to write a null string\");\n            return;\n          }\n          this._currentString += str;\n        }\n        // Serialise the root object into a JSON string.\n        toString() {\n          if (this._jsonObject === null) {\n            return \"\";\n          }\n          return JSON.stringify(this._jsonObject);\n        }\n        // Prepare the state stack when adding new objects / values.\n        StartNewObject(container) {\n          if (container) {\n            this.Assert(this.state === SimpleJson.Writer.State.None || this.state === SimpleJson.Writer.State.Property || this.state === SimpleJson.Writer.State.Array);\n          } else {\n            this.Assert(this.state === SimpleJson.Writer.State.Property || this.state === SimpleJson.Writer.State.Array);\n          }\n          if (this.state === SimpleJson.Writer.State.Property) {\n            this.Assert(this.childCount === 0);\n          }\n          if (this.state === SimpleJson.Writer.State.Array || this.state === SimpleJson.Writer.State.Property) {\n            this.IncrementChildCount();\n          }\n        }\n        // These getters peek all the different stacks.\n        get state() {\n          if (this._stateStack.length > 0) {\n            return this._stateStack[this._stateStack.length - 1].type;\n          } else {\n            return SimpleJson.Writer.State.None;\n          }\n        }\n        get childCount() {\n          if (this._stateStack.length > 0) {\n            return this._stateStack[this._stateStack.length - 1].childCount;\n          } else {\n            return 0;\n          }\n        }\n        get currentCollection() {\n          if (this._collectionStack.length > 0) {\n            return this._collectionStack[this._collectionStack.length - 1];\n          } else {\n            return null;\n          }\n        }\n        get currentPropertyName() {\n          if (this._propertyNameStack.length > 0) {\n            return this._propertyNameStack[this._propertyNameStack.length - 1];\n          } else {\n            return null;\n          }\n        }\n        IncrementChildCount() {\n          this.Assert(this._stateStack.length > 0);\n          var currEl = this._stateStack.pop();\n          currEl.childCount++;\n          this._stateStack.push(currEl);\n        }\n        Assert(condition) {\n          if (!condition) throw Error(\"Assert failed while writing JSON\");\n        }\n        // This method did not exist in the original C# code. It adds\n        // the given value to the current collection (used by Write methods).\n        _addToCurrentObject(value) {\n          this.Assert(this.currentCollection !== null);\n          if (this.state === SimpleJson.Writer.State.Array) {\n            this.Assert(Array.isArray(this.currentCollection));\n            this.currentCollection.push(value);\n          } else if (this.state === SimpleJson.Writer.State.Property) {\n            this.Assert(!Array.isArray(this.currentCollection));\n            this.Assert(this.currentPropertyName !== null);\n            this.currentCollection[this.currentPropertyName] = value;\n            this._propertyNameStack.pop();\n          }\n        }\n      }\n      SimpleJson.Writer = Writer;\n      (function (Writer) {\n        (function (State) {\n          State[State[\"None\"] = 0] = \"None\";\n          State[State[\"Object\"] = 1] = \"Object\";\n          State[State[\"Array\"] = 2] = \"Array\";\n          State[State[\"Property\"] = 3] = \"Property\";\n          State[State[\"PropertyName\"] = 4] = \"PropertyName\";\n          State[State[\"String\"] = 5] = \"String\";\n        })(Writer.State || (Writer.State = {}));\n        class StateElement {\n          constructor(type) {\n            this.type = SimpleJson.Writer.State.None;\n            this.childCount = 0;\n            this.type = type;\n          }\n        }\n        Writer.StateElement = StateElement;\n      })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));\n    })(SimpleJson$1 || (SimpleJson.SimpleJson = SimpleJson$1 = {}));\n    return SimpleJson;\n  }\n\n  var Flow = {};\n\n  var hasRequiredFlow;\n  function requireFlow() {\n    if (hasRequiredFlow) return Flow;\n    hasRequiredFlow = 1;\n    Object.defineProperty(Flow, \"__esModule\", {\n      value: true\n    });\n    Flow.Flow = void 0;\n    var CallStack_1 = requireCallStack();\n    var JsonSerialisation_1 = requireJsonSerialisation();\n    var NullException_1 = requireNullException();\n    let Flow$1 = class Flow {\n      constructor() {\n        var name = arguments[0];\n        var story = arguments[1];\n        this.name = name;\n        this.callStack = new CallStack_1.CallStack(story);\n        if (arguments[2]) {\n          var jObject = arguments[2];\n          this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n          this.outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"outputStream\"]);\n          this.currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"currentChoices\"]);\n          var jChoiceThreadsObj = jObject[\"choiceThreads\"];\n          if (typeof jChoiceThreadsObj !== \"undefined\") {\n            this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n          }\n        } else {\n          this.outputStream = [];\n          this.currentChoices = [];\n        }\n      }\n      WriteJson(writer) {\n        writer.WriteObjectStart();\n        writer.WriteProperty(\"callstack\", w => this.callStack.WriteJson(w));\n        writer.WriteProperty(\"outputStream\", w => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream));\n        var hasChoiceThreads = false;\n        for (var c of this.currentChoices) {\n          if (c.threadAtGeneration === null) return (0, NullException_1.throwNullException)(\"c.threadAtGeneration\");\n          c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n          if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n            if (!hasChoiceThreads) {\n              hasChoiceThreads = true;\n              writer.WritePropertyStart(\"choiceThreads\");\n              writer.WriteObjectStart();\n            }\n            writer.WritePropertyStart(c.originalThreadIndex);\n            c.threadAtGeneration.WriteJson(writer);\n            writer.WritePropertyEnd();\n          }\n        }\n        if (hasChoiceThreads) {\n          writer.WriteObjectEnd();\n          writer.WritePropertyEnd();\n        }\n        writer.WriteProperty(\"currentChoices\", w => {\n          w.WriteArrayStart();\n          for (var _c of this.currentChoices) {\n            JsonSerialisation_1.JsonSerialisation.WriteChoice(w, _c);\n          }\n          w.WriteArrayEnd();\n        });\n        writer.WriteObjectEnd();\n      }\n      LoadFlowChoiceThreads(jChoiceThreads, story) {\n        for (var choice of this.currentChoices) {\n          var foundActiveThread = this.callStack.ThreadWithIndex(choice.originalThreadIndex);\n          if (foundActiveThread !== null) {\n            choice.threadAtGeneration = foundActiveThread.Copy();\n          } else {\n            var jSavedChoiceThread = jChoiceThreads[\"\".concat(choice.originalThreadIndex)];\n            choice.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, story);\n          }\n        }\n      }\n    };\n    Flow.Flow = Flow$1;\n    return Flow;\n  }\n\n  var hasRequiredStoryState;\n  function requireStoryState() {\n    if (hasRequiredStoryState) return StoryState;\n    hasRequiredStoryState = 1;\n    Object.defineProperty(StoryState, \"__esModule\", {\n      value: true\n    });\n    StoryState.StoryState = void 0;\n    var CallStack_1 = requireCallStack();\n    var VariablesState_1 = requireVariablesState();\n    var Value_1 = requireValue();\n    var PushPop_1 = requirePushPop();\n    var Tag_1 = requireTag$1();\n    var Glue_1 = requireGlue$1();\n    var Path_1 = requirePath$1();\n    var ControlCommand_1 = requireControlCommand();\n    var StringBuilder_1 = requireStringBuilder();\n    var JsonSerialisation_1 = requireJsonSerialisation();\n    var PRNG_1 = requirePRNG();\n    var Void_1 = requireVoid();\n    var Pointer_1 = requirePointer();\n    var TryGetResult_1 = requireTryGetResult();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var Debug_1 = requireDebug();\n    var NullException_1 = requireNullException();\n    var Story_1 = requireStory$1();\n    var StatePatch_1 = requireStatePatch();\n    var SimpleJson_1 = requireSimpleJson();\n    var Flow_1 = requireFlow();\n    var InkList_1 = requireInkList();\n    let StoryState$1 = class StoryState {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      ToJson() {\n        var writer = new SimpleJson_1.SimpleJson.Writer();\n        this.WriteJson(writer);\n        return writer.toString();\n      }\n      toJson() {\n        var indented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        return this.ToJson(indented);\n      }\n      LoadJson(json) {\n        var jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);\n        this.LoadJsonObj(jObject);\n        if (this.onDidLoadState !== null) this.onDidLoadState();\n      }\n      VisitCountAtPathString(pathString) {\n        var visitCountOut;\n        if (this._patch !== null) {\n          var container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;\n          if (container === null) throw new Error(\"Content at path not found: \" + pathString);\n          visitCountOut = this._patch.TryGetVisitCount(container, 0);\n          if (visitCountOut.exists) return visitCountOut.result;\n        }\n        visitCountOut = (0, TryGetResult_1.tryGetValueFromMap)(this._visitCounts, pathString, null);\n        if (visitCountOut.exists) return visitCountOut.result;\n        return 0;\n      }\n      VisitCountForContainer(container) {\n        if (container === null) {\n          return (0, NullException_1.throwNullException)(\"container\");\n        }\n        if (!container.visitsShouldBeCounted) {\n          this.story.Error(\"Read count for target (\" + container.name + \" - on \" + container.debugMetadata + \") unknown. The story may need to be compiled with countAllVisits flag (-c).\");\n          return 0;\n        }\n        if (this._patch !== null) {\n          var count = this._patch.TryGetVisitCount(container, 0);\n          if (count.exists) {\n            return count.result;\n          }\n        }\n        var containerPathStr = container.path.toString();\n        var count2 = (0, TryGetResult_1.tryGetValueFromMap)(this._visitCounts, containerPathStr, null);\n        if (count2.exists) {\n          return count2.result;\n        }\n        return 0;\n      }\n      IncrementVisitCountForContainer(container) {\n        if (this._patch !== null) {\n          var currCount = this.VisitCountForContainer(container);\n          currCount++;\n          this._patch.SetVisitCount(container, currCount);\n          return;\n        }\n        var containerPathStr = container.path.toString();\n        var count = (0, TryGetResult_1.tryGetValueFromMap)(this._visitCounts, containerPathStr, null);\n        if (count.exists) {\n          this._visitCounts.set(containerPathStr, count.result + 1);\n        } else {\n          this._visitCounts.set(containerPathStr, 1);\n        }\n      }\n      RecordTurnIndexVisitToContainer(container) {\n        if (this._patch !== null) {\n          this._patch.SetTurnIndex(container, this.currentTurnIndex);\n          return;\n        }\n        var containerPathStr = container.path.toString();\n        this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n      }\n      TurnsSinceForContainer(container) {\n        if (!container.turnIndexShouldBeCounted) {\n          this.story.Error(\"TURNS_SINCE() for target (\" + container.name + \" - on \" + container.debugMetadata + \") unknown. The story may need to be compiled with countAllVisits flag (-c).\");\n        }\n        if (this._patch !== null) {\n          var index = this._patch.TryGetTurnIndex(container, 0);\n          if (index.exists) {\n            return this.currentTurnIndex - index.result;\n          }\n        }\n        var containerPathStr = container.path.toString();\n        var index2 = (0, TryGetResult_1.tryGetValueFromMap)(this._turnIndices, containerPathStr, 0);\n        if (index2.exists) {\n          return this.currentTurnIndex - index2.result;\n        } else {\n          return -1;\n        }\n      }\n      get callstackDepth() {\n        return this.callStack.depth;\n      }\n      get outputStream() {\n        return this._currentFlow.outputStream;\n      }\n      get currentChoices() {\n        // If we can continue generating text content rather than choices,\n        // then we reflect the choice list as being empty, since choices\n        // should always come at the end.\n        if (this.canContinue) return [];\n        return this._currentFlow.currentChoices;\n      }\n      get generatedChoices() {\n        return this._currentFlow.currentChoices;\n      }\n      get currentErrors() {\n        return this._currentErrors;\n      }\n      get currentWarnings() {\n        return this._currentWarnings;\n      }\n      get variablesState() {\n        return this._variablesState;\n      }\n      set variablesState(value) {\n        this._variablesState = value;\n      }\n      get callStack() {\n        return this._currentFlow.callStack;\n      }\n      get evaluationStack() {\n        return this._evaluationStack;\n      }\n      get currentTurnIndex() {\n        return this._currentTurnIndex;\n      }\n      set currentTurnIndex(value) {\n        this._currentTurnIndex = value;\n      }\n      get currentPathString() {\n        var pointer = this.currentPointer;\n        if (pointer.isNull) {\n          return null;\n        } else {\n          if (pointer.path === null) {\n            return (0, NullException_1.throwNullException)(\"pointer.path\");\n          }\n          return pointer.path.toString();\n        }\n      }\n      get previousPathString() {\n        var pointer = this.previousPointer;\n        if (pointer.isNull) {\n          return null;\n        } else {\n          if (pointer.path === null) {\n            return (0, NullException_1.throwNullException)(\"previousPointer.path\");\n          }\n          return pointer.path.toString();\n        }\n      }\n      get currentPointer() {\n        return this.callStack.currentElement.currentPointer.copy();\n      }\n      set currentPointer(value) {\n        this.callStack.currentElement.currentPointer = value.copy();\n      }\n      get previousPointer() {\n        return this.callStack.currentThread.previousPointer.copy();\n      }\n      set previousPointer(value) {\n        this.callStack.currentThread.previousPointer = value.copy();\n      }\n      get canContinue() {\n        return !this.currentPointer.isNull && !this.hasError;\n      }\n      get hasError() {\n        return this.currentErrors != null && this.currentErrors.length > 0;\n      }\n      get hasWarning() {\n        return this.currentWarnings != null && this.currentWarnings.length > 0;\n      }\n      get currentText() {\n        if (this._outputStreamTextDirty) {\n          var sb = new StringBuilder_1.StringBuilder();\n          var inTag = false;\n          for (var outputObj of this.outputStream) {\n            // var textContent = outputObj as StringValue;\n            var textContent = (0, TypeAssertion_1.asOrNull)(outputObj, Value_1.StringValue);\n            if (!inTag && textContent !== null) {\n              sb.Append(textContent.value);\n            } else {\n              var controlCommand = (0, TypeAssertion_1.asOrNull)(outputObj, ControlCommand_1.ControlCommand);\n              if (controlCommand !== null) {\n                if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n                  inTag = true;\n                } else if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.EndTag) {\n                  inTag = false;\n                }\n              }\n            }\n          }\n          this._currentText = this.CleanOutputWhitespace(sb.toString());\n          this._outputStreamTextDirty = false;\n        }\n        return this._currentText;\n      }\n      CleanOutputWhitespace(str) {\n        var sb = new StringBuilder_1.StringBuilder();\n        var currentWhitespaceStart = -1;\n        var startOfLine = 0;\n        for (var i = 0; i < str.length; i++) {\n          var c = str.charAt(i);\n          var isInlineWhitespace = c == \" \" || c == \"\\t\";\n          if (isInlineWhitespace && currentWhitespaceStart == -1) currentWhitespaceStart = i;\n          if (!isInlineWhitespace) {\n            if (c != \"\\n\" && currentWhitespaceStart > 0 && currentWhitespaceStart != startOfLine) {\n              sb.Append(\" \");\n            }\n            currentWhitespaceStart = -1;\n          }\n          if (c == \"\\n\") startOfLine = i + 1;\n          if (!isInlineWhitespace) sb.Append(c);\n        }\n        return sb.toString();\n      }\n      get currentTags() {\n        if (this._outputStreamTagsDirty) {\n          this._currentTags = [];\n          var inTag = false;\n          var sb = new StringBuilder_1.StringBuilder();\n          for (var outputObj of this.outputStream) {\n            var controlCommand = (0, TypeAssertion_1.asOrNull)(outputObj, ControlCommand_1.ControlCommand);\n            if (controlCommand != null) {\n              if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n                if (inTag && sb.Length > 0) {\n                  var txt = this.CleanOutputWhitespace(sb.toString());\n                  this._currentTags.push(txt);\n                  sb.Clear();\n                }\n                inTag = true;\n              } else if (controlCommand.commandType == ControlCommand_1.ControlCommand.CommandType.EndTag) {\n                if (sb.Length > 0) {\n                  var _txt = this.CleanOutputWhitespace(sb.toString());\n                  this._currentTags.push(_txt);\n                  sb.Clear();\n                }\n                inTag = false;\n              }\n            } else if (inTag) {\n              var strVal = (0, TypeAssertion_1.asOrNull)(outputObj, Value_1.StringValue);\n              if (strVal !== null) {\n                sb.Append(strVal.value);\n              }\n            } else {\n              var tag = (0, TypeAssertion_1.asOrNull)(outputObj, Tag_1.Tag);\n              if (tag != null && tag.text != null && tag.text.length > 0) {\n                this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n              }\n            }\n          }\n          if (sb.Length > 0) {\n            var _txt2 = this.CleanOutputWhitespace(sb.toString());\n            this._currentTags.push(_txt2);\n            sb.Clear();\n          }\n          this._outputStreamTagsDirty = false;\n        }\n        return this._currentTags;\n      }\n      get currentFlowName() {\n        return this._currentFlow.name;\n      }\n      get currentFlowIsDefaultFlow() {\n        return this._currentFlow.name == this.kDefaultFlowName;\n      }\n      get aliveFlowNames() {\n        if (this._aliveFlowNamesDirty) {\n          this._aliveFlowNames = [];\n          if (this._namedFlows != null) {\n            for (var flowName of this._namedFlows.keys()) {\n              if (flowName != this.kDefaultFlowName) {\n                this._aliveFlowNames.push(flowName);\n              }\n            }\n          }\n          this._aliveFlowNamesDirty = false;\n        }\n        return this._aliveFlowNames;\n      }\n      get inExpressionEvaluation() {\n        return this.callStack.currentElement.inExpressionEvaluation;\n      }\n      set inExpressionEvaluation(value) {\n        this.callStack.currentElement.inExpressionEvaluation = value;\n      }\n      constructor(story) {\n        // Backward compatible changes since v8:\n        // v10: dynamic tags\n        // v9:  multi-flows\n        this.kInkSaveStateVersion = 10;\n        this.kMinCompatibleLoadVersion = 8;\n        this.onDidLoadState = null;\n        this._currentErrors = null;\n        this._currentWarnings = null;\n        this.divertedPointer = Pointer_1.Pointer.Null;\n        this._currentTurnIndex = 0;\n        this.storySeed = 0;\n        this.previousRandom = 0;\n        this.didSafeExit = false;\n        this._currentText = null;\n        this._currentTags = null;\n        this._outputStreamTextDirty = true;\n        this._outputStreamTagsDirty = true;\n        this._patch = null;\n        this._aliveFlowNames = null;\n        this._namedFlows = null;\n        this.kDefaultFlowName = \"DEFAULT_FLOW\";\n        this._aliveFlowNamesDirty = true;\n        this.story = story;\n        this._currentFlow = new Flow_1.Flow(this.kDefaultFlowName, story);\n        this.OutputStreamDirty();\n        this._aliveFlowNamesDirty = true;\n        this._evaluationStack = [];\n        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);\n        this._visitCounts = new Map();\n        this._turnIndices = new Map();\n        this.currentTurnIndex = -1;\n        var timeSeed = new Date().getTime();\n        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;\n        this.previousRandom = 0;\n        this.GoToStart();\n      }\n      GoToStart() {\n        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);\n      }\n      SwitchFlow_Internal(flowName) {\n        if (flowName === null) throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n        if (this._namedFlows === null) {\n          this._namedFlows = new Map();\n          this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n        }\n        if (flowName === this._currentFlow.name) {\n          return;\n        }\n        var flow;\n        var content = (0, TryGetResult_1.tryGetValueFromMap)(this._namedFlows, flowName, null);\n        if (content.exists) {\n          flow = content.result;\n        } else {\n          flow = new Flow_1.Flow(flowName, this.story);\n          this._namedFlows.set(flowName, flow);\n          this._aliveFlowNamesDirty = true;\n        }\n        this._currentFlow = flow;\n        this.variablesState.callStack = this._currentFlow.callStack;\n        this.OutputStreamDirty();\n      }\n      SwitchToDefaultFlow_Internal() {\n        if (this._namedFlows === null) return;\n        this.SwitchFlow_Internal(this.kDefaultFlowName);\n      }\n      RemoveFlow_Internal(flowName) {\n        if (flowName === null) throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n        if (flowName === this.kDefaultFlowName) throw new Error(\"Cannot destroy default flow\");\n        if (this._currentFlow.name === flowName) {\n          this.SwitchToDefaultFlow_Internal();\n        }\n        if (this._namedFlows === null) return (0, NullException_1.throwNullException)(\"this._namedFlows\");\n        this._namedFlows.delete(flowName);\n        this._aliveFlowNamesDirty = true;\n      }\n      CopyAndStartPatching(forBackgroundSave) {\n        var copy = new StoryState(this.story);\n        copy._patch = new StatePatch_1.StatePatch(this._patch);\n        copy._currentFlow.name = this._currentFlow.name;\n        copy._currentFlow.callStack = new CallStack_1.CallStack(this._currentFlow.callStack);\n        copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n        copy.OutputStreamDirty();\n        // When background saving we need to make copies of choices since they each have\n        // a snapshot of the thread at the time of generation since the game could progress\n        // significantly and threads modified during the save process.\n        // However, when doing internal saving and restoring of snapshots this isn't an issue,\n        // and we can simply ref-copy the choices with their existing threads.\n        if (forBackgroundSave) {\n          for (var choice of this._currentFlow.currentChoices) {\n            copy._currentFlow.currentChoices.push(choice.Clone());\n          }\n        } else {\n          copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n        }\n        if (this._namedFlows !== null) {\n          copy._namedFlows = new Map();\n          for (var [namedFlowKey, namedFlowValue] of this._namedFlows) {\n            copy._namedFlows.set(namedFlowKey, namedFlowValue);\n            copy._aliveFlowNamesDirty = true;\n          }\n          copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n        }\n        if (this.hasError) {\n          copy._currentErrors = [];\n          copy._currentErrors.push(...(this.currentErrors || []));\n        }\n        if (this.hasWarning) {\n          copy._currentWarnings = [];\n          copy._currentWarnings.push(...(this.currentWarnings || []));\n        }\n        copy.variablesState = this.variablesState;\n        copy.variablesState.callStack = copy.callStack;\n        copy.variablesState.patch = copy._patch;\n        copy.evaluationStack.push(...this.evaluationStack);\n        if (!this.divertedPointer.isNull) copy.divertedPointer = this.divertedPointer.copy();\n        copy.previousPointer = this.previousPointer.copy();\n        copy._visitCounts = this._visitCounts;\n        copy._turnIndices = this._turnIndices;\n        copy.currentTurnIndex = this.currentTurnIndex;\n        copy.storySeed = this.storySeed;\n        copy.previousRandom = this.previousRandom;\n        copy.didSafeExit = this.didSafeExit;\n        return copy;\n      }\n      RestoreAfterPatch() {\n        this.variablesState.callStack = this.callStack;\n        this.variablesState.patch = this._patch;\n      }\n      ApplyAnyPatch() {\n        if (this._patch === null) return;\n        this.variablesState.ApplyPatch();\n        for (var [key, value] of this._patch.visitCounts) this.ApplyCountChanges(key, value, true);\n        for (var [_key, _value] of this._patch.turnIndices) this.ApplyCountChanges(_key, _value, false);\n        this._patch = null;\n      }\n      ApplyCountChanges(container, newCount, isVisit) {\n        var counts = isVisit ? this._visitCounts : this._turnIndices;\n        counts.set(container.path.toString(), newCount);\n      }\n      WriteJson(writer) {\n        writer.WriteObjectStart();\n        writer.WritePropertyStart(\"flows\");\n        writer.WriteObjectStart();\n        // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n        // Call it inside a function to make sure `this` is correctly bound\n        // and passed down the call hierarchy.\n        if (this._namedFlows !== null) {\n          var _loop = function _loop(namedFlowValue) {\n            writer.WriteProperty(namedFlowKey, w => namedFlowValue.WriteJson(w));\n          };\n          for (var [namedFlowKey, namedFlowValue] of this._namedFlows) {\n            _loop(namedFlowValue);\n          }\n        } else {\n          writer.WriteProperty(this._currentFlow.name, w => this._currentFlow.WriteJson(w));\n        }\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n        writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n        writer.WriteProperty(\"variablesState\", w => this.variablesState.WriteJson(w));\n        writer.WriteProperty(\"evalStack\", w => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));\n        if (!this.divertedPointer.isNull) {\n          if (this.divertedPointer.path === null) {\n            return (0, NullException_1.throwNullException)(\"divertedPointer\");\n          }\n          writer.WriteProperty(\"currentDivertTarget\", this.divertedPointer.path.componentsString);\n        }\n        writer.WriteProperty(\"visitCounts\", w => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));\n        writer.WriteProperty(\"turnIndices\", w => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));\n        writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n        writer.WriteIntProperty(\"storySeed\", this.storySeed);\n        writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n        writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n        writer.WriteIntProperty(\"inkFormatVersion\", Story_1.Story.inkVersionCurrent);\n        writer.WriteObjectEnd();\n      }\n      LoadJsonObj(value) {\n        var jObject = value;\n        var jSaveVersion = jObject[\"inkSaveVersion\"];\n        if (jSaveVersion == null) {\n          throw new Error(\"ink save format incorrect, can't load.\");\n        } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n          throw new Error(\"Ink save format isn't compatible with the current version (saw '\" + jSaveVersion + \"', but minimum is \" + this.kMinCompatibleLoadVersion + \"), so can't load.\");\n        }\n        var flowsObj = jObject[\"flows\"];\n        if (flowsObj != null) {\n          var flowsObjDict = flowsObj;\n          // Single default flow\n          if (Object.keys(flowsObjDict).length === 1) {\n            this._namedFlows = null;\n          } else if (this._namedFlows === null) {\n            this._namedFlows = new Map();\n          } else {\n            this._namedFlows.clear();\n          }\n          var flowsObjDictEntries = Object.entries(flowsObjDict);\n          for (var [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n            var name = namedFlowObjKey;\n            var flowObj = namedFlowObjValue;\n            var flow = new Flow_1.Flow(name, this.story, flowObj);\n            if (Object.keys(flowsObjDict).length === 1) {\n              this._currentFlow = new Flow_1.Flow(name, this.story, flowObj);\n            } else {\n              if (this._namedFlows === null) return (0, NullException_1.throwNullException)(\"this._namedFlows\");\n              this._namedFlows.set(name, flow);\n            }\n          }\n          if (this._namedFlows != null && this._namedFlows.size > 1) {\n            var currFlowName = jObject[\"currentFlowName\"];\n            // Adding a bang at the end, because we're trusting the save, as\n            // done in upstream.  If the save is corrupted, the execution\n            // is undefined.\n            this._currentFlow = this._namedFlows.get(currFlowName);\n          }\n        } else {\n          this._namedFlows = null;\n          this._currentFlow.name = this.kDefaultFlowName;\n          this._currentFlow.callStack.SetJsonToken(jObject[\"callstackThreads\"], this.story);\n          this._currentFlow.outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"outputStream\"]);\n          this._currentFlow.currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"currentChoices\"]);\n          var jChoiceThreadsObj = jObject[\"choiceThreads\"];\n          this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n        }\n        this.OutputStreamDirty();\n        this._aliveFlowNamesDirty = true;\n        this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n        this.variablesState.callStack = this._currentFlow.callStack;\n        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject[\"evalStack\"]);\n        var currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n        if (currentDivertTargetPath != null) {\n          var divertPath = new Path_1.Path(currentDivertTargetPath.toString());\n          this.divertedPointer = this.story.PointerAtPath(divertPath);\n        }\n        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject[\"visitCounts\"]);\n        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject[\"turnIndices\"]);\n        this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n        this.storySeed = parseInt(jObject[\"storySeed\"]);\n        this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n      }\n      ResetErrors() {\n        this._currentErrors = null;\n        this._currentWarnings = null;\n      }\n      ResetOutput() {\n        var objs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        this.outputStream.length = 0;\n        if (objs !== null) this.outputStream.push(...objs);\n        this.OutputStreamDirty();\n      }\n      PushToOutputStream(obj) {\n        // var text = obj as StringValue;\n        var text = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n        if (text !== null) {\n          var listText = this.TrySplittingHeadTailWhitespace(text);\n          if (listText !== null) {\n            for (var textObj of listText) {\n              this.PushToOutputStreamIndividual(textObj);\n            }\n            this.OutputStreamDirty();\n            return;\n          }\n        }\n        this.PushToOutputStreamIndividual(obj);\n        this.OutputStreamDirty();\n      }\n      PopFromOutputStream(count) {\n        this.outputStream.splice(this.outputStream.length - count, count);\n        this.OutputStreamDirty();\n      }\n      TrySplittingHeadTailWhitespace(single) {\n        var str = single.value;\n        if (str === null) {\n          return (0, NullException_1.throwNullException)(\"single.value\");\n        }\n        var headFirstNewlineIdx = -1;\n        var headLastNewlineIdx = -1;\n        for (var i = 0; i < str.length; i++) {\n          var c = str[i];\n          if (c == \"\\n\") {\n            if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n            headLastNewlineIdx = i;\n          } else if (c == \" \" || c == \"\\t\") continue;else break;\n        }\n        var tailLastNewlineIdx = -1;\n        var tailFirstNewlineIdx = -1;\n        for (var _i = str.length - 1; _i >= 0; _i--) {\n          var _c = str[_i];\n          if (_c == \"\\n\") {\n            if (tailLastNewlineIdx == -1) tailLastNewlineIdx = _i;\n            tailFirstNewlineIdx = _i;\n          } else if (_c == \" \" || _c == \"\\t\") continue;else break;\n        }\n        // No splitting to be done?\n        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n        var listTexts = [];\n        var innerStrStart = 0;\n        var innerStrEnd = str.length;\n        if (headFirstNewlineIdx != -1) {\n          if (headFirstNewlineIdx > 0) {\n            var leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));\n            listTexts.push(leadingSpaces);\n          }\n          listTexts.push(new Value_1.StringValue(\"\\n\"));\n          innerStrStart = headLastNewlineIdx + 1;\n        }\n        if (tailLastNewlineIdx != -1) {\n          innerStrEnd = tailFirstNewlineIdx;\n        }\n        if (innerStrEnd > innerStrStart) {\n          var innerStrText = str.substring(innerStrStart, innerStrEnd);\n          listTexts.push(new Value_1.StringValue(innerStrText));\n        }\n        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n          listTexts.push(new Value_1.StringValue(\"\\n\"));\n          if (tailLastNewlineIdx < str.length - 1) {\n            var numSpaces = str.length - tailLastNewlineIdx - 1;\n            var trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, tailLastNewlineIdx + 1 + numSpaces));\n            listTexts.push(trailingSpaces);\n          }\n        }\n        return listTexts;\n      }\n      PushToOutputStreamIndividual(obj) {\n        var glue = (0, TypeAssertion_1.asOrNull)(obj, Glue_1.Glue);\n        var text = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n        var includeInOutput = true;\n        if (glue) {\n          this.TrimNewlinesFromOutputStream();\n          includeInOutput = true;\n        } else if (text) {\n          var functionTrimIndex = -1;\n          var currEl = this.callStack.currentElement;\n          if (currEl.type == PushPop_1.PushPopType.Function) {\n            functionTrimIndex = currEl.functionStartInOutputStream;\n          }\n          var glueTrimIndex = -1;\n          for (var i = this.outputStream.length - 1; i >= 0; i--) {\n            var o = this.outputStream[i];\n            var c = o instanceof ControlCommand_1.ControlCommand ? o : null;\n            var g = o instanceof Glue_1.Glue ? o : null;\n            if (g != null) {\n              glueTrimIndex = i;\n              break;\n            } else if (c != null && c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {\n              if (i >= functionTrimIndex) {\n                functionTrimIndex = -1;\n              }\n              break;\n            }\n          }\n          var trimIndex = -1;\n          if (glueTrimIndex != -1 && functionTrimIndex != -1) trimIndex = Math.min(functionTrimIndex, glueTrimIndex);else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;else trimIndex = functionTrimIndex;\n          if (trimIndex != -1) {\n            if (text.isNewline) {\n              includeInOutput = false;\n            } else if (text.isNonWhitespace) {\n              if (glueTrimIndex > -1) this.RemoveExistingGlue();\n              if (functionTrimIndex > -1) {\n                var callStackElements = this.callStack.elements;\n                for (var _i2 = callStackElements.length - 1; _i2 >= 0; _i2--) {\n                  var el = callStackElements[_i2];\n                  if (el.type == PushPop_1.PushPopType.Function) {\n                    el.functionStartInOutputStream = -1;\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          } else if (text.isNewline) {\n            if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent) includeInOutput = false;\n          }\n        }\n        if (includeInOutput) {\n          if (obj === null) {\n            return (0, NullException_1.throwNullException)(\"obj\");\n          }\n          this.outputStream.push(obj);\n          this.OutputStreamDirty();\n        }\n      }\n      TrimNewlinesFromOutputStream() {\n        var removeWhitespaceFrom = -1;\n        var i = this.outputStream.length - 1;\n        while (i >= 0) {\n          var obj = this.outputStream[i];\n          var cmd = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n          var txt = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n          if (cmd != null || txt != null && txt.isNonWhitespace) {\n            break;\n          } else if (txt != null && txt.isNewline) {\n            removeWhitespaceFrom = i;\n          }\n          i--;\n        }\n        // Remove the whitespace\n        if (removeWhitespaceFrom >= 0) {\n          i = removeWhitespaceFrom;\n          while (i < this.outputStream.length) {\n            var text = (0, TypeAssertion_1.asOrNull)(this.outputStream[i], Value_1.StringValue);\n            if (text) {\n              this.outputStream.splice(i, 1);\n            } else {\n              i++;\n            }\n          }\n        }\n        this.OutputStreamDirty();\n      }\n      RemoveExistingGlue() {\n        for (var i = this.outputStream.length - 1; i >= 0; i--) {\n          var c = this.outputStream[i];\n          if (c instanceof Glue_1.Glue) {\n            this.outputStream.splice(i, 1);\n          } else if (c instanceof ControlCommand_1.ControlCommand) {\n            break;\n          }\n        }\n        this.OutputStreamDirty();\n      }\n      get outputStreamEndsInNewline() {\n        if (this.outputStream.length > 0) {\n          for (var i = this.outputStream.length - 1; i >= 0; i--) {\n            var obj = this.outputStream[i];\n            if (obj instanceof ControlCommand_1.ControlCommand) break;\n            var text = this.outputStream[i];\n            if (text instanceof Value_1.StringValue) {\n              if (text.isNewline) return true;else if (text.isNonWhitespace) break;\n            }\n          }\n        }\n        return false;\n      }\n      get outputStreamContainsContent() {\n        for (var content of this.outputStream) {\n          if (content instanceof Value_1.StringValue) return true;\n        }\n        return false;\n      }\n      get inStringEvaluation() {\n        for (var i = this.outputStream.length - 1; i >= 0; i--) {\n          var cmd = (0, TypeAssertion_1.asOrNull)(this.outputStream[i], ControlCommand_1.ControlCommand);\n          if (cmd instanceof ControlCommand_1.ControlCommand && cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {\n            return true;\n          }\n        }\n        return false;\n      }\n      PushEvaluationStack(obj) {\n        // var listValue = obj as ListValue;\n        var listValue = (0, TypeAssertion_1.asOrNull)(obj, Value_1.ListValue);\n        if (listValue) {\n          // Update origin when list is has something to indicate the list origin\n          var rawList = listValue.value;\n          if (rawList === null) {\n            return (0, NullException_1.throwNullException)(\"rawList\");\n          }\n          if (rawList.originNames != null) {\n            if (!rawList.origins) rawList.origins = [];\n            rawList.origins.length = 0;\n            for (var n of rawList.originNames) {\n              if (this.story.listDefinitions === null) return (0, NullException_1.throwNullException)(\"StoryState.story.listDefinitions\");\n              var def = this.story.listDefinitions.TryListGetDefinition(n, null);\n              if (def.result === null) return (0, NullException_1.throwNullException)(\"StoryState def.result\");\n              if (rawList.origins.indexOf(def.result) < 0) rawList.origins.push(def.result);\n            }\n          }\n        }\n        if (obj === null) {\n          return (0, NullException_1.throwNullException)(\"obj\");\n        }\n        this.evaluationStack.push(obj);\n      }\n      PopEvaluationStack(numberOfObjects) {\n        if (typeof numberOfObjects === \"undefined\") {\n          var obj = this.evaluationStack.pop();\n          return (0, TypeAssertion_1.nullIfUndefined)(obj);\n        } else {\n          if (numberOfObjects > this.evaluationStack.length) {\n            throw new Error(\"trying to pop too many objects\");\n          }\n          var popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);\n          return (0, TypeAssertion_1.nullIfUndefined)(popped);\n        }\n      }\n      PeekEvaluationStack() {\n        return this.evaluationStack[this.evaluationStack.length - 1];\n      }\n      ForceEnd() {\n        this.callStack.Reset();\n        this._currentFlow.currentChoices.length = 0;\n        this.currentPointer = Pointer_1.Pointer.Null;\n        this.previousPointer = Pointer_1.Pointer.Null;\n        this.didSafeExit = true;\n      }\n      TrimWhitespaceFromFunctionEnd() {\n        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);\n        var functionStartPoint = this.callStack.currentElement.functionStartInOutputStream;\n        if (functionStartPoint == -1) {\n          functionStartPoint = 0;\n        }\n        for (var i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n          var obj = this.outputStream[i];\n          var txt = (0, TypeAssertion_1.asOrNull)(obj, Value_1.StringValue);\n          var cmd = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n          if (txt == null) continue;\n          if (cmd) break;\n          if (txt.isNewline || txt.isInlineWhitespace) {\n            this.outputStream.splice(i, 1);\n            this.OutputStreamDirty();\n          } else {\n            break;\n          }\n        }\n      }\n      PopCallStack() {\n        var popType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function) this.TrimWhitespaceFromFunctionEnd();\n        this.callStack.Pop(popType);\n      }\n      SetChosenPath(path, incrementingTurnIndex) {\n        // Changing direction, assume we need to clear current set of choices\n        this._currentFlow.currentChoices.length = 0;\n        var newPointer = this.story.PointerAtPath(path);\n        if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n        this.currentPointer = newPointer;\n        if (incrementingTurnIndex) {\n          this.currentTurnIndex++;\n        }\n      }\n      StartFunctionEvaluationFromGame(funcContainer, args) {\n        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);\n        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);\n        this.PassArgumentsToEvaluationStack(args);\n      }\n      PassArgumentsToEvaluationStack(args) {\n        if (args !== null) {\n          for (var i = 0; i < args.length; i++) {\n            if (!(typeof args[i] === \"number\" || typeof args[i] === \"string\" || typeof args[i] === \"boolean\" || args[i] instanceof InkList_1.InkList)) {\n              throw new Error(\"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" + \"number, string, bool or InkList. Argument was \" + ((0, TypeAssertion_1.nullIfUndefined)(args[i]) === null ? \"null\" : args[i].constructor.name));\n            }\n            this.PushEvaluationStack(Value_1.Value.Create(args[i]));\n          }\n        }\n      }\n      TryExitFunctionEvaluationFromGame() {\n        if (this.callStack.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame) {\n          this.currentPointer = Pointer_1.Pointer.Null;\n          this.didSafeExit = true;\n          return true;\n        }\n        return false;\n      }\n      CompleteFunctionEvaluationFromGame() {\n        if (this.callStack.currentElement.type != PushPop_1.PushPopType.FunctionEvaluationFromGame) {\n          throw new Error(\"Expected external function evaluation to be complete. Stack trace: \" + this.callStack.callStackTrace);\n        }\n        var originalEvaluationStackHeight = this.callStack.currentElement.evaluationStackHeightWhenPushed;\n        var returnedObj = null;\n        while (this.evaluationStack.length > originalEvaluationStackHeight) {\n          var poppedObj = this.PopEvaluationStack();\n          if (returnedObj === null) returnedObj = poppedObj;\n        }\n        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);\n        if (returnedObj) {\n          if (returnedObj instanceof Void_1.Void) return null;\n          // Some kind of value, if not void\n          // var returnVal = returnedObj as Runtime.Value;\n          var returnVal = (0, TypeAssertion_1.asOrThrows)(returnedObj, Value_1.Value);\n          // DivertTargets get returned as the string of components\n          // (rather than a Path, which isn't public)\n          if (returnVal.valueType == Value_1.ValueType.DivertTarget) {\n            return \"-> \" + returnVal.valueObject.toString();\n          }\n          // Other types can just have their exact object type:\n          // int, float, string. VariablePointers get returned as strings.\n          return returnVal.valueObject;\n        }\n        return null;\n      }\n      AddError(message, isWarning) {\n        if (!isWarning) {\n          if (this._currentErrors == null) this._currentErrors = [];\n          this._currentErrors.push(message);\n        } else {\n          if (this._currentWarnings == null) this._currentWarnings = [];\n          this._currentWarnings.push(message);\n        }\n      }\n      OutputStreamDirty() {\n        this._outputStreamTextDirty = true;\n        this._outputStreamTagsDirty = true;\n      }\n    };\n    StoryState.StoryState = StoryState$1;\n    return StoryState;\n  }\n\n  var StopWatch = {};\n\n  var hasRequiredStopWatch;\n  function requireStopWatch() {\n    if (hasRequiredStopWatch) return StopWatch;\n    hasRequiredStopWatch = 1;\n    Object.defineProperty(StopWatch, \"__esModule\", {\n      value: true\n    });\n    StopWatch.Stopwatch = void 0;\n    // This is simple replacement of the Stopwatch class from the .NET Framework.\n    // The original class can count time with much more accuracy than the Javascript version.\n    // It might be worth considering using `window.performance` in the browser\n    // or `process.hrtime()` in node.\n    class Stopwatch {\n      constructor() {\n        this.startTime = undefined;\n      }\n      get ElapsedMilliseconds() {\n        if (typeof this.startTime === \"undefined\") {\n          return 0;\n        }\n        return new Date().getTime() - this.startTime;\n      }\n      Start() {\n        this.startTime = new Date().getTime();\n      }\n      Stop() {\n        this.startTime = undefined;\n      }\n    }\n    StopWatch.Stopwatch = Stopwatch;\n    return StopWatch;\n  }\n\n  var _Error = {};\n\n  var hasRequired_Error;\n  function require_Error() {\n    if (hasRequired_Error) return _Error;\n    hasRequired_Error = 1;\n    // TODO: Unify with Compiler.\n    Object.defineProperty(_Error, \"__esModule\", {\n      value: true\n    });\n    _Error.ErrorType = void 0;\n    var ErrorType;\n    (function (ErrorType) {\n      ErrorType[ErrorType[\"Author\"] = 0] = \"Author\";\n      ErrorType[ErrorType[\"Warning\"] = 1] = \"Warning\";\n      ErrorType[ErrorType[\"Error\"] = 2] = \"Error\";\n    })(ErrorType || (_Error.ErrorType = ErrorType = {}));\n    return _Error;\n  }\n\n  var hasRequiredStory$1;\n  function requireStory$1() {\n    if (hasRequiredStory$1) return Story$2;\n    hasRequiredStory$1 = 1;\n    (function (exports) {\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.Story = exports.InkList = void 0;\n      var Container_1 = requireContainer();\n      var Object_1 = require_Object$1();\n      var JsonSerialisation_1 = requireJsonSerialisation();\n      var StoryState_1 = requireStoryState();\n      var ControlCommand_1 = requireControlCommand();\n      var PushPop_1 = requirePushPop();\n      var ChoicePoint_1 = requireChoicePoint();\n      var Choice_1 = requireChoice$1();\n      var Divert_1 = requireDivert$1();\n      var Value_1 = requireValue();\n      var Path_1 = requirePath$1();\n      var Void_1 = requireVoid();\n      var Tag_1 = requireTag$1();\n      var VariableAssignment_1 = requireVariableAssignment$1();\n      var VariableReference_1 = requireVariableReference$1();\n      var NativeFunctionCall_1 = requireNativeFunctionCall();\n      var StoryException_1 = requireStoryException();\n      var PRNG_1 = requirePRNG();\n      var StringBuilder_1 = requireStringBuilder();\n      var ListDefinitionsOrigin_1 = requireListDefinitionsOrigin();\n      var StopWatch_1 = requireStopWatch();\n      var Pointer_1 = requirePointer();\n      var InkList_1 = requireInkList();\n      var TypeAssertion_1 = requireTypeAssertion();\n      var NullException_1 = requireNullException();\n      var SimpleJson_1 = requireSimpleJson();\n      var Error_1 = require_Error();\n      var InkList_2 = requireInkList();\n      Object.defineProperty(exports, \"InkList\", {\n        enumerable: true,\n        get: function get() {\n          return InkList_2.InkList;\n        }\n      });\n      if (!Number.isInteger) {\n        Number.isInteger = function isInteger(nVal) {\n          return typeof nVal === \"number\" && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;\n        };\n      }\n      class Story extends Object_1.InkObject {\n        get currentChoices() {\n          var choices = [];\n          if (this._state === null) {\n            return (0, NullException_1.throwNullException)(\"this._state\");\n          }\n          for (var c of this._state.currentChoices) {\n            if (!c.isInvisibleDefault) {\n              c.index = choices.length;\n              choices.push(c);\n            }\n          }\n          return choices;\n        }\n        get currentText() {\n          this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n          return this.state.currentText;\n        }\n        get currentTags() {\n          this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n          return this.state.currentTags;\n        }\n        get currentErrors() {\n          return this.state.currentErrors;\n        }\n        get currentWarnings() {\n          return this.state.currentWarnings;\n        }\n        get currentFlowName() {\n          return this.state.currentFlowName;\n        }\n        get currentFlowIsDefaultFlow() {\n          return this.state.currentFlowIsDefaultFlow;\n        }\n        get aliveFlowNames() {\n          return this.state.aliveFlowNames;\n        }\n        get hasError() {\n          return this.state.hasError;\n        }\n        get hasWarning() {\n          return this.state.hasWarning;\n        }\n        get variablesState() {\n          return this.state.variablesState;\n        }\n        get listDefinitions() {\n          return this._listDefinitions;\n        }\n        get state() {\n          return this._state;\n        }\n        // TODO: Implement Profiler\n        StartProfiling() {\n          /* */\n        }\n        EndProfiling() {\n          /* */\n        }\n        constructor() {\n          super();\n          this.inkVersionMinimumCompatible = 18;\n          this.onError = null;\n          this.onDidContinue = null;\n          this.onMakeChoice = null;\n          this.onEvaluateFunction = null;\n          this.onCompleteEvaluateFunction = null;\n          this.onChoosePathString = null;\n          this._prevContainers = [];\n          this.allowExternalFunctionFallbacks = false;\n          this._listDefinitions = null;\n          this._variableObservers = null;\n          this._hasValidatedExternals = false;\n          this._temporaryEvaluationContainer = null;\n          this._asyncContinueActive = false;\n          this._stateSnapshotAtLastNewline = null;\n          this._sawLookaheadUnsafeFunctionAfterNewline = false;\n          this._recursiveContinueCount = 0;\n          this._asyncSaving = false;\n          this._profiler = null; // TODO: Profiler\n          // Discrimination between constructors\n          var contentContainer;\n          var lists = null;\n          var json = null;\n          if (arguments[0] instanceof Container_1.Container) {\n            contentContainer = arguments[0];\n            if (typeof arguments[1] !== \"undefined\") {\n              lists = arguments[1];\n            }\n            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n            this._mainContentContainer = contentContainer;\n            // ------\n          } else {\n            if (typeof arguments[0] === \"string\") {\n              var jsonString = arguments[0];\n              json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);\n            } else {\n              json = arguments[0];\n            }\n          }\n          // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n          if (lists != null) this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);\n          this._externals = new Map();\n          // ------\n          // ------ Story(string jsonString) : this((Container)null)\n          if (json !== null) {\n            var rootObject = json;\n            var versionObj = rootObject[\"inkVersion\"];\n            if (versionObj == null) throw new Error(\"ink version number not found. Are you sure it's a valid .ink.json file?\");\n            var formatFromFile = parseInt(versionObj);\n            if (formatFromFile > Story.inkVersionCurrent) {\n              throw new Error(\"Version of ink used to build story was newer than the current version of the engine\");\n            } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n              throw new Error(\"Version of ink used to build story is too old to be loaded by this version of the engine\");\n            } else if (formatFromFile != Story.inkVersionCurrent) {\n              console.warn(\"WARNING: Version of ink \".concat(Story.inkVersionCurrent, \" used to build story doesn't match current version of engine (\").concat(formatFromFile, \"). Non-critical, but recommend synchronising.\"));\n            }\n            var rootToken = rootObject[\"root\"];\n            if (rootToken == null) throw new Error(\"Root node for ink not found. Are you sure it's a valid .ink.json file?\");\n            var listDefsObj;\n            if (listDefsObj = rootObject[\"listDefs\"]) {\n              this._listDefinitions = JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n            }\n            this._mainContentContainer = (0, TypeAssertion_1.asOrThrows)(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);\n            this.ResetState();\n          }\n          // ------\n        }\n        // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n        // Will only return a value if writer was not provided.\n        ToJson(writer) {\n          var shouldReturn = false;\n          if (!writer) {\n            shouldReturn = true;\n            writer = new SimpleJson_1.SimpleJson.Writer();\n          }\n          writer.WriteObjectStart();\n          writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n          writer.WriteProperty(\"root\", w => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));\n          if (this._listDefinitions != null) {\n            writer.WritePropertyStart(\"listDefs\");\n            writer.WriteObjectStart();\n            for (var def of this._listDefinitions.lists) {\n              writer.WritePropertyStart(def.name);\n              writer.WriteObjectStart();\n              for (var [key, value] of def.items) {\n                var item = InkList_1.InkListItem.fromSerializedKey(key);\n                var val = value;\n                writer.WriteIntProperty(item.itemName, val);\n              }\n              writer.WriteObjectEnd();\n              writer.WritePropertyEnd();\n            }\n            writer.WriteObjectEnd();\n            writer.WritePropertyEnd();\n          }\n          writer.WriteObjectEnd();\n          if (shouldReturn) return writer.toString();\n        }\n        ResetState() {\n          this.IfAsyncWeCant(\"ResetState\");\n          this._state = new StoryState_1.StoryState(this);\n          this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));\n          this.ResetGlobals();\n        }\n        ResetErrors() {\n          if (this._state === null) {\n            return (0, NullException_1.throwNullException)(\"this._state\");\n          }\n          this._state.ResetErrors();\n        }\n        ResetCallstack() {\n          this.IfAsyncWeCant(\"ResetCallstack\");\n          if (this._state === null) {\n            return (0, NullException_1.throwNullException)(\"this._state\");\n          }\n          this._state.ForceEnd();\n        }\n        ResetGlobals() {\n          if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n            var originalPointer = this.state.currentPointer.copy();\n            this.ChoosePath(new Path_1.Path(\"global decl\"), false);\n            this.ContinueInternal();\n            this.state.currentPointer = originalPointer;\n          }\n          this.state.variablesState.SnapshotDefaultGlobals();\n        }\n        SwitchFlow(flowName) {\n          this.IfAsyncWeCant(\"switch flow\");\n          if (this._asyncSaving) {\n            throw new Error(\"Story is already in background saving mode, can't switch flow to \" + flowName);\n          }\n          this.state.SwitchFlow_Internal(flowName);\n        }\n        RemoveFlow(flowName) {\n          this.state.RemoveFlow_Internal(flowName);\n        }\n        SwitchToDefaultFlow() {\n          this.state.SwitchToDefaultFlow_Internal();\n        }\n        Continue() {\n          this.ContinueAsync(0);\n          return this.currentText;\n        }\n        get canContinue() {\n          return this.state.canContinue;\n        }\n        get asyncContinueComplete() {\n          return !this._asyncContinueActive;\n        }\n        ContinueAsync(millisecsLimitAsync) {\n          if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n          this.ContinueInternal(millisecsLimitAsync);\n        }\n        ContinueInternal() {\n          var millisecsLimitAsync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          if (this._profiler != null) this._profiler.PreContinue();\n          var isAsyncTimeLimited = millisecsLimitAsync > 0;\n          this._recursiveContinueCount++;\n          if (!this._asyncContinueActive) {\n            this._asyncContinueActive = isAsyncTimeLimited;\n            if (!this.canContinue) {\n              throw new Error(\"Can't continue - should check canContinue before calling Continue\");\n            }\n            this._state.didSafeExit = false;\n            this._state.ResetOutput();\n            if (this._recursiveContinueCount == 1) this._state.variablesState.StartVariableObservation();\n          } else if (this._asyncContinueActive && !isAsyncTimeLimited) {\n            this._asyncContinueActive = false;\n          }\n          var durationStopwatch = new StopWatch_1.Stopwatch();\n          durationStopwatch.Start();\n          var outputStreamEndsInNewline = false;\n          this._sawLookaheadUnsafeFunctionAfterNewline = false;\n          do {\n            try {\n              outputStreamEndsInNewline = this.ContinueSingleStep();\n            } catch (e) {\n              if (!(e instanceof StoryException_1.StoryException)) throw e;\n              this.AddError(e.message, undefined, e.useEndLineNumber);\n              break;\n            }\n            if (outputStreamEndsInNewline) break;\n            if (this._asyncContinueActive && durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {\n              break;\n            }\n          } while (this.canContinue);\n          durationStopwatch.Stop();\n          var changedVariablesToObserve = null;\n          if (outputStreamEndsInNewline || !this.canContinue) {\n            if (this._stateSnapshotAtLastNewline !== null) {\n              this.RestoreStateSnapshot();\n            }\n            if (!this.canContinue) {\n              if (this.state.callStack.canPopThread) this.AddError(\"Thread available to pop, threads should always be flat by the end of evaluation?\");\n              if (this.state.generatedChoices.length == 0 && !this.state.didSafeExit && this._temporaryEvaluationContainer == null) {\n                if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel)) this.AddError(\"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\");else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) this.AddError(\"unexpectedly reached end of content. Do you need a '~ return'?\");else if (!this.state.callStack.canPop) this.AddError(\"ran out of content. Do you need a '-> DONE' or '-> END'?\");else this.AddError(\"unexpectedly reached end of content for unknown reason. Please debug compiler!\");\n              }\n            }\n            this.state.didSafeExit = false;\n            this._sawLookaheadUnsafeFunctionAfterNewline = false;\n            if (this._recursiveContinueCount == 1) changedVariablesToObserve = this._state.variablesState.CompleteVariableObservation();\n            this._asyncContinueActive = false;\n            if (this.onDidContinue !== null) this.onDidContinue();\n          }\n          this._recursiveContinueCount--;\n          if (this._profiler != null) this._profiler.PostContinue();\n          // In the following code, we're masking a lot of non-null assertion,\n          // because testing for against `hasError` or `hasWarning` makes sure\n          // the arrays are present and contain at least one element.\n          if (this.state.hasError || this.state.hasWarning) {\n            if (this.onError !== null) {\n              if (this.state.hasError) {\n                for (var err of this.state.currentErrors) {\n                  this.onError(err, Error_1.ErrorType.Error);\n                }\n              }\n              if (this.state.hasWarning) {\n                for (var _err of this.state.currentWarnings) {\n                  this.onError(_err, Error_1.ErrorType.Warning);\n                }\n              }\n              this.ResetErrors();\n            } else {\n              var sb = new StringBuilder_1.StringBuilder();\n              sb.Append(\"Ink had \");\n              if (this.state.hasError) {\n                sb.Append(\"\".concat(this.state.currentErrors.length));\n                sb.Append(this.state.currentErrors.length == 1 ? \" error\" : \" errors\");\n                if (this.state.hasWarning) sb.Append(\" and \");\n              }\n              if (this.state.hasWarning) {\n                sb.Append(\"\".concat(this.state.currentWarnings.length));\n                sb.Append(this.state.currentWarnings.length == 1 ? \" warning\" : \" warnings\");\n                if (this.state.hasWarning) sb.Append(\" and \");\n              }\n              sb.Append(\". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \");\n              sb.Append(this.state.hasError ? this.state.currentErrors[0] : this.state.currentWarnings[0]);\n              throw new StoryException_1.StoryException(sb.toString());\n            }\n          }\n          if (changedVariablesToObserve != null && Object.keys(changedVariablesToObserve).length > 0) {\n            this._state.variablesState.NotifyObservers(changedVariablesToObserve);\n          }\n        }\n        ContinueSingleStep() {\n          if (this._profiler != null) this._profiler.PreStep();\n          this.Step();\n          if (this._profiler != null) this._profiler.PostStep();\n          if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n            this.TryFollowDefaultInvisibleChoice();\n          }\n          if (this._profiler != null) this._profiler.PreSnapshot();\n          if (!this.state.inStringEvaluation) {\n            if (this._stateSnapshotAtLastNewline !== null) {\n              if (this._stateSnapshotAtLastNewline.currentTags === null) {\n                return (0, NullException_1.throwNullException)(\"this._stateAtLastNewline.currentTags\");\n              }\n              if (this.state.currentTags === null) {\n                return (0, NullException_1.throwNullException)(\"this.state.currentTags\");\n              }\n              var change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);\n              if (change == Story.OutputStateChange.ExtendedBeyondNewline || this._sawLookaheadUnsafeFunctionAfterNewline) {\n                this.RestoreStateSnapshot();\n                return true;\n              } else if (change == Story.OutputStateChange.NewlineRemoved) {\n                this.DiscardSnapshot();\n              }\n            }\n            if (this.state.outputStreamEndsInNewline) {\n              if (this.canContinue) {\n                if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n              } else {\n                this.DiscardSnapshot();\n              }\n            }\n          }\n          if (this._profiler != null) this._profiler.PostSnapshot();\n          return false;\n        }\n        CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {\n          if (prevText === null) {\n            return (0, NullException_1.throwNullException)(\"prevText\");\n          }\n          if (currText === null) {\n            return (0, NullException_1.throwNullException)(\"currText\");\n          }\n          var newlineStillExists = currText.length >= prevText.length && prevText.length > 0 && currText.charAt(prevText.length - 1) == \"\\n\";\n          if (prevTagCount == currTagCount && prevText.length == currText.length && newlineStillExists) return Story.OutputStateChange.NoChange;\n          if (!newlineStillExists) {\n            return Story.OutputStateChange.NewlineRemoved;\n          }\n          if (currTagCount > prevTagCount) return Story.OutputStateChange.ExtendedBeyondNewline;\n          for (var i = prevText.length; i < currText.length; i++) {\n            var c = currText.charAt(i);\n            if (c != \" \" && c != \"\\t\") {\n              return Story.OutputStateChange.ExtendedBeyondNewline;\n            }\n          }\n          return Story.OutputStateChange.NoChange;\n        }\n        ContinueMaximally() {\n          this.IfAsyncWeCant(\"ContinueMaximally\");\n          var sb = new StringBuilder_1.StringBuilder();\n          while (this.canContinue) {\n            sb.Append(this.Continue());\n          }\n          return sb.toString();\n        }\n        ContentAtPath(path) {\n          return this.mainContentContainer.ContentAtPath(path);\n        }\n        KnotContainerWithName(name) {\n          var namedContainer = this.mainContentContainer.namedContent.get(name);\n          if (namedContainer instanceof Container_1.Container) return namedContainer;else return null;\n        }\n        PointerAtPath(path) {\n          if (path.length == 0) return Pointer_1.Pointer.Null;\n          var p = new Pointer_1.Pointer();\n          var pathLengthToUse = path.length;\n          var result = null;\n          if (path.lastComponent === null) {\n            return (0, NullException_1.throwNullException)(\"path.lastComponent\");\n          }\n          if (path.lastComponent.isIndex) {\n            pathLengthToUse = path.length - 1;\n            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);\n            p.container = result.container;\n            p.index = path.lastComponent.index;\n          } else {\n            result = this.mainContentContainer.ContentAtPath(path);\n            p.container = result.container;\n            p.index = -1;\n          }\n          if (result.obj == null || result.obj == this.mainContentContainer && pathLengthToUse > 0) {\n            this.Error(\"Failed to find content at path '\" + path + \"', and no approximation of it was possible.\");\n          } else if (result.approximate) this.Warning(\"Failed to find content at path '\" + path + \"', so it was approximated to: '\" + result.obj.path + \"'.\");\n          return p;\n        }\n        StateSnapshot() {\n          this._stateSnapshotAtLastNewline = this._state;\n          this._state = this._state.CopyAndStartPatching(false);\n        }\n        RestoreStateSnapshot() {\n          if (this._stateSnapshotAtLastNewline === null) {\n            (0, NullException_1.throwNullException)(\"_stateSnapshotAtLastNewline\");\n          }\n          this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n          this._state = this._stateSnapshotAtLastNewline;\n          this._stateSnapshotAtLastNewline = null;\n          if (!this._asyncSaving) {\n            this._state.ApplyAnyPatch();\n          }\n        }\n        DiscardSnapshot() {\n          if (!this._asyncSaving) this._state.ApplyAnyPatch();\n          this._stateSnapshotAtLastNewline = null;\n        }\n        CopyStateForBackgroundThreadSave() {\n          this.IfAsyncWeCant(\"start saving on a background thread\");\n          if (this._asyncSaving) throw new Error(\"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\");\n          var stateToSave = this._state;\n          this._state = this._state.CopyAndStartPatching(true);\n          this._asyncSaving = true;\n          return stateToSave;\n        }\n        BackgroundSaveComplete() {\n          if (this._stateSnapshotAtLastNewline === null) {\n            this._state.ApplyAnyPatch();\n          }\n          this._asyncSaving = false;\n        }\n        Step() {\n          var shouldAddToStream = true;\n          var pointer = this.state.currentPointer.copy();\n          if (pointer.isNull) {\n            return;\n          }\n          // Container containerToEnter = pointer.Resolve () as Container;\n          var containerToEnter = (0, TypeAssertion_1.asOrNull)(pointer.Resolve(), Container_1.Container);\n          while (containerToEnter) {\n            this.VisitContainer(containerToEnter, true);\n            // No content? the most we can do is step past it\n            if (containerToEnter.content.length == 0) {\n              break;\n            }\n            pointer = Pointer_1.Pointer.StartOf(containerToEnter);\n            // containerToEnter = pointer.Resolve() as Container;\n            containerToEnter = (0, TypeAssertion_1.asOrNull)(pointer.Resolve(), Container_1.Container);\n          }\n          this.state.currentPointer = pointer.copy();\n          if (this._profiler != null) this._profiler.Step(this.state.callStack);\n          // Is the current content object:\n          //  - Normal content\n          //  - Or a logic/flow statement - if so, do it\n          // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n          // that was diverted to rather than called as a function)\n          var currentContentObj = pointer.Resolve();\n          var isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);\n          // Has flow been forced to end by flow control above?\n          if (this.state.currentPointer.isNull) {\n            return;\n          }\n          if (isLogicOrFlowControl) {\n            shouldAddToStream = false;\n          }\n          // Choice with condition?\n          // var choicePoint = currentContentObj as ChoicePoint;\n          var choicePoint = (0, TypeAssertion_1.asOrNull)(currentContentObj, ChoicePoint_1.ChoicePoint);\n          if (choicePoint) {\n            var choice = this.ProcessChoice(choicePoint);\n            if (choice) {\n              this.state.generatedChoices.push(choice);\n            }\n            currentContentObj = null;\n            shouldAddToStream = false;\n          }\n          // If the container has no content, then it will be\n          // the \"content\" itself, but we skip over it.\n          if (currentContentObj instanceof Container_1.Container) {\n            shouldAddToStream = false;\n          }\n          // Content to add to evaluation stack or the output stream\n          if (shouldAddToStream) {\n            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n            // to our current (possibly temporary) context index. And make a copy of the pointer\n            // so that we're not editing the original runtime object.\n            // var varPointer = currentContentObj as VariablePointerValue;\n            var varPointer = (0, TypeAssertion_1.asOrNull)(currentContentObj, Value_1.VariablePointerValue);\n            if (varPointer && varPointer.contextIndex == -1) {\n              // Create new object so we're not overwriting the story's own data\n              var contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);\n              currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);\n            }\n            // Expression evaluation content\n            if (this.state.inExpressionEvaluation) {\n              this.state.PushEvaluationStack(currentContentObj);\n            }\n            // Output stream content (i.e. not expression evaluation)\n            else {\n              this.state.PushToOutputStream(currentContentObj);\n            }\n          }\n          // Increment the content pointer, following diverts if necessary\n          this.NextContent();\n          // Starting a thread should be done after the increment to the content pointer,\n          // so that when returning from the thread, it returns to the content after this instruction.\n          // var controlCmd = currentContentObj as ;\n          var controlCmd = (0, TypeAssertion_1.asOrNull)(currentContentObj, ControlCommand_1.ControlCommand);\n          if (controlCmd && controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {\n            this.state.callStack.PushThread();\n          }\n        }\n        VisitContainer(container, atStart) {\n          if (!container.countingAtStartOnly || atStart) {\n            if (container.visitsShouldBeCounted) this.state.IncrementVisitCountForContainer(container);\n            if (container.turnIndexShouldBeCounted) this.state.RecordTurnIndexVisitToContainer(container);\n          }\n        }\n        VisitChangedContainersDueToDivert() {\n          var previousPointer = this.state.previousPointer.copy();\n          var pointer = this.state.currentPointer.copy();\n          if (pointer.isNull || pointer.index == -1) return;\n          this._prevContainers.length = 0;\n          if (!previousPointer.isNull) {\n            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n            var resolvedPreviousAncestor = previousPointer.Resolve();\n            var prevAncestor = (0, TypeAssertion_1.asOrNull)(resolvedPreviousAncestor, Container_1.Container) || (0, TypeAssertion_1.asOrNull)(previousPointer.container, Container_1.Container);\n            while (prevAncestor) {\n              this._prevContainers.push(prevAncestor);\n              // prevAncestor = prevAncestor.parent as Container;\n              prevAncestor = (0, TypeAssertion_1.asOrNull)(prevAncestor.parent, Container_1.Container);\n            }\n          }\n          var currentChildOfContainer = pointer.Resolve();\n          if (currentChildOfContainer == null) return;\n          // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n          var currentContainerAncestor = (0, TypeAssertion_1.asOrNull)(currentChildOfContainer.parent, Container_1.Container);\n          var allChildrenEnteredAtStart = true;\n          while (currentContainerAncestor && (this._prevContainers.indexOf(currentContainerAncestor) < 0 || currentContainerAncestor.countingAtStartOnly)) {\n            // Check whether this ancestor container is being entered at the start,\n            // by checking whether the child object is the first.\n            var enteringAtStart = currentContainerAncestor.content.length > 0 && currentChildOfContainer == currentContainerAncestor.content[0] && allChildrenEnteredAtStart;\n            if (!enteringAtStart) allChildrenEnteredAtStart = false;\n            // Mark a visit to this container\n            this.VisitContainer(currentContainerAncestor, enteringAtStart);\n            currentChildOfContainer = currentContainerAncestor;\n            // currentContainerAncestor = currentContainerAncestor.parent as Container;\n            currentContainerAncestor = (0, TypeAssertion_1.asOrNull)(currentContainerAncestor.parent, Container_1.Container);\n          }\n        }\n        PopChoiceStringAndTags(tags) {\n          var choiceOnlyStrVal = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.StringValue);\n          while (this.state.evaluationStack.length > 0 && (0, TypeAssertion_1.asOrNull)(this.state.PeekEvaluationStack(), Tag_1.Tag) != null) {\n            var tag = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Tag_1.Tag);\n            if (tag) tags.push(tag.text);\n          }\n          return choiceOnlyStrVal.value;\n        }\n        ProcessChoice(choicePoint) {\n          var showChoice = true;\n          // Don't create choice if choice point doesn't pass conditional\n          if (choicePoint.hasCondition) {\n            var conditionValue = this.state.PopEvaluationStack();\n            if (!this.IsTruthy(conditionValue)) {\n              showChoice = false;\n            }\n          }\n          var startText = \"\";\n          var choiceOnlyText = \"\";\n          var tags = [];\n          if (choicePoint.hasChoiceOnlyContent) {\n            choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n          }\n          if (choicePoint.hasStartContent) {\n            startText = this.PopChoiceStringAndTags(tags) || \"\";\n          }\n          // Don't create choice if player has already read this content\n          if (choicePoint.onceOnly) {\n            var visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);\n            if (visitCount > 0) {\n              showChoice = false;\n            }\n          }\n          // We go through the full process of creating the choice above so\n          // that we consume the content for it, since otherwise it'll\n          // be shown on the output stream.\n          if (!showChoice) {\n            return null;\n          }\n          var choice = new Choice_1.Choice();\n          choice.targetPath = choicePoint.pathOnChoice;\n          choice.sourcePath = choicePoint.path.toString();\n          choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n          choice.threadAtGeneration = this.state.callStack.ForkThread();\n          choice.tags = tags.reverse(); //C# is a stack\n          choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n          return choice;\n        }\n        IsTruthy(obj) {\n          var truthy = false;\n          if (obj instanceof Value_1.Value) {\n            var val = obj;\n            if (val instanceof Value_1.DivertTargetValue) {\n              var divTarget = val;\n              this.Error(\"Shouldn't use a divert target (to \" + divTarget.targetPath + \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\");\n              return false;\n            }\n            return val.isTruthy;\n          }\n          return truthy;\n        }\n        PerformLogicAndFlowControl(contentObj) {\n          if (contentObj == null) {\n            return false;\n          }\n          // Divert\n          if (contentObj instanceof Divert_1.Divert) {\n            var currentDivert = contentObj;\n            if (currentDivert.isConditional) {\n              var conditionValue = this.state.PopEvaluationStack();\n              // False conditional? Cancel divert\n              if (!this.IsTruthy(conditionValue)) return true;\n            }\n            if (currentDivert.hasVariableTarget) {\n              var varName = currentDivert.variableDivertName;\n              var varContents = this.state.variablesState.GetVariableWithName(varName);\n              if (varContents == null) {\n                this.Error(\"Tried to divert using a target from a variable that could not be found (\" + varName + \")\");\n              } else if (!(varContents instanceof Value_1.DivertTargetValue)) {\n                // var intContent = varContents as IntValue;\n                var intContent = (0, TypeAssertion_1.asOrNull)(varContents, Value_1.IntValue);\n                var errorMessage = \"Tried to divert to a target from a variable, but the variable (\" + varName + \") didn't contain a divert target, it \";\n                if (intContent instanceof Value_1.IntValue && intContent.value == 0) {\n                  errorMessage += \"was empty/null (the value 0).\";\n                } else {\n                  errorMessage += \"contained '\" + varContents + \"'.\";\n                }\n                this.Error(errorMessage);\n              }\n              var target = (0, TypeAssertion_1.asOrThrows)(varContents, Value_1.DivertTargetValue);\n              this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n            } else if (currentDivert.isExternal) {\n              this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);\n              return true;\n            } else {\n              this.state.divertedPointer = currentDivert.targetPointer.copy();\n            }\n            if (currentDivert.pushesToStack) {\n              this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);\n            }\n            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n              if (currentDivert && currentDivert.debugMetadata && currentDivert.debugMetadata.sourceName != null) {\n                this.Error(\"Divert target doesn't exist: \" + currentDivert.debugMetadata.sourceName);\n              } else {\n                this.Error(\"Divert resolution failed: \" + currentDivert);\n              }\n            }\n            return true;\n          }\n          // Start/end an expression evaluation? Or print out the result?\n          else if (contentObj instanceof ControlCommand_1.ControlCommand) {\n            var evalCommand = contentObj;\n            switch (evalCommand.commandType) {\n              case ControlCommand_1.ControlCommand.CommandType.EvalStart:\n                this.Assert(this.state.inExpressionEvaluation === false, \"Already in expression evaluation?\");\n                this.state.inExpressionEvaluation = true;\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.EvalEnd:\n                this.Assert(this.state.inExpressionEvaluation === true, \"Not in expression evaluation mode\");\n                this.state.inExpressionEvaluation = false;\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.EvalOutput:\n                // If the expression turned out to be empty, there may not be anything on the stack\n                if (this.state.evaluationStack.length > 0) {\n                  var output = this.state.PopEvaluationStack();\n                  // Functions may evaluate to Void, in which case we skip output\n                  if (!(output instanceof Void_1.Void)) {\n                    // TODO: Should we really always blanket convert to string?\n                    // It would be okay to have numbers in the output stream the\n                    // only problem is when exporting text for viewing, it skips over numbers etc.\n                    var text = new Value_1.StringValue(output.toString());\n                    this.state.PushToOutputStream(text);\n                  }\n                }\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.NoOp:\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.Duplicate:\n                this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:\n                this.state.PopEvaluationStack();\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.PopFunction:\n              case ControlCommand_1.ControlCommand.CommandType.PopTunnel:\n                var popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction ? PushPop_1.PushPopType.Function : PushPop_1.PushPopType.Tunnel;\n                var overrideTunnelReturnTarget = null;\n                if (popType == PushPop_1.PushPopType.Tunnel) {\n                  var popped = this.state.PopEvaluationStack();\n                  // overrideTunnelReturnTarget = popped as DivertTargetValue;\n                  overrideTunnelReturnTarget = (0, TypeAssertion_1.asOrNull)(popped, Value_1.DivertTargetValue);\n                  if (overrideTunnelReturnTarget === null) {\n                    this.Assert(popped instanceof Void_1.Void, \"Expected void if ->-> doesn't override target\");\n                  }\n                }\n                if (this.state.TryExitFunctionEvaluationFromGame()) {\n                  break;\n                } else if (this.state.callStack.currentElement.type != popType || !this.state.callStack.canPop) {\n                  var names = new Map();\n                  names.set(PushPop_1.PushPopType.Function, \"function return statement (~ return)\");\n                  names.set(PushPop_1.PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n                  var expected = names.get(this.state.callStack.currentElement.type);\n                  if (!this.state.callStack.canPop) {\n                    expected = \"end of flow (-> END or choice)\";\n                  }\n                  var errorMsg = \"Found \" + names.get(popType) + \", when expected \" + expected;\n                  this.Error(errorMsg);\n                } else {\n                  this.state.PopCallStack();\n                  if (overrideTunnelReturnTarget) this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);\n                }\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.BeginString:\n                this.state.PushToOutputStream(evalCommand);\n                this.Assert(this.state.inExpressionEvaluation === true, \"Expected to be in an expression when evaluating a string\");\n                this.state.inExpressionEvaluation = false;\n                break;\n              // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n              // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n              // to try and flatten dynamic tags to strings every time \\n is pushed to output\n              case ControlCommand_1.ControlCommand.CommandType.BeginTag:\n                this.state.PushToOutputStream(evalCommand);\n                break;\n              // EndTag has 2 modes:\n              //  - When in string evaluation (for choices)\n              //  - Normal\n              //\n              // The only way you could have an EndTag in the middle of\n              // string evaluation is if we're currently generating text for a\n              // choice, such as:\n              //\n              //   + choice # tag\n              //\n              // In the above case, the ink will be run twice:\n              //  - First, to generate the choice text. String evaluation\n              //    will be on, and the final string will be pushed to the\n              //    evaluation stack, ready to be popped to make a Choice\n              //    object.\n              //  - Second, when ink generates text after choosing the choice.\n              //    On this ocassion, it's not in string evaluation mode.\n              //\n              // On the writing side, we disallow manually putting tags within\n              // strings like this:\n              //\n              //   {\"hello # world\"}\n              //\n              // So we know that the tag must be being generated as part of\n              // choice content. Therefore, when the tag has been generated,\n              // we push it onto the evaluation stack in the exact same way\n              // as the string for the choice content.\n              case ControlCommand_1.ControlCommand.CommandType.EndTag:\n                {\n                  if (this.state.inStringEvaluation) {\n                    var contentStackForTag = [];\n                    var outputCountConsumed = 0;\n                    for (var i = this.state.outputStream.length - 1; i >= 0; --i) {\n                      var obj = this.state.outputStream[i];\n                      outputCountConsumed++;\n                      // var command = obj as ControlCommand;\n                      var command = (0, TypeAssertion_1.asOrNull)(obj, ControlCommand_1.ControlCommand);\n                      if (command != null) {\n                        if (command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n                          break;\n                        } else {\n                          this.Error(\"Unexpected ControlCommand while extracting tag from choice\");\n                          break;\n                        }\n                      }\n                      if (obj instanceof Value_1.StringValue) {\n                        contentStackForTag.push(obj);\n                      }\n                    }\n                    // Consume the content that was produced for this string\n                    this.state.PopFromOutputStream(outputCountConsumed);\n                    // Build string out of the content we collected\n                    var sb = new StringBuilder_1.StringBuilder();\n                    for (var strVal of contentStackForTag.reverse()) {\n                      sb.Append(strVal.toString());\n                    }\n                    var choiceTag = new Tag_1.Tag(this.state.CleanOutputWhitespace(sb.toString()));\n                    // Pushing to the evaluation stack means it gets picked up\n                    // when a Choice is generated from the next Choice Point.\n                    this.state.PushEvaluationStack(choiceTag);\n                  } else {\n                    // Otherwise! Simply push EndTag, so that in the output stream we\n                    // have a structure of: [BeginTag, \"the tag content\", EndTag]\n                    this.state.PushToOutputStream(evalCommand);\n                  }\n                  break;\n                }\n              case ControlCommand_1.ControlCommand.CommandType.EndString:\n                {\n                  var contentStackForString = [];\n                  var contentToRetain = [];\n                  var _outputCountConsumed = 0;\n                  for (var _i = this.state.outputStream.length - 1; _i >= 0; --_i) {\n                    var _obj = this.state.outputStream[_i];\n                    _outputCountConsumed++;\n                    // var command = obj as ControlCommand;\n                    var _command = (0, TypeAssertion_1.asOrNull)(_obj, ControlCommand_1.ControlCommand);\n                    if (_command && _command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {\n                      break;\n                    }\n                    if (_obj instanceof Tag_1.Tag) {\n                      contentToRetain.push(_obj);\n                    }\n                    if (_obj instanceof Value_1.StringValue) {\n                      contentStackForString.push(_obj);\n                    }\n                  }\n                  // Consume the content that was produced for this string\n                  this.state.PopFromOutputStream(_outputCountConsumed);\n                  // Rescue the tags that we want actually to keep on the output stack\n                  // rather than consume as part of the string we're building.\n                  // At the time of writing, this only applies to Tag objects generated\n                  // by choices, which are pushed to the stack during string generation.\n                  for (var rescuedTag of contentToRetain) this.state.PushToOutputStream(rescuedTag);\n                  // The C# version uses a Stack for contentStackForString, but we're\n                  // using a simple array, so we need to reverse it before using it\n                  contentStackForString = contentStackForString.reverse();\n                  // Build string out of the content we collected\n                  var _sb = new StringBuilder_1.StringBuilder();\n                  for (var c of contentStackForString) {\n                    _sb.Append(c.toString());\n                  }\n                  // Return to expression evaluation (from content mode)\n                  this.state.inExpressionEvaluation = true;\n                  this.state.PushEvaluationStack(new Value_1.StringValue(_sb.toString()));\n                  break;\n                }\n              case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:\n                var choiceCount = this.state.generatedChoices.length;\n                this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.Turns:\n                this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.TurnsSince:\n              case ControlCommand_1.ControlCommand.CommandType.ReadCount:\n                var _target = this.state.PopEvaluationStack();\n                if (!(_target instanceof Value_1.DivertTargetValue)) {\n                  var extraNote = \"\";\n                  if (_target instanceof Value_1.IntValue) extraNote = \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n                  this.Error(\"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" + _target + extraNote);\n                  break;\n                }\n                // var divertTarget = target as DivertTargetValue;\n                var divertTarget = (0, TypeAssertion_1.asOrThrows)(_target, Value_1.DivertTargetValue);\n                // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n                var container = (0, TypeAssertion_1.asOrNull)(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);\n                var eitherCount;\n                if (container != null) {\n                  if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince) eitherCount = this.state.TurnsSinceForContainer(container);else eitherCount = this.state.VisitCountForContainer(container);\n                } else {\n                  if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince) eitherCount = -1;else eitherCount = 0;\n                  this.Warning(\"Failed to find container for \" + evalCommand.toString() + \" lookup at \" + divertTarget.targetPath.toString());\n                }\n                this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.Random:\n                {\n                  var maxInt = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n                  var minInt = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n                  if (minInt == null || minInt instanceof Value_1.IntValue === false) return this.Error(\"Invalid value for minimum parameter of RANDOM(min, max)\");\n                  if (maxInt == null || maxInt instanceof Value_1.IntValue === false) return this.Error(\"Invalid value for maximum parameter of RANDOM(min, max)\");\n                  // Originally a primitive type, but here, can be null.\n                  // TODO: Replace by default value?\n                  if (maxInt.value === null) {\n                    return (0, NullException_1.throwNullException)(\"maxInt.value\");\n                  }\n                  if (minInt.value === null) {\n                    return (0, NullException_1.throwNullException)(\"minInt.value\");\n                  }\n                  // This code is differs a bit from the reference implementation, since\n                  // JavaScript has no true integers. Hence integer arithmetics and\n                  // interger overflows don't apply here. A loss of precision can\n                  // happen with big numbers however.\n                  //\n                  // The case where 'randomRange' is lower than zero is handled below,\n                  // so there's no need to test against Number.MIN_SAFE_INTEGER.\n                  var randomRange = maxInt.value - minInt.value + 1;\n                  if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n                    randomRange = Number.MAX_SAFE_INTEGER;\n                    this.Error(\"RANDOM was called with a range that exceeds the size that ink numbers can use.\");\n                  }\n                  if (randomRange <= 0) this.Error(\"RANDOM was called with minimum as \" + minInt.value + \" and maximum as \" + maxInt.value + \". The maximum must be larger\");\n                  var resultSeed = this.state.storySeed + this.state.previousRandom;\n                  var random = new PRNG_1.PRNG(resultSeed);\n                  var nextRandom = random.next();\n                  var chosenValue = nextRandom % randomRange + minInt.value;\n                  this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));\n                  // Next random number (rather than keeping the Random object around)\n                  this.state.previousRandom = nextRandom;\n                  break;\n                }\n              case ControlCommand_1.ControlCommand.CommandType.SeedRandom:\n                var seed = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n                if (seed == null || seed instanceof Value_1.IntValue === false) return this.Error(\"Invalid value passed to SEED_RANDOM\");\n                // Originally a primitive type, but here, can be null.\n                // TODO: Replace by default value?\n                if (seed.value === null) {\n                  return (0, NullException_1.throwNullException)(\"minInt.value\");\n                }\n                this.state.storySeed = seed.value;\n                this.state.previousRandom = 0;\n                this.state.PushEvaluationStack(new Void_1.Void());\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.VisitIndex:\n                var count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count\n                this.state.PushEvaluationStack(new Value_1.IntValue(count));\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:\n                var shuffleIndex = this.NextSequenceShuffleIndex();\n                this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.StartThread:\n                // Handled in main step function\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.Done:\n                // We may exist in the context of the initial\n                // act of creating the thread, or in the context of\n                // evaluating the content.\n                if (this.state.callStack.canPopThread) {\n                  this.state.callStack.PopThread();\n                }\n                // In normal flow - allow safe exit without warning\n                else {\n                  this.state.didSafeExit = true;\n                  // Stop flow in current thread\n                  this.state.currentPointer = Pointer_1.Pointer.Null;\n                }\n                break;\n              // Force flow to end completely\n              case ControlCommand_1.ControlCommand.CommandType.End:\n                this.state.ForceEnd();\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.ListFromInt:\n                // var intVal = state.PopEvaluationStack () as IntValue;\n                var intVal = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n                // var listNameVal = state.PopEvaluationStack () as StringValue;\n                var listNameVal = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.StringValue);\n                if (intVal === null) {\n                  throw new StoryException_1.StoryException(\"Passed non-integer when creating a list element from a numerical value.\");\n                }\n                var generatedListValue = null;\n                if (this.listDefinitions === null) {\n                  return (0, NullException_1.throwNullException)(\"this.listDefinitions\");\n                }\n                var foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);\n                if (foundListDef.exists) {\n                  // Originally a primitive type, but here, can be null.\n                  // TODO: Replace by default value?\n                  if (intVal.value === null) {\n                    return (0, NullException_1.throwNullException)(\"minInt.value\");\n                  }\n                  var foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);\n                  if (foundItem.exists) {\n                    generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);\n                  }\n                } else {\n                  throw new StoryException_1.StoryException(\"Failed to find LIST called \" + listNameVal.value);\n                }\n                if (generatedListValue == null) generatedListValue = new Value_1.ListValue();\n                this.state.PushEvaluationStack(generatedListValue);\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.ListRange:\n                var max = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.Value);\n                var min = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.Value);\n                // var targetList = state.PopEvaluationStack () as ListValue;\n                var targetList = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.ListValue);\n                if (targetList === null || min === null || max === null) throw new StoryException_1.StoryException(\"Expected list, minimum and maximum for LIST_RANGE\");\n                if (targetList.value === null) {\n                  return (0, NullException_1.throwNullException)(\"targetList.value\");\n                }\n                var result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);\n                this.state.PushEvaluationStack(new Value_1.ListValue(result));\n                break;\n              case ControlCommand_1.ControlCommand.CommandType.ListRandom:\n                {\n                  var listVal = this.state.PopEvaluationStack();\n                  if (listVal === null) throw new StoryException_1.StoryException(\"Expected list for LIST_RANDOM\");\n                  var list = listVal.value;\n                  var newList = null;\n                  if (list === null) {\n                    throw (0, NullException_1.throwNullException)(\"list\");\n                  }\n                  if (list.Count == 0) {\n                    newList = new InkList_1.InkList();\n                  } else {\n                    // Generate a random index for the element to take\n                    var _resultSeed = this.state.storySeed + this.state.previousRandom;\n                    var _random = new PRNG_1.PRNG(_resultSeed);\n                    var _nextRandom = _random.next();\n                    var listItemIndex = _nextRandom % list.Count;\n                    // This bit is a little different from the original\n                    // C# code, since iterators do not work in the same way.\n                    // First, we iterate listItemIndex - 1 times, calling next().\n                    // The listItemIndex-th time is made outside of the loop,\n                    // in order to retrieve the value.\n                    var listEnumerator = list.entries();\n                    for (var _i2 = 0; _i2 <= listItemIndex - 1; _i2++) {\n                      listEnumerator.next();\n                    }\n                    var value = listEnumerator.next().value;\n                    var randomItem = {\n                      Key: InkList_1.InkListItem.fromSerializedKey(value[0]),\n                      Value: value[1]\n                    };\n                    // Origin list is simply the origin of the one element\n                    if (randomItem.Key.originName === null) {\n                      return (0, NullException_1.throwNullException)(\"randomItem.Key.originName\");\n                    }\n                    newList = new InkList_1.InkList(randomItem.Key.originName, this);\n                    newList.Add(randomItem.Key, randomItem.Value);\n                    this.state.previousRandom = _nextRandom;\n                  }\n                  this.state.PushEvaluationStack(new Value_1.ListValue(newList));\n                  break;\n                }\n              default:\n                this.Error(\"unhandled ControlCommand: \" + evalCommand);\n                break;\n            }\n            return true;\n          }\n          // Variable assignment\n          else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {\n            var varAss = contentObj;\n            var assignedVal = this.state.PopEvaluationStack();\n            this.state.variablesState.Assign(varAss, assignedVal);\n            return true;\n          }\n          // Variable reference\n          else if (contentObj instanceof VariableReference_1.VariableReference) {\n            var varRef = contentObj;\n            var foundValue = null;\n            // Explicit read count value\n            if (varRef.pathForCount != null) {\n              var _container = varRef.containerForCount;\n              var _count = this.state.VisitCountForContainer(_container);\n              foundValue = new Value_1.IntValue(_count);\n            }\n            // Normal variable reference\n            else {\n              foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n              if (foundValue == null) {\n                this.Warning(\"Variable not found: '\" + varRef.name + \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\");\n                foundValue = new Value_1.IntValue(0);\n              }\n            }\n            this.state.PushEvaluationStack(foundValue);\n            return true;\n          }\n          // Native function call\n          else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {\n            var func = contentObj;\n            var funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n            var _result = func.Call(funcParams);\n            this.state.PushEvaluationStack(_result);\n            return true;\n          }\n          // No control content, must be ordinary content\n          return false;\n        }\n        ChoosePathString(path) {\n          var resetCallstack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n          this.IfAsyncWeCant(\"call ChoosePathString right now\");\n          if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n          if (resetCallstack) {\n            this.ResetCallstack();\n          } else {\n            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {\n              var funcDetail = \"\";\n              var container = this.state.callStack.currentElement.currentPointer.container;\n              if (container != null) {\n                funcDetail = \"(\" + container.path.toString() + \") \";\n              }\n              throw new Error(\"Story was running a function \" + funcDetail + \"when you called ChoosePathString(\" + path + \") - this is almost certainly not not what you want! Full stack trace: \\n\" + this.state.callStack.callStackTrace);\n            }\n          }\n          this.state.PassArgumentsToEvaluationStack(args);\n          this.ChoosePath(new Path_1.Path(path));\n        }\n        IfAsyncWeCant(activityStr) {\n          if (this._asyncContinueActive) throw new Error(\"Can't \" + activityStr + \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\");\n        }\n        ChoosePath(p) {\n          var incrementingTurnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          this.state.SetChosenPath(p, incrementingTurnIndex);\n          // Take a note of newly visited containers for read counts etc\n          this.VisitChangedContainersDueToDivert();\n        }\n        ChooseChoiceIndex(choiceIdx) {\n          choiceIdx = choiceIdx;\n          var choices = this.currentChoices;\n          this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, \"choice out of range\");\n          var choiceToChoose = choices[choiceIdx];\n          if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n          if (choiceToChoose.threadAtGeneration === null) {\n            return (0, NullException_1.throwNullException)(\"choiceToChoose.threadAtGeneration\");\n          }\n          if (choiceToChoose.targetPath === null) {\n            return (0, NullException_1.throwNullException)(\"choiceToChoose.targetPath\");\n          }\n          this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n          this.ChoosePath(choiceToChoose.targetPath);\n        }\n        HasFunction(functionName) {\n          try {\n            return this.KnotContainerWithName(functionName) != null;\n          } catch (e) {\n            return false;\n          }\n        }\n        EvaluateFunction(functionName) {\n          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          var returnTextOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          // EvaluateFunction behaves slightly differently than the C# version.\n          // In C#, you can pass a (second) parameter `out textOutput` to get the\n          // text outputted by the function. This is not possible in js. Instead,\n          // we maintain the regular signature (functionName, args), plus an\n          // optional third parameter returnTextOutput. If set to true, we will\n          // return both the textOutput and the returned value, as an object.\n          if (this.onEvaluateFunction !== null) this.onEvaluateFunction(functionName, args);\n          this.IfAsyncWeCant(\"evaluate a function\");\n          if (functionName == null) {\n            throw new Error(\"Function is null\");\n          } else if (functionName == \"\" || functionName.trim() == \"\") {\n            throw new Error(\"Function is empty or white space.\");\n          }\n          var funcContainer = this.KnotContainerWithName(functionName);\n          if (funcContainer == null) {\n            throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n          }\n          var outputStreamBefore = [];\n          outputStreamBefore.push(...this.state.outputStream);\n          this._state.ResetOutput();\n          this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n          // Evaluate the function, and collect the string output\n          var stringOutput = new StringBuilder_1.StringBuilder();\n          while (this.canContinue) {\n            stringOutput.Append(this.Continue());\n          }\n          var textOutput = stringOutput.toString();\n          this._state.ResetOutput(outputStreamBefore);\n          var result = this.state.CompleteFunctionEvaluationFromGame();\n          if (this.onCompleteEvaluateFunction != null) this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n          return returnTextOutput ? {\n            returned: result,\n            output: textOutput\n          } : result;\n        }\n        EvaluateExpression(exprContainer) {\n          var startCallStackHeight = this.state.callStack.elements.length;\n          this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);\n          this._temporaryEvaluationContainer = exprContainer;\n          this.state.GoToStart();\n          var evalStackHeight = this.state.evaluationStack.length;\n          this.Continue();\n          this._temporaryEvaluationContainer = null;\n          // Should have fallen off the end of the Container, which should\n          // have auto-popped, but just in case we didn't for some reason,\n          // manually pop to restore the state (including currentPath).\n          if (this.state.callStack.elements.length > startCallStackHeight) {\n            this.state.PopCallStack();\n          }\n          var endStackHeight = this.state.evaluationStack.length;\n          if (endStackHeight > evalStackHeight) {\n            return this.state.PopEvaluationStack();\n          } else {\n            return null;\n          }\n        }\n        CallExternalFunction(funcName, numberOfArguments) {\n          if (funcName === null) {\n            return (0, NullException_1.throwNullException)(\"funcName\");\n          }\n          var funcDef = this._externals.get(funcName);\n          var fallbackFunctionContainer = null;\n          var foundExternal = typeof funcDef !== \"undefined\";\n          if (foundExternal && !funcDef.lookAheadSafe && this._state.inStringEvaluation) {\n            this.Error(\"External function \" + funcName + ' could not be called because 1) it wasn\\'t marked as lookaheadSafe when BindExternalFunction was called and 2) the story is in the middle of string generation, either because choice text is being generated, or because you have ink like \"hello {func()}\". You can work around this by generating the result of your function into a temporary variable before the string or choice gets generated: ~ temp x = ' + funcName + \"()\");\n          }\n          if (foundExternal && !funcDef.lookAheadSafe && this._stateSnapshotAtLastNewline !== null) {\n            this._sawLookaheadUnsafeFunctionAfterNewline = true;\n            return;\n          }\n          if (!foundExternal) {\n            if (this.allowExternalFunctionFallbacks) {\n              fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n              this.Assert(fallbackFunctionContainer !== null, \"Trying to call EXTERNAL function '\" + funcName + \"' which has not been bound, and fallback ink function could not be found.\");\n              // Divert direct into fallback function and we're done\n              this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);\n              this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);\n              return;\n            } else {\n              this.Assert(false, \"Trying to call EXTERNAL function '\" + funcName + \"' which has not been bound (and ink fallbacks disabled).\");\n            }\n          }\n          // Pop arguments\n          var args = [];\n          for (var i = 0; i < numberOfArguments; ++i) {\n            // var poppedObj = state.PopEvaluationStack () as Value;\n            var poppedObj = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.Value);\n            var valueObj = poppedObj.valueObject;\n            args.push(valueObj);\n          }\n          // Reverse arguments from the order they were popped,\n          // so they're the right way round again.\n          args.reverse();\n          // Run the function!\n          var funcResult = funcDef.function(args);\n          // Convert return value (if any) to the a type that the ink engine can use\n          var returnObj = null;\n          if (funcResult != null) {\n            returnObj = Value_1.Value.Create(funcResult);\n            this.Assert(returnObj !== null, \"Could not create ink value from returned object of type \" + typeof funcResult);\n          } else {\n            returnObj = new Void_1.Void();\n          }\n          this.state.PushEvaluationStack(returnObj);\n        }\n        BindExternalFunctionGeneral(funcName, func) {\n          var lookaheadSafe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n          this.IfAsyncWeCant(\"bind an external function\");\n          this.Assert(!this._externals.has(funcName), \"Function '\" + funcName + \"' has already been bound.\");\n          this._externals.set(funcName, {\n            function: func,\n            lookAheadSafe: lookaheadSafe\n          });\n        }\n        TryCoerce(value) {\n          // We're skipping type coercition in this implementation. First of, js\n          // is loosely typed, so it's not that important. Secondly, there is no\n          // clean way (AFAIK) for the user to describe what type of parameters\n          // they expect.\n          return value;\n        }\n        BindExternalFunction(funcName, func) {\n          var lookaheadSafe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          this.Assert(func != null, \"Can't bind a null function\");\n          this.BindExternalFunctionGeneral(funcName, args => {\n            this.Assert(args.length >= func.length, \"External function expected \" + func.length + \" arguments\");\n            var coercedArgs = [];\n            for (var i = 0, l = args.length; i < l; i++) {\n              coercedArgs[i] = this.TryCoerce(args[i]);\n            }\n            return func.apply(null, coercedArgs);\n          }, lookaheadSafe);\n        }\n        UnbindExternalFunction(funcName) {\n          this.IfAsyncWeCant(\"unbind an external a function\");\n          this.Assert(this._externals.has(funcName), \"Function '\" + funcName + \"' has not been bound.\");\n          this._externals.delete(funcName);\n        }\n        ValidateExternalBindings() {\n          var c = null;\n          var o = null;\n          var missingExternals = arguments[1] || new Set();\n          if (arguments[0] instanceof Container_1.Container) {\n            c = arguments[0];\n          }\n          if (arguments[0] instanceof Object_1.InkObject) {\n            o = arguments[0];\n          }\n          if (c === null && o === null) {\n            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);\n            this._hasValidatedExternals = true;\n            // No problem! Validation complete\n            if (missingExternals.size == 0) {\n              this._hasValidatedExternals = true;\n            } else {\n              var message = \"Error: Missing function binding for external\";\n              message += missingExternals.size > 1 ? \"s\" : \"\";\n              message += \": '\";\n              message += Array.from(missingExternals).join(\"', '\");\n              message += \"' \";\n              message += this.allowExternalFunctionFallbacks ? \", and no fallback ink function found.\" : \" (ink fallbacks disabled)\";\n              this.Error(message);\n            }\n          } else if (c != null) {\n            for (var innerContent of c.content) {\n              var container = innerContent;\n              if (container == null || !container.hasValidName) this.ValidateExternalBindings(innerContent, missingExternals);\n            }\n            for (var [, value] of c.namedContent) {\n              this.ValidateExternalBindings((0, TypeAssertion_1.asOrNull)(value, Object_1.InkObject), missingExternals);\n            }\n          } else if (o != null) {\n            var divert = (0, TypeAssertion_1.asOrNull)(o, Divert_1.Divert);\n            if (divert && divert.isExternal) {\n              var name = divert.targetPathString;\n              if (name === null) {\n                return (0, NullException_1.throwNullException)(\"name\");\n              }\n              if (!this._externals.has(name)) {\n                if (this.allowExternalFunctionFallbacks) {\n                  var fallbackFound = this.mainContentContainer.namedContent.has(name);\n                  if (!fallbackFound) {\n                    missingExternals.add(name);\n                  }\n                } else {\n                  missingExternals.add(name);\n                }\n              }\n            }\n          }\n        }\n        ObserveVariable(variableName, observer) {\n          this.IfAsyncWeCant(\"observe a new variable\");\n          if (this._variableObservers === null) this._variableObservers = new Map();\n          if (!this.state.variablesState.GlobalVariableExistsWithName(variableName)) throw new Error(\"Cannot observe variable '\" + variableName + \"' because it wasn't declared in the ink story.\");\n          if (this._variableObservers.has(variableName)) {\n            this._variableObservers.get(variableName).push(observer);\n          } else {\n            this._variableObservers.set(variableName, [observer]);\n          }\n        }\n        ObserveVariables(variableNames, observers) {\n          for (var i = 0, l = variableNames.length; i < l; i++) {\n            this.ObserveVariable(variableNames[i], observers[i]);\n          }\n        }\n        RemoveVariableObserver(observer, specificVariableName) {\n          // A couple of things to know about this method:\n          //\n          // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n          //    optionality is marked as `undefined` rather than `null`.\n          //    To keep things simple, null-checks are performed using regular\n          //    equality operators, where undefined == null.\n          //\n          // 2. Since C# delegates are translated to arrays of functions,\n          //    -= becomes a call to splice and null-checks are replaced by\n          //    emptiness-checks.\n          //\n          this.IfAsyncWeCant(\"remove a variable observer\");\n          if (this._variableObservers === null) return;\n          if (specificVariableName != null) {\n            if (this._variableObservers.has(specificVariableName)) {\n              if (observer != null) {\n                var variableObservers = this._variableObservers.get(specificVariableName);\n                if (variableObservers != null) {\n                  variableObservers.splice(variableObservers.indexOf(observer), 1);\n                  if (variableObservers.length === 0) {\n                    this._variableObservers.delete(specificVariableName);\n                  }\n                }\n              } else {\n                this._variableObservers.delete(specificVariableName);\n              }\n            }\n          } else if (observer != null) {\n            var keys = this._variableObservers.keys();\n            for (var varName of keys) {\n              var _variableObservers = this._variableObservers.get(varName);\n              if (_variableObservers != null) {\n                _variableObservers.splice(_variableObservers.indexOf(observer), 1);\n                if (_variableObservers.length === 0) {\n                  this._variableObservers.delete(varName);\n                }\n              }\n            }\n          }\n        }\n        VariableStateDidChangeEvent(variableName, newValueObj) {\n          if (this._variableObservers === null) return;\n          var observers = this._variableObservers.get(variableName);\n          if (typeof observers !== \"undefined\") {\n            if (!(newValueObj instanceof Value_1.Value)) {\n              throw new Error(\"Tried to get the value of a variable that isn't a standard type\");\n            }\n            // var val = newValueObj as Value;\n            var val = (0, TypeAssertion_1.asOrThrows)(newValueObj, Value_1.Value);\n            for (var observer of observers) {\n              observer(variableName, val.valueObject);\n            }\n          }\n        }\n        get globalTags() {\n          return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n        }\n        TagsForContentAtPath(path) {\n          return this.TagsAtStartOfFlowContainerWithPathString(path);\n        }\n        TagsAtStartOfFlowContainerWithPathString(pathString) {\n          var path = new Path_1.Path(pathString);\n          var flowContainer = this.ContentAtPath(path).container;\n          if (flowContainer === null) {\n            return (0, NullException_1.throwNullException)(\"flowContainer\");\n          }\n          while (true) {\n            var firstContent = flowContainer.content[0];\n            if (firstContent instanceof Container_1.Container) flowContainer = firstContent;else break;\n          }\n          var inTag = false;\n          var tags = null;\n          for (var c of flowContainer.content) {\n            // var tag = c as Runtime.Tag;\n            var command = (0, TypeAssertion_1.asOrNull)(c, ControlCommand_1.ControlCommand);\n            if (command != null) {\n              if (command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginTag) {\n                inTag = true;\n              } else if (command.commandType == ControlCommand_1.ControlCommand.CommandType.EndTag) {\n                inTag = false;\n              }\n            } else if (inTag) {\n              var str = (0, TypeAssertion_1.asOrNull)(c, Value_1.StringValue);\n              if (str !== null) {\n                if (tags === null) tags = [];\n                if (str.value !== null) tags.push(str.value);\n              } else {\n                this.Error(\"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\");\n              }\n            } else {\n              break;\n            }\n          }\n          return tags;\n        }\n        BuildStringOfHierarchy() {\n          var sb = new StringBuilder_1.StringBuilder();\n          this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());\n          return sb.toString();\n        }\n        BuildStringOfContainer(container) {\n          var sb = new StringBuilder_1.StringBuilder();\n          container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());\n          return sb.toString();\n        }\n        NextContent() {\n          this.state.previousPointer = this.state.currentPointer.copy();\n          if (!this.state.divertedPointer.isNull) {\n            this.state.currentPointer = this.state.divertedPointer.copy();\n            this.state.divertedPointer = Pointer_1.Pointer.Null;\n            this.VisitChangedContainersDueToDivert();\n            if (!this.state.currentPointer.isNull) {\n              return;\n            }\n          }\n          var successfulPointerIncrement = this.IncrementContentPointer();\n          if (!successfulPointerIncrement) {\n            var didPop = false;\n            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {\n              this.state.PopCallStack(PushPop_1.PushPopType.Function);\n              if (this.state.inExpressionEvaluation) {\n                this.state.PushEvaluationStack(new Void_1.Void());\n              }\n              didPop = true;\n            } else if (this.state.callStack.canPopThread) {\n              this.state.callStack.PopThread();\n              didPop = true;\n            } else {\n              this.state.TryExitFunctionEvaluationFromGame();\n            }\n            if (didPop && !this.state.currentPointer.isNull) {\n              this.NextContent();\n            }\n          }\n        }\n        IncrementContentPointer() {\n          var successfulIncrement = true;\n          var pointer = this.state.callStack.currentElement.currentPointer.copy();\n          pointer.index++;\n          if (pointer.container === null) {\n            return (0, NullException_1.throwNullException)(\"pointer.container\");\n          }\n          while (pointer.index >= pointer.container.content.length) {\n            successfulIncrement = false;\n            // Container nextAncestor = pointer.container.parent as Container;\n            var nextAncestor = (0, TypeAssertion_1.asOrNull)(pointer.container.parent, Container_1.Container);\n            if (nextAncestor instanceof Container_1.Container === false) {\n              break;\n            }\n            var indexInAncestor = nextAncestor.content.indexOf(pointer.container);\n            if (indexInAncestor == -1) {\n              break;\n            }\n            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);\n            pointer.index++;\n            successfulIncrement = true;\n            if (pointer.container === null) {\n              return (0, NullException_1.throwNullException)(\"pointer.container\");\n            }\n          }\n          if (!successfulIncrement) pointer = Pointer_1.Pointer.Null;\n          this.state.callStack.currentElement.currentPointer = pointer.copy();\n          return successfulIncrement;\n        }\n        TryFollowDefaultInvisibleChoice() {\n          var allChoices = this._state.currentChoices;\n          var invisibleChoices = allChoices.filter(c => c.isInvisibleDefault);\n          if (invisibleChoices.length == 0 || allChoices.length > invisibleChoices.length) return false;\n          var choice = invisibleChoices[0];\n          if (choice.targetPath === null) {\n            return (0, NullException_1.throwNullException)(\"choice.targetPath\");\n          }\n          if (choice.threadAtGeneration === null) {\n            return (0, NullException_1.throwNullException)(\"choice.threadAtGeneration\");\n          }\n          this.state.callStack.currentThread = choice.threadAtGeneration;\n          if (this._stateSnapshotAtLastNewline !== null) {\n            this.state.callStack.currentThread = this.state.callStack.ForkThread();\n          }\n          this.ChoosePath(choice.targetPath, false);\n          return true;\n        }\n        NextSequenceShuffleIndex() {\n          // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n          var numElementsIntVal = (0, TypeAssertion_1.asOrNull)(this.state.PopEvaluationStack(), Value_1.IntValue);\n          if (!(numElementsIntVal instanceof Value_1.IntValue)) {\n            this.Error(\"expected number of elements in sequence for shuffle index\");\n            return 0;\n          }\n          var seqContainer = this.state.currentPointer.container;\n          if (seqContainer === null) {\n            return (0, NullException_1.throwNullException)(\"seqContainer\");\n          }\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (numElementsIntVal.value === null) {\n            return (0, NullException_1.throwNullException)(\"numElementsIntVal.value\");\n          }\n          var numElements = numElementsIntVal.value;\n          // var seqCountVal = state.PopEvaluationStack () as IntValue;\n          var seqCountVal = (0, TypeAssertion_1.asOrThrows)(this.state.PopEvaluationStack(), Value_1.IntValue);\n          var seqCount = seqCountVal.value;\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seqCount === null) {\n            return (0, NullException_1.throwNullException)(\"seqCount\");\n          }\n          var loopIndex = seqCount / numElements;\n          var iterationIndex = seqCount % numElements;\n          var seqPathStr = seqContainer.path.toString();\n          var sequenceHash = 0;\n          for (var i = 0, l = seqPathStr.length; i < l; i++) {\n            sequenceHash += seqPathStr.charCodeAt(i) || 0;\n          }\n          var randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n          var random = new PRNG_1.PRNG(Math.floor(randomSeed));\n          var unpickedIndices = [];\n          for (var _i3 = 0; _i3 < numElements; ++_i3) {\n            unpickedIndices.push(_i3);\n          }\n          for (var _i4 = 0; _i4 <= iterationIndex; ++_i4) {\n            var chosen = random.next() % unpickedIndices.length;\n            var chosenIndex = unpickedIndices[chosen];\n            unpickedIndices.splice(chosen, 1);\n            if (_i4 == iterationIndex) {\n              return chosenIndex;\n            }\n          }\n          throw new Error(\"Should never reach here\");\n        }\n        Error(message) {\n          var useEndLineNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          var e = new StoryException_1.StoryException(message);\n          e.useEndLineNumber = useEndLineNumber;\n          throw e;\n        }\n        Warning(message) {\n          this.AddError(message, true);\n        }\n        AddError(message) {\n          var isWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          var useEndLineNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          var dm = this.currentDebugMetadata;\n          var errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n          if (dm != null) {\n            var lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n            message = \"RUNTIME \" + errorTypeStr + \": '\" + dm.fileName + \"' line \" + lineNum + \": \" + message;\n          } else if (!this.state.currentPointer.isNull) {\n            message = \"RUNTIME \" + errorTypeStr + \": (\" + this.state.currentPointer + \"): \" + message;\n          } else {\n            message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n          }\n          this.state.AddError(message, isWarning);\n          // In a broken state don't need to know about any other errors.\n          if (!isWarning) this.state.ForceEnd();\n        }\n        Assert(condition) {\n          var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          if (condition == false) {\n            if (message == null) {\n              message = \"Story assert\";\n            }\n            throw new Error(message + \" \" + this.currentDebugMetadata);\n          }\n        }\n        get currentDebugMetadata() {\n          var dm;\n          var pointer = this.state.currentPointer;\n          if (!pointer.isNull && pointer.Resolve() !== null) {\n            dm = pointer.Resolve().debugMetadata;\n            if (dm !== null) {\n              return dm;\n            }\n          }\n          for (var i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n            pointer = this.state.callStack.elements[i].currentPointer;\n            if (!pointer.isNull && pointer.Resolve() !== null) {\n              dm = pointer.Resolve().debugMetadata;\n              if (dm !== null) {\n                return dm;\n              }\n            }\n          }\n          for (var _i5 = this.state.outputStream.length - 1; _i5 >= 0; --_i5) {\n            var outputObj = this.state.outputStream[_i5];\n            dm = outputObj.debugMetadata;\n            if (dm !== null) {\n              return dm;\n            }\n          }\n          return null;\n        }\n        get mainContentContainer() {\n          if (this._temporaryEvaluationContainer) {\n            return this._temporaryEvaluationContainer;\n          } else {\n            return this._mainContentContainer;\n          }\n        }\n      }\n      exports.Story = Story;\n      Story.inkVersionCurrent = 21;\n      (function (Story) {\n        (function (OutputStateChange) {\n          OutputStateChange[OutputStateChange[\"NoChange\"] = 0] = \"NoChange\";\n          OutputStateChange[OutputStateChange[\"ExtendedBeyondNewline\"] = 1] = \"ExtendedBeyondNewline\";\n          OutputStateChange[OutputStateChange[\"NewlineRemoved\"] = 2] = \"NewlineRemoved\";\n        })(Story.OutputStateChange || (Story.OutputStateChange = {}));\n      })(Story || (exports.Story = Story = {}));\n    })(Story$2);\n    return Story$2;\n  }\n\n  var Compiler = {};\n\n  var CompilerOptions = {};\n\n  var hasRequiredCompilerOptions;\n  function requireCompilerOptions() {\n    if (hasRequiredCompilerOptions) return CompilerOptions;\n    hasRequiredCompilerOptions = 1;\n    Object.defineProperty(CompilerOptions, \"__esModule\", {\n      value: true\n    });\n    CompilerOptions.CompilerOptions = void 0;\n    let CompilerOptions$1 = class CompilerOptions {\n      constructor() {\n        var sourceFilename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var pluginNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var countAllVisits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var errorHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var fileHandler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        this.sourceFilename = sourceFilename;\n        this.pluginNames = pluginNames;\n        this.countAllVisits = countAllVisits;\n        this.errorHandler = errorHandler;\n        this.fileHandler = fileHandler;\n      }\n    };\n    CompilerOptions.CompilerOptions = CompilerOptions$1;\n    return CompilerOptions;\n  }\n\n  var DebugSourceRange = {};\n\n  var hasRequiredDebugSourceRange;\n  function requireDebugSourceRange() {\n    if (hasRequiredDebugSourceRange) return DebugSourceRange;\n    hasRequiredDebugSourceRange = 1;\n    Object.defineProperty(DebugSourceRange, \"__esModule\", {\n      value: true\n    });\n    DebugSourceRange.DebugSourceRange = void 0;\n    let DebugSourceRange$1 = class DebugSourceRange {\n      constructor(length, debugMetadata, text) {\n        this.length = length;\n        this.debugMetadata = debugMetadata;\n        this.text = text;\n      }\n    };\n    DebugSourceRange.DebugSourceRange = DebugSourceRange$1;\n    return DebugSourceRange;\n  }\n\n  var ErrorType = {};\n\n  var hasRequiredErrorType;\n  function requireErrorType() {\n    if (hasRequiredErrorType) return ErrorType;\n    hasRequiredErrorType = 1;\n    // TODO: Unifify with Engine.\n    Object.defineProperty(ErrorType, \"__esModule\", {\n      value: true\n    });\n    ErrorType.ErrorType = void 0;\n    var ErrorType$1;\n    (function (ErrorType) {\n      ErrorType[ErrorType[\"Author\"] = 0] = \"Author\";\n      ErrorType[ErrorType[\"Warning\"] = 1] = \"Warning\";\n      ErrorType[ErrorType[\"Error\"] = 2] = \"Error\";\n    })(ErrorType$1 || (ErrorType.ErrorType = ErrorType$1 = {}));\n    return ErrorType;\n  }\n\n  var InkParser = {};\n\n  var Argument = {};\n\n  var hasRequiredArgument;\n  function requireArgument() {\n    if (hasRequiredArgument) return Argument;\n    hasRequiredArgument = 1;\n    Object.defineProperty(Argument, \"__esModule\", {\n      value: true\n    });\n    Argument.Argument = void 0;\n    let Argument$1 = class Argument {\n      constructor() {\n        var identifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var isByReference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var isDivertTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        this.identifier = identifier;\n        this.isByReference = isByReference;\n        this.isDivertTarget = isDivertTarget;\n      }\n      get typeName() {\n        return \"Argument\";\n      }\n    };\n    Argument.Argument = Argument$1;\n    return Argument;\n  }\n\n  var AuthorWarning = {};\n\n  var _Object = {};\n\n  var hasRequired_Object;\n  function require_Object() {\n    if (hasRequired_Object) return _Object;\n    hasRequired_Object = 1;\n    Object.defineProperty(_Object, \"__esModule\", {\n      value: true\n    });\n    _Object.ParsedObject = void 0;\n    var TypeAssertion_1 = requireTypeAssertion();\n    class ParsedObject {\n      constructor() {\n        var _this = this;\n        this._alreadyHadError = false;\n        this._alreadyHadWarning = false;\n        this._debugMetadata = null;\n        this._runtimeObject = null;\n        this.content = [];\n        this.parent = null;\n        this.GetType = () => this.typeName;\n        /*\n        get descriptionOfScope(): string {\n          const locationNames: string[] = [];\n                  let ancestor: ParsedObject | null = this;\n          while (ancestor) {\n            var ancestorFlow = ancestor as FlowBase;\n            if (ancestorFlow && ancestorFlow.name != null) {\n              locationNames.push(`'${ancestorFlow.name}'`);\n            }\n            ancestor = ancestor.parent;\n          }\n                  let scopeSB = '';\n          if (locationNames.length > 0) {\n            const locationsListStr = locationNames.join(', ');\n            scopeSB += `${locationsListStr} and`;\n          }\n                  scopeSB += 'at top scope';\n                  return scopeSB;\n        }\n        */\n        // Return the object so that method can be chained easily\n        this.AddContent = subContent => {\n          if (this.content === null) {\n            this.content = [];\n          }\n          var sub = Array.isArray(subContent) ? subContent : [subContent];\n          // Make resilient to content not existing, which can happen\n          // in the case of parse errors where we've already reported\n          // an error but still want a valid structure so we can\n          // carry on parsing.\n          for (var ss of sub) {\n            if (ss.hasOwnProperty(\"parent\")) {\n              ss.parent = this;\n            }\n            this.content.push(ss);\n          }\n          if (Array.isArray(subContent)) {\n            return;\n          } else {\n            return subContent;\n          }\n        };\n        this.InsertContent = (index, subContent) => {\n          if (this.content === null) {\n            this.content = [];\n          }\n          subContent.parent = this;\n          this.content.splice(index, 0, subContent);\n          return subContent;\n        };\n        this.Find = type => function () {\n          var queryFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          var tObj = (0, TypeAssertion_1.asOrNull)(_this, type);\n          if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {\n            return tObj;\n          }\n          if (_this.content === null) {\n            return null;\n          }\n          for (var obj of _this.content) {\n            var nestedResult = obj.Find && obj.Find(type)(queryFunc);\n            if (nestedResult) {\n              return nestedResult;\n            }\n          }\n          return null;\n        };\n        this.FindAll = type => (queryFunc, foundSoFar) => {\n          var found = Array.isArray(foundSoFar) ? foundSoFar : [];\n          var tObj = (0, TypeAssertion_1.asOrNull)(this, type);\n          if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {\n            found.push(tObj);\n          }\n          if (this.content === null) {\n            return [];\n          }\n          for (var obj of this.content) {\n            obj.FindAll && obj.FindAll(type)(queryFunc, found);\n          }\n          return found;\n        };\n        this.Warning = function (message) {\n          var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          _this.Error(message, source, true);\n        };\n      }\n      get debugMetadata() {\n        if (this._debugMetadata === null && this.parent) {\n          return this.parent.debugMetadata;\n        }\n        return this._debugMetadata;\n      }\n      set debugMetadata(value) {\n        this._debugMetadata = value;\n      }\n      get hasOwnDebugMetadata() {\n        return Boolean(this.debugMetadata);\n      }\n      get typeName() {\n        return \"ParsedObject\";\n      }\n      get story() {\n        var ancestor = this;\n        while (ancestor.parent) {\n          ancestor = ancestor.parent;\n        }\n        return ancestor;\n      }\n      get runtimeObject() {\n        if (!this._runtimeObject) {\n          this._runtimeObject = this.GenerateRuntimeObject();\n          if (this._runtimeObject) {\n            this._runtimeObject.debugMetadata = this.debugMetadata;\n          }\n        }\n        return this._runtimeObject;\n      }\n      set runtimeObject(value) {\n        this._runtimeObject = value;\n      }\n      get runtimePath() {\n        if (!this.runtimeObject.path) {\n          throw new Error();\n        }\n        return this.runtimeObject.path;\n      }\n      // When counting visits and turns since, different object\n      // types may have different containers that needs to be counted.\n      // For most it'll just be the object's main runtime object,\n      // but for e.g. choices, it'll be the target container.\n      get containerForCounting() {\n        return this.runtimeObject;\n      }\n      get ancestry() {\n        var result = [];\n        var ancestor = this.parent;\n        while (ancestor) {\n          result.push(ancestor);\n          ancestor = ancestor.parent;\n        }\n        result = result.reverse();\n        return result;\n      }\n      ResolveReferences(context) {\n        if (this.content !== null) {\n          for (var obj of this.content) {\n            obj.ResolveReferences(context);\n          }\n        }\n      }\n      Error(message) {\n        var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var isWarning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (source === null) {\n          source = this;\n        }\n        // Only allow a single parsed object to have a single error *directly* associated with it\n        if (source._alreadyHadError && !isWarning || source._alreadyHadWarning && isWarning) {\n          return;\n        }\n        if (this.parent) {\n          this.parent.Error(message, source, isWarning);\n        } else {\n          throw new Error(\"No parent object to send error to: \".concat(message));\n        }\n        if (isWarning) {\n          source._alreadyHadWarning = true;\n        } else {\n          source._alreadyHadError = true;\n        }\n      }\n    }\n    _Object.ParsedObject = ParsedObject;\n    return _Object;\n  }\n\n  var hasRequiredAuthorWarning;\n  function requireAuthorWarning() {\n    if (hasRequiredAuthorWarning) return AuthorWarning;\n    hasRequiredAuthorWarning = 1;\n    Object.defineProperty(AuthorWarning, \"__esModule\", {\n      value: true\n    });\n    AuthorWarning.AuthorWarning = void 0;\n    var Object_1 = require_Object();\n    let AuthorWarning$1 = class AuthorWarning extends Object_1.ParsedObject {\n      constructor(warningMessage) {\n        super();\n        this.warningMessage = warningMessage;\n        this.GenerateRuntimeObject = () => {\n          this.Warning(this.warningMessage);\n          return null;\n        };\n      }\n      get typeName() {\n        return \"AuthorWarning\";\n      }\n    };\n    AuthorWarning.AuthorWarning = AuthorWarning$1;\n    return AuthorWarning;\n  }\n\n  var BinaryExpression = {};\n\n  var Expression = {};\n\n  var hasRequiredExpression;\n  function requireExpression() {\n    if (hasRequiredExpression) return Expression;\n    hasRequiredExpression = 1;\n    Object.defineProperty(Expression, \"__esModule\", {\n      value: true\n    });\n    Expression.Expression = void 0;\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Object_1 = require_Object();\n    let Expression$1 = class Expression extends Object_1.ParsedObject {\n      constructor() {\n        super(...arguments);\n        this._prototypeRuntimeConstantExpression = null;\n        this.outputWhenComplete = false;\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          // Tell Runtime to start evaluating the following content as an expression\n          container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n          this.GenerateIntoContainer(container);\n          // Tell Runtime to output the result of the expression evaluation to the output stream\n          if (this.outputWhenComplete) {\n            container.AddContent(ControlCommand_1.ControlCommand.EvalOutput());\n          }\n          // Tell Runtime to stop evaluating the content as an expression\n          container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n          return container;\n        };\n        // When generating the value of a constant expression,\n        // we can't just keep generating the same constant expression into\n        // different places where the constant value is referenced, since then\n        // the same runtime objects would be used in multiple places, which\n        // is impossible since each runtime object should have one parent.\n        // Instead, we generate a prototype of the runtime object(s), then\n        // copy them each time they're used.\n        this.GenerateConstantIntoContainer = container => {\n          if (this._prototypeRuntimeConstantExpression === null) {\n            this._prototypeRuntimeConstantExpression = new Container_1.Container();\n            this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);\n          }\n          for (var runtimeObj of this._prototypeRuntimeConstantExpression.content) {\n            var copy = runtimeObj.Copy();\n            if (copy) {\n              container.AddContent(copy);\n            }\n          }\n        };\n        this.toString = () => \"No string value in JavaScript.\";\n      }\n      get typeName() {\n        return \"Expression\";\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      Equals(obj) {\n        return false;\n      }\n    };\n    Expression.Expression = Expression$1;\n    return Expression;\n  }\n\n  var UnaryExpression = {};\n\n  var NumberExpression = {};\n\n  var hasRequiredNumberExpression;\n  function requireNumberExpression() {\n    if (hasRequiredNumberExpression) return NumberExpression;\n    hasRequiredNumberExpression = 1;\n    Object.defineProperty(NumberExpression, \"__esModule\", {\n      value: true\n    });\n    NumberExpression.NumberExpression = void 0;\n    var Expression_1 = requireExpression();\n    var Value_1 = requireValue();\n    var TypeAssertion_1 = requireTypeAssertion();\n    // This class is named Number in the C# codebase\n    // but this conflict with the built-in Number class\n    let NumberExpression$1 = class NumberExpression extends Expression_1.Expression {\n      constructor(value, subtype) {\n        super();\n        this.isInt = () => this.subtype == \"int\";\n        this.isFloat = () => this.subtype == \"float\";\n        this.isBool = () => this.subtype == \"bool\";\n        this.GenerateIntoContainer = container => {\n          if (this.isInt()) {\n            container.AddContent(new Value_1.IntValue(this.value));\n          } else if (this.isFloat()) {\n            container.AddContent(new Value_1.FloatValue(this.value));\n          } else if (this.isBool()) {\n            container.AddContent(new Value_1.BoolValue(this.value));\n          }\n        };\n        this.toString = () => String(this.value);\n        if (typeof value === \"number\" && !Number.isNaN(value) || typeof value == \"boolean\") {\n          this.value = value;\n          this.subtype = subtype;\n        } else {\n          throw new Error(\"Unexpected object type in NumberExpression.\");\n        }\n      }\n      get typeName() {\n        return \"Number\";\n      }\n      Equals(obj) {\n        var numberExpression = (0, TypeAssertion_1.asOrNull)(obj, NumberExpression);\n        if (!numberExpression) return false;\n        return numberExpression.subtype == this.subtype && numberExpression.value == this.value;\n      }\n    };\n    NumberExpression.NumberExpression = NumberExpression$1;\n    return NumberExpression;\n  }\n\n  var hasRequiredUnaryExpression;\n  function requireUnaryExpression() {\n    if (hasRequiredUnaryExpression) return UnaryExpression;\n    hasRequiredUnaryExpression = 1;\n    Object.defineProperty(UnaryExpression, \"__esModule\", {\n      value: true\n    });\n    UnaryExpression.UnaryExpression = void 0;\n    var Expression_1 = requireExpression();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var NumberExpression_1 = requireNumberExpression();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let UnaryExpression$1 = class UnaryExpression extends Expression_1.Expression {\n      get nativeNameForOp() {\n        // Replace \"-\" with \"_\" to make it unique (compared to subtraction)\n        if (this.op === \"-\") {\n          return \"_\";\n        } else if (this.op === \"not\") {\n          return \"!\";\n        }\n        return this.op;\n      }\n      constructor(inner, op) {\n        super();\n        this.op = op;\n        this.GenerateIntoContainer = container => {\n          this.innerExpression.GenerateIntoContainer(container);\n          container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.nativeNameForOp));\n        };\n        this.toString = () => this.nativeNameForOp + this.innerExpression;\n        this.innerExpression = this.AddContent(inner);\n      }\n      get typeName() {\n        return \"UnaryExpression\";\n      }\n    };\n    UnaryExpression.UnaryExpression = UnaryExpression$1;\n    // Attempt to flatten inner expression immediately\n    // e.g. convert (-(5)) into (-5)\n    UnaryExpression$1.WithInner = (inner, op) => {\n      var innerNumber = (0, TypeAssertion_1.asOrNull)(inner, NumberExpression_1.NumberExpression);\n      if (innerNumber) {\n        if (op === \"-\") {\n          if (innerNumber.isInt()) {\n            return new NumberExpression_1.NumberExpression(-innerNumber.value, \"int\");\n          } else if (innerNumber.isFloat()) {\n            return new NumberExpression_1.NumberExpression(-innerNumber.value, \"float\");\n          }\n        } else if (op == \"!\" || op == \"not\") {\n          if (innerNumber.isInt()) {\n            return new NumberExpression_1.NumberExpression(innerNumber.value == 0, \"bool\");\n          } else if (innerNumber.isFloat()) {\n            return new NumberExpression_1.NumberExpression(innerNumber.value == 0.0, \"bool\");\n          } else if (innerNumber.isBool()) {\n            return new NumberExpression_1.NumberExpression(!innerNumber.value, \"bool\");\n          }\n        }\n        throw new Error(\"Unexpected operation or number type\");\n      }\n      // Normal fallback\n      var unary = new UnaryExpression$1(inner, op);\n      return unary;\n    };\n    return UnaryExpression;\n  }\n\n  var hasRequiredBinaryExpression;\n  function requireBinaryExpression() {\n    if (hasRequiredBinaryExpression) return BinaryExpression;\n    hasRequiredBinaryExpression = 1;\n    Object.defineProperty(BinaryExpression, \"__esModule\", {\n      value: true\n    });\n    BinaryExpression.BinaryExpression = void 0;\n    var Expression_1 = requireExpression();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var UnaryExpression_1 = requireUnaryExpression();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let BinaryExpression$1 = class BinaryExpression extends Expression_1.Expression {\n      constructor(left, right, opName) {\n        super();\n        this.opName = opName;\n        this.GenerateIntoContainer = container => {\n          this.leftExpression.GenerateIntoContainer(container);\n          this.rightExpression.GenerateIntoContainer(container);\n          this.opName = this.NativeNameForOp(this.opName);\n          container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.opName));\n        };\n        this.NativeNameForOp = opName => {\n          if (opName === \"and\") {\n            return \"&&\";\n          } else if (opName === \"or\") {\n            return \"||\";\n          } else if (opName === \"mod\") {\n            return \"%\";\n          } else if (opName === \"has\") {\n            return \"?\";\n          } else if (opName === \"hasnt\") {\n            return \"!?\";\n          }\n          return opName;\n        };\n        this.toString = () => \"(\".concat(this.leftExpression, \" \").concat(this.opName, \" \").concat(this.rightExpression, \")\");\n        this.leftExpression = this.AddContent(left);\n        this.rightExpression = this.AddContent(right);\n        this.opName = opName;\n      }\n      get typeName() {\n        return \"BinaryExpression\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        // Check for the following case:\n        //\n        //    (not A) ? B\n        //\n        // Since this easy to accidentally do:\n        //\n        //    not A ? B\n        //\n        // when you intend:\n        //\n        //    not (A ? B)\n        if (this.NativeNameForOp(this.opName) === \"?\") {\n          var leftUnary = (0, TypeAssertion_1.asOrNull)(this.leftExpression, UnaryExpression_1.UnaryExpression);\n          if (leftUnary !== null && (leftUnary.op === \"not\" || leftUnary.op === \"!\")) {\n            this.Error(\"Using 'not' or '!' here negates '\".concat(leftUnary.innerExpression, \"' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.\"));\n          }\n        }\n      }\n    };\n    BinaryExpression.BinaryExpression = BinaryExpression$1;\n    return BinaryExpression;\n  }\n\n  var CharacterRange = {};\n\n  var CharacterSet = {};\n\n  var hasRequiredCharacterSet;\n  function requireCharacterSet() {\n    if (hasRequiredCharacterSet) return CharacterSet;\n    hasRequiredCharacterSet = 1;\n    Object.defineProperty(CharacterSet, \"__esModule\", {\n      value: true\n    });\n    CharacterSet.CharacterSet = void 0;\n    let CharacterSet$1 = class CharacterSet {\n      constructor(arg) {\n        this.set = new Set();\n        this.Add = arg => this.set.add(arg);\n        this.AddRange = (start, end) => {\n          for (var c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {\n            this.Add(String.fromCharCode(c));\n          }\n          return this;\n        };\n        this.AddCharacters = chars => {\n          if (typeof chars === \"string\" || Array.isArray(chars)) {\n            for (var c of chars) {\n              this.Add(c);\n            }\n          } else {\n            for (var _c of chars.set) {\n              this.Add(_c);\n            }\n          }\n          return this;\n        };\n        if (arg) {\n          this.AddCharacters(arg);\n        }\n      }\n    };\n    CharacterSet.CharacterSet = CharacterSet$1;\n    CharacterSet$1.FromRange = (start, end) => new CharacterSet$1().AddRange(start, end);\n    return CharacterSet;\n  }\n\n  var hasRequiredCharacterRange;\n  function requireCharacterRange() {\n    if (hasRequiredCharacterRange) return CharacterRange;\n    hasRequiredCharacterRange = 1;\n    Object.defineProperty(CharacterRange, \"__esModule\", {\n      value: true\n    });\n    CharacterRange.CharacterRange = void 0;\n    var CharacterSet_1 = requireCharacterSet();\n    /// <summary>\n    /// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.\n    /// </summary>\n    let CharacterRange$1 = class CharacterRange {\n      constructor(_start, _end) {\n        var excludes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        this._start = _start;\n        this._end = _end;\n        this._correspondingCharSet = new CharacterSet_1.CharacterSet();\n        this._excludes = new Set();\n        /// <summary>\n        /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range\n        /// represented by the current instance.\n        /// </summary>\n        /// <remarks>\n        /// The internal character set is created once and cached in memory.\n        /// </remarks>\n        /// <returns>The char set.</returns>\n        this.ToCharacterSet = () => {\n          if (this._correspondingCharSet.set.size === 0) {\n            for (var ii = this.start.charCodeAt(0), c; ii <= this.end.charCodeAt(0); ii += 1) {\n              c = String.fromCharCode(ii);\n              if (!this._excludes.has(c)) {\n                this._correspondingCharSet.AddCharacters(c);\n              }\n            }\n          }\n          return this._correspondingCharSet;\n        };\n        if (excludes instanceof CharacterSet_1.CharacterSet) {\n          this._excludes = excludes.set;\n        } else {\n          for (var item of excludes) {\n            this._excludes.add(item);\n          }\n        }\n      }\n      get start() {\n        return this._start;\n      }\n      get end() {\n        return this._end;\n      }\n    };\n    CharacterRange.CharacterRange = CharacterRange$1;\n    CharacterRange$1.Define = function (start, end) {\n      var excludes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return new CharacterRange$1(start, end, excludes);\n    };\n    return CharacterRange;\n  }\n\n  var Choice = {};\n\n  var SymbolType = {};\n\n  var hasRequiredSymbolType;\n  function requireSymbolType() {\n    if (hasRequiredSymbolType) return SymbolType;\n    hasRequiredSymbolType = 1;\n    Object.defineProperty(SymbolType, \"__esModule\", {\n      value: true\n    });\n    SymbolType.SymbolType = void 0;\n    var SymbolType$1;\n    (function (SymbolType) {\n      SymbolType[SymbolType[\"Knot\"] = 0] = \"Knot\";\n      SymbolType[SymbolType[\"List\"] = 1] = \"List\";\n      SymbolType[SymbolType[\"ListItem\"] = 2] = \"ListItem\";\n      SymbolType[SymbolType[\"Var\"] = 3] = \"Var\";\n      SymbolType[SymbolType[\"SubFlowAndWeave\"] = 4] = \"SubFlowAndWeave\";\n      SymbolType[SymbolType[\"Arg\"] = 5] = \"Arg\";\n      SymbolType[SymbolType[\"Temp\"] = 6] = \"Temp\";\n    })(SymbolType$1 || (SymbolType.SymbolType = SymbolType$1 = {}));\n    return SymbolType;\n  }\n\n  var hasRequiredChoice;\n  function requireChoice() {\n    if (hasRequiredChoice) return Choice;\n    hasRequiredChoice = 1;\n    Object.defineProperty(Choice, \"__esModule\", {\n      value: true\n    });\n    Choice.Choice = void 0;\n    var ChoicePoint_1 = requireChoicePoint();\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Divert_1 = requireDivert$1();\n    var Value_1 = requireValue();\n    var Object_1 = require_Object();\n    var SymbolType_1 = requireSymbolType();\n    var VariableAssignment_1 = requireVariableAssignment$1();\n    let Choice$1 = class Choice extends Object_1.ParsedObject {\n      get runtimeChoice() {\n        if (!this._runtimeChoice) {\n          throw new Error();\n        }\n        return this._runtimeChoice;\n      }\n      get name() {\n        var _a;\n        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n      }\n      get condition() {\n        return this._condition;\n      }\n      set condition(value) {\n        this._condition = value;\n        if (value) {\n          this.AddContent(value);\n        }\n      }\n      // Required for IWeavePoint interface\n      // Choice's target container. Used by weave to append any extra\n      // nested weave content into.\n      get runtimeContainer() {\n        return this._innerContentContainer;\n      }\n      get innerContentContainer() {\n        return this._innerContentContainer;\n      }\n      get containerForCounting() {\n        return this._innerContentContainer;\n      }\n      // Override runtimePath to point to the Choice's target content (after it's chosen),\n      // as opposed to the default implementation which would point to the choice itself\n      // (or it's outer container), which is what runtimeObject is.\n      get runtimePath() {\n        if (!this.innerContentContainer || !this.innerContentContainer.path) {\n          throw new Error();\n        }\n        return this.innerContentContainer.path;\n      }\n      constructor(startContent, choiceOnlyContent, innerContent) {\n        super();\n        this._condition = null;\n        this._innerContentContainer = null;\n        this._outerContainer = null;\n        this._runtimeChoice = null;\n        this._returnToR1 = null;\n        this._returnToR2 = null;\n        this._r1Label = null;\n        this._r2Label = null;\n        this._divertToStartContentOuter = null;\n        this._divertToStartContentInner = null;\n        this._startContentRuntimeContainer = null;\n        this.isInvisibleDefault = false;\n        this.hasWeaveStyleInlineBrackets = false;\n        this.GenerateRuntimeObject = () => {\n          this._outerContainer = new Container_1.Container();\n          // Content names for different types of choice:\n          //  * start content [choice only content] inner content\n          //  * start content   -> divert\n          //  * start content\n          //  * [choice only content]\n          // Hmm, this structure has become slightly insane!\n          //\n          // [\n          //     EvalStart\n          //     assign $r = $r1   -- return target = return label 1\n          //     BeginString\n          //     -> s\n          //     [(r1)]            -- return label 1 (after start content)\n          //     EndString\n          //     BeginString\n          //     ... choice only content\n          //     EndEval\n          //     Condition expression\n          //     choice: -> \"c-0\"\n          //     (s) = [\n          //         start content\n          //         -> r          -- goto return label 1 or 2\n          //     ]\n          //  ]\n          //\n          //  in parent's container: (the inner content for the choice)\n          //\n          //  (c-0) = [\n          //      EvalStart\n          //      assign $r = $r2   -- return target = return label 2\n          //      EndEval\n          //      -> s\n          //      [(r2)]            -- return label 1 (after start content)\n          //      inner content\n          //  ]\n          //\n          this._runtimeChoice = new ChoicePoint_1.ChoicePoint(this.onceOnly);\n          this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;\n          if (this.startContent || this.choiceOnlyContent || this.condition) {\n            this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n          }\n          // Start content is put into a named container that's referenced both\n          // when displaying the choice initially, and when generating the text\n          // when the choice is chosen.\n          if (this.startContent) {\n            // Generate start content and return\n            //  - We can't use a function since it uses a call stack element, which would\n            //    put temporary values out of scope. Instead we manually divert around.\n            //  - $r is a variable divert target contains the return point\n            this._returnToR1 = new Value_1.DivertTargetValue();\n            this._outerContainer.AddContent(this._returnToR1);\n            var varAssign = new VariableAssignment_1.VariableAssignment(\"$r\", true);\n            this._outerContainer.AddContent(varAssign);\n            // Mark the start of the choice text generation, so that the runtime\n            // knows where to rewind to to extract the content from the output stream.\n            this._outerContainer.AddContent(ControlCommand_1.ControlCommand.BeginString());\n            this._divertToStartContentOuter = new Divert_1.Divert();\n            this._outerContainer.AddContent(this._divertToStartContentOuter);\n            // Start content itself in a named container\n            this._startContentRuntimeContainer = this.startContent.GenerateRuntimeObject();\n            this._startContentRuntimeContainer.name = \"s\";\n            // Effectively, the \"return\" statement - return to the point specified by $r\n            var varDivert = new Divert_1.Divert();\n            varDivert.variableDivertName = \"$r\";\n            this._startContentRuntimeContainer.AddContent(varDivert);\n            // Add the container\n            this._outerContainer.AddToNamedContentOnly(this._startContentRuntimeContainer);\n            // This is the label to return to\n            this._r1Label = new Container_1.Container();\n            this._r1Label.name = \"$r1\";\n            this._outerContainer.AddContent(this._r1Label);\n            this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EndString());\n            this._runtimeChoice.hasStartContent = true;\n          }\n          // Choice only content - mark the start, then generate it directly into the outer container\n          if (this.choiceOnlyContent) {\n            this._outerContainer.AddContent(ControlCommand_1.ControlCommand.BeginString());\n            var choiceOnlyRuntimeContent = this.choiceOnlyContent.GenerateRuntimeObject();\n            this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);\n            this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EndString());\n            this._runtimeChoice.hasChoiceOnlyContent = true;\n          }\n          // Generate any condition for this choice\n          if (this.condition) {\n            this.condition.GenerateIntoContainer(this._outerContainer);\n            this._runtimeChoice.hasCondition = true;\n          }\n          if (this.startContent || this.choiceOnlyContent || this.condition) {\n            this._outerContainer.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n          }\n          // Add choice itself\n          this._outerContainer.AddContent(this._runtimeChoice);\n          // Container that choice points to for when it's chosen\n          this._innerContentContainer = new Container_1.Container();\n          // Repeat start content by diverting to its container\n          if (this.startContent) {\n            // Set the return point when jumping back into the start content\n            //  - In this case, it's the $r2 point, within the choice content \"c\".\n            this._returnToR2 = new Value_1.DivertTargetValue();\n            this._innerContentContainer.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n            this._innerContentContainer.AddContent(this._returnToR2);\n            this._innerContentContainer.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n            var _varAssign = new VariableAssignment_1.VariableAssignment(\"$r\", true);\n            this._innerContentContainer.AddContent(_varAssign);\n            // Main divert into start content\n            this._divertToStartContentInner = new Divert_1.Divert();\n            this._innerContentContainer.AddContent(this._divertToStartContentInner);\n            // Define label to return to\n            this._r2Label = new Container_1.Container();\n            this._r2Label.name = \"$r2\";\n            this._innerContentContainer.AddContent(this._r2Label);\n          }\n          // Choice's own inner content\n          if (this.innerContent) {\n            var innerChoiceOnlyContent = this.innerContent.GenerateRuntimeObject();\n            this._innerContentContainer.AddContentsOfContainer(innerChoiceOnlyContent);\n          }\n          if (this.story.countAllVisits) {\n            this._innerContentContainer.visitsShouldBeCounted = true;\n          }\n          this._innerContentContainer.countingAtStartOnly = true;\n          return this._outerContainer;\n        };\n        this.toString = () => {\n          if (this.choiceOnlyContent !== null) {\n            return \"* \".concat(this.startContent, \"[\").concat(this.choiceOnlyContent, \"]...\");\n          }\n          return \"* \".concat(this.startContent, \"...\");\n        };\n        this.startContent = startContent;\n        this.choiceOnlyContent = choiceOnlyContent;\n        this.innerContent = innerContent;\n        this.indentationDepth = 1;\n        if (startContent) {\n          this.AddContent(this.startContent);\n        }\n        if (choiceOnlyContent) {\n          this.AddContent(this.choiceOnlyContent);\n        }\n        if (innerContent) {\n          this.AddContent(this.innerContent);\n        }\n        this.onceOnly = true; // default\n      }\n      get typeName() {\n        return \"Choice\";\n      }\n      ResolveReferences(context) {\n        var _a;\n        // Weave style choice - target own content container\n        if (this._innerContentContainer) {\n          this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;\n          if (this.onceOnly) {\n            this._innerContentContainer.visitsShouldBeCounted = true;\n          }\n        }\n        if (this._returnToR1) {\n          if (!this._r1Label) {\n            throw new Error();\n          }\n          this._returnToR1.targetPath = this._r1Label.path;\n        }\n        if (this._returnToR2) {\n          if (!this._r2Label) {\n            throw new Error();\n          }\n          this._returnToR2.targetPath = this._r2Label.path;\n        }\n        if (this._divertToStartContentOuter) {\n          if (!this._startContentRuntimeContainer) {\n            throw new Error();\n          }\n          this._divertToStartContentOuter.targetPath = this._startContentRuntimeContainer.path;\n        }\n        if (this._divertToStartContentInner) {\n          if (!this._startContentRuntimeContainer) {\n            throw new Error();\n          }\n          this._divertToStartContentInner.targetPath = this._startContentRuntimeContainer.path;\n        }\n        super.ResolveReferences(context);\n        if (this.identifier && (((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\").length > 0) {\n          context.CheckForNamingCollisions(this, this.identifier, SymbolType_1.SymbolType.SubFlowAndWeave);\n        }\n      }\n    };\n    Choice.Choice = Choice$1;\n    return Choice;\n  }\n\n  var CommentEliminator = {};\n\n  var StringParser = {};\n\n  var StringParserState = {};\n\n  var StringParserElement = {};\n\n  var hasRequiredStringParserElement;\n  function requireStringParserElement() {\n    if (hasRequiredStringParserElement) return StringParserElement;\n    hasRequiredStringParserElement = 1;\n    Object.defineProperty(StringParserElement, \"__esModule\", {\n      value: true\n    });\n    StringParserElement.StringParserElement = void 0;\n    let StringParserElement$1 = class StringParserElement {\n      constructor() {\n        this.characterIndex = 0;\n        this.characterInLineIndex = 0;\n        this.lineIndex = 0;\n        this.reportedErrorInScope = false;\n        this.uniqueId = 0;\n        this.customFlags = 0;\n        this.CopyFrom = fromElement => {\n          StringParserElement._uniqueIdCounter++;\n          this.uniqueId = StringParserElement._uniqueIdCounter;\n          this.characterIndex = fromElement.characterIndex;\n          this.characterInLineIndex = fromElement.characterInLineIndex;\n          this.lineIndex = fromElement.lineIndex;\n          this.customFlags = fromElement.customFlags;\n          this.reportedErrorInScope = false;\n        };\n        // Squash is used when succeeding from a rule,\n        // so only the state information we wanted to carry forward is\n        // retained. e.g. characterIndex and lineIndex are global,\n        // however uniqueId is specific to the individual rule,\n        // and likewise, custom flags are designed for the temporary\n        // state of the individual rule too.\n        this.SquashFrom = fromElement => {\n          this.characterIndex = fromElement.characterIndex;\n          this.characterInLineIndex = fromElement.characterInLineIndex;\n          this.lineIndex = fromElement.lineIndex;\n          this.reportedErrorInScope = fromElement.reportedErrorInScope;\n          this.customFlags = fromElement.customFlags;\n        };\n      }\n    };\n    StringParserElement.StringParserElement = StringParserElement$1;\n    StringParserElement$1._uniqueIdCounter = 1000;\n    return StringParserElement;\n  }\n\n  var hasRequiredStringParserState;\n  function requireStringParserState() {\n    if (hasRequiredStringParserState) return StringParserState;\n    hasRequiredStringParserState = 1;\n    Object.defineProperty(StringParserState, \"__esModule\", {\n      value: true\n    });\n    StringParserState.StringParserState = void 0;\n    var StringParserElement_1 = requireStringParserElement();\n    let StringParserState$1 = class StringParserState {\n      get currentElement() {\n        return this._stack[this._numElements - 1];\n      }\n      get lineIndex() {\n        return this.currentElement.lineIndex;\n      }\n      set lineIndex(value) {\n        this.currentElement.lineIndex = value;\n      }\n      get characterIndex() {\n        return this.currentElement.characterIndex;\n      }\n      set characterIndex(value) {\n        this.currentElement.characterIndex = value;\n      }\n      get characterInLineIndex() {\n        return this.currentElement.characterInLineIndex;\n      }\n      set characterInLineIndex(value) {\n        this.currentElement.characterInLineIndex = value;\n      }\n      get customFlags() {\n        return this.currentElement.customFlags;\n      }\n      set customFlags(value) {\n        this.currentElement.customFlags = value;\n      }\n      get errorReportedAlreadyInScope() {\n        return this.currentElement.reportedErrorInScope;\n      }\n      get stackHeight() {\n        return this._numElements;\n      }\n      constructor() {\n        this._stack = [];\n        this._numElements = 0;\n        this.StringParserState = () => {\n          var kExpectedMaxStackDepth = 200;\n          this._stack = new Array(kExpectedMaxStackDepth);\n          for (var ii = 0; ii < kExpectedMaxStackDepth; ++ii) {\n            this._stack[ii] = new StringParserElement_1.StringParserElement();\n          }\n          this._numElements = 1;\n        };\n        this.Push = () => {\n          if (this._numElements >= this._stack.length && this._numElements > 0) {\n            throw new Error(\"Stack overflow in parser state.\");\n          }\n          var prevElement = this._stack[this._numElements - 1];\n          var newElement = this._stack[this._numElements];\n          this._numElements++;\n          newElement.CopyFrom(prevElement);\n          return newElement.uniqueId;\n        };\n        this.Pop = expectedRuleId => {\n          if (this._numElements == 1) {\n            throw new Error(\"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\");\n          }\n          if (this.currentElement.uniqueId != expectedRuleId) {\n            throw new Error(\"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\");\n          }\n          // Restore state\n          this._numElements -= 1;\n        };\n        this.Peek = expectedRuleId => {\n          if (this.currentElement.uniqueId != expectedRuleId) {\n            throw new Error(\"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\");\n          }\n          return this._stack[this._numElements - 1];\n        };\n        this.PeekPenultimate = () => {\n          if (this._numElements >= 2) {\n            return this._stack[this._numElements - 2];\n          }\n          return null;\n        };\n        // Reduce stack height while maintaining currentElement\n        // Remove second last element: i.e. \"squash last two elements together\"\n        // Used when succeeding from a rule (and ONLY when succeeding, since\n        // the state of the top element is retained).\n        this.Squash = () => {\n          if (this._numElements < 2) {\n            throw new Error(\"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\");\n          }\n          var penultimateEl = this._stack[this._numElements - 2];\n          var lastEl = this._stack[this._numElements - 1];\n          penultimateEl.SquashFrom(lastEl);\n          this._numElements -= 1;\n        };\n        this.NoteErrorReported = () => {\n          for (var el of this._stack) {\n            el.reportedErrorInScope = true;\n          }\n        };\n        var kExpectedMaxStackDepth = 200;\n        for (var i = 0; i < kExpectedMaxStackDepth; i++) {\n          this._stack[i] = new StringParserElement_1.StringParserElement();\n        }\n        this._numElements = 1;\n      }\n    };\n    StringParserState.StringParserState = StringParserState$1;\n    return StringParserState;\n  }\n\n  var hasRequiredStringParser;\n  function requireStringParser() {\n    if (hasRequiredStringParser) return StringParser;\n    hasRequiredStringParser = 1;\n    (function (exports) {\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.StringParser = exports.ParseSuccess = void 0;\n      var CharacterSet_1 = requireCharacterSet();\n      var StringParserState_1 = requireStringParserState();\n      exports.ParseSuccess = Symbol(\"ParseSuccessStruct\");\n      class StringParser {\n        constructor(str) {\n          var _this = this;\n          this.ParseRule = null;\n          this.errorHandler = null;\n          this.hadError = false;\n          //--------------------------------\n          // Parse state\n          //--------------------------------\n          this.BeginRule = () => this.state.Push();\n          this.FailRule = expectedRuleId => {\n            this.state.Pop(expectedRuleId);\n            return null;\n          };\n          this.CancelRule = expectedRuleId => {\n            this.state.Pop(expectedRuleId);\n          };\n          this.SucceedRule = function (expectedRuleId) {\n            var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            // Get state at point where this rule stared evaluating\n            var stateAtSucceedRule = _this.state.Peek(expectedRuleId);\n            var stateAtBeginRule = _this.state.PeekPenultimate();\n            // Allow subclass to receive callback\n            if (_this.RuleDidSucceed) {\n              _this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);\n            }\n            // Flatten state stack so that we maintain the same values,\n            // but remove one level in the stack.\n            _this.state.Squash();\n            var finalResult = result;\n            if (finalResult === null) {\n              finalResult = StringParser.ParseSuccess;\n            }\n            return finalResult;\n          };\n          this.Expect = function (rule) {\n            var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var recoveryRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var result = _this.ParseObject(rule);\n            if (result === null) {\n              if (message === null) {\n                message = rule.name;\n              }\n              var butSaw;\n              var lineRemainder = _this.LineRemainder();\n              if (lineRemainder === null || lineRemainder.length === 0) {\n                butSaw = \"end of line\";\n              } else {\n                butSaw = \"'\".concat(lineRemainder, \"'\");\n              }\n              _this.Error(\"Expected \".concat(message, \" but saw \").concat(butSaw));\n              if (recoveryRule !== null) {\n                result = recoveryRule();\n              }\n            }\n            return result;\n          };\n          this.Error = function (message) {\n            var isWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            _this.ErrorOnLine(message, _this.lineIndex + 1, isWarning);\n          };\n          this.ErrorWithParsedObject = function (message, result) {\n            var isWarning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            _this.ErrorOnLine(message, result.debugMetadata ? result.debugMetadata.startLineNumber : -1, isWarning);\n          };\n          this.ErrorOnLine = (message, lineNumber, isWarning) => {\n            if (!this.state.errorReportedAlreadyInScope) {\n              var errorType = isWarning ? \"Warning\" : \"Error\";\n              if (!this.errorHandler) {\n                throw new Error(\"\".concat(errorType, \" on line \").concat(lineNumber, \": \").concat(message));\n              } else {\n                this.errorHandler(message, this.index, lineNumber - 1, isWarning);\n              }\n              this.state.NoteErrorReported();\n            }\n            if (!isWarning) {\n              this.hadError = true;\n            }\n          };\n          this.Warning = message => this.Error(message, true);\n          this.LineRemainder = () => this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\"));\n          this.SetFlag = (flag, trueOrFalse) => {\n            if (trueOrFalse) {\n              this.state.customFlags |= flag;\n            } else {\n              this.state.customFlags &= ~flag;\n            }\n          };\n          this.GetFlag = flag => Boolean(this.state.customFlags & flag);\n          //--------------------------------\n          // Structuring\n          //--------------------------------\n          this.ParseObject = rule => {\n            var ruleId = this.BeginRule();\n            var stackHeightBefore = this.state.stackHeight;\n            var result = rule();\n            if (stackHeightBefore !== this.state.stackHeight) {\n              throw new Error(\"Mismatched Begin/Fail/Succeed rules\");\n            }\n            if (result === null) {\n              return this.FailRule(ruleId);\n            }\n            this.SucceedRule(ruleId, result);\n            return result;\n          };\n          this.Parse = rule => {\n            var ruleId = this.BeginRule();\n            var result = rule();\n            if (result === null) {\n              this.FailRule(ruleId);\n              return null;\n            }\n            this.SucceedRule(ruleId, result);\n            return result;\n          };\n          this.OneOf = array => {\n            for (var rule of array) {\n              var result = this.ParseObject(rule);\n              if (result !== null) {\n                return result;\n              }\n            }\n            return null;\n          };\n          this.OneOrMore = rule => {\n            var results = [];\n            var result = null;\n            do {\n              result = this.ParseObject(rule);\n              if (result !== null) {\n                results.push(result);\n              }\n            } while (result !== null);\n            if (results.length > 0) {\n              return results;\n            }\n            return null;\n          };\n          this.Optional = rule => () => {\n            var result = this.ParseObject(rule);\n            if (result === null) return StringParser.ParseSuccess;\n            return result;\n          };\n          // Return ParseSuccess instead the real result so that it gets excluded\n          // from result arrays (e.g. Interleave)\n          this.Exclude = rule => () => this.ParseObject(rule) && StringParser.ParseSuccess;\n          // Combination of both of the above\n          this.OptionalExclude = rule => () => {\n            this.ParseObject(rule);\n            return StringParser.ParseSuccess;\n          };\n          // Convenience method for creating more readable ParseString rules that can be combined\n          // in other structuring rules (like OneOf etc)\n          // e.g. OneOf(String(\"one\"), String(\"two\"))\n          this.String = str => () => this.ParseString(str);\n          this.TryAddResultToList = function (result, list) {\n            var flatten = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            if (result === StringParser.ParseSuccess) {\n              return;\n            }\n            if (flatten && Array.isArray(result)) {\n              var resultCollection = result;\n              if (resultCollection !== null) {\n                for (var obj of resultCollection) {\n                  list.push(obj);\n                }\n                return;\n              }\n            }\n            list.push(result);\n          };\n          this.Interleave = function (ruleA, ruleB) {\n            var untilTerminator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var flatten = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n            var ruleId = _this.BeginRule();\n            var results = [];\n            // First outer padding\n            var firstA = _this.ParseObject(ruleA);\n            if (firstA === null) {\n              return _this.FailRule(ruleId);\n            } else {\n              _this.TryAddResultToList(firstA, results, flatten);\n            }\n            var lastMainResult = null;\n            var outerResult = null;\n            do {\n              // \"until\" condition hit?\n              if (untilTerminator !== null && _this.Peek(untilTerminator) !== null) {\n                break;\n              }\n              // Main inner\n              lastMainResult = _this.ParseObject(ruleB);\n              if (lastMainResult === null) {\n                break;\n              } else {\n                _this.TryAddResultToList(lastMainResult, results, flatten);\n              }\n              // Outer result (i.e. last A in ABA)\n              outerResult = null;\n              if (lastMainResult !== null) {\n                outerResult = _this.ParseObject(ruleA);\n                if (outerResult === null) {\n                  break;\n                } else {\n                  _this.TryAddResultToList(outerResult, results, flatten);\n                }\n              }\n              // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)\n            } while ((lastMainResult !== null || outerResult !== null) && !(lastMainResult === StringParser.ParseSuccess && outerResult == StringParser.ParseSuccess) && _this.remainingLength > 0);\n            if (results.length === 0) {\n              return _this.FailRule(ruleId);\n            }\n            return _this.SucceedRule(ruleId, results);\n          };\n          //--------------------------------\n          // Basic string parsing\n          //--------------------------------\n          this.ParseString = str => {\n            if (str.length > this.remainingLength) {\n              return null;\n            }\n            var ruleId = this.BeginRule();\n            // Optimisation from profiling:\n            // Store in temporary local variables\n            // since they're properties that would have to access\n            // the rule stack every time otherwise.\n            var i = this.index;\n            var cli = this.characterInLineIndex;\n            var li = this.lineIndex;\n            var success = true;\n            for (var tempIdx = 0; tempIdx < str.length; tempIdx += 1) {\n              var c = str[tempIdx];\n              if (this._chars[i] !== c) {\n                success = false;\n                break;\n              }\n              if (c === \"\\n\") {\n                li++;\n                cli = -1;\n              }\n              i++;\n              cli++;\n            }\n            this.index = i;\n            this.characterInLineIndex = cli;\n            this.lineIndex = li;\n            if (success) {\n              return this.SucceedRule(ruleId, str);\n            }\n            return this.FailRule(ruleId);\n          };\n          this.ParseSingleCharacter = () => {\n            if (this.remainingLength > 0) {\n              var c = this._chars[this.index];\n              if (c === \"\\n\") {\n                this.lineIndex += 1;\n                this.characterInLineIndex = -1;\n              }\n              this.index += 1;\n              this.characterInLineIndex += 1;\n              return c;\n            }\n            return \"0\";\n          };\n          this.ParseUntilCharactersFromString = function (str) {\n            var maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n            return _this.ParseCharactersFromString(str, false, maxCount);\n          };\n          this.ParseUntilCharactersFromCharSet = function (charSet) {\n            var maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n            return _this.ParseCharactersFromCharSet(charSet, false, maxCount);\n          };\n          this.ParseCharactersFromString = function (str) {\n            var maxCountOrShouldIncludeStrChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n            var maxCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n            var charSet = new CharacterSet_1.CharacterSet(str);\n            if (typeof maxCountOrShouldIncludeStrChars === \"number\") {\n              return _this.ParseCharactersFromCharSet(charSet, true, maxCountOrShouldIncludeStrChars);\n            }\n            return _this.ParseCharactersFromCharSet(charSet, maxCountOrShouldIncludeStrChars, maxCount);\n          };\n          this.ParseCharactersFromCharSet = function (charSet) {\n            var shouldIncludeChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var maxCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n            if (maxCount === -1) {\n              maxCount = Number.MAX_SAFE_INTEGER;\n            }\n            var startIndex = _this.index;\n            // Optimisation from profiling:\n            // Store in temporary local variables\n            // since they're properties that would have to access\n            // the rule stack every time otherwise.\n            var ii = _this.index;\n            var cli = _this.characterInLineIndex;\n            var li = _this.lineIndex;\n            var count = 0;\n            while (ii < _this._chars.length && charSet.set.has(_this._chars[ii]) === shouldIncludeChars && count < maxCount) {\n              if (_this._chars[ii] === \"\\n\") {\n                li += 1;\n                cli = -1;\n              }\n              ii += 1;\n              cli += 1;\n              count += 1;\n            }\n            _this.index = ii;\n            _this.characterInLineIndex = cli;\n            _this.lineIndex = li;\n            var lastCharIndex = _this.index;\n            if (lastCharIndex > startIndex) {\n              return _this._chars.slice(startIndex, _this.index).join(\"\");\n            }\n            return null;\n          };\n          this.Peek = rule => {\n            var ruleId = this.BeginRule();\n            var result = rule();\n            this.CancelRule(ruleId);\n            return result;\n          };\n          // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n          this.ParseInt = () => {\n            var oldIndex = this.index;\n            var oldCharacterInLineIndex = this.characterInLineIndex;\n            var negative = this.ParseString(\"-\") !== null;\n            // Optional whitespace\n            this.ParseCharactersFromString(\" \\t\");\n            var parsedString = this.ParseCharactersFromCharSet(StringParser.numbersCharacterSet);\n            if (parsedString === null) {\n              // Roll back and fail\n              this.index = oldIndex;\n              this.characterInLineIndex = oldCharacterInLineIndex;\n              return null;\n            }\n            var parsedInt;\n            if (!Number.isNaN(Number(parsedString))) {\n              parsedInt = Number(parsedString);\n              return negative ? -parsedInt : parsedInt;\n            }\n            this.Error(\"Failed to read integer value: \" + parsedString + \". Perhaps it's out of the range of acceptable numbers ink supports? (\" + Number.MIN_SAFE_INTEGER + \" to \" + Number.MAX_SAFE_INTEGER + \")\");\n            return null;\n          };\n          // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n          this.ParseFloat = () => {\n            var oldIndex = this.index;\n            var oldCharacterInLineIndex = this.characterInLineIndex;\n            var leadingInt = this.ParseInt();\n            if (leadingInt !== null) {\n              if (this.ParseString(\".\") !== null) {\n                var afterDecimalPointStr = this.ParseCharactersFromCharSet(StringParser.numbersCharacterSet);\n                return Number(\"\".concat(leadingInt, \".\").concat(afterDecimalPointStr));\n              }\n            }\n            // Roll back and fail\n            this.index = oldIndex;\n            this.characterInLineIndex = oldCharacterInLineIndex;\n            return null;\n          };\n          this.ParseNewline = () => {\n            var ruleId = this.BeginRule();\n            // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n            // 2nd May 2016: Always collapse \\r\\n to just \\n\n            this.ParseString(\"\\r\");\n            if (this.ParseString(\"\\n\") === null) {\n              return this.FailRule(ruleId);\n            }\n            return this.SucceedRule(ruleId, \"\\n\");\n          };\n          var strPreProc = this.PreProcessInputString(str);\n          this.state = new StringParserState_1.StringParserState();\n          if (str) {\n            this._chars = strPreProc.split(\"\");\n          } else {\n            this._chars = [];\n          }\n          this.inputString = strPreProc;\n        }\n        get currentCharacter() {\n          if (this.index >= 0 && this.remainingLength > 0) {\n            return this._chars[this.index];\n          }\n          return \"0\";\n        }\n        // Don't do anything by default, but provide ability for subclasses\n        // to manipulate the string before it's used as input (converted to a char array)\n        PreProcessInputString(str) {\n          return str;\n        }\n        get endOfInput() {\n          return this.index >= this._chars.length;\n        }\n        get remainingString() {\n          return this._chars.slice(this.index, this.index + this.remainingLength).join(\"\");\n        }\n        get remainingLength() {\n          return this._chars.length - this.index;\n        }\n        get lineIndex() {\n          return this.state.lineIndex;\n        }\n        set lineIndex(value) {\n          this.state.lineIndex = value;\n        }\n        set characterInLineIndex(value) {\n          this.state.characterInLineIndex = value;\n        }\n        get characterInLineIndex() {\n          return this.state.characterInLineIndex;\n        }\n        get index() {\n          // If we want subclass parsers to be able to set the index directly,\n          // then we would need to know what the lineIndex of the new\n          // index would be - would we have to step through manually\n          // counting the newlines to do so?\n          return this.state.characterIndex;\n        }\n        set index(value) {\n          this.state.characterIndex = value;\n        }\n        ParseUntil(stopRule) {\n          var pauseCharacters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          var endCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n          var ruleId = this.BeginRule();\n          var pauseAndEnd = new CharacterSet_1.CharacterSet();\n          if (pauseCharacters !== null) {\n            pauseAndEnd.set = new Set([...pauseAndEnd.set.values(), ...pauseCharacters.set.values()]);\n          }\n          if (endCharacters !== null) {\n            pauseAndEnd.set = new Set([...pauseAndEnd.set.values(), ...endCharacters.set.values()]);\n          }\n          var parsedString = \"\";\n          var ruleResultAtPause = null;\n          // Keep attempting to parse strings up to the pause (and end) points.\n          //  - At each of the pause points, attempt to parse according to the rule\n          //  - When the end point is reached (or EOF), we're done\n          do {\n            // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?\n            var partialParsedString = this.ParseUntilCharactersFromCharSet(pauseAndEnd);\n            if (partialParsedString) {\n              parsedString += partialParsedString;\n            }\n            // Attempt to run the parse rule at this pause point\n            ruleResultAtPause = this.Peek(stopRule);\n            // Rule completed - we're done\n            if (ruleResultAtPause !== null) {\n              break;\n            } else {\n              if (this.endOfInput) {\n                break;\n              }\n              // Reached a pause point, but rule failed. Step past and continue parsing string\n              var pauseCharacter = this.currentCharacter;\n              if (pauseCharacters !== null && pauseCharacters.set.has(pauseCharacter)) {\n                parsedString += pauseCharacter;\n                if (pauseCharacter === \"\\n\") {\n                  this.lineIndex += 1;\n                  this.characterInLineIndex = -1;\n                }\n                this.index += 1;\n                this.characterInLineIndex += 1;\n                continue;\n              } else {\n                break;\n              }\n            }\n          } while (true);\n          if (parsedString.length > 0) {\n            return this.SucceedRule(ruleId, String(parsedString));\n          }\n          return this.FailRule(ruleId);\n        }\n      }\n      exports.StringParser = StringParser;\n      StringParser.ParseSuccess = exports.ParseSuccess;\n      StringParser.numbersCharacterSet = new CharacterSet_1.CharacterSet(\"0123456789\");\n    })(StringParser);\n    return StringParser;\n  }\n\n  var hasRequiredCommentEliminator;\n  function requireCommentEliminator() {\n    if (hasRequiredCommentEliminator) return CommentEliminator;\n    hasRequiredCommentEliminator = 1;\n    Object.defineProperty(CommentEliminator, \"__esModule\", {\n      value: true\n    });\n    CommentEliminator.CommentEliminator = void 0;\n    var CharacterSet_1 = requireCharacterSet();\n    var StringParser_1 = requireStringParser();\n    /// <summary>\n    /// Pre-pass before main ink parser runs. It actually performs two main tasks:\n    ///  - comment elimination to simplify the parse rules in the main parser\n    ///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so\n    ///    we don't have to worry about them later.\n    /// </summary>\n    let CommentEliminator$1 = class CommentEliminator extends StringParser_1.StringParser {\n      constructor() {\n        super(...arguments);\n        this._commentOrNewlineStartCharacter = new CharacterSet_1.CharacterSet(\"/\\r\\n\");\n        this._commentBlockEndCharacter = new CharacterSet_1.CharacterSet(\"*\");\n        this._newlineCharacters = new CharacterSet_1.CharacterSet(\"\\n\\r\");\n        this.Process = () => {\n          // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)\n          var stringList = this.Interleave(this.Optional(this.CommentsAndNewlines), this.Optional(this.MainInk));\n          if (stringList !== null) {\n            return stringList.join(\"\");\n          } else {\n            return \"\";\n          }\n        };\n        this.MainInk = () => this.ParseUntil(this.CommentsAndNewlines, this._commentOrNewlineStartCharacter, null);\n        this.CommentsAndNewlines = () => {\n          var newLines = this.Interleave(this.Optional(this.ParseNewline), this.Optional(this.ParseSingleComment));\n          if (newLines !== null) {\n            return newLines.join(\"\");\n          }\n          return null;\n        };\n        // Valid comments always return either an empty string or pure newlines,\n        // which we want to keep so that line numbers stay the same\n        this.ParseSingleComment = () => this.OneOf([this.EndOfLineComment, this.BlockComment]);\n        this.EndOfLineComment = () => {\n          if (this.ParseString(\"//\") === null) {\n            return null;\n          }\n          this.ParseUntilCharactersFromCharSet(this._newlineCharacters);\n          return \"\";\n        };\n        this.BlockComment = () => {\n          if (this.ParseString(\"/*\") === null) {\n            return null;\n          }\n          var startLineIndex = this.lineIndex;\n          var commentResult = this.ParseUntil(this.String(\"*/\"), this._commentBlockEndCharacter, null);\n          if (!this.endOfInput) {\n            this.ParseString(\"*/\");\n          }\n          // Count the number of lines that were inside the block, and replicate them as newlines\n          // so that the line indexing still works from the original source\n          if (commentResult != null) {\n            return \"\\n\".repeat(this.lineIndex - startLineIndex);\n          }\n          // No comment at all\n          return null;\n        };\n      }\n      PreProcessInputString(str) {\n        return str;\n      }\n    };\n    CommentEliminator.CommentEliminator = CommentEliminator$1;\n    return CommentEliminator;\n  }\n\n  var Conditional = {};\n\n  var hasRequiredConditional;\n  function requireConditional() {\n    if (hasRequiredConditional) return Conditional;\n    hasRequiredConditional = 1;\n    Object.defineProperty(Conditional, \"__esModule\", {\n      value: true\n    });\n    Conditional.Conditional = void 0;\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Object_1 = require_Object();\n    let Conditional$1 = class Conditional extends Object_1.ParsedObject {\n      constructor(initialCondition, branches) {\n        super();\n        this.initialCondition = initialCondition;\n        this.branches = branches;\n        this._reJoinTarget = null;\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          // Initial condition\n          if (this.initialCondition) {\n            container.AddContent(this.initialCondition.runtimeObject);\n          }\n          // Individual branches\n          for (var branch of this.branches) {\n            var branchContainer = branch.runtimeObject;\n            container.AddContent(branchContainer);\n          }\n          // If it's a switch-like conditional, each branch\n          // will have a \"duplicate\" operation for the original\n          // switched value. If there's no final else clause\n          // and we fall all the way through, we need to clean up.\n          // (An else clause doesn't dup but it *does* pop)\n          if (this.initialCondition !== null && this.branches[0].ownExpression !== null && !this.branches[this.branches.length - 1].isElse) {\n            container.AddContent(ControlCommand_1.ControlCommand.PopEvaluatedValue());\n          }\n          // Target for branches to rejoin to\n          this._reJoinTarget = ControlCommand_1.ControlCommand.NoOp();\n          container.AddContent(this._reJoinTarget);\n          return container;\n        };\n        if (this.initialCondition) {\n          this.AddContent(this.initialCondition);\n        }\n        if (this.branches !== null) {\n          this.AddContent(this.branches);\n        }\n      }\n      get typeName() {\n        return \"Conditional\";\n      }\n      ResolveReferences(context) {\n        var pathToReJoin = this._reJoinTarget.path;\n        for (var branch of this.branches) {\n          if (!branch.returnDivert) {\n            throw new Error();\n          }\n          branch.returnDivert.targetPath = pathToReJoin;\n        }\n        super.ResolveReferences(context);\n      }\n    };\n    Conditional.Conditional = Conditional$1;\n    return Conditional;\n  }\n\n  var ConditionalSingleBranch = {};\n\n  var Text = {};\n\n  var hasRequiredText;\n  function requireText() {\n    if (hasRequiredText) return Text;\n    hasRequiredText = 1;\n    Object.defineProperty(Text, \"__esModule\", {\n      value: true\n    });\n    Text.Text = void 0;\n    var Object_1 = require_Object();\n    var Value_1 = requireValue();\n    let Text$1 = class Text extends Object_1.ParsedObject {\n      constructor(text) {\n        super();\n        this.text = text;\n        this.GenerateRuntimeObject = () => new Value_1.StringValue(this.text);\n        this.toString = () => this.text;\n      }\n      get typeName() {\n        return \"Text\";\n      }\n    };\n    Text.Text = Text$1;\n    return Text;\n  }\n\n  var Weave = {};\n\n  var ConstantDeclaration = {};\n\n  var hasRequiredConstantDeclaration;\n  function requireConstantDeclaration() {\n    if (hasRequiredConstantDeclaration) return ConstantDeclaration;\n    hasRequiredConstantDeclaration = 1;\n    Object.defineProperty(ConstantDeclaration, \"__esModule\", {\n      value: true\n    });\n    ConstantDeclaration.ConstantDeclaration = void 0;\n    var Object_1 = require_Object();\n    var SymbolType_1 = requireSymbolType();\n    let ConstantDeclaration$1 = class ConstantDeclaration extends Object_1.ParsedObject {\n      get constantName() {\n        var _a;\n        return (_a = this.constantIdentifier) === null || _a === void 0 ? void 0 : _a.name;\n      }\n      get expression() {\n        if (!this._expression) {\n          throw new Error();\n        }\n        return this._expression;\n      }\n      constructor(name, assignedExpression) {\n        super();\n        this._expression = null;\n        this.GenerateRuntimeObject = () => {\n          // Global declarations don't generate actual procedural\n          // runtime objects, but instead add a global variable to the story itself.\n          // The story then initialises them all in one go at the start of the game.\n          return null;\n        };\n        this.constantIdentifier = name;\n        // Defensive programming in case parsing of assignedExpression failed\n        if (assignedExpression) {\n          this._expression = this.AddContent(assignedExpression);\n        }\n      }\n      get typeName() {\n        return \"CONST\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        context.CheckForNamingCollisions(this, this.constantIdentifier, SymbolType_1.SymbolType.Var);\n      }\n    };\n    ConstantDeclaration.ConstantDeclaration = ConstantDeclaration$1;\n    return ConstantDeclaration;\n  }\n\n  var Divert = {};\n\n  var DivertTarget = {};\n\n  var FlowBase = {};\n\n  var FlowLevel = {};\n\n  var hasRequiredFlowLevel;\n  function requireFlowLevel() {\n    if (hasRequiredFlowLevel) return FlowLevel;\n    hasRequiredFlowLevel = 1;\n    Object.defineProperty(FlowLevel, \"__esModule\", {\n      value: true\n    });\n    FlowLevel.FlowLevel = void 0;\n    var FlowLevel$1;\n    (function (FlowLevel) {\n      FlowLevel[FlowLevel[\"Story\"] = 0] = \"Story\";\n      FlowLevel[FlowLevel[\"Knot\"] = 1] = \"Knot\";\n      FlowLevel[FlowLevel[\"Stitch\"] = 2] = \"Stitch\";\n      // not actually a FlowBase, but used for diverts\n      FlowLevel[FlowLevel[\"WeavePoint\"] = 3] = \"WeavePoint\";\n    })(FlowLevel$1 || (FlowLevel.FlowLevel = FlowLevel$1 = {}));\n    return FlowLevel;\n  }\n\n  var Gather = {};\n\n  var hasRequiredGather;\n  function requireGather() {\n    if (hasRequiredGather) return Gather;\n    hasRequiredGather = 1;\n    Object.defineProperty(Gather, \"__esModule\", {\n      value: true\n    });\n    Gather.Gather = void 0;\n    var Container_1 = requireContainer();\n    var Object_1 = require_Object();\n    var SymbolType_1 = requireSymbolType();\n    let Gather$1 = class Gather extends Object_1.ParsedObject {\n      get name() {\n        var _a;\n        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n      }\n      get runtimeContainer() {\n        return this.runtimeObject;\n      }\n      constructor(identifier, indentationDepth) {\n        super();\n        this.indentationDepth = indentationDepth;\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          container.name = this.name;\n          if (this.story.countAllVisits) {\n            container.visitsShouldBeCounted = true;\n          }\n          container.countingAtStartOnly = true;\n          // A gather can have null content, e.g. it's just purely a line with \"-\"\n          if (this.content) {\n            for (var c of this.content) {\n              container.AddContent(c.runtimeObject);\n            }\n          }\n          return container;\n        };\n        this.toString = () => {\n          var _a, _b;\n          return \"- \".concat(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) ? \"(\" + ((_b = this.identifier) === null || _b === void 0 ? void 0 : _b.name) + \")\" : \"gather\");\n        };\n        if (identifier) this.identifier = identifier;\n      }\n      get typeName() {\n        return \"Gather\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        if (this.identifier && (this.identifier.name || \"\").length > 0) {\n          context.CheckForNamingCollisions(this, this.identifier, SymbolType_1.SymbolType.SubFlowAndWeave);\n        }\n      }\n    };\n    Gather.Gather = Gather$1;\n    return Gather;\n  }\n\n  var Path = {};\n\n  var hasRequiredPath;\n  function requirePath() {\n    if (hasRequiredPath) return Path;\n    hasRequiredPath = 1;\n    Object.defineProperty(Path, \"__esModule\", {\n      value: true\n    });\n    Path.Path = void 0;\n    var TypeAssertion_1 = requireTypeAssertion();\n    var FlowBase_1 = requireFlowBase();\n    var FlowLevel_1 = requireFlowLevel();\n    var Weave_1 = requireWeave();\n    let Path$1 = class Path {\n      get baseTargetLevel() {\n        if (this.baseLevelIsAmbiguous) {\n          return FlowLevel_1.FlowLevel.Story;\n        }\n        return this._baseTargetLevel;\n      }\n      get baseLevelIsAmbiguous() {\n        return !this._baseTargetLevel;\n      }\n      get firstComponent() {\n        if (this.components == null || !this.components.length) {\n          return null;\n        }\n        return this.components[0].name;\n      }\n      get numberOfComponents() {\n        return this.components ? this.components.length : 0;\n      }\n      get dotSeparatedComponents() {\n        if (this._dotSeparatedComponents == null) {\n          this._dotSeparatedComponents = (this.components ? this.components : []).map(c => c.name).filter(TypeAssertion_1.filterUndef).join(\".\");\n        }\n        return this._dotSeparatedComponents;\n      }\n      constructor(argOne, argTwo) {\n        this._dotSeparatedComponents = null;\n        this.toString = () => {\n          if (this.components === null || this.components.length === 0) {\n            if (this.baseTargetLevel === FlowLevel_1.FlowLevel.WeavePoint) {\n              return \"-> <next gather point>\";\n            }\n            return \"<invalid Path>\";\n          }\n          return \"-> \".concat(this.dotSeparatedComponents);\n        };\n        this.ResolveFromContext = context => {\n          if (this.components == null || this.components.length == 0) {\n            return null;\n          }\n          // Find base target of path from current context. e.g.\n          //   ==> BASE.sub.sub\n          var baseTargetObject = this.ResolveBaseTarget(context);\n          if (baseTargetObject === null) {\n            return null;\n          }\n          // Given base of path, resolve final target by working deeper into hierarchy\n          //  e.g. ==> base.mid.FINAL\n          if (this.components.length > 1) {\n            return this.ResolveTailComponents(baseTargetObject);\n          }\n          return baseTargetObject;\n        };\n        // Find the root object from the base, i.e. root from:\n        //    root.sub1.sub2\n        this.ResolveBaseTarget = originalContext => {\n          var firstComp = this.firstComponent;\n          // Work up the ancestry to find the node that has the named object\n          var ancestorContext = originalContext;\n          while (ancestorContext) {\n            // Only allow deep search when searching deeper from original context.\n            // Don't allow search upward *then* downward, since that's searching *everywhere*!\n            // Allowed examples:\n            //  - From an inner gather of a stitch, you should search up to find a knot called 'x'\n            //    at the root of a story, but not a stitch called 'x' in that knot.\n            //  - However, from within a knot, you should be able to find a gather/choice\n            //    anywhere called 'x'\n            // (that latter example is quite loose, but we allow it)\n            var deepSearch = ancestorContext === originalContext;\n            var foundBase = this.GetChildFromContext(ancestorContext, firstComp, null, deepSearch);\n            if (foundBase) {\n              return foundBase;\n            }\n            ancestorContext = ancestorContext.parent;\n          }\n          return null;\n        };\n        // Find the final child from path given root, i.e.:\n        //   root.sub.finalChild\n        this.ResolveTailComponents = rootTarget => {\n          var foundComponent = rootTarget;\n          if (!this.components) return null;\n          for (var ii = 1; ii < this.components.length; ++ii) {\n            var compName = this.components[ii].name;\n            var minimumExpectedLevel = void 0;\n            var foundFlow = (0, TypeAssertion_1.asOrNull)(foundComponent, FlowBase_1.FlowBase);\n            if (foundFlow !== null) {\n              minimumExpectedLevel = foundFlow.flowLevel + 1;\n            } else {\n              minimumExpectedLevel = FlowLevel_1.FlowLevel.WeavePoint;\n            }\n            foundComponent = this.GetChildFromContext(foundComponent, compName, minimumExpectedLevel);\n            if (foundComponent === null) {\n              break;\n            }\n          }\n          return foundComponent;\n        };\n        // See whether \"context\" contains a child with a given name at a given flow level\n        // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)\n        // This function also ignores any other object types that are neither FlowBase nor Weave.\n        // Called from both ResolveBase (force deep) and ResolveTail for the individual components.\n        this.GetChildFromContext = function (context, childName, minimumLevel) {\n          var forceDeepSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n          // null childLevel means that we don't know where to find it\n          var ambiguousChildLevel = minimumLevel === null;\n          // Search for WeavePoint within Weave\n          var weaveContext = (0, TypeAssertion_1.asOrNull)(context, Weave_1.Weave);\n          if (childName && weaveContext !== null && (ambiguousChildLevel || minimumLevel === FlowLevel_1.FlowLevel.WeavePoint)) {\n            return weaveContext.WeavePointNamed(childName);\n          }\n          // Search for content within Flow (either a sub-Flow or a WeavePoint)\n          var flowContext = (0, TypeAssertion_1.asOrNull)(context, FlowBase_1.FlowBase);\n          if (childName && flowContext !== null) {\n            // When searching within a Knot, allow a deep searches so that\n            // named weave points (choices and gathers) can be found within any stitch\n            // Otherwise, we just search within the immediate object.\n            var shouldDeepSearch = forceDeepSearch || flowContext.flowLevel === FlowLevel_1.FlowLevel.Knot;\n            return flowContext.ContentWithNameAtLevel(childName, minimumLevel, shouldDeepSearch);\n          }\n          return null;\n        };\n        if (Object.values(FlowLevel_1.FlowLevel).includes(argOne)) {\n          this._baseTargetLevel = argOne;\n          this.components = argTwo || [];\n        } else if (Array.isArray(argOne)) {\n          this._baseTargetLevel = null;\n          this.components = argOne || [];\n        } else {\n          this._baseTargetLevel = null;\n          this.components = [argOne];\n        }\n      }\n      get typeName() {\n        return \"Path\";\n      }\n    };\n    Path.Path = Path$1;\n    return Path;\n  }\n\n  var ReturnType = {};\n\n  var hasRequiredReturnType;\n  function requireReturnType() {\n    if (hasRequiredReturnType) return ReturnType;\n    hasRequiredReturnType = 1;\n    Object.defineProperty(ReturnType, \"__esModule\", {\n      value: true\n    });\n    ReturnType.ReturnType = void 0;\n    var Object_1 = require_Object();\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Void_1 = requireVoid();\n    let ReturnType$1 = class ReturnType extends Object_1.ParsedObject {\n      constructor() {\n        var returnedExpression = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        super();\n        this.returnedExpression = null;\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          if (this.returnedExpression) {\n            // Evaluate expression\n            container.AddContent(this.returnedExpression.runtimeObject);\n          } else {\n            // Return Runtime.Void when there's no expression to evaluate\n            // (This evaluation will just add the Void object to the evaluation stack)\n            container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n            container.AddContent(new Void_1.Void());\n            container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n          }\n          // Then pop the call stack\n          // (the evaluated expression will leave the return value on the evaluation stack)\n          container.AddContent(ControlCommand_1.ControlCommand.PopFunction());\n          return container;\n        };\n        if (returnedExpression) {\n          this.returnedExpression = this.AddContent(returnedExpression);\n        }\n      }\n      get typeName() {\n        return \"ReturnType\";\n      }\n    };\n    ReturnType.ReturnType = ReturnType$1;\n    return ReturnType;\n  }\n\n  var ClosestFlowBase = {};\n\n  var hasRequiredClosestFlowBase;\n  function requireClosestFlowBase() {\n    if (hasRequiredClosestFlowBase) return ClosestFlowBase;\n    hasRequiredClosestFlowBase = 1;\n    // import { FlowBase } from './FlowBase';\n    Object.defineProperty(ClosestFlowBase, \"__esModule\", {\n      value: true\n    });\n    ClosestFlowBase.ClosestFlowBase = void 0;\n    function ClosestFlowBase$1(obj) {\n      var ancestor = obj.parent;\n      while (ancestor) {\n        if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {\n          return ancestor;\n        }\n        ancestor = ancestor.parent;\n      }\n      return null;\n    }\n    ClosestFlowBase.ClosestFlowBase = ClosestFlowBase$1;\n    return ClosestFlowBase;\n  }\n\n  var Identifier = {};\n\n  var hasRequiredIdentifier;\n  function requireIdentifier() {\n    if (hasRequiredIdentifier) return Identifier;\n    hasRequiredIdentifier = 1;\n    Object.defineProperty(Identifier, \"__esModule\", {\n      value: true\n    });\n    Identifier.Identifier = void 0;\n    let Identifier$1 = class Identifier {\n      constructor(name) {\n        this.debugMetadata = null;\n        this.toString = () => this.name || \"undefined identifer\";\n        this.name = name;\n      }\n      get typeName() {\n        return \"Identifier\";\n      }\n      static Done() {\n        return new Identifier(\"DONE\");\n      }\n    };\n    Identifier.Identifier = Identifier$1;\n    return Identifier;\n  }\n\n  var hasRequiredFlowBase;\n  function requireFlowBase() {\n    if (hasRequiredFlowBase) return FlowBase;\n    hasRequiredFlowBase = 1;\n    Object.defineProperty(FlowBase, \"__esModule\", {\n      value: true\n    });\n    FlowBase.FlowBase = void 0;\n    var Choice_1 = requireChoice();\n    var Divert_1 = requireDivert();\n    var DivertTarget_1 = requireDivertTarget();\n    var FlowLevel_1 = requireFlowLevel();\n    var Gather_1 = requireGather();\n    // import { Knot } from '../Knot';\n    var Object_1 = require_Object();\n    var Path_1 = requirePath();\n    var ReturnType_1 = requireReturnType();\n    var Container_1 = requireContainer();\n    var Divert_2 = requireDivert$1();\n    var VariableAssignment_1 = requireVariableAssignment$1();\n    //import { Story } from '../Story';\n    var SymbolType_1 = requireSymbolType();\n    var Weave_1 = requireWeave();\n    var ClosestFlowBase_1 = requireClosestFlowBase();\n    var Identifier_1 = requireIdentifier();\n    var TypeAssertion_1 = requireTypeAssertion();\n    // Base class for Knots and Stitches\n    let FlowBase$1 = class FlowBase extends Object_1.ParsedObject {\n      get hasParameters() {\n        return this.args !== null && this.args.length > 0;\n      }\n      get subFlowsByName() {\n        return this._subFlowsByName;\n      }\n      get typeName() {\n        if (this.isFunction) {\n          return \"Function\";\n        }\n        return String(this.flowLevel);\n      }\n      get name() {\n        var _a;\n        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n      }\n      constructor(identifier) {\n        var _this;\n        var topLevelObjects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var isFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        var isIncludedStory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n        super();\n        _this = this;\n        this.isFunction = isFunction;\n        this._rootWeave = null;\n        this._subFlowsByName = new Map();\n        this._startingSubFlowDivert = null;\n        this._startingSubFlowRuntime = null;\n        this._firstChildFlow = null;\n        this.variableDeclarations = new Map();\n        this.identifier = null;\n        this.args = null;\n        this.iamFlowbase = () => true;\n        this.SplitWeaveAndSubFlowContent = (contentObjs, isRootStory) => {\n          var _a, _b;\n          var weaveObjs = [];\n          var subFlowObjs = [];\n          this._subFlowsByName = new Map();\n          for (var obj of contentObjs) {\n            var subFlow = (0, TypeAssertion_1.asOrNull)(obj, FlowBase);\n            if (subFlow) {\n              if (this._firstChildFlow === null) {\n                this._firstChildFlow = subFlow;\n              }\n              subFlowObjs.push(obj);\n              if ((_a = subFlow.identifier) === null || _a === void 0 ? void 0 : _a.name) {\n                this._subFlowsByName.set((_b = subFlow.identifier) === null || _b === void 0 ? void 0 : _b.name, subFlow);\n              }\n            } else {\n              weaveObjs.push(obj);\n            }\n          }\n          // Implicit final gather in top level story for ending without warning that you run out of content\n          if (isRootStory) {\n            weaveObjs.push(new Gather_1.Gather(null, 1), new Divert_1.Divert(new Path_1.Path(Identifier_1.Identifier.Done())));\n          }\n          var finalContent = [];\n          if (weaveObjs.length > 0) {\n            this._rootWeave = new Weave_1.Weave(weaveObjs, 0);\n            finalContent.push(this._rootWeave);\n          }\n          if (subFlowObjs.length > 0) {\n            finalContent.push(...subFlowObjs);\n          }\n          return finalContent;\n        };\n        this.ResolveVariableWithName = (varName, fromNode) => {\n          var _a;\n          var result = {};\n          // Search in the stitch / knot that owns the node first\n          var ownerFlow = fromNode === null ? this : (0, ClosestFlowBase_1.ClosestFlowBase)(fromNode);\n          if (ownerFlow) {\n            // Argument\n            if (ownerFlow.args !== null) {\n              for (var arg of ownerFlow.args) {\n                if (((_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name) === varName) {\n                  result.found = true;\n                  result.isArgument = true;\n                  result.ownerFlow = ownerFlow;\n                  return result;\n                }\n              }\n            }\n            // Temp\n            if (ownerFlow !== this.story && ownerFlow.variableDeclarations.has(varName)) {\n              result.found = true;\n              result.ownerFlow = ownerFlow;\n              result.isTemporary = true;\n              return result;\n            }\n          }\n          // Global\n          if (this.story.variableDeclarations.has(varName)) {\n            result.found = true;\n            result.ownerFlow = this.story;\n            result.isGlobal = true;\n            return result;\n          }\n          result.found = false;\n          return result;\n        };\n        this.AddNewVariableDeclaration = varDecl => {\n          var varName = varDecl.variableName;\n          if (this.variableDeclarations.has(varName)) {\n            var varab = this.variableDeclarations.get(varName);\n            var prevDeclError = \"\";\n            var debugMetadata = varab.debugMetadata;\n            if (debugMetadata) {\n              prevDeclError = \" (\".concat(varab.debugMetadata, \")\");\n            }\n            this.Error(\"found declaration variable '\".concat(varName, \"' that was already declared\").concat(prevDeclError), varDecl, false);\n            return;\n          }\n          this.variableDeclarations.set(varDecl.variableName, varDecl);\n        };\n        this.ResolveWeavePointNaming = () => {\n          // Find all weave points and organise them by name ready for\n          // diverting. Also detect naming collisions.\n          if (this._rootWeave) {\n            this._rootWeave.ResolveWeavePointNaming();\n          }\n          for (var [, value] of this._subFlowsByName) {\n            if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {\n              value.ResolveWeavePointNaming();\n            }\n          }\n        };\n        this.GenerateRuntimeObject = () => {\n          var _a;\n          var foundReturn = null;\n          if (this.isFunction) {\n            this.CheckForDisallowedFunctionFlowControl();\n          } else if (this.flowLevel === FlowLevel_1.FlowLevel.Knot || this.flowLevel === FlowLevel_1.FlowLevel.Stitch) {\n            // Non-functon: Make sure knots and stitches don't attempt to use Return statement\n            foundReturn = this.Find(ReturnType_1.ReturnType)();\n            if (foundReturn !== null) {\n              this.Error(\"Return statements can only be used in knots that are declared as functions: == function \".concat(this.identifier, \" ==\"), foundReturn);\n            }\n          }\n          var container = new Container_1.Container();\n          container.name = (_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name;\n          if (this.story.countAllVisits) {\n            container.visitsShouldBeCounted = true;\n          }\n          this.GenerateArgumentVariableAssignments(container);\n          // Run through content defined for this knot/stitch:\n          //  - First of all, any initial content before a sub-stitch\n          //    or any weave content is added to the main content container\n          //  - The first inner knot/stitch is automatically entered, while\n          //    the others are only accessible by an explicit divert\n          //       - The exception to this rule is if the knot/stitch takes\n          //         parameters, in which case it can't be auto-entered.\n          //  - Any Choices and Gathers (i.e. IWeavePoint) found are\n          //    processsed by GenerateFlowContent.\n          var contentIdx = 0;\n          while (this.content !== null && contentIdx < this.content.length) {\n            var obj = this.content[contentIdx];\n            // Inner knots and stitches\n            if (obj instanceof FlowBase) {\n              var childFlow = obj;\n              var childFlowRuntime = childFlow.runtimeObject;\n              // First inner stitch - automatically step into it\n              // 20/09/2016 - let's not auto step into knots\n              if (contentIdx === 0 && !childFlow.hasParameters && this.flowLevel === FlowLevel_1.FlowLevel.Knot) {\n                this._startingSubFlowDivert = new Divert_2.Divert();\n                container.AddContent(this._startingSubFlowDivert);\n                this._startingSubFlowRuntime = childFlowRuntime;\n              }\n              // Check for duplicate knots/stitches with same name\n              var namedChild = childFlowRuntime;\n              var existingChild = container.namedContent.get(namedChild.name) || null;\n              if (existingChild) {\n                var errorMsg = \"\".concat(this.GetType(), \" already contains flow named '\").concat(namedChild.name, \"' (at \").concat(existingChild.debugMetadata, \")\");\n                this.Error(errorMsg, childFlow);\n              }\n              container.AddToNamedContentOnly(namedChild);\n            } else if (obj) {\n              // Other content (including entire Weaves that were grouped in the constructor)\n              // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"\n              // and it's always the root Weave\n              container.AddContent(obj.runtimeObject);\n            }\n            contentIdx += 1;\n          }\n          // CHECK FOR FINAL LOOSE ENDS!\n          // Notes:\n          //  - Functions don't need to terminate - they just implicitly return\n          //  - If return statement was found, don't continue finding warnings for missing control flow,\n          // since it's likely that a return statement has been used instead of a ->-> or something,\n          // or the writer failed to mark the knot as a function.\n          //  - _rootWeave may be null if it's a knot that only has stitches\n          if (this.flowLevel !== FlowLevel_1.FlowLevel.Story && !this.isFunction && this._rootWeave !== null && foundReturn === null) {\n            this._rootWeave.ValidateTermination(this.WarningInTermination);\n          }\n          return container;\n        };\n        this.GenerateArgumentVariableAssignments = container => {\n          var _a;\n          if (this.args === null || this.args.length === 0) {\n            return;\n          }\n          // Assign parameters in reverse since they'll be popped off the evaluation stack\n          // No need to generate EvalStart and EvalEnd since there's nothing being pushed\n          // back onto the evaluation stack.\n          for (var ii = this.args.length - 1; ii >= 0; --ii) {\n            var paramName = ((_a = this.args[ii].identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n            var assign = new VariableAssignment_1.VariableAssignment(paramName, true);\n            container.AddContent(assign);\n          }\n        };\n        this.ContentWithNameAtLevel = function (name) {\n          var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          var deepSearch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          var _a;\n          // Referencing self?\n          if (level === _this.flowLevel || level === null) {\n            if (name === ((_a = _this.identifier) === null || _a === void 0 ? void 0 : _a.name)) {\n              return _this;\n            }\n          }\n          if (level === FlowLevel_1.FlowLevel.WeavePoint || level === null) {\n            var weavePointResult = null;\n            if (_this._rootWeave) {\n              weavePointResult = _this._rootWeave.WeavePointNamed(name);\n              if (weavePointResult) {\n                return weavePointResult;\n              }\n            }\n            // Stop now if we only wanted a result if it's a weave point?\n            if (level === FlowLevel_1.FlowLevel.WeavePoint) {\n              return deepSearch ? _this.DeepSearchForAnyLevelContent(name) : null;\n            }\n          }\n          // If this flow would be incapable of containing the requested level, early out\n          // (e.g. asking for a Knot from a Stitch)\n          if (level !== null && level < _this.flowLevel) {\n            return null;\n          }\n          var subFlow = _this._subFlowsByName.get(name) || null;\n          if (subFlow && (level === null || level === subFlow.flowLevel)) {\n            return subFlow;\n          }\n          return deepSearch ? _this.DeepSearchForAnyLevelContent(name) : null;\n        };\n        this.DeepSearchForAnyLevelContent = name => {\n          var weaveResultSelf = this.ContentWithNameAtLevel(name, FlowLevel_1.FlowLevel.WeavePoint, false);\n          if (weaveResultSelf) {\n            return weaveResultSelf;\n          }\n          for (var [, value] of this._subFlowsByName) {\n            var deepResult = value.ContentWithNameAtLevel(name, null, true);\n            if (deepResult) {\n              return deepResult;\n            }\n          }\n          return null;\n        };\n        this.CheckForDisallowedFunctionFlowControl = () => {\n          // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy\n          if (this.flowLevel !== FlowLevel_1.FlowLevel.Knot) {\n            this.Error(\"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\");\n          }\n          // Not allowed sub-flows\n          for (var [key, value] of this._subFlowsByName) {\n            this.Error(\"Functions may not contain stitches, but saw '\".concat(key, \"' within the function '\").concat(this.identifier, \"'\"), value);\n          }\n          if (!this._rootWeave) {\n            throw new Error();\n          }\n          var allDiverts = this._rootWeave.FindAll(Divert_1.Divert)();\n          for (var divert of allDiverts) {\n            if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget_1.DivertTarget)) {\n              this.Error(\"Functions may not contain diverts, but saw '\".concat(divert, \"'\"), divert);\n            }\n          }\n          var allChoices = this._rootWeave.FindAll(Choice_1.Choice)();\n          for (var choice of allChoices) {\n            this.Error(\"Functions may not contain choices, but saw '\".concat(choice, \"'\"), choice);\n          }\n        };\n        this.WarningInTermination = terminatingObject => {\n          var message = \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";\n          if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {\n            message = \"\".concat(message, \" Note that if you intend to enter '\").concat(this._firstChildFlow.identifier, \"' next, you need to divert to it explicitly.\");\n          }\n          var terminatingDivert = (0, TypeAssertion_1.asOrNull)(terminatingObject, Divert_1.Divert);\n          if (terminatingDivert && terminatingDivert.isTunnel) {\n            message += \" When final tunnel to '\".concat(terminatingDivert.target, \" ->' returns it won't have anywhere to go.\");\n          }\n          this.Warning(message, terminatingObject);\n        };\n        this.toString = () => \"\".concat(this.typeName, \" '\").concat(this.identifier, \"'\");\n        this.identifier = identifier;\n        this.args = args;\n        if (topLevelObjects === null) {\n          topLevelObjects = [];\n        }\n        // Used by story to add includes\n        this.PreProcessTopLevelObjects(topLevelObjects);\n        topLevelObjects = this.SplitWeaveAndSubFlowContent(topLevelObjects, this.GetType() == \"Story\" && !isIncludedStory);\n        this.AddContent(topLevelObjects);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      PreProcessTopLevelObjects(_) {\n        // empty by default, used by Story to process included file references\n      }\n      ResolveReferences(context) {\n        var _a, _b;\n        if (this._startingSubFlowDivert) {\n          if (!this._startingSubFlowRuntime) {\n            throw new Error();\n          }\n          this._startingSubFlowDivert.targetPath = this._startingSubFlowRuntime.path;\n        }\n        super.ResolveReferences(context);\n        // Check validity of parameter names\n        if (this.args !== null) {\n          for (var arg of this.args) {\n            context.CheckForNamingCollisions(this, arg.identifier, SymbolType_1.SymbolType.Arg, \"argument\");\n          }\n          // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,\n          // so have to be checked independently.\n          for (var ii = 0; ii < this.args.length; ii += 1) {\n            for (var jj = ii + 1; jj < this.args.length; jj += 1) {\n              if (((_a = this.args[ii].identifier) === null || _a === void 0 ? void 0 : _a.name) == ((_b = this.args[jj].identifier) === null || _b === void 0 ? void 0 : _b.name)) {\n                this.Error(\"Multiple arguments with the same name: '\".concat(this.args[ii].identifier, \"'\"));\n              }\n            }\n          }\n        }\n        // Check naming collisions for knots and stitches\n        if (this.flowLevel !== FlowLevel_1.FlowLevel.Story) {\n          // Weave points aren't FlowBases, so this will only be knot or stitch\n          var symbolType = this.flowLevel === FlowLevel_1.FlowLevel.Knot ? SymbolType_1.SymbolType.Knot : SymbolType_1.SymbolType.SubFlowAndWeave;\n          context.CheckForNamingCollisions(this, this.identifier, symbolType);\n        }\n      }\n    };\n    FlowBase.FlowBase = FlowBase$1;\n    return FlowBase;\n  }\n\n  var FunctionCall = {};\n\n  var VariableReference = {};\n\n  var ContentList = {};\n\n  var hasRequiredContentList;\n  function requireContentList() {\n    if (hasRequiredContentList) return ContentList;\n    hasRequiredContentList = 1;\n    Object.defineProperty(ContentList, \"__esModule\", {\n      value: true\n    });\n    ContentList.ContentList = void 0;\n    var Container_1 = requireContainer();\n    var Object_1 = require_Object();\n    var Text_1 = requireText();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let ContentList$1 = class ContentList extends Object_1.ParsedObject {\n      get runtimeContainer() {\n        return this.runtimeObject;\n      }\n      constructor(objects) {\n        super();\n        this.dontFlatten = false;\n        this.TrimTrailingWhitespace = () => {\n          for (var ii = this.content.length - 1; ii >= 0; --ii) {\n            var text = (0, TypeAssertion_1.asOrNull)(this.content[ii], Text_1.Text);\n            if (text === null) {\n              break;\n            }\n            text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");\n            if (text.text.length === 0) {\n              this.content.splice(ii, 1);\n            } else {\n              break;\n            }\n          }\n        };\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          if (this.content !== null) {\n            for (var obj of this.content) {\n              var contentObjRuntime = obj.runtimeObject;\n              // Some objects (e.g. author warnings) don't generate runtime objects\n              if (contentObjRuntime) {\n                container.AddContent(contentObjRuntime);\n              }\n            }\n          }\n          if (this.dontFlatten) {\n            this.story.DontFlattenContainer(container);\n          }\n          return container;\n        };\n        this.toString = () => \"ContentList(\".concat(this.content.join(\", \"), \")\");\n        if (objects) {\n          this.AddContent(objects);\n        }\n        for (var _len = arguments.length, moreObjects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          moreObjects[_key - 1] = arguments[_key];\n        }\n        if (moreObjects) {\n          this.AddContent(moreObjects);\n        }\n      }\n      get typeName() {\n        return \"ContentList\";\n      }\n    };\n    ContentList.ContentList = ContentList$1;\n    return ContentList;\n  }\n\n  var hasRequiredVariableReference;\n  function requireVariableReference() {\n    if (hasRequiredVariableReference) return VariableReference;\n    hasRequiredVariableReference = 1;\n    Object.defineProperty(VariableReference, \"__esModule\", {\n      value: true\n    });\n    VariableReference.VariableReference = void 0;\n    var ContentList_1 = requireContentList();\n    var Expression_1 = requireExpression();\n    var FlowBase_1 = requireFlowBase();\n    var Path_1 = requirePath();\n    var VariableReference_1 = requireVariableReference$1();\n    var Weave_1 = requireWeave();\n    var Identifier_1 = requireIdentifier();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let VariableReference$1 = class VariableReference extends Expression_1.Expression {\n      // - Normal variables have a single item in their \"path\"\n      // - Knot/stitch names for read counts are actual dot-separated paths\n      //   (though this isn't actually used at time of writing)\n      // - List names are dot separated: listName.itemName (or just itemName)\n      get name() {\n        return this.path.join(\".\");\n      }\n      get path() {\n        return this.pathIdentifiers.map(id => id.name).filter(TypeAssertion_1.filterUndef);\n      }\n      get identifier() {\n        if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {\n          return null;\n        }\n        var name = this.path.join(\".\");\n        var id = new Identifier_1.Identifier(name);\n        return id;\n      }\n      get runtimeVarRef() {\n        return this._runtimeVarRef;\n      }\n      constructor(pathIdentifiers) {\n        super();\n        this.pathIdentifiers = pathIdentifiers;\n        this._runtimeVarRef = null;\n        // Only known after GenerateIntoContainer has run\n        this.isConstantReference = false;\n        this.isListItemReference = false;\n        this.GenerateIntoContainer = container => {\n          var constantValue = this.story.constants.get(this.name);\n          // If it's a constant reference, just generate the literal expression value\n          // It's okay to access the constants at code generation time, since the\n          // first thing the ExportRuntime function does it search for all the constants\n          // in the story hierarchy, so they're all available.\n          if (constantValue) {\n            constantValue.GenerateConstantIntoContainer(container);\n            this.isConstantReference = true;\n            return;\n          }\n          this._runtimeVarRef = new VariableReference_1.VariableReference(this.name);\n          // List item reference?\n          // Path might be to a list (listName.listItemName or just listItemName)\n          if (this.path.length === 1 || this.path.length === 2) {\n            var listItemName = \"\";\n            var listName = \"\";\n            if (this.path.length === 1) {\n              listItemName = this.path[0];\n            } else {\n              listName = this.path[0];\n              listItemName = this.path[1];\n            }\n            var listItem = this.story.ResolveListItem(listName, listItemName, this);\n            if (listItem) {\n              this.isListItemReference = true;\n            }\n          }\n          container.AddContent(this._runtimeVarRef);\n        };\n        this.toString = () => \"{\".concat(this.path.join(\".\"), \"}\");\n      }\n      get typeName() {\n        return \"ref\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        // Work is already done if it's a constant or list item reference\n        if (this.isConstantReference || this.isListItemReference) {\n          return;\n        }\n        // Is it a read count?\n        var parsedPath = new Path_1.Path(this.pathIdentifiers);\n        var targetForCount = parsedPath.ResolveFromContext(this);\n        if (targetForCount) {\n          if (!targetForCount.containerForCounting) {\n            throw new Error();\n          }\n          targetForCount.containerForCounting.visitsShouldBeCounted = true;\n          // If this is an argument to a function that wants a variable to be\n          // passed by reference, then the Parsed.Divert will have generated a\n          // Runtime.VariablePointerValue instead of allowing this object\n          // to generate its RuntimeVariableReference. This only happens under\n          // error condition since we shouldn't be passing a read count by\n          // reference, but we don't want it to crash!\n          if (this._runtimeVarRef === null) {\n            return;\n          }\n          this._runtimeVarRef.pathForCount = targetForCount.runtimePath;\n          this._runtimeVarRef.name = null;\n          // Check for very specific writer error: getting read count and\n          // printing it as content rather than as a piece of logic\n          // e.g. Writing {myFunc} instead of {myFunc()}\n          var targetFlow = (0, TypeAssertion_1.asOrNull)(targetForCount, FlowBase_1.FlowBase);\n          if (targetFlow && targetFlow.isFunction) {\n            // Is parent context content rather than logic?\n            if (this.parent instanceof Weave_1.Weave || this.parent instanceof ContentList_1.ContentList || this.parent instanceof FlowBase_1.FlowBase) {\n              this.Warning(\"'\".concat(targetFlow.identifier, \"' being used as read count rather than being called as function. Perhaps you intended to write \").concat(targetFlow.identifier, \"()\"));\n            }\n          }\n          return;\n        }\n        // Couldn't find this multi-part path at all, whether as a divert\n        // target or as a list item reference.\n        if (this.path.length > 1) {\n          var errorMsg = \"Could not find target for read count: \".concat(parsedPath);\n          if (this.path.length <= 2) {\n            errorMsg += \", or couldn't find list item with the name \".concat(this.path.join(\",\"));\n          }\n          this.Error(errorMsg);\n          return;\n        }\n        if (!context.ResolveVariableWithName(this.name, this).found) {\n          this.Error(\"Unresolved variable: \".concat(this.name), this);\n        }\n      }\n    };\n    VariableReference.VariableReference = VariableReference$1;\n    return VariableReference;\n  }\n\n  var hasRequiredFunctionCall;\n  function requireFunctionCall() {\n    if (hasRequiredFunctionCall) return FunctionCall;\n    hasRequiredFunctionCall = 1;\n    Object.defineProperty(FunctionCall, \"__esModule\", {\n      value: true\n    });\n    FunctionCall.FunctionCall = void 0;\n    var ControlCommand_1 = requireControlCommand();\n    var Divert_1 = requireDivert();\n    var DivertTarget_1 = requireDivertTarget();\n    var Expression_1 = requireExpression();\n    var InkList_1 = requireInkList();\n    var Value_1 = requireValue();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var NumberExpression_1 = requireNumberExpression();\n    var Path_1 = requirePath();\n    var Value_2 = requireValue();\n    var VariableReference_1 = requireVariableReference();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let FunctionCall$1 = class FunctionCall extends Expression_1.Expression {\n      get proxyDivert() {\n        return this._proxyDivert;\n      }\n      get name() {\n        return this._proxyDivert.target.firstComponent || \"\";\n      }\n      get args() {\n        return this._proxyDivert.args;\n      }\n      get runtimeDivert() {\n        return this._proxyDivert.runtimeDivert;\n      }\n      get isChoiceCount() {\n        return this.name === \"CHOICE_COUNT\";\n      }\n      get isTurns() {\n        return this.name === \"TURNS\";\n      }\n      get isTurnsSince() {\n        return this.name === \"TURNS_SINCE\";\n      }\n      get isRandom() {\n        return this.name === \"RANDOM\";\n      }\n      get isSeedRandom() {\n        return this.name === \"SEED_RANDOM\";\n      }\n      get isListRange() {\n        return this.name === \"LIST_RANGE\";\n      }\n      get isListRandom() {\n        return this.name === \"LIST_RANDOM\";\n      }\n      get isReadCount() {\n        return this.name === \"READ_COUNT\";\n      }\n      constructor(functionName, args) {\n        super();\n        this._divertTargetToCount = null;\n        this._variableReferenceToCount = null;\n        this.shouldPopReturnedValue = false;\n        this.GenerateIntoContainer = container => {\n          var foundList = this.story.ResolveList(this.name);\n          var usingProxyDivert = false;\n          if (this.isChoiceCount) {\n            if (this.args.length > 0) {\n              this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");\n            }\n            container.AddContent(ControlCommand_1.ControlCommand.ChoiceCount());\n          } else if (this.isTurns) {\n            if (this.args.length > 0) {\n              this.Error(\"The TURNS() function shouldn't take any arguments\");\n            }\n            container.AddContent(ControlCommand_1.ControlCommand.Turns());\n          } else if (this.isTurnsSince || this.isReadCount) {\n            var divertTarget = (0, TypeAssertion_1.asOrNull)(this.args[0], DivertTarget_1.DivertTarget);\n            var variableDivertTarget = (0, TypeAssertion_1.asOrNull)(this.args[0], VariableReference_1.VariableReference);\n            if (this.args.length !== 1 || divertTarget === null && variableDivertTarget === null) {\n              this.Error(\"The \".concat(this.name, \"() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)\"));\n              return;\n            }\n            if (divertTarget) {\n              this._divertTargetToCount = divertTarget;\n              this.AddContent(this._divertTargetToCount);\n              this._divertTargetToCount.GenerateIntoContainer(container);\n            } else if (variableDivertTarget) {\n              this._variableReferenceToCount = variableDivertTarget;\n              this.AddContent(this._variableReferenceToCount);\n              this._variableReferenceToCount.GenerateIntoContainer(container);\n            }\n            if (this.isTurnsSince) {\n              container.AddContent(ControlCommand_1.ControlCommand.TurnsSince());\n            } else {\n              container.AddContent(ControlCommand_1.ControlCommand.ReadCount());\n            }\n          } else if (this.isRandom) {\n            if (this.args.length !== 2) {\n              this.Error(\"RANDOM should take 2 parameters: a minimum and a maximum integer\");\n            }\n            // We can type check single values, but not complex expressions\n            for (var ii = 0; ii < this.args.length; ii += 1) {\n              var num = (0, TypeAssertion_1.asOrNull)(this.args[ii], NumberExpression_1.NumberExpression);\n              if (num && !num.isInt()) {\n                var paramName = ii === 0 ? \"minimum\" : \"maximum\";\n                this.Error(\"RANDOM's \".concat(paramName, \" parameter should be an integer\"));\n              }\n              this.args[ii].GenerateIntoContainer(container);\n            }\n            container.AddContent(ControlCommand_1.ControlCommand.Random());\n          } else if (this.isSeedRandom) {\n            if (this.args.length !== 1) {\n              this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");\n            }\n            var _num = (0, TypeAssertion_1.asOrNull)(this.args[0], NumberExpression_1.NumberExpression);\n            if (_num && !_num.isInt()) {\n              this.Error(\"SEED_RANDOM's parameter should be an integer seed\");\n            }\n            this.args[0].GenerateIntoContainer(container);\n            container.AddContent(ControlCommand_1.ControlCommand.SeedRandom());\n          } else if (this.isListRange) {\n            if (this.args.length !== 3) {\n              this.Error(\"LIST_RANGE should take 3 parameters - a list, a min and a max\");\n            }\n            for (var _ii = 0; _ii < this.args.length; _ii += 1) {\n              this.args[_ii].GenerateIntoContainer(container);\n            }\n            container.AddContent(ControlCommand_1.ControlCommand.ListRange());\n          } else if (this.isListRandom) {\n            if (this.args.length !== 1) {\n              this.Error(\"LIST_RANDOM should take 1 parameter - a list\");\n            }\n            this.args[0].GenerateIntoContainer(container);\n            container.AddContent(ControlCommand_1.ControlCommand.ListRandom());\n          } else if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(this.name)) {\n            var nativeCall = NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.name);\n            if (nativeCall.numberOfParameters !== this.args.length) {\n              var msg = \"\".concat(FunctionCall.name, \" should take \").concat(nativeCall.numberOfParameters, \" parameter\");\n              if (nativeCall.numberOfParameters > 1) {\n                msg += \"s\";\n              }\n              this.Error(msg);\n            }\n            for (var _ii2 = 0; _ii2 < this.args.length; _ii2 += 1) {\n              this.args[_ii2].GenerateIntoContainer(container);\n            }\n            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.name));\n          } else if (foundList !== null) {\n            if (this.args.length > 1) {\n              this.Error(\"Can currently only construct a list from one integer (or an empty list from a given list definition)\");\n            }\n            // List item from given int\n            if (this.args.length === 1) {\n              container.AddContent(new Value_2.StringValue(this.name));\n              this.args[0].GenerateIntoContainer(container);\n              container.AddContent(ControlCommand_1.ControlCommand.ListFromInt());\n            } else {\n              // Empty list with given origin.\n              var list = new InkList_1.InkList();\n              list.SetInitialOriginName(this.name);\n              container.AddContent(new Value_1.ListValue(list));\n            }\n          } else {\n            // Normal function call\n            container.AddContent(this._proxyDivert.runtimeObject);\n            usingProxyDivert = true;\n          }\n          // Don't attempt to resolve as a divert if we're not doing a normal function call\n          if (!usingProxyDivert) {\n            this.content.splice(this.content.indexOf(this._proxyDivert), 1);\n          }\n          // Function calls that are used alone on a tilda-based line:\n          //  ~ func()\n          // Should tidy up any returned value from the evaluation stack,\n          // since it's unused.\n          if (this.shouldPopReturnedValue) {\n            container.AddContent(ControlCommand_1.ControlCommand.PopEvaluatedValue());\n          }\n        };\n        this.toString = () => {\n          var strArgs = this.args.join(\", \");\n          return \"\".concat(this.name, \"(\").concat(strArgs, \")\");\n        };\n        this._proxyDivert = new Divert_1.Divert(new Path_1.Path(functionName), args);\n        this._proxyDivert.isFunctionCall = true;\n        this.AddContent(this._proxyDivert);\n      }\n      get typeName() {\n        return \"FunctionCall\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        // If we aren't using the proxy divert after all (e.g. if\n        // it's a native function call), but we still have arguments,\n        // we need to make sure they get resolved since the proxy divert\n        // is no longer in the content array.\n        if (!this.content.includes(this._proxyDivert) && this.args !== null) {\n          for (var arg of this.args) {\n            arg.ResolveReferences(context);\n          }\n        }\n        if (this._divertTargetToCount) {\n          var divert = this._divertTargetToCount.divert;\n          var attemptingTurnCountOfVariableTarget = divert.runtimeDivert.variableDivertName != null;\n          if (attemptingTurnCountOfVariableTarget) {\n            this.Error(\"When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(\".concat(divert.runtimeDivert.variableDivertName, \")\"));\n            return;\n          }\n          var targetObject = divert.targetContent;\n          if (targetObject === null) {\n            if (!attemptingTurnCountOfVariableTarget) {\n              this.Error(\"Failed to find target for TURNS_SINCE: '\".concat(divert.target, \"'\"));\n            }\n          } else {\n            if (!targetObject.containerForCounting) {\n              throw new Error();\n            }\n            targetObject.containerForCounting.turnIndexShouldBeCounted = true;\n          }\n        } else if (this._variableReferenceToCount) {\n          var runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;\n          if (!runtimeVarRef) {\n            throw new Error();\n          }\n          if (runtimeVarRef.pathForCount !== null) {\n            this.Error(\"Should be '\".concat(FunctionCall.name, \"'(-> '\").concat(this._variableReferenceToCount.name, \"). Usage without the '->' only makes sense for variable targets.\"));\n          }\n        }\n      }\n    };\n    FunctionCall.FunctionCall = FunctionCall$1;\n    FunctionCall$1.IsBuiltIn = name => {\n      if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(name)) {\n        return true;\n      }\n      return name === \"CHOICE_COUNT\" || name === \"TURNS_SINCE\" || name === \"TURNS\" || name === \"RANDOM\" || name === \"SEED_RANDOM\" || name === \"LIST_VALUE\" || name === \"LIST_RANDOM\" || name === \"READ_COUNT\";\n    };\n    return FunctionCall;\n  }\n\n  var MultipleConditionExpression = {};\n\n  var hasRequiredMultipleConditionExpression;\n  function requireMultipleConditionExpression() {\n    if (hasRequiredMultipleConditionExpression) return MultipleConditionExpression;\n    hasRequiredMultipleConditionExpression = 1;\n    Object.defineProperty(MultipleConditionExpression, \"__esModule\", {\n      value: true\n    });\n    MultipleConditionExpression.MultipleConditionExpression = void 0;\n    var Expression_1 = requireExpression();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    let MultipleConditionExpression$1 = class MultipleConditionExpression extends Expression_1.Expression {\n      get subExpressions() {\n        return this.content;\n      }\n      constructor(conditionExpressions) {\n        super();\n        this.GenerateIntoContainer = container => {\n          //    A && B && C && D\n          // => (((A B &&) C &&) D &&) etc\n          var isFirst = true;\n          for (var conditionExpr of this.subExpressions) {\n            conditionExpr.GenerateIntoContainer(container);\n            if (!isFirst) {\n              container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"&&\"));\n            }\n            isFirst = false;\n          }\n        };\n        this.AddContent(conditionExpressions);\n      }\n      get typeName() {\n        return \"MultipleConditionExpression\";\n      }\n    };\n    MultipleConditionExpression.MultipleConditionExpression = MultipleConditionExpression$1;\n    return MultipleConditionExpression;\n  }\n\n  var hasRequiredDivertTarget;\n  function requireDivertTarget() {\n    if (hasRequiredDivertTarget) return DivertTarget;\n    hasRequiredDivertTarget = 1;\n    Object.defineProperty(DivertTarget, \"__esModule\", {\n      value: true\n    });\n    DivertTarget.DivertTarget = void 0;\n    var BinaryExpression_1 = requireBinaryExpression();\n    var Choice_1 = requireChoice();\n    var Conditional_1 = requireConditional();\n    var ConditionalSingleBranch_1 = requireConditionalSingleBranch();\n    var Value_1 = requireValue();\n    var Expression_1 = requireExpression();\n    var FlowBase_1 = requireFlowBase();\n    var FunctionCall_1 = requireFunctionCall();\n    var MultipleConditionExpression_1 = requireMultipleConditionExpression();\n    var VariableReference_1 = requireVariableReference();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let DivertTarget$1 = class DivertTarget extends Expression_1.Expression {\n      get runtimeDivert() {\n        if (!this._runtimeDivert) {\n          throw new Error();\n        }\n        return this._runtimeDivert;\n      }\n      get runtimeDivertTargetValue() {\n        if (!this._runtimeDivertTargetValue) {\n          throw new Error();\n        }\n        return this._runtimeDivertTargetValue;\n      }\n      constructor(divert) {\n        super();\n        this._runtimeDivert = null;\n        this._runtimeDivertTargetValue = null;\n        this.GenerateIntoContainer = container => {\n          this.divert.GenerateRuntimeObject();\n          this._runtimeDivert = this.divert.runtimeDivert;\n          this._runtimeDivertTargetValue = new Value_1.DivertTargetValue();\n          container.AddContent(this.runtimeDivertTargetValue);\n        };\n        // Equals override necessary in order to check for CONST multiple definition equality\n        this.Equals = obj => {\n          var otherDivTarget = (0, TypeAssertion_1.asOrNull)(obj, DivertTarget);\n          if (!otherDivTarget || !this.divert.target || !otherDivTarget.divert.target) {\n            return false;\n          }\n          var targetStr = this.divert.target.dotSeparatedComponents;\n          var otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;\n          return targetStr === otherTargetStr;\n        };\n        this.divert = this.AddContent(divert);\n      }\n      get typeName() {\n        return \"DivertTarget\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        if (this.divert.isDone || this.divert.isEnd) {\n          this.Error(\"Can't use -> DONE or -> END as variable divert targets\", this);\n          return;\n        }\n        var usageContext = this;\n        while (usageContext && usageContext instanceof Expression_1.Expression) {\n          var badUsage = false;\n          var foundUsage = false;\n          var usageParent = usageContext.parent;\n          if (usageParent instanceof BinaryExpression_1.BinaryExpression) {\n            // Only allowed to compare for equality\n            var binaryExprParent = usageParent;\n            if (binaryExprParent.opName !== \"==\" && binaryExprParent.opName !== \"!=\") {\n              badUsage = true;\n            } else {\n              if (!(binaryExprParent.leftExpression instanceof DivertTarget || binaryExprParent.leftExpression instanceof VariableReference_1.VariableReference)) {\n                badUsage = true;\n              } else if (!(binaryExprParent.rightExpression instanceof DivertTarget || binaryExprParent.rightExpression instanceof VariableReference_1.VariableReference)) {\n                badUsage = true;\n              }\n            }\n            foundUsage = true;\n          } else if (usageParent instanceof FunctionCall_1.FunctionCall) {\n            var funcCall = usageParent;\n            if (!funcCall.isTurnsSince && !funcCall.isReadCount) {\n              badUsage = true;\n            }\n            foundUsage = true;\n          } else if (usageParent instanceof Expression_1.Expression) {\n            badUsage = true;\n            foundUsage = true;\n          } else if (usageParent instanceof MultipleConditionExpression_1.MultipleConditionExpression) {\n            badUsage = true;\n            foundUsage = true;\n          } else if (usageParent instanceof Choice_1.Choice && usageParent.condition === usageContext) {\n            badUsage = true;\n            foundUsage = true;\n          } else if (usageParent instanceof Conditional_1.Conditional || usageParent instanceof ConditionalSingleBranch_1.ConditionalSingleBranch) {\n            badUsage = true;\n            foundUsage = true;\n          }\n          if (badUsage) {\n            this.Error(\"Can't use a divert target like that. Did you intend to call '\".concat(this.divert.target, \"' as a function: likeThis(), or check the read count: likeThis, with no arrows?\"), this);\n          }\n          if (foundUsage) {\n            break;\n          }\n          usageContext = usageParent;\n        }\n        // Example ink for this case:\n        //\n        //     VAR x = -> blah\n        //\n        // ...which means that \"blah\" is expected to be a literal stitch target rather\n        // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to\n        // contain a divert target itself) since really we should be generating a variable reference\n        // rather than a concrete DivertTarget, so we list it as an error.\n        if (this.runtimeDivert.hasVariableTarget) {\n          if (!this.divert.target) {\n            throw new Error();\n          }\n          this.Error(\"Since '\".concat(this.divert.target.dotSeparatedComponents, \"' is a variable, it shouldn't be preceded by '->' here.\"));\n        }\n        // Main resolve\n        this.runtimeDivert.targetPath && (this.runtimeDivertTargetValue.targetPath = this.runtimeDivert.targetPath);\n        // Tell hard coded (yet variable) divert targets that they also need to be counted\n        // TODO: Only detect DivertTargets that are values rather than being used directly for\n        // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting\n        var targetContent = this.divert.targetContent;\n        if (targetContent !== null) {\n          var target = targetContent.containerForCounting;\n          if (target !== null) {\n            // Purpose is known: used directly in TURNS_SINCE(-> divTarg)\n            var parentFunc = (0, TypeAssertion_1.asOrNull)(this.parent, FunctionCall_1.FunctionCall);\n            if (parentFunc && parentFunc.isTurnsSince) {\n              target.turnIndexShouldBeCounted = true;\n            } else {\n              // Unknown purpose, count everything\n              target.visitsShouldBeCounted = true;\n              target.turnIndexShouldBeCounted = true;\n            }\n          }\n          // Unfortunately not possible:\n          // https://github.com/inkle/ink/issues/538\n          //\n          // VAR func = -> double\n          //\n          // === function double(ref x)\n          //    ~ x = x * 2\n          //\n          // Because when generating the parameters for a function\n          // to be called, it needs to know ahead of time when\n          // compiling whether to pass a variable reference or value.\n          //\n          var targetFlow = (0, TypeAssertion_1.asOrNull)(targetContent, FlowBase_1.FlowBase);\n          if (targetFlow != null && targetFlow.args !== null) {\n            for (var arg of targetFlow.args) {\n              if (arg.isByReference) {\n                this.Error(\"Can't store a divert target to a knot or function that has by-reference arguments ('\".concat(targetFlow.identifier, \"' has 'ref \").concat(arg.identifier, \"').\"));\n              }\n            }\n          }\n        }\n      }\n    };\n    DivertTarget.DivertTarget = DivertTarget$1;\n    return DivertTarget;\n  }\n\n  var hasRequiredDivert;\n  function requireDivert() {\n    if (hasRequiredDivert) return Divert;\n    hasRequiredDivert = 1;\n    Object.defineProperty(Divert, \"__esModule\", {\n      value: true\n    });\n    Divert.Divert = void 0;\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Divert_1 = requireDivert$1();\n    var DivertTarget_1 = requireDivertTarget();\n    var FlowBase_1 = requireFlowBase();\n    var FunctionCall_1 = requireFunctionCall();\n    var Object_1 = require_Object();\n    var Path_1 = requirePath();\n    var Path_2 = requirePath$1();\n    var PushPop_1 = requirePushPop();\n    var Value_1 = requireValue();\n    var VariableReference_1 = requireVariableReference();\n    var ClosestFlowBase_1 = requireClosestFlowBase();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let Divert$1 = class Divert extends Object_1.ParsedObject {\n      get runtimeDivert() {\n        if (!this._runtimeDivert) {\n          throw new Error();\n        }\n        return this._runtimeDivert;\n      }\n      set runtimeDivert(value) {\n        this._runtimeDivert = value;\n      }\n      get isEnd() {\n        return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");\n      }\n      get isDone() {\n        return Boolean(this.target && this.target.dotSeparatedComponents === \"DONE\");\n      }\n      constructor(target, args) {\n        super();\n        this.args = [];\n        this.target = null;\n        this.targetContent = null;\n        this._runtimeDivert = null;\n        this.isFunctionCall = false;\n        this.isEmpty = false;\n        this.isTunnel = false;\n        this.isThread = false;\n        this.GenerateRuntimeObject = () => {\n          // End = end flow immediately\n          // Done = return from thread or instruct the flow that it's safe to exit\n          if (this.isEnd) {\n            return ControlCommand_1.ControlCommand.End();\n          } else if (this.isDone) {\n            return ControlCommand_1.ControlCommand.Done();\n          }\n          this.runtimeDivert = new Divert_1.Divert();\n          // Normally we resolve the target content during the\n          // Resolve phase, since we expect all runtime objects to\n          // be available in order to find the final runtime path for\n          // the destination. However, we need to resolve the target\n          // (albeit without the runtime target) early so that\n          // we can get information about the arguments - whether\n          // they're by reference - since it affects the code we\n          // generate here.\n          this.ResolveTargetContent();\n          this.CheckArgumentValidity();\n          // Passing arguments to the knot\n          var requiresArgCodeGen = this.args !== null && this.args.length > 0;\n          if (requiresArgCodeGen || this.isFunctionCall || this.isTunnel || this.isThread) {\n            var container = new Container_1.Container();\n            // Generate code for argument evaluation\n            // This argument generation is coded defensively - it should\n            // attempt to generate the code for all the parameters, even if\n            // they don't match the expected arguments. This is so that the\n            // parameter objects themselves are generated correctly and don't\n            // get into a state of attempting to resolve references etc\n            // without being generated.\n            if (requiresArgCodeGen) {\n              // Function calls already in an evaluation context\n              if (!this.isFunctionCall) {\n                container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n              }\n              var targetArguments = null;\n              if (this.targetContent) {\n                targetArguments = this.targetContent.args;\n              }\n              for (var ii = 0; ii < this.args.length; ++ii) {\n                var argToPass = this.args[ii];\n                var argExpected = null;\n                if (targetArguments && ii < targetArguments.length) {\n                  argExpected = targetArguments[ii];\n                }\n                // Pass by reference: argument needs to be a variable reference\n                if (argExpected && argExpected.isByReference) {\n                  var varRef = (0, TypeAssertion_1.asOrNull)(argToPass, VariableReference_1.VariableReference);\n                  if (!varRef) {\n                    this.Error(\"Expected variable name to pass by reference to 'ref \".concat(argExpected.identifier, \"' but saw \").concat(argToPass));\n                    break;\n                  }\n                  // Check that we're not attempting to pass a read count by reference\n                  var targetPath = new Path_1.Path(varRef.pathIdentifiers);\n                  var targetForCount = targetPath.ResolveFromContext(this);\n                  if (targetForCount) {\n                    this.Error(\"can't pass a read count by reference. '\".concat(targetPath.dotSeparatedComponents, \"' is a knot/stitch/label, but '\").concat(this.target.dotSeparatedComponents, \"' requires the name of a VAR to be passed.\"));\n                    break;\n                  }\n                  var varPointer = new Value_1.VariablePointerValue(varRef.name);\n                  container.AddContent(varPointer);\n                } else {\n                  // Normal value being passed: evaluate it as normal\n                  argToPass.GenerateIntoContainer(container);\n                }\n              }\n              // Function calls were already in an evaluation context\n              if (!this.isFunctionCall) {\n                container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n              }\n            }\n            // Starting a thread? A bit like a push to the call stack below... but not.\n            // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.\n            if (this.isThread) {\n              container.AddContent(ControlCommand_1.ControlCommand.StartThread());\n            } else if (this.isFunctionCall || this.isTunnel) {\n              // If this divert is a function call, tunnel, we push to the call stack\n              // so we can return again\n              this.runtimeDivert.pushesToStack = true;\n              this.runtimeDivert.stackPushType = this.isFunctionCall ? PushPop_1.PushPopType.Function : PushPop_1.PushPopType.Tunnel;\n            }\n            // Jump into the \"function\" (knot/stitch)\n            container.AddContent(this.runtimeDivert);\n            return container;\n          }\n          // Simple divert\n          return this.runtimeDivert;\n        };\n        // When the divert is to a target that's actually a variable name\n        // rather than an explicit knot/stitch name, try interpretting it\n        // as such by getting the variable name.\n        this.PathAsVariableName = () => this.target ? this.target.firstComponent : null;\n        this.ResolveTargetContent = () => {\n          if (this.isEmpty || this.isEnd) {\n            return;\n          }\n          if (this.targetContent === null) {\n            // Is target of this divert a variable name that will be de-referenced\n            // at runtime? If so, there won't be any further reference resolution\n            // we can do at this point.\n            var variableTargetName = this.PathAsVariableName();\n            if (variableTargetName !== null) {\n              var flowBaseScope = (0, TypeAssertion_1.asOrNull)((0, ClosestFlowBase_1.ClosestFlowBase)(this), FlowBase_1.FlowBase);\n              if (flowBaseScope) {\n                var resolveResult = flowBaseScope.ResolveVariableWithName(variableTargetName, this);\n                if (resolveResult.found) {\n                  // Make sure that the flow was typed correctly, given that we know that this\n                  // is meant to be a divert target\n                  if (resolveResult.isArgument && resolveResult.ownerFlow && resolveResult.ownerFlow.args) {\n                    var argument = resolveResult.ownerFlow.args.find(a => {\n                      var _a;\n                      return ((_a = a.identifier) === null || _a === void 0 ? void 0 : _a.name) == variableTargetName;\n                    });\n                    if (argument && !argument.isDivertTarget) {\n                      this.Error(\"Since '\".concat(argument.identifier, \"' is used as a variable divert target (on \").concat(this.debugMetadata, \"), it should be marked as: -> \").concat(argument.identifier), resolveResult.ownerFlow);\n                    }\n                  }\n                  this.runtimeDivert.variableDivertName = variableTargetName;\n                  return;\n                }\n              }\n            }\n            if (!this.target) {\n              throw new Error();\n            }\n            this.targetContent = this.target.ResolveFromContext(this);\n          }\n        };\n        // Returns false if there's an error\n        this.CheckArgumentValidity = () => {\n          if (this.isEmpty) {\n            return;\n          }\n          // Argument passing: Check for errors in number of arguments\n          var numArgs = 0;\n          if (this.args !== null && this.args.length > 0) {\n            numArgs = this.args.length;\n          }\n          // Missing content?\n          // Can't check arguments properly. It'll be due to some\n          // other error though, so although there's a problem and\n          // we report false, we don't need to report a specific error.\n          // It may also be because it's a valid call to an external\n          // function, that we check at the resolve stage.\n          if (this.targetContent === null) {\n            return;\n          }\n          var targetFlow = (0, TypeAssertion_1.asOrNull)(this.targetContent, FlowBase_1.FlowBase);\n          // No error, crikey!\n          if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {\n            return;\n          } else if (targetFlow === null && numArgs > 0) {\n            this.Error(\"target needs to be a knot or stitch in order to pass arguments\");\n            return;\n          } else if (targetFlow !== null && (targetFlow.args === null || !targetFlow.args && numArgs > 0)) {\n            this.Error(\"target (\".concat(targetFlow.name, \") doesn't take parameters\"));\n            return;\n          } else if (this.parent instanceof DivertTarget_1.DivertTarget) {\n            if (numArgs > 0) {\n              this.Error(\"can't store arguments in a divert target variable\");\n            }\n            return;\n          }\n          var paramCount = targetFlow.args.length;\n          if (paramCount !== numArgs) {\n            var butClause;\n            if (numArgs === 0) {\n              butClause = \"but there weren't any passed to it\";\n            } else if (numArgs < paramCount) {\n              butClause = \"but only got \".concat(numArgs);\n            } else {\n              butClause = \"but got \".concat(numArgs);\n            }\n            this.Error(\"to '\".concat(targetFlow.identifier, \"' requires \").concat(paramCount, \" arguments, \").concat(butClause));\n            return;\n          }\n          // Light type-checking for divert target arguments\n          for (var ii = 0; ii < paramCount; ++ii) {\n            var flowArg = targetFlow.args[ii];\n            var divArgExpr = this.args[ii];\n            // Expecting a divert target as an argument, let's do some basic type checking\n            if (flowArg.isDivertTarget) {\n              // Not passing a divert target or any kind of variable reference?\n              var varRef = (0, TypeAssertion_1.asOrNull)(divArgExpr, VariableReference_1.VariableReference);\n              if (!(divArgExpr instanceof DivertTarget_1.DivertTarget) && varRef === null) {\n                this.Error(\"Target '\".concat(targetFlow.identifier, \"' expects a divert target for the parameter named -> \").concat(flowArg.identifier, \" but saw \").concat(divArgExpr), divArgExpr);\n              } else if (varRef) {\n                // Passing 'a' instead of '-> a'?\n                // i.e. read count instead of divert target\n                // Unfortunately have to manually resolve here since we're still in code gen\n                var knotCountPath = new Path_1.Path(varRef.pathIdentifiers);\n                var targetForCount = knotCountPath.ResolveFromContext(varRef);\n                if (targetForCount) {\n                  this.Error(\"Passing read count of '\".concat(knotCountPath.dotSeparatedComponents, \"' instead of a divert target. You probably meant '\").concat(knotCountPath, \"'\"));\n                }\n              }\n            }\n          }\n          if (targetFlow === null) {\n            this.Error(\"Can't call as a function or with arguments unless it's a knot or stitch\");\n            return;\n          }\n          return;\n        };\n        this.CheckExternalArgumentValidity = context => {\n          var externalName = this.target ? this.target.firstComponent : null;\n          var external = context.externals.get(externalName);\n          if (!external) {\n            throw new Error(\"external not found\");\n          }\n          var externalArgCount = external.argumentNames.length;\n          var ownArgCount = 0;\n          if (this.args) {\n            ownArgCount = this.args.length;\n          }\n          if (ownArgCount !== externalArgCount) {\n            this.Error(\"incorrect number of arguments sent to external function '\".concat(externalName, \"'. Expected \").concat(externalArgCount, \" but got \").concat(ownArgCount));\n          }\n        };\n        this.toString = () => {\n          var returnString = \"\";\n          if (this.target !== null) {\n            returnString += this.target.toString();\n          } else {\n            return \"-> <empty divert>\";\n          }\n          if (this.isTunnel) {\n            returnString += \" ->\";\n          }\n          if (this.isFunctionCall) {\n            returnString += \" ()\";\n          }\n          return returnString;\n        };\n        if (target) {\n          this.target = target;\n        }\n        if (args) {\n          this.args = args;\n          this.AddContent(args);\n        }\n      }\n      get typeName() {\n        return \"Divert\";\n      }\n      ResolveReferences(context) {\n        if (this.isEmpty || this.isEnd || this.isDone) {\n          return;\n        } else if (!this.runtimeDivert) {\n          throw new Error();\n        }\n        if (this.targetContent) {\n          this.runtimeDivert.targetPath = this.targetContent.runtimePath;\n        }\n        // Resolve children (the arguments)\n        super.ResolveReferences(context);\n        // May be null if it's a built in function (e.g. TURNS_SINCE)\n        // or if it's a variable target.\n        var targetFlow = (0, TypeAssertion_1.asOrNull)(this.targetContent, FlowBase_1.FlowBase);\n        if (targetFlow) {\n          if (!targetFlow.isFunction && this.isFunctionCall) {\n            super.Error(\"\".concat(targetFlow.identifier, \" hasn't been marked as a function, but it's being called as one. Do you need to declare the knot as '== function \").concat(targetFlow.identifier, \" =='?\"));\n          } else if (targetFlow.isFunction && !this.isFunctionCall && !(this.parent instanceof DivertTarget_1.DivertTarget)) {\n            super.Error(targetFlow.identifier + \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" + targetFlow.identifier + \"(...)'\");\n          }\n        }\n        // Check validity of target content\n        var targetWasFound = this.targetContent !== null;\n        var isBuiltIn = false;\n        var isExternal = false;\n        if (!this.target) {\n          throw new Error();\n        } else if (this.target.numberOfComponents === 1) {\n          if (!this.target.firstComponent) {\n            throw new Error();\n          }\n          // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM\n          isBuiltIn = FunctionCall_1.FunctionCall.IsBuiltIn(this.target.firstComponent);\n          // Client-bound function?\n          isExternal = context.IsExternal(this.target.firstComponent);\n          if (isBuiltIn || isExternal) {\n            if (!this.isFunctionCall) {\n              super.Error(\"\".concat(this.target.firstComponent, \" must be called as a function: ~ \").concat(this.target.firstComponent, \"()\"));\n            }\n            if (isExternal) {\n              this.runtimeDivert.isExternal = true;\n              if (this.args !== null) {\n                this.runtimeDivert.externalArgs = this.args.length;\n              }\n              this.runtimeDivert.pushesToStack = false;\n              this.runtimeDivert.targetPath = new Path_2.Path(this.target.firstComponent);\n              this.CheckExternalArgumentValidity(context);\n            }\n            return;\n          }\n        }\n        // Variable target?\n        if (this.runtimeDivert.variableDivertName != null) {\n          return;\n        }\n        if (!targetWasFound && !isBuiltIn && !isExternal) {\n          this.Error(\"target not found: '\".concat(this.target, \"'\"));\n        }\n      }\n      Error(message) {\n        var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var isWarning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        // Could be getting an error from a nested Divert\n        if (source !== this && source) {\n          super.Error(message, source);\n          return;\n        }\n        if (this.isFunctionCall) {\n          super.Error(\"Function call \".concat(message), source, isWarning);\n        } else {\n          super.Error(\"Divert \".concat(message), source, isWarning);\n        }\n      }\n    };\n    Divert.Divert = Divert$1;\n    return Divert;\n  }\n\n  var GatherPointToResolve = {};\n\n  var hasRequiredGatherPointToResolve;\n  function requireGatherPointToResolve() {\n    if (hasRequiredGatherPointToResolve) return GatherPointToResolve;\n    hasRequiredGatherPointToResolve = 1;\n    Object.defineProperty(GatherPointToResolve, \"__esModule\", {\n      value: true\n    });\n    GatherPointToResolve.GatherPointToResolve = void 0;\n    let GatherPointToResolve$1 = class GatherPointToResolve {\n      constructor(divert, targetRuntimeObj) {\n        this.divert = divert;\n        this.targetRuntimeObj = targetRuntimeObj;\n      }\n    };\n    GatherPointToResolve.GatherPointToResolve = GatherPointToResolve$1;\n    return GatherPointToResolve;\n  }\n\n  var Sequence = {};\n\n  var SequenceDivertToResolve = {};\n\n  var hasRequiredSequenceDivertToResolve;\n  function requireSequenceDivertToResolve() {\n    if (hasRequiredSequenceDivertToResolve) return SequenceDivertToResolve;\n    hasRequiredSequenceDivertToResolve = 1;\n    Object.defineProperty(SequenceDivertToResolve, \"__esModule\", {\n      value: true\n    });\n    SequenceDivertToResolve.SequenceDivertToResolve = void 0;\n    let SequenceDivertToResolve$1 = class SequenceDivertToResolve {\n      constructor(divert, targetContent) {\n        this.divert = divert;\n        this.targetContent = targetContent;\n      }\n    };\n    SequenceDivertToResolve.SequenceDivertToResolve = SequenceDivertToResolve$1;\n    return SequenceDivertToResolve;\n  }\n\n  var SequenceType = {};\n\n  var hasRequiredSequenceType;\n  function requireSequenceType() {\n    if (hasRequiredSequenceType) return SequenceType;\n    hasRequiredSequenceType = 1;\n    Object.defineProperty(SequenceType, \"__esModule\", {\n      value: true\n    });\n    SequenceType.SequenceType = void 0;\n    var SequenceType$1;\n    (function (SequenceType) {\n      SequenceType[SequenceType[\"Stopping\"] = 1] = \"Stopping\";\n      SequenceType[SequenceType[\"Cycle\"] = 2] = \"Cycle\";\n      SequenceType[SequenceType[\"Shuffle\"] = 4] = \"Shuffle\";\n      SequenceType[SequenceType[\"Once\"] = 8] = \"Once\";\n    })(SequenceType$1 || (SequenceType.SequenceType = SequenceType$1 = {}));\n    return SequenceType;\n  }\n\n  var hasRequiredSequence;\n  function requireSequence() {\n    if (hasRequiredSequence) return Sequence;\n    hasRequiredSequence = 1;\n    Object.defineProperty(Sequence, \"__esModule\", {\n      value: true\n    });\n    Sequence.Sequence = void 0;\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Divert_1 = requireDivert$1();\n    var Value_1 = requireValue();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var Object_1 = require_Object();\n    var SequenceDivertToResolve_1 = requireSequenceDivertToResolve();\n    var SequenceType_1 = requireSequenceType();\n    var Weave_1 = requireWeave();\n    let Sequence$1 = class Sequence extends Object_1.ParsedObject {\n      constructor(elementContentLists, sequenceType) {\n        super();\n        this.sequenceType = sequenceType;\n        this._sequenceDivertsToResolve = [];\n        // Generate runtime code that looks like:\n        //\n        //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"\n        //   if chosenIndex == 0, divert to s0\n        //   if chosenIndex == 1, divert to s1  [etc]\n        //\n        //   - s0:\n        //      <content for sequence element>\n        //      divert to no-op\n        //   - s1:\n        //      <content for sequence element>\n        //      divert to no-op\n        //   - s2:\n        //      empty branch if using \"once\"\n        //      divert to no-op\n        //\n        //    no-op\n        //\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          container.visitsShouldBeCounted = true;\n          container.countingAtStartOnly = true;\n          this._sequenceDivertsToResolve = [];\n          // Get sequence read count\n          container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n          container.AddContent(ControlCommand_1.ControlCommand.VisitIndex());\n          var once = (this.sequenceType & SequenceType_1.SequenceType.Once) > 0;\n          var cycle = (this.sequenceType & SequenceType_1.SequenceType.Cycle) > 0;\n          var stopping = (this.sequenceType & SequenceType_1.SequenceType.Stopping) > 0;\n          var shuffle = (this.sequenceType & SequenceType_1.SequenceType.Shuffle) > 0;\n          var seqBranchCount = this.sequenceElements.length;\n          if (once) {\n            seqBranchCount += 1;\n          }\n          // Chosen sequence index:\n          //  - Stopping: take the MIN(read count, num elements - 1)\n          //  - Once: take the MIN(read count, num elements)\n          //    (the last one being empty)\n          if (stopping || once) {\n            //var limit = stopping ? seqBranchCount-1 : seqBranchCount;\n            container.AddContent(new Value_1.IntValue(seqBranchCount - 1));\n            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"MIN\"));\n          } else if (cycle) {\n            // - Cycle: take (read count % num elements)\n            container.AddContent(new Value_1.IntValue(this.sequenceElements.length));\n            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"%\"));\n          }\n          // Shuffle\n          if (shuffle) {\n            // Create point to return to when sequence is complete\n            var postShuffleNoOp = ControlCommand_1.ControlCommand.NoOp();\n            // When visitIndex == lastIdx, we skip the shuffle\n            if (once || stopping) {\n              // if( visitIndex == lastIdx ) -> skipShuffle\n              var lastIdx = stopping ? this.sequenceElements.length - 1 : this.sequenceElements.length;\n              container.AddContent(ControlCommand_1.ControlCommand.Duplicate());\n              container.AddContent(new Value_1.IntValue(lastIdx));\n              container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"==\"));\n              var skipShuffleDivert = new Divert_1.Divert();\n              skipShuffleDivert.isConditional = true;\n              container.AddContent(skipShuffleDivert);\n              this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);\n            }\n            // This one's a bit more complex! Choose the index at runtime.\n            var elementCountToShuffle = this.sequenceElements.length;\n            if (stopping) {\n              elementCountToShuffle -= 1;\n            }\n            container.AddContent(new Value_1.IntValue(elementCountToShuffle));\n            container.AddContent(ControlCommand_1.ControlCommand.SequenceShuffleIndex());\n            if (once || stopping) {\n              container.AddContent(postShuffleNoOp);\n            }\n          }\n          container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n          // Create point to return to when sequence is complete\n          var postSequenceNoOp = ControlCommand_1.ControlCommand.NoOp();\n          // Each of the main sequence branches, and one extra empty branch if\n          // we have a \"once\" sequence.\n          for (var elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {\n            // This sequence element:\n            //  if( chosenIndex == this index ) divert to this sequence element\n            // duplicate chosen sequence index, since it'll be consumed by \"==\"\n            container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n            container.AddContent(ControlCommand_1.ControlCommand.Duplicate());\n            container.AddContent(new Value_1.IntValue(elIndex));\n            container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"==\"));\n            container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n            // Divert branch for this sequence element\n            var sequenceDivert = new Divert_1.Divert();\n            sequenceDivert.isConditional = true;\n            container.AddContent(sequenceDivert);\n            var contentContainerForSequenceBranch = void 0;\n            // Generate content for this sequence element\n            if (elIndex < this.sequenceElements.length) {\n              var el = this.sequenceElements[elIndex];\n              contentContainerForSequenceBranch = el.runtimeObject;\n            } else {\n              // Final empty branch for \"once\" sequences\n              contentContainerForSequenceBranch = new Container_1.Container();\n            }\n            contentContainerForSequenceBranch.name = \"s\".concat(elIndex);\n            contentContainerForSequenceBranch.InsertContent(ControlCommand_1.ControlCommand.PopEvaluatedValue(), 0);\n            // When sequence element is complete, divert back to end of sequence\n            var seqBranchCompleteDivert = new Divert_1.Divert();\n            contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);\n            container.AddToNamedContentOnly(contentContainerForSequenceBranch);\n            // Save the diverts for reference resolution later (in ResolveReferences)\n            this.AddDivertToResolve(sequenceDivert, contentContainerForSequenceBranch);\n            this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);\n          }\n          container.AddContent(postSequenceNoOp);\n          return container;\n        };\n        this.AddDivertToResolve = (divert, targetContent) => {\n          this._sequenceDivertsToResolve.push(new SequenceDivertToResolve_1.SequenceDivertToResolve(divert, targetContent));\n        };\n        this.sequenceType = sequenceType;\n        this.sequenceElements = [];\n        for (var elementContentList of elementContentLists) {\n          var contentObjs = elementContentList.content;\n          var seqElObject = null;\n          // Don't attempt to create a weave for the sequence element\n          // if the content list is empty. Weaves don't like it!\n          if (contentObjs === null || contentObjs.length === 0) {\n            seqElObject = elementContentList;\n          } else {\n            seqElObject = new Weave_1.Weave(contentObjs);\n          }\n          this.sequenceElements.push(seqElObject);\n          this.AddContent(seqElObject);\n        }\n      }\n      get typeName() {\n        return \"Sequence\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        for (var toResolve of this._sequenceDivertsToResolve) {\n          toResolve.divert.targetPath = toResolve.targetContent.path;\n        }\n      }\n    };\n    Sequence.Sequence = Sequence$1;\n    return Sequence;\n  }\n\n  var TunnelOnwards = {};\n\n  var hasRequiredTunnelOnwards;\n  function requireTunnelOnwards() {\n    if (hasRequiredTunnelOnwards) return TunnelOnwards;\n    hasRequiredTunnelOnwards = 1;\n    Object.defineProperty(TunnelOnwards, \"__esModule\", {\n      value: true\n    });\n    TunnelOnwards.TunnelOnwards = void 0;\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Divert_1 = requireDivert$1();\n    var Value_1 = requireValue();\n    var Object_1 = require_Object();\n    var Void_1 = requireVoid();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var VariableReference_1 = requireVariableReference$1();\n    let TunnelOnwards$1 = class TunnelOnwards extends Object_1.ParsedObject {\n      constructor() {\n        super(...arguments);\n        this._overrideDivertTarget = null;\n        this._divertAfter = null;\n        this.GenerateRuntimeObject = () => {\n          var container = new Container_1.Container();\n          // Set override path for tunnel onwards (or nothing)\n          container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n          if (this.divertAfter) {\n            // Generate runtime object's generated code and steal the arguments runtime code\n            var returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();\n            var returnRuntimeContainer = returnRuntimeObj;\n            if (returnRuntimeContainer) {\n              // Steal all code for generating arguments from the divert\n              var args = this.divertAfter.args;\n              if (args !== null && args.length > 0) {\n                // Steal everything betwen eval start and eval end\n                var evalStart = -1;\n                var evalEnd = -1;\n                for (var ii = 0; ii < returnRuntimeContainer.content.length; ii += 1) {\n                  var cmd = returnRuntimeContainer.content[ii];\n                  if (cmd) {\n                    if (evalStart == -1 && cmd.commandType === ControlCommand_1.ControlCommand.CommandType.EvalStart) {\n                      evalStart = ii;\n                    } else if (cmd.commandType === ControlCommand_1.ControlCommand.CommandType.EvalEnd) {\n                      evalEnd = ii;\n                    }\n                  }\n                }\n                for (var _ii = evalStart + 1; _ii < evalEnd; _ii += 1) {\n                  var obj = returnRuntimeContainer.content[_ii];\n                  obj.parent = null; // prevent error of being moved between owners\n                  container.AddContent(returnRuntimeContainer.content[_ii]);\n                }\n              }\n            }\n            // Supply the divert target for the tunnel onwards target, either variable or more commonly, the explicit name\n            // var returnDivertObj = returnRuntimeObj as Runtime.Divert;\n            var returnDivertObj = (0, TypeAssertion_1.asOrNull)(returnRuntimeObj, Divert_1.Divert);\n            if (returnDivertObj != null && returnDivertObj.hasVariableTarget) {\n              var runtimeVarRef = new VariableReference_1.VariableReference(returnDivertObj.variableDivertName);\n              container.AddContent(runtimeVarRef);\n            } else {\n              this._overrideDivertTarget = new Value_1.DivertTargetValue();\n              container.AddContent(this._overrideDivertTarget);\n            }\n          } else {\n            // No divert after tunnel onwards\n            container.AddContent(new Void_1.Void());\n          }\n          container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n          container.AddContent(ControlCommand_1.ControlCommand.PopTunnel());\n          return container;\n        };\n        this.toString = () => {\n          return \" -> \".concat(this._divertAfter);\n        };\n      }\n      get divertAfter() {\n        return this._divertAfter;\n      }\n      set divertAfter(value) {\n        this._divertAfter = value;\n        if (this._divertAfter) {\n          this.AddContent(this._divertAfter);\n        }\n      }\n      get typeName() {\n        return \"TunnelOnwards\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        if (this.divertAfter && this.divertAfter.targetContent) {\n          this._overrideDivertTarget.targetPath = this.divertAfter.targetContent.runtimePath;\n        }\n      }\n    };\n    TunnelOnwards.TunnelOnwards = TunnelOnwards$1;\n    return TunnelOnwards;\n  }\n\n  var VariableAssignment = {};\n\n  var ListDefinition = {};\n\n  var hasRequiredListDefinition;\n  function requireListDefinition() {\n    if (hasRequiredListDefinition) return ListDefinition;\n    hasRequiredListDefinition = 1;\n    Object.defineProperty(ListDefinition, \"__esModule\", {\n      value: true\n    });\n    ListDefinition.ListDefinition = void 0;\n    var InkList_1 = requireInkList();\n    var InkList_2 = requireInkList();\n    var ListDefinition_1 = requireListDefinition$1();\n    var Value_1 = requireValue();\n    var Object_1 = require_Object();\n    var SymbolType_1 = requireSymbolType();\n    let ListDefinition$1 = class ListDefinition extends Object_1.ParsedObject {\n      get typeName() {\n        return \"ListDefinition\";\n      }\n      get runtimeListDefinition() {\n        var _a;\n        var allItems = new Map();\n        for (var e of this.itemDefinitions) {\n          if (!allItems.has(e.name)) {\n            allItems.set(e.name, e.seriesValue);\n          } else {\n            this.Error(\"List '\".concat(this.identifier, \"' contains duplicate items called '\").concat(e.name, \"'\"));\n          }\n        }\n        return new ListDefinition_1.ListDefinition(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\", allItems);\n      }\n      constructor(itemDefinitions) {\n        super();\n        this.itemDefinitions = itemDefinitions;\n        this.identifier = null;\n        this.variableAssignment = null;\n        this._elementsByName = null;\n        this.ItemNamed = itemName => {\n          if (this._elementsByName === null) {\n            this._elementsByName = new Map();\n            for (var el of this.itemDefinitions) {\n              this._elementsByName.set(el.name, el);\n            }\n          }\n          var foundElement = this._elementsByName.get(itemName) || null;\n          return foundElement;\n        };\n        this.GenerateRuntimeObject = () => {\n          var _a, _b;\n          var initialValues = new InkList_1.InkList();\n          for (var itemDef of this.itemDefinitions) {\n            if (itemDef.inInitialList) {\n              var item = new InkList_2.InkListItem(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null, itemDef.name || null);\n              initialValues.Add(item, itemDef.seriesValue);\n            }\n          }\n          // Set origin name, so\n          initialValues.SetInitialOriginName(((_b = this.identifier) === null || _b === void 0 ? void 0 : _b.name) || \"\");\n          return new Value_1.ListValue(initialValues);\n        };\n        var currentValue = 1;\n        for (var e of this.itemDefinitions) {\n          if (e.explicitValue !== null) {\n            currentValue = e.explicitValue;\n          }\n          e.seriesValue = currentValue;\n          currentValue += 1;\n        }\n        this.AddContent(itemDefinitions);\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        context.CheckForNamingCollisions(this, this.identifier, SymbolType_1.SymbolType.List);\n      }\n    };\n    ListDefinition.ListDefinition = ListDefinition$1;\n    return ListDefinition;\n  }\n\n  var hasRequiredVariableAssignment;\n  function requireVariableAssignment() {\n    if (hasRequiredVariableAssignment) return VariableAssignment;\n    hasRequiredVariableAssignment = 1;\n    Object.defineProperty(VariableAssignment, \"__esModule\", {\n      value: true\n    });\n    VariableAssignment.VariableAssignment = void 0;\n    var Container_1 = requireContainer();\n    var ClosestFlowBase_1 = requireClosestFlowBase();\n    var ListDefinition_1 = requireListDefinition();\n    var Object_1 = require_Object();\n    var SymbolType_1 = requireSymbolType();\n    var VariableAssignment_1 = requireVariableAssignment$1();\n    var VariableReference_1 = requireVariableReference();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let VariableAssignment$1 = class VariableAssignment extends Object_1.ParsedObject {\n      get variableName() {\n        return this.variableIdentifier.name;\n      }\n      get typeName() {\n        if (this.isNewTemporaryDeclaration) {\n          return \"temp\";\n        } else if (this.isGlobalDeclaration) {\n          if (this.listDefinition !== null) {\n            return \"LIST\";\n          }\n          return \"VAR\";\n        }\n        return \"variable assignment\";\n      }\n      get isDeclaration() {\n        return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;\n      }\n      constructor(_ref) {\n        var {\n          assignedExpression,\n          isGlobalDeclaration,\n          isTemporaryNewDeclaration,\n          listDef,\n          variableIdentifier\n        } = _ref;\n        super();\n        this._runtimeAssignment = null;\n        this.expression = null;\n        this.listDefinition = null;\n        this.GenerateRuntimeObject = () => {\n          var newDeclScope = null;\n          if (this.isGlobalDeclaration) {\n            newDeclScope = this.story;\n          } else if (this.isNewTemporaryDeclaration) {\n            newDeclScope = (0, ClosestFlowBase_1.ClosestFlowBase)(this);\n          }\n          if (newDeclScope) {\n            newDeclScope.AddNewVariableDeclaration(this);\n          }\n          // Global declarations don't generate actual procedural\n          // runtime objects, but instead add a global variable to the story itself.\n          // The story then initialises them all in one go at the start of the game.\n          if (this.isGlobalDeclaration) {\n            return null;\n          }\n          var container = new Container_1.Container();\n          // The expression's runtimeObject is actually another nested container\n          if (this.expression) {\n            container.AddContent(this.expression.runtimeObject);\n          } else if (this.listDefinition) {\n            container.AddContent(this.listDefinition.runtimeObject);\n          }\n          this._runtimeAssignment = new VariableAssignment_1.VariableAssignment(this.variableName, this.isNewTemporaryDeclaration);\n          container.AddContent(this._runtimeAssignment);\n          return container;\n        };\n        this.toString = () => \"\".concat(this.isGlobalDeclaration ? \"VAR\" : this.isNewTemporaryDeclaration ? \"~ temp\" : \"\", \" \").concat(this.variableName);\n        this.variableIdentifier = variableIdentifier;\n        this.isGlobalDeclaration = Boolean(isGlobalDeclaration);\n        this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);\n        // Defensive programming in case parsing of assignedExpression failed\n        if (listDef instanceof ListDefinition_1.ListDefinition) {\n          this.listDefinition = this.AddContent(listDef);\n          this.listDefinition.variableAssignment = this;\n          // List definitions are always global\n          this.isGlobalDeclaration = true;\n        } else if (assignedExpression) {\n          this.expression = this.AddContent(assignedExpression);\n        }\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        // List definitions are checked for conflicts separately\n        if (this.isDeclaration && this.listDefinition === null) {\n          context.CheckForNamingCollisions(this, this.variableIdentifier, this.isGlobalDeclaration ? SymbolType_1.SymbolType.Var : SymbolType_1.SymbolType.Temp);\n        }\n        // Initial VAR x = [intialValue] declaration, not re-assignment\n        if (this.isGlobalDeclaration) {\n          var variableReference = (0, TypeAssertion_1.asOrNull)(this.expression, VariableReference_1.VariableReference);\n          if (variableReference && !variableReference.isConstantReference && !variableReference.isListItemReference) {\n            this.Error(\"global variable assignments cannot refer to other variables, only literal values, constants and list items\");\n          }\n        }\n        if (!this.isNewTemporaryDeclaration) {\n          var resolvedVarAssignment = context.ResolveVariableWithName(this.variableName, this);\n          if (!resolvedVarAssignment.found) {\n            if (this.variableName in this.story.constants) {\n              this.Error(\"Can't re-assign to a constant (do you need to use VAR when declaring '\".concat(this.variableName, \"'?)\"), this);\n            } else {\n              this.Error(\"Variable could not be found to assign to: '\".concat(this.variableName, \"'\"), this);\n            }\n          }\n          // A runtime assignment may not have been generated if it's the initial global declaration,\n          // since these are hoisted out and handled specially in Story.ExportRuntime.\n          if (this._runtimeAssignment) {\n            this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;\n          }\n        }\n      }\n    };\n    VariableAssignment.VariableAssignment = VariableAssignment$1;\n    return VariableAssignment;\n  }\n\n  var hasRequiredWeave;\n  function requireWeave() {\n    if (hasRequiredWeave) return Weave;\n    hasRequiredWeave = 1;\n    Object.defineProperty(Weave, \"__esModule\", {\n      value: true\n    });\n    Weave.Weave = void 0;\n    var AuthorWarning_1 = requireAuthorWarning();\n    var Choice_1 = requireChoice();\n    var Conditional_1 = requireConditional();\n    var ConstantDeclaration_1 = requireConstantDeclaration();\n    var Container_1 = requireContainer();\n    var Divert_1 = requireDivert();\n    var Divert_2 = requireDivert$1();\n    var DivertTarget_1 = requireDivertTarget();\n    var FlowBase_1 = requireFlowBase();\n    var Gather_1 = requireGather();\n    var GatherPointToResolve_1 = requireGatherPointToResolve();\n    var Object_1 = require_Object();\n    var Sequence_1 = requireSequence();\n    var Text_1 = requireText();\n    var TunnelOnwards_1 = requireTunnelOnwards();\n    var VariableAssignment_1 = requireVariableAssignment();\n    var TypeAssertion_1 = requireTypeAssertion();\n    // Used by the FlowBase when constructing the weave flow from\n    // a flat list of content objects.\n    let Weave$1 = class Weave extends Object_1.ParsedObject {\n      // Containers can be chained as multiple gather points\n      // get created as the same indentation level.\n      // rootContainer is always the first in the chain, while\n      // currentContainer is the latest.\n      get rootContainer() {\n        if (!this._rootContainer) {\n          this._rootContainer = this.GenerateRuntimeObject();\n        }\n        return this._rootContainer;\n      }\n      get namedWeavePoints() {\n        return this._namedWeavePoints;\n      }\n      get lastParsedSignificantObject() {\n        if (this.content.length === 0) {\n          return null;\n        }\n        // Don't count extraneous newlines or VAR/CONST declarations,\n        // since they're \"empty\" statements outside of the main flow.\n        var lastObject = null;\n        for (var ii = this.content.length - 1; ii >= 0; --ii) {\n          lastObject = this.content[ii];\n          var lastText = (0, TypeAssertion_1.asOrNull)(lastObject, Text_1.Text);\n          if (lastText && lastText.text === \"\\n\") {\n            continue;\n          }\n          if (this.IsGlobalDeclaration(lastObject)) {\n            continue;\n          }\n          break;\n        }\n        var lastWeave = (0, TypeAssertion_1.asOrNull)(lastObject, Weave);\n        if (lastWeave) {\n          lastObject = lastWeave.lastParsedSignificantObject;\n        }\n        return lastObject;\n      }\n      constructor(cont) {\n        var indentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        super();\n        // Keep track of previous weave point (Choice or Gather)\n        // at the current indentation level:\n        //  - to add ordinary content to be nested under it\n        //  - to add nested content under it when it's indented\n        //  - to remove it from the list of loose ends when\n        //     - it has indented content since it's no longer a loose end\n        //     - it's a gather and it has a choice added to it\n        this.previousWeavePoint = null;\n        this.addContentToPreviousWeavePoint = false;\n        // Used for determining whether the next Gather should auto-enter\n        this.hasSeenChoiceInSection = false;\n        this.currentContainer = null;\n        this._unnamedGatherCount = 0;\n        this._choiceCount = 0;\n        this._rootContainer = null;\n        this._namedWeavePoints = new Map();\n        // Loose ends are:\n        //  - Choices or Gathers that need to be joined up\n        //  - Explicit Divert to gather points (i.e. \"->\" without a target)\n        this.looseEnds = [];\n        this.gatherPointsToResolve = [];\n        this.ResolveWeavePointNaming = () => {\n          var _a, _b, _c;\n          var namedWeavePoints = [...this.FindAll(Gather_1.Gather)(w => !(w.name === null || w.name === undefined)), ...this.FindAll(Choice_1.Choice)(w => !(w.name === null || w.name === undefined))];\n          this._namedWeavePoints = new Map();\n          for (var weavePoint of namedWeavePoints) {\n            // Check for weave point naming collisions\n            var existingWeavePoint = this.namedWeavePoints.get(((_a = weavePoint.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\");\n            if (existingWeavePoint) {\n              var typeName = existingWeavePoint instanceof Gather_1.Gather ? \"gather\" : \"choice\";\n              var existingObj = existingWeavePoint;\n              this.Error(\"A \".concat(typeName, \" with the same label name '\").concat(weavePoint.name, \"' already exists in this context on line \").concat(existingObj.debugMetadata ? existingObj.debugMetadata.startLineNumber : \"NO DEBUG METADATA AVAILABLE\"), weavePoint);\n            }\n            if ((_b = weavePoint.identifier) === null || _b === void 0 ? void 0 : _b.name) {\n              this.namedWeavePoints.set((_c = weavePoint.identifier) === null || _c === void 0 ? void 0 : _c.name, weavePoint);\n            }\n          }\n        };\n        this.ConstructWeaveHierarchyFromIndentation = () => {\n          // Find nested indentation and convert to a proper object hierarchy\n          // (i.e. indented content is replaced with a Weave object that contains\n          // that nested content)\n          var contentIdx = 0;\n          while (contentIdx < this.content.length) {\n            var obj = this.content[contentIdx];\n            // Choice or Gather\n            if (obj instanceof Choice_1.Choice || obj instanceof Gather_1.Gather) {\n              var weavePoint = obj;\n              var weaveIndentIdx = weavePoint.indentationDepth - 1;\n              // Inner level indentation - recurse\n              if (weaveIndentIdx > this.baseIndentIndex) {\n                // Step through content until indent jumps out again\n                var innerWeaveStartIdx = contentIdx;\n                while (contentIdx < this.content.length) {\n                  var innerWeaveObj = (0, TypeAssertion_1.asOrNull)(this.content[contentIdx], Choice_1.Choice) || (0, TypeAssertion_1.asOrNull)(this.content[contentIdx], Gather_1.Gather);\n                  if (innerWeaveObj !== null) {\n                    var innerIndentIdx = innerWeaveObj.indentationDepth - 1;\n                    if (innerIndentIdx <= this.baseIndentIndex) {\n                      break;\n                    }\n                  }\n                  contentIdx += 1;\n                }\n                var weaveContentCount = contentIdx - innerWeaveStartIdx;\n                var weaveContent = this.content.slice(innerWeaveStartIdx, innerWeaveStartIdx + weaveContentCount);\n                this.content.splice(innerWeaveStartIdx, weaveContentCount);\n                var weave = new Weave(weaveContent, weaveIndentIdx);\n                this.InsertContent(innerWeaveStartIdx, weave);\n                // Continue iteration from this point\n                contentIdx = innerWeaveStartIdx;\n              }\n            }\n            contentIdx += 1;\n          }\n        };\n        // When the indentation wasn't told to us at construction time using\n        // a choice point with a known indentation level, we may be told to\n        // determine the indentation level by incrementing from our closest ancestor.\n        this.DetermineBaseIndentationFromContent = contentList => {\n          for (var obj of contentList) {\n            if (obj instanceof Choice_1.Choice || obj instanceof Gather_1.Gather) {\n              return obj.indentationDepth - 1;\n            }\n          }\n          // No weave points, so it doesn't matter\n          return 0;\n        };\n        this.GenerateRuntimeObject = () => {\n          this._rootContainer = new Container_1.Container();\n          this.currentContainer = this._rootContainer;\n          this.looseEnds = [];\n          this.gatherPointsToResolve = [];\n          // Iterate through content for the block at this level of indentation\n          //  - Normal content is nested under Choices and Gathers\n          //  - Blocks that are further indented cause recursion\n          //  - Keep track of loose ends so that they can be diverted to Gathers\n          for (var obj of this.content) {\n            // Choice or Gather\n            if (obj instanceof Choice_1.Choice || obj instanceof Gather_1.Gather) {\n              this.AddRuntimeForWeavePoint(obj);\n            } else {\n              // Non-weave point\n              if (obj instanceof Weave) {\n                // Nested weave\n                var weave = obj;\n                this.AddRuntimeForNestedWeave(weave);\n                this.gatherPointsToResolve.splice(0, 0, ...weave.gatherPointsToResolve);\n              } else {\n                // Other object\n                // May be complex object that contains statements - e.g. a multi-line conditional\n                this.AddGeneralRuntimeContent(obj.runtimeObject);\n              }\n            }\n          }\n          // Pass any loose ends up the hierarhcy\n          this.PassLooseEndsToAncestors();\n          return this._rootContainer;\n        };\n        // Found gather point:\n        //  - gather any loose ends\n        //  - set the gather as the main container to dump new content in\n        this.AddRuntimeForGather = gather => {\n          // Determine whether this Gather should be auto-entered:\n          //  - It is auto-entered if there were no choices in the last section\n          //  - A section is \"since the previous gather\" - so reset now\n          var autoEnter = !this.hasSeenChoiceInSection;\n          this.hasSeenChoiceInSection = false;\n          var gatherContainer = gather.runtimeContainer;\n          if (!gather.name) {\n            // Use disallowed character so it's impossible to have a name collision\n            gatherContainer.name = \"g-\".concat(this._unnamedGatherCount);\n            this._unnamedGatherCount += 1;\n          }\n          if (autoEnter) {\n            if (!this.currentContainer) {\n              throw new Error();\n            }\n            // Auto-enter: include in main content\n            this.currentContainer.AddContent(gatherContainer);\n          } else {\n            // Don't auto-enter:\n            // Add this gather to the main content, but only accessible\n            // by name so that it isn't stepped into automatically, but only via\n            // a divert from a loose end.\n            this.rootContainer.AddToNamedContentOnly(gatherContainer);\n          }\n          // Consume loose ends: divert them to this gather\n          for (var looseEndWeavePoint of this.looseEnds) {\n            var looseEnd = looseEndWeavePoint;\n            // Skip gather loose ends that are at the same level\n            // since they'll be handled by the auto-enter code below\n            // that only jumps into the gather if (current runtime choices == 0)\n            if (looseEnd instanceof Gather_1.Gather) {\n              var prevGather = looseEnd;\n              if (prevGather.indentationDepth == gather.indentationDepth) {\n                continue;\n              }\n            }\n            var divert = null;\n            if (looseEnd instanceof Divert_1.Divert) {\n              divert = looseEnd.runtimeObject;\n            } else {\n              divert = new Divert_2.Divert();\n              var looseWeavePoint = looseEnd;\n              if (!looseWeavePoint.runtimeContainer) {\n                throw new Error();\n              }\n              looseWeavePoint.runtimeContainer.AddContent(divert);\n            }\n            // Pass back knowledge of this loose end being diverted\n            // to the FlowBase so that it can maintain a list of them,\n            // and resolve the divert references later\n            this.gatherPointsToResolve.push(new GatherPointToResolve_1.GatherPointToResolve(divert, gatherContainer));\n          }\n          this.looseEnds = [];\n          // Replace the current container itself\n          this.currentContainer = gatherContainer;\n        };\n        this.AddRuntimeForWeavePoint = weavePoint => {\n          // Current level Gather\n          if (weavePoint instanceof Gather_1.Gather) {\n            this.AddRuntimeForGather(weavePoint);\n          }\n          // Current level choice\n          else if (weavePoint instanceof Choice_1.Choice) {\n            if (!this.currentContainer) {\n              throw new Error();\n            }\n            // Gathers that contain choices are no longer loose ends\n            // (same as when weave points get nested content)\n            if (this.previousWeavePoint instanceof Gather_1.Gather) {\n              this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n            }\n            // Add choice point content\n            var choice = weavePoint; //, Choice);\n            this.currentContainer.AddContent(choice.runtimeObject);\n            if (!choice.innerContentContainer) {\n              throw new Error();\n            } //guaranteed not to happen\n            // Add choice's inner content to self\n            choice.innerContentContainer.name = \"c-\".concat(this._choiceCount);\n            this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);\n            this._choiceCount += 1;\n            this.hasSeenChoiceInSection = true;\n          }\n          // Keep track of loose ends\n          this.addContentToPreviousWeavePoint = false; // default\n          if (this.WeavePointHasLooseEnd(weavePoint)) {\n            this.looseEnds.push(weavePoint);\n            var looseChoice = (0, TypeAssertion_1.asOrNull)(weavePoint, Choice_1.Choice);\n            if (looseChoice) {\n              this.addContentToPreviousWeavePoint = true;\n            }\n          }\n          this.previousWeavePoint = weavePoint;\n        };\n        // Add nested block at a greater indentation level\n        this.AddRuntimeForNestedWeave = nestedResult => {\n          // Add this inner block to current container\n          // (i.e. within the main container, or within the last defined Choice/Gather)\n          this.AddGeneralRuntimeContent(nestedResult.rootContainer);\n          // Now there's a deeper indentation level, the previous weave point doesn't\n          // count as a loose end (since it will have content to go to)\n          if (this.previousWeavePoint !== null) {\n            this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n            this.addContentToPreviousWeavePoint = false;\n          }\n        };\n        // Normal content gets added into the latest Choice or Gather by default,\n        // unless there hasn't been one yet.\n        this.AddGeneralRuntimeContent = content => {\n          // Content is allowed to evaluate runtimeObject to null\n          // (e.g. AuthorWarning, which doesn't make it into the runtime)\n          if (content === null) {\n            return;\n          }\n          if (this.addContentToPreviousWeavePoint) {\n            if (!this.previousWeavePoint || !this.previousWeavePoint.runtimeContainer) {\n              throw new Error();\n            }\n            this.previousWeavePoint.runtimeContainer.AddContent(content);\n          } else {\n            if (!this.currentContainer) {\n              throw new Error();\n            }\n            this.currentContainer.AddContent(content);\n          }\n        };\n        this.PassLooseEndsToAncestors = () => {\n          if (this.looseEnds.length === 0) {\n            return;\n          }\n          // Search for Weave ancestor to pass loose ends to for gathering.\n          // There are two types depending on whether the current weave\n          // is separated by a conditional or sequence.\n          //  - An \"inner\" weave is one that is directly connected to the current\n          //    weave - i.e. you don't have to pass through a conditional or\n          //    sequence to get to it. We're allowed to pass all loose ends to\n          //    one of these.\n          //  - An \"outer\" weave is one that is outside of a conditional/sequence\n          //    that the current weave is nested within. We're only allowed to\n          //    pass gathers (i.e. 'normal flow') loose ends up there, not normal\n          //    choices. The rule is that choices have to be diverted explicitly\n          //    by the author since it's ambiguous where flow should go otherwise.\n          //\n          // e.g.:\n          //\n          //   - top                       <- e.g. outer weave\n          //   {true:\n          //       * choice                <- e.g. inner weave\n          //         * * choice 2\n          //             more content      <- e.g. current weave\n          //       * choice 2\n          //   }\n          //   - more of outer weave\n          //\n          var closestInnerWeaveAncestor = null;\n          var closestOuterWeaveAncestor = null;\n          // Find inner and outer ancestor weaves as defined above.\n          var nested = false;\n          for (var ancestor = this.parent; ancestor !== null; ancestor = ancestor.parent) {\n            // Found ancestor?\n            var weaveAncestor = (0, TypeAssertion_1.asOrNull)(ancestor, Weave);\n            if (weaveAncestor) {\n              if (!nested && closestInnerWeaveAncestor === null) {\n                closestInnerWeaveAncestor = weaveAncestor;\n              }\n              if (nested && closestOuterWeaveAncestor === null) {\n                closestOuterWeaveAncestor = weaveAncestor;\n              }\n            }\n            // Weaves nested within Sequences or Conditionals are\n            // \"sealed\" - any loose ends require explicit diverts.\n            if (ancestor instanceof Sequence_1.Sequence || ancestor instanceof Conditional_1.Conditional) {\n              nested = true;\n            }\n          }\n          // No weave to pass loose ends to at all?\n          if (closestInnerWeaveAncestor === null && closestOuterWeaveAncestor === null) {\n            return;\n          }\n          // Follow loose end passing logic as defined above\n          for (var ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {\n            var looseEnd = this.looseEnds[ii];\n            var received = false;\n            if (nested) {\n              // This weave is nested within a conditional or sequence:\n              //  - choices can only be passed up to direct ancestor (\"inner\") weaves\n              //  - gathers can be passed up to either, but favour the closer (inner) weave\n              //    if there is one\n              if (looseEnd instanceof Choice_1.Choice && closestInnerWeaveAncestor !== null) {\n                closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n                received = true;\n              } else if (!(looseEnd instanceof Choice_1.Choice)) {\n                var receivingWeave = closestInnerWeaveAncestor || closestOuterWeaveAncestor;\n                if (receivingWeave !== null) {\n                  receivingWeave.ReceiveLooseEnd(looseEnd);\n                  received = true;\n                }\n              }\n            } else {\n              // No nesting, all loose ends can be safely passed up\n              if (closestInnerWeaveAncestor === null || closestInnerWeaveAncestor === void 0 ? void 0 : closestInnerWeaveAncestor.hasOwnProperty(\"ReceiveLooseEnd\")) {\n                closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n              }\n              received = true;\n            }\n            if (received) {\n              this.looseEnds.splice(ii, 1);\n            }\n          }\n        };\n        this.ReceiveLooseEnd = childWeaveLooseEnd => {\n          this.looseEnds.push(childWeaveLooseEnd);\n        };\n        this.WeavePointNamed = name => {\n          if (!this.namedWeavePoints) {\n            return null;\n          }\n          var weavePointResult = this.namedWeavePoints.get(name);\n          if (weavePointResult) {\n            return weavePointResult;\n          }\n          return null;\n        };\n        // Global VARs and CONSTs are treated as \"outside of the flow\"\n        // when iterating over content that follows loose ends\n        this.IsGlobalDeclaration = obj => {\n          var varAss = (0, TypeAssertion_1.asOrNull)(obj, VariableAssignment_1.VariableAssignment);\n          if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {\n            return true;\n          }\n          var constDecl = (0, TypeAssertion_1.asOrNull)(obj, ConstantDeclaration_1.ConstantDeclaration);\n          if (constDecl) {\n            return true;\n          }\n          return false;\n        };\n        // While analysing final loose ends, we look to see whether there\n        // are any diverts etc which choices etc divert from\n        this.ContentThatFollowsWeavePoint = weavePoint => {\n          var returned = [];\n          var obj = weavePoint;\n          // Inner content first (e.g. for a choice)\n          if (obj.content !== null) {\n            for (var contentObj of obj.content) {\n              // Global VARs and CONSTs are treated as \"outside of the flow\"\n              if (this.IsGlobalDeclaration(contentObj)) {\n                continue;\n              }\n              returned.push(contentObj);\n            }\n          }\n          var parentWeave = (0, TypeAssertion_1.asOrNull)(obj.parent, Weave);\n          if (parentWeave === null) {\n            throw new Error(\"Expected weave point parent to be weave?\");\n          }\n          var weavePointIdx = parentWeave.content.indexOf(obj);\n          for (var ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {\n            var laterObj = parentWeave.content[ii];\n            // Global VARs and CONSTs are treated as \"outside of the flow\"\n            if (this.IsGlobalDeclaration(laterObj)) {\n              continue;\n            }\n            // End of the current flow\n            // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts\n            if (laterObj instanceof Choice_1.Choice || laterObj instanceof Gather_1.Gather) {\n              break;\n            }\n            // Other weaves will be have their own loose ends\n            if (laterObj instanceof Weave) {\n              break;\n            }\n            returned.push(laterObj);\n          }\n          return returned;\n        };\n        this.ValidateTermination = badTerminationHandler => {\n          // Don't worry if the last object in the flow is a \"TODO\",\n          // even if there are other loose ends in other places\n          if (this.lastParsedSignificantObject instanceof AuthorWarning_1.AuthorWarning) {\n            return;\n          }\n          // By now, any sub-weaves will have passed loose ends up to the root weave (this).\n          // So there are 2 possible situations:\n          //  - There are loose ends from somewhere in the flow.\n          //    These aren't necessarily \"real\" loose ends - they're weave points\n          //    that don't connect to any lower weave points, so we just\n          //    have to check that they terminate properly.\n          //  - This weave is just a list of content with no actual weave points,\n          //    so we just need to check that the list of content terminates.\n          var hasLooseEnds = this.looseEnds !== null && this.looseEnds.length > 0;\n          if (hasLooseEnds) {\n            for (var looseEnd of this.looseEnds) {\n              var looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);\n              this.ValidateFlowOfObjectsTerminates(looseEndFlow, looseEnd, badTerminationHandler);\n            }\n          } else {\n            // No loose ends... is there any inner weaving at all?\n            // If not, make sure the single content stream is terminated correctly\n            //\n            // If there's any actual weaving, assume that content is\n            // terminated correctly since we would've had a loose end otherwise\n            for (var obj of this.content) {\n              if (obj instanceof Choice_1.Choice || obj instanceof Divert_1.Divert) {\n                return;\n              }\n            }\n            // Straight linear flow? Check it terminates\n            this.ValidateFlowOfObjectsTerminates(this.content, this, badTerminationHandler);\n          }\n        };\n        this.BadNestedTerminationHandler = terminatingObj => {\n          var conditional = null;\n          for (var ancestor = terminatingObj.parent; ancestor !== null; ancestor = ancestor.parent) {\n            if (ancestor instanceof Sequence_1.Sequence || ancestor instanceof Conditional_1.Conditional) {\n              conditional = (0, TypeAssertion_1.asOrNull)(ancestor, Conditional_1.Conditional);\n              break;\n            }\n          }\n          var errorMsg = \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";\n          // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.\n          // { condition:\n          //      * choice\n          // }\n          if (conditional !== null) {\n            var numChoices = conditional.FindAll(Choice_1.Choice)().length;\n            if (numChoices === 1) {\n              errorMsg = \"Choices with conditions should be written: '* {condition} choice'. Otherwise, \".concat(errorMsg.toLowerCase());\n            }\n          }\n          this.Error(errorMsg, terminatingObj);\n        };\n        this.ValidateFlowOfObjectsTerminates = (objFlow, defaultObj, badTerminationHandler) => {\n          var terminated = false;\n          var terminatingObj = defaultObj;\n          for (var flowObj of objFlow) {\n            var divert = flowObj.Find(Divert_1.Divert)(d => !d.isThread && !d.isTunnel && !d.isFunctionCall && !(d.parent instanceof DivertTarget_1.DivertTarget));\n            if (divert !== null) {\n              terminated = true;\n            }\n            if (flowObj.Find(TunnelOnwards_1.TunnelOnwards)() != null) {\n              terminated = true;\n              break;\n            }\n            terminatingObj = flowObj;\n          }\n          if (!terminated) {\n            // Author has left a note to self here - clearly we don't need\n            // to leave them with another warning since they know what they're doing.\n            if (terminatingObj instanceof AuthorWarning_1.AuthorWarning) {\n              return;\n            }\n            badTerminationHandler(terminatingObj);\n          }\n        };\n        this.WeavePointHasLooseEnd = weavePoint => {\n          // No content, must be a loose end.\n          if (weavePoint.content === null) {\n            return true;\n          }\n          // If a weave point is diverted from, it doesn't have a loose end.\n          // Detect a divert object within a weavePoint's main content\n          // Work backwards since we're really interested in the end,\n          // although it doesn't actually make a difference!\n          // (content after a divert will simply be inaccessible)\n          for (var ii = weavePoint.content.length - 1; ii >= 0; --ii) {\n            var innerDivert = (0, TypeAssertion_1.asOrNull)(weavePoint.content[ii], Divert_1.Divert);\n            if (innerDivert) {\n              var willReturn = innerDivert.isThread || innerDivert.isTunnel || innerDivert.isFunctionCall;\n              if (!willReturn) {\n                return false;\n              }\n            }\n          }\n          return true;\n        };\n        // Enforce rule that weave points must not have the same\n        // name as any stitches or knots upwards in the hierarchy\n        this.CheckForWeavePointNamingCollisions = () => {\n          if (!this.namedWeavePoints) {\n            return;\n          }\n          var ancestorFlows = [];\n          for (var obj of this.ancestry) {\n            var flow = (0, TypeAssertion_1.asOrNull)(obj, FlowBase_1.FlowBase);\n            if (flow) {\n              ancestorFlows.push(flow);\n            } else {\n              break;\n            }\n          }\n          for (var [weavePointName, weavePoint] of this.namedWeavePoints) {\n            for (var _flow of ancestorFlows) {\n              // Shallow search\n              var otherContentWithName = _flow.ContentWithNameAtLevel(weavePointName);\n              if (otherContentWithName && otherContentWithName !== weavePoint) {\n                var errorMsg = \"\".concat(weavePoint.GetType(), \" '\").concat(weavePointName, \"' has the same label name as a \").concat(otherContentWithName.GetType(), \" (on \").concat(otherContentWithName.debugMetadata, \")\");\n                this.Error(errorMsg, weavePoint);\n              }\n            }\n          }\n        };\n        if (indentIndex == -1) {\n          this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);\n        } else {\n          this.baseIndentIndex = indentIndex;\n        }\n        this.AddContent(cont);\n        this.ConstructWeaveHierarchyFromIndentation();\n      }\n      get typeName() {\n        return \"Weave\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        // Check that choices nested within conditionals and sequences are terminated\n        if (this.looseEnds !== null && this.looseEnds.length > 0) {\n          var isNestedWeave = false;\n          for (var ancestor = this.parent; ancestor !== null; ancestor = ancestor.parent) {\n            if (ancestor instanceof Sequence_1.Sequence || ancestor instanceof Conditional_1.Conditional) {\n              isNestedWeave = true;\n              break;\n            }\n          }\n          if (isNestedWeave) {\n            this.ValidateTermination(this.BadNestedTerminationHandler);\n          }\n        }\n        for (var gatherPoint of this.gatherPointsToResolve) {\n          gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;\n        }\n        this.CheckForWeavePointNamingCollisions();\n      }\n    };\n    Weave.Weave = Weave$1;\n    return Weave;\n  }\n\n  var hasRequiredConditionalSingleBranch;\n  function requireConditionalSingleBranch() {\n    if (hasRequiredConditionalSingleBranch) return ConditionalSingleBranch;\n    hasRequiredConditionalSingleBranch = 1;\n    Object.defineProperty(ConditionalSingleBranch, \"__esModule\", {\n      value: true\n    });\n    ConditionalSingleBranch.ConditionalSingleBranch = void 0;\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var Divert_1 = requireDivert$1();\n    var Object_1 = require_Object();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var Value_1 = requireValue();\n    var Text_1 = requireText();\n    var Weave_1 = requireWeave();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let ConditionalSingleBranch$1 = class ConditionalSingleBranch extends Object_1.ParsedObject {\n      // When each branch has its own expression like a switch statement,\n      // this is non-null. e.g.\n      // { x:\n      //    - 4: the value of x is four (ownExpression is the value 4)\n      //    - 3: the value of x is three\n      // }\n      get ownExpression() {\n        return this._ownExpression;\n      }\n      set ownExpression(value) {\n        this._ownExpression = value;\n        if (this._ownExpression) {\n          this.AddContent(this._ownExpression);\n        }\n      }\n      constructor(content) {\n        super();\n        this._contentContainer = null;\n        this._conditionalDivert = null;\n        this._ownExpression = null;\n        this._innerWeave = null;\n        // bool condition, e.g.:\n        // { 5 == 4:\n        //   - the true branch\n        //   - the false branch\n        // }\n        this.isTrueBranch = false;\n        // In the above example, match equality of x with 4 for the first branch.\n        // This is as opposed to simply evaluating boolean equality for each branch,\n        // example when shouldMatchEquality is FALSE:\n        // {\n        //    3 > 2:  This will happen\n        //    2 > 3:  This won't happen\n        // }\n        this.matchingEquality = false;\n        this.isElse = false;\n        this.isInline = false;\n        this.returnDivert = null;\n        // Runtime content can be summarised as follows:\n        //  - Evaluate an expression if necessary to branch on\n        //  - Branch to a named container if true\n        //       - Divert back to main flow\n        //         (owner Conditional is in control of this target point)\n        this.GenerateRuntimeObject = () => {\n          // Check for common mistake, of putting \"else:\" instead of \"- else:\"\n          if (this._innerWeave) {\n            for (var c of this._innerWeave.content) {\n              var text = (0, TypeAssertion_1.asOrNull)(c, Text_1.Text);\n              if (text) {\n                // Don't need to trim at the start since the parser handles that already\n                if (text.text.startsWith(\"else:\")) {\n                  this.Warning(\"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\", text);\n                }\n              }\n            }\n          }\n          var container = new Container_1.Container();\n          // Are we testing against a condition that's used for more than just this\n          // branch? If so, the first thing we need to do is replicate the value that's\n          // on the evaluation stack so that we don't fully consume it, in case other\n          // branches need to use it.\n          var duplicatesStackValue = this.matchingEquality && !this.isElse;\n          if (duplicatesStackValue) {\n            container.AddContent(ControlCommand_1.ControlCommand.Duplicate());\n          }\n          this._conditionalDivert = new Divert_1.Divert();\n          // else clause is unconditional catch-all, otherwise the divert is conditional\n          this._conditionalDivert.isConditional = !this.isElse;\n          // Need extra evaluation?\n          if (!this.isTrueBranch && !this.isElse) {\n            var needsEval = this.ownExpression !== null;\n            if (needsEval) {\n              container.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n            }\n            if (this.ownExpression) {\n              this.ownExpression.GenerateIntoContainer(container);\n            }\n            // Uses existing duplicated value\n            if (this.matchingEquality) {\n              container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(\"==\"));\n            }\n            if (needsEval) {\n              container.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n            }\n          }\n          // Will pop from stack if conditional\n          container.AddContent(this._conditionalDivert);\n          this._contentContainer = this.GenerateRuntimeForContent();\n          this._contentContainer.name = \"b\";\n          // Multi-line conditionals get a newline at the start of each branch\n          // (as opposed to the start of the multi-line conditional since the condition\n          //  may evaluate to false.)\n          if (!this.isInline) {\n            this._contentContainer.InsertContent(new Value_1.StringValue(\"\\n\"), 0);\n          }\n          if (duplicatesStackValue || this.isElse && this.matchingEquality) {\n            this._contentContainer.InsertContent(ControlCommand_1.ControlCommand.PopEvaluatedValue(), 0);\n          }\n          container.AddToNamedContentOnly(this._contentContainer);\n          this.returnDivert = new Divert_1.Divert();\n          this._contentContainer.AddContent(this.returnDivert);\n          return container;\n        };\n        this.GenerateRuntimeForContent = () => {\n          // Empty branch - create empty container\n          if (this._innerWeave === null) {\n            return new Container_1.Container();\n          }\n          return this._innerWeave.rootContainer;\n        };\n        // Branches are allowed to be empty\n        if (content) {\n          this._innerWeave = new Weave_1.Weave(content);\n          this.AddContent(this._innerWeave);\n        }\n      }\n      get typeName() {\n        return \"ConditionalSingleBranch\";\n      }\n      ResolveReferences(context) {\n        if (!this._conditionalDivert || !this._contentContainer) {\n          throw new Error();\n        }\n        this._conditionalDivert.targetPath = this._contentContainer.path;\n        super.ResolveReferences(context);\n      }\n    };\n    ConditionalSingleBranch.ConditionalSingleBranch = ConditionalSingleBranch$1;\n    return ConditionalSingleBranch;\n  }\n\n  var CustomFlags = {};\n\n  var hasRequiredCustomFlags;\n  function requireCustomFlags() {\n    if (hasRequiredCustomFlags) return CustomFlags;\n    hasRequiredCustomFlags = 1;\n    Object.defineProperty(CustomFlags, \"__esModule\", {\n      value: true\n    });\n    CustomFlags.CustomFlags = void 0;\n    var CustomFlags$1;\n    (function (CustomFlags) {\n      CustomFlags[CustomFlags[\"ParsingString\"] = 1] = \"ParsingString\";\n      CustomFlags[CustomFlags[\"TagActive\"] = 2] = \"TagActive\";\n    })(CustomFlags$1 || (CustomFlags.CustomFlags = CustomFlags$1 = {}));\n    return CustomFlags;\n  }\n\n  var DebugMetadata = {};\n\n  var hasRequiredDebugMetadata;\n  function requireDebugMetadata() {\n    if (hasRequiredDebugMetadata) return DebugMetadata;\n    hasRequiredDebugMetadata = 1;\n    Object.defineProperty(DebugMetadata, \"__esModule\", {\n      value: true\n    });\n    DebugMetadata.DebugMetadata = void 0;\n    let DebugMetadata$1 = class DebugMetadata {\n      constructor() {\n        this.startLineNumber = 0;\n        this.endLineNumber = 0;\n        this.startCharacterNumber = 0;\n        this.endCharacterNumber = 0;\n        this.fileName = null;\n        this.sourceName = null;\n      }\n      Merge(dm) {\n        var newDebugMetadata = new DebugMetadata();\n        newDebugMetadata.fileName = this.fileName;\n        newDebugMetadata.sourceName = this.sourceName;\n        if (this.startLineNumber < dm.startLineNumber) {\n          newDebugMetadata.startLineNumber = this.startLineNumber;\n          newDebugMetadata.startCharacterNumber = this.startCharacterNumber;\n        } else if (this.startLineNumber > dm.startLineNumber) {\n          newDebugMetadata.startLineNumber = dm.startLineNumber;\n          newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;\n        } else {\n          newDebugMetadata.startLineNumber = this.startLineNumber;\n          newDebugMetadata.startCharacterNumber = Math.min(this.startCharacterNumber, dm.startCharacterNumber);\n        }\n        if (this.endLineNumber > dm.endLineNumber) {\n          newDebugMetadata.endLineNumber = this.endLineNumber;\n          newDebugMetadata.endCharacterNumber = this.endCharacterNumber;\n        } else if (this.endLineNumber < dm.endLineNumber) {\n          newDebugMetadata.endLineNumber = dm.endLineNumber;\n          newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;\n        } else {\n          newDebugMetadata.endLineNumber = this.endLineNumber;\n          newDebugMetadata.endCharacterNumber = Math.max(this.endCharacterNumber, dm.endCharacterNumber);\n        }\n        return newDebugMetadata;\n      }\n      toString() {\n        if (this.fileName !== null) {\n          return \"line \".concat(this.startLineNumber, \" of \").concat(this.fileName, \"\\\"\");\n        } else {\n          return \"line \" + this.startLineNumber;\n        }\n      }\n    };\n    DebugMetadata.DebugMetadata = DebugMetadata$1;\n    return DebugMetadata;\n  }\n\n  var ExternalDeclaration = {};\n\n  var hasRequiredExternalDeclaration;\n  function requireExternalDeclaration() {\n    if (hasRequiredExternalDeclaration) return ExternalDeclaration;\n    hasRequiredExternalDeclaration = 1;\n    Object.defineProperty(ExternalDeclaration, \"__esModule\", {\n      value: true\n    });\n    ExternalDeclaration.ExternalDeclaration = void 0;\n    var Object_1 = require_Object();\n    let ExternalDeclaration$1 = class ExternalDeclaration extends Object_1.ParsedObject {\n      get name() {\n        var _a;\n        return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n      }\n      constructor(identifier, argumentNames) {\n        super();\n        this.identifier = identifier;\n        this.argumentNames = argumentNames;\n        this.GenerateRuntimeObject = () => {\n          this.story.AddExternal(this);\n          // No runtime code exists for an external, only metadata\n          return null;\n        };\n      }\n      get typeName() {\n        return \"EXTERNAL\";\n      }\n      toString() {\n        var _a;\n        return \"EXTERNAL \".concat((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name);\n      }\n    };\n    ExternalDeclaration.ExternalDeclaration = ExternalDeclaration$1;\n    return ExternalDeclaration;\n  }\n\n  var FlowDecl = {};\n\n  var hasRequiredFlowDecl;\n  function requireFlowDecl() {\n    if (hasRequiredFlowDecl) return FlowDecl;\n    hasRequiredFlowDecl = 1;\n    Object.defineProperty(FlowDecl, \"__esModule\", {\n      value: true\n    });\n    FlowDecl.FlowDecl = void 0;\n    let FlowDecl$1 = class FlowDecl {\n      constructor(name, args, isFunction) {\n        this.name = name;\n        this.args = args;\n        this.isFunction = isFunction;\n      }\n    };\n    FlowDecl.FlowDecl = FlowDecl$1;\n    return FlowDecl;\n  }\n\n  var Glue = {};\n\n  var Wrap = {};\n\n  var hasRequiredWrap;\n  function requireWrap() {\n    if (hasRequiredWrap) return Wrap;\n    hasRequiredWrap = 1;\n    Object.defineProperty(Wrap, \"__esModule\", {\n      value: true\n    });\n    Wrap.Wrap = void 0;\n    var Object_1 = require_Object();\n    let Wrap$1 = class Wrap extends Object_1.ParsedObject {\n      constructor(_objToWrap) {\n        super();\n        this._objToWrap = _objToWrap;\n        this.GenerateRuntimeObject = () => this._objToWrap;\n      }\n    };\n    Wrap.Wrap = Wrap$1;\n    return Wrap;\n  }\n\n  var hasRequiredGlue;\n  function requireGlue() {\n    if (hasRequiredGlue) return Glue;\n    hasRequiredGlue = 1;\n    Object.defineProperty(Glue, \"__esModule\", {\n      value: true\n    });\n    Glue.Glue = void 0;\n    var Wrap_1 = requireWrap();\n    let Glue$1 = class Glue extends Wrap_1.Wrap {\n      constructor(glue) {\n        super(glue);\n      }\n      get typeName() {\n        return \"Glue\";\n      }\n    };\n    Glue.Glue = Glue$1;\n    return Glue;\n  }\n\n  var IncDecExpression = {};\n\n  var hasRequiredIncDecExpression;\n  function requireIncDecExpression() {\n    if (hasRequiredIncDecExpression) return IncDecExpression;\n    hasRequiredIncDecExpression = 1;\n    Object.defineProperty(IncDecExpression, \"__esModule\", {\n      value: true\n    });\n    IncDecExpression.IncDecExpression = void 0;\n    var ContentList_1 = requireContentList();\n    var Expression_1 = requireExpression();\n    var FlowBase_1 = requireFlowBase();\n    var NativeFunctionCall_1 = requireNativeFunctionCall();\n    var Value_1 = requireValue();\n    var VariableAssignment_1 = requireVariableAssignment$1();\n    var VariableReference_1 = requireVariableReference$1();\n    var Weave_1 = requireWeave();\n    let IncDecExpression$1 = class IncDecExpression extends Expression_1.Expression {\n      constructor(varIdentifier, isIncOrExpression, isInc) {\n        super();\n        this.varIdentifier = varIdentifier;\n        this._runtimeAssignment = null;\n        this.expression = null;\n        this.GenerateIntoContainer = container => {\n          // x = x + y\n          // ^^^ ^ ^ ^\n          //  4  1 3 2\n          // Reverse polish notation: (x 1 +) (assign to x)\n          var _a, _b;\n          // 1.\n          container.AddContent(new VariableReference_1.VariableReference(((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name) || null));\n          // 2.\n          // - Expression used in the form ~ x += y\n          // - Simple version: ~ x++\n          if (this.expression) {\n            this.expression.GenerateIntoContainer(container);\n          } else {\n            container.AddContent(new Value_1.IntValue(1));\n          }\n          // 3.\n          container.AddContent(NativeFunctionCall_1.NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\"));\n          // 4.\n          this._runtimeAssignment = new VariableAssignment_1.VariableAssignment(((_b = this.varIdentifier) === null || _b === void 0 ? void 0 : _b.name) || null, false);\n          container.AddContent(this._runtimeAssignment);\n        };\n        this.toString = () => {\n          var _a, _b;\n          if (this.expression) {\n            return \"\".concat((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name).concat(this.isInc ? \" += \" : \" -= \").concat(this.expression);\n          }\n          return \"\".concat((_b = this.varIdentifier) === null || _b === void 0 ? void 0 : _b.name) + (this.isInc ? \"++\" : \"--\");\n        };\n        if (isIncOrExpression instanceof Expression_1.Expression) {\n          this.expression = isIncOrExpression;\n          this.AddContent(this.expression);\n          this.isInc = Boolean(isInc);\n        } else {\n          this.isInc = isIncOrExpression;\n        }\n      }\n      get typeName() {\n        return \"IncDecExpression\";\n      }\n      ResolveReferences(context) {\n        var _a;\n        super.ResolveReferences(context);\n        var varResolveResult = context.ResolveVariableWithName(((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name) || \"\", this);\n        if (!varResolveResult.found) {\n          this.Error(\"variable for \".concat(this.incrementDecrementWord, \" could not be found: '\").concat(this.varIdentifier, \"' after searching: {this.descriptionOfScope}\"));\n        }\n        if (!this._runtimeAssignment) {\n          throw new Error();\n        }\n        this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;\n        if (!(this.parent instanceof Weave_1.Weave) && !(this.parent instanceof FlowBase_1.FlowBase) && !(this.parent instanceof ContentList_1.ContentList)) {\n          this.Error(\"Can't use \".concat(this.incrementDecrementWord, \" as sub-expression\"));\n        }\n      }\n      get incrementDecrementWord() {\n        if (this.isInc) {\n          return \"increment\";\n        }\n        return \"decrement\";\n      }\n    };\n    IncDecExpression.IncDecExpression = IncDecExpression$1;\n    return IncDecExpression;\n  }\n\n  var IncludedFile = {};\n\n  var hasRequiredIncludedFile;\n  function requireIncludedFile() {\n    if (hasRequiredIncludedFile) return IncludedFile;\n    hasRequiredIncludedFile = 1;\n    Object.defineProperty(IncludedFile, \"__esModule\", {\n      value: true\n    });\n    IncludedFile.IncludedFile = void 0;\n    var Object_1 = require_Object();\n    let IncludedFile$1 = class IncludedFile extends Object_1.ParsedObject {\n      constructor(includedStory) {\n        super();\n        this.includedStory = includedStory;\n        this.GenerateRuntimeObject = () => {\n          // Left to the main story to process\n          return null;\n        };\n      }\n      get typeName() {\n        return \"IncludedFile\";\n      }\n    };\n    IncludedFile.IncludedFile = IncludedFile$1;\n    return IncludedFile;\n  }\n\n  var InfixOperator = {};\n\n  var hasRequiredInfixOperator;\n  function requireInfixOperator() {\n    if (hasRequiredInfixOperator) return InfixOperator;\n    hasRequiredInfixOperator = 1;\n    Object.defineProperty(InfixOperator, \"__esModule\", {\n      value: true\n    });\n    InfixOperator.InfixOperator = void 0;\n    let InfixOperator$1 = class InfixOperator {\n      constructor(type, precedence, requireWhitespace) {\n        this.type = type;\n        this.precedence = precedence;\n        this.requireWhitespace = requireWhitespace;\n        this.toString = () => this.type;\n      }\n    };\n    InfixOperator.InfixOperator = InfixOperator$1;\n    return InfixOperator;\n  }\n\n  var Knot = {};\n\n  var hasRequiredKnot;\n  function requireKnot() {\n    if (hasRequiredKnot) return Knot;\n    hasRequiredKnot = 1;\n    Object.defineProperty(Knot, \"__esModule\", {\n      value: true\n    });\n    Knot.Knot = void 0;\n    var FlowBase_1 = requireFlowBase();\n    var FlowLevel_1 = requireFlowLevel();\n    let Knot$1 = class Knot extends FlowBase_1.FlowBase {\n      get flowLevel() {\n        return FlowLevel_1.FlowLevel.Knot;\n      }\n      constructor(name, topLevelObjects, args, isFunction) {\n        super(name, topLevelObjects, args, isFunction);\n      }\n      get typeName() {\n        return this.isFunction ? \"Function\" : \"Knot\";\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        var parentStory = this.story;\n        // Enforce rule that stitches must not have the same\n        // name as any knots that exist in the story\n        for (var stitchName in this.subFlowsByName) {\n          var knotWithStitchName = parentStory.ContentWithNameAtLevel(stitchName, FlowLevel_1.FlowLevel.Knot, false);\n          if (knotWithStitchName) {\n            var stitch = this.subFlowsByName.get(stitchName);\n            var errorMsg = \"Stitch '\".concat(stitch ? stitch.name : \"NO STITCH FOUND\", \"' has the same name as a knot (on \").concat(knotWithStitchName.debugMetadata, \")\");\n            this.Error(errorMsg, stitch);\n          }\n        }\n      }\n    };\n    Knot.Knot = Knot$1;\n    return Knot;\n  }\n\n  var List = {};\n\n  var hasRequiredList;\n  function requireList() {\n    if (hasRequiredList) return List;\n    hasRequiredList = 1;\n    Object.defineProperty(List, \"__esModule\", {\n      value: true\n    });\n    List.List = void 0;\n    var Expression_1 = requireExpression();\n    var InkList_1 = requireInkList();\n    var InkList_2 = requireInkList();\n    var Value_1 = requireValue();\n    let List$1 = class List extends Expression_1.Expression {\n      constructor(itemIdentifierList) {\n        super();\n        this.itemIdentifierList = itemIdentifierList;\n        this.GenerateIntoContainer = container => {\n          var _a, _b;\n          var runtimeRawList = new InkList_1.InkList();\n          if (this.itemIdentifierList != null) {\n            for (var itemIdentifier of this.itemIdentifierList) {\n              var nameParts = ((_a = itemIdentifier === null || itemIdentifier === void 0 ? void 0 : itemIdentifier.name) === null || _a === void 0 ? void 0 : _a.split(\".\")) || [];\n              var listName = null;\n              var listItemName = \"\";\n              if (nameParts.length > 1) {\n                listName = nameParts[0];\n                listItemName = nameParts[1];\n              } else {\n                listItemName = nameParts[0];\n              }\n              var listItem = this.story.ResolveListItem(listName, listItemName, this);\n              if (listItem === null) {\n                if (listName === null) {\n                  this.Error(\"Could not find list definition that contains item '\".concat(itemIdentifier, \"'\"));\n                } else {\n                  this.Error(\"Could not find list item \".concat(itemIdentifier));\n                }\n              } else {\n                if (listItem.parent == null) {\n                  this.Error(\"Could not find list definition for item \".concat(itemIdentifier));\n                  return;\n                }\n                if (!listName) {\n                  listName = ((_b = listItem.parent.identifier) === null || _b === void 0 ? void 0 : _b.name) || null;\n                }\n                var item = new InkList_2.InkListItem(listName, listItem.name || null);\n                if (runtimeRawList.has(item.serialized())) {\n                  this.Warning(\"Duplicate of item '\".concat(itemIdentifier, \"' in list.\"));\n                } else {\n                  runtimeRawList.Add(item, listItem.seriesValue);\n                }\n              }\n            }\n          }\n          container.AddContent(new Value_1.ListValue(runtimeRawList));\n        };\n      }\n      get typeName() {\n        return \"List\";\n      }\n    };\n    List.List = List$1;\n    return List;\n  }\n\n  var ListElementDefinition = {};\n\n  var hasRequiredListElementDefinition;\n  function requireListElementDefinition() {\n    if (hasRequiredListElementDefinition) return ListElementDefinition;\n    hasRequiredListElementDefinition = 1;\n    Object.defineProperty(ListElementDefinition, \"__esModule\", {\n      value: true\n    });\n    ListElementDefinition.ListElementDefinition = void 0;\n    var Object_1 = require_Object();\n    var SymbolType_1 = requireSymbolType();\n    let ListElementDefinition$1 = class ListElementDefinition extends Object_1.ParsedObject {\n      get fullName() {\n        var _a;\n        var parentList = this.parent;\n        if (parentList === null) {\n          throw new Error(\"Can't get full name without a parent list.\");\n        }\n        return \"\".concat((_a = parentList.identifier) === null || _a === void 0 ? void 0 : _a.name, \".\").concat(this.name);\n      }\n      get typeName() {\n        return \"ListElement\";\n      }\n      get name() {\n        var _a;\n        return ((_a = this.indentifier) === null || _a === void 0 ? void 0 : _a.name) || null;\n      }\n      constructor(indentifier, inInitialList) {\n        var explicitValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        super();\n        this.indentifier = indentifier;\n        this.inInitialList = inInitialList;\n        this.explicitValue = explicitValue;\n        this.seriesValue = 0;\n        this.parent = null;\n        this.GenerateRuntimeObject = () => {\n          throw new Error(\"Not implemented.\");\n        };\n        this.toString = () => this.fullName;\n        this.parent = this.parent;\n      }\n      ResolveReferences(context) {\n        super.ResolveReferences(context);\n        context.CheckForNamingCollisions(this, this.indentifier, SymbolType_1.SymbolType.ListItem);\n      }\n    };\n    ListElementDefinition.ListElementDefinition = ListElementDefinition$1;\n    return ListElementDefinition;\n  }\n\n  var StatementLevel = {};\n\n  var hasRequiredStatementLevel;\n  function requireStatementLevel() {\n    if (hasRequiredStatementLevel) return StatementLevel;\n    hasRequiredStatementLevel = 1;\n    Object.defineProperty(StatementLevel, \"__esModule\", {\n      value: true\n    });\n    StatementLevel.StatementLevel = void 0;\n    var StatementLevel$1;\n    (function (StatementLevel) {\n      StatementLevel[StatementLevel[\"InnerBlock\"] = 0] = \"InnerBlock\";\n      StatementLevel[StatementLevel[\"Stitch\"] = 1] = \"Stitch\";\n      StatementLevel[StatementLevel[\"Knot\"] = 2] = \"Knot\";\n      StatementLevel[StatementLevel[\"Top\"] = 3] = \"Top\";\n    })(StatementLevel$1 || (StatementLevel.StatementLevel = StatementLevel$1 = {}));\n    return StatementLevel;\n  }\n\n  var Stitch = {};\n\n  var hasRequiredStitch;\n  function requireStitch() {\n    if (hasRequiredStitch) return Stitch;\n    hasRequiredStitch = 1;\n    Object.defineProperty(Stitch, \"__esModule\", {\n      value: true\n    });\n    Stitch.Stitch = void 0;\n    var FlowBase_1 = requireFlowBase();\n    var FlowLevel_1 = requireFlowLevel();\n    let Stitch$1 = class Stitch extends FlowBase_1.FlowBase {\n      get flowLevel() {\n        return FlowLevel_1.FlowLevel.Stitch;\n      }\n      constructor(name, topLevelObjects, args, isFunction) {\n        super(name, topLevelObjects, args, isFunction);\n        // Fixes TS issue with not being able to access the prototype via `super` in functions\n        // attached to the class as properties.\n        this.baseToString = this.toString;\n        this.toString = () => {\n          return \"\".concat(this.parent !== null ? this.parent + \" > \" : \"\").concat(this.baseToString());\n        };\n      }\n      get typeName() {\n        return \"Stitch\";\n      }\n    };\n    Stitch.Stitch = Stitch$1;\n    return Stitch;\n  }\n\n  var Story$1 = {};\n\n  var hasRequiredStory;\n  function requireStory() {\n    if (hasRequiredStory) return Story$1;\n    hasRequiredStory = 1;\n    Object.defineProperty(Story$1, \"__esModule\", {\n      value: true\n    });\n    Story$1.Story = void 0;\n    var AuthorWarning_1 = requireAuthorWarning();\n    var ConstantDeclaration_1 = requireConstantDeclaration();\n    var Container_1 = requireContainer();\n    var ControlCommand_1 = requireControlCommand();\n    var ErrorType_1 = requireErrorType();\n    var FlowBase_1 = requireFlowBase();\n    var FlowLevel_1 = requireFlowLevel();\n    var IncludedFile_1 = requireIncludedFile();\n    var ListDefinition_1 = requireListDefinition();\n    var ListElementDefinition_1 = requireListElementDefinition();\n    var Story_1 = requireStory$1();\n    var SymbolType_1 = requireSymbolType();\n    var Text_1 = requireText();\n    var VariableAssignment_1 = requireVariableAssignment$1();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var ClosestFlowBase_1 = requireClosestFlowBase();\n    var FunctionCall_1 = requireFunctionCall();\n    var Path_1 = requirePath();\n    class Story extends FlowBase_1.FlowBase {\n      get flowLevel() {\n        return FlowLevel_1.FlowLevel.Story;\n      }\n      get hadError() {\n        return this._hadError;\n      }\n      get hadWarning() {\n        return this._hadWarning;\n      }\n      constructor(toplevelObjects) {\n        var _this;\n        var isInclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Don't do anything much on construction, leave it lightweight until\n        // the ExportRuntime method is called.\n        super(null, toplevelObjects, null, false, isInclude);\n        _this = this;\n        this._errorHandler = null;\n        this._hadError = false;\n        this._hadWarning = false;\n        this._dontFlattenContainers = new Set();\n        this._listDefs = new Map();\n        this.constants = new Map();\n        this.externals = new Map();\n        // Build setting for exporting:\n        // When true, the visit count for *all* knots, stitches, choices,\n        // and gathers is counted. When false, only those that are direclty\n        // referenced by the ink are recorded. Use this flag to allow game-side\n        // querying of  arbitrary knots/stitches etc.\n        // Storing all counts is more robust and future proof (updates to the story file\n        // that reference previously uncounted visits are possible, but generates a much\n        // larger safe file, with a lot of potentially redundant counts.\n        this.countAllVisits = false;\n        this.ExportRuntime = function () {\n          var errorHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          var _a, _b;\n          _this._errorHandler = errorHandler;\n          // Find all constants before main export begins, so that VariableReferences know\n          // whether to generate a runtime variable reference or the literal value\n          _this.constants = new Map();\n          for (var constDecl of _this.FindAll(ConstantDeclaration_1.ConstantDeclaration)()) {\n            // Check for duplicate definitions\n            var existingDefinition = _this.constants.get(constDecl.constantName);\n            if (existingDefinition) {\n              if (!existingDefinition.Equals(constDecl.expression)) {\n                var errorMsg = \"CONST '\".concat(constDecl.constantName, \"' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on \").concat(existingDefinition.debugMetadata, \".\");\n                _this.Error(errorMsg, constDecl, false);\n              }\n            }\n            _this.constants.set(constDecl.constantName, constDecl.expression);\n          }\n          // List definitions are treated like constants too - they should be usable\n          // from other variable declarations.\n          _this._listDefs = new Map();\n          for (var listDef of _this.FindAll(ListDefinition_1.ListDefinition)()) {\n            if ((_a = listDef.identifier) === null || _a === void 0 ? void 0 : _a.name) {\n              _this._listDefs.set((_b = listDef.identifier) === null || _b === void 0 ? void 0 : _b.name, listDef);\n            }\n          }\n          _this.externals = new Map();\n          // Resolution of weave point names has to come first, before any runtime code generation\n          // since names have to be ready before diverts start getting created.\n          // (It used to be done in the constructor for a weave, but didn't allow us to generate\n          // errors when name resolution failed.)\n          _this.ResolveWeavePointNaming();\n          // Get default implementation of runtimeObject, which calls ContainerBase's generation method\n          var rootContainer = _this.runtimeObject;\n          // Export initialisation of global variables\n          // TODO: We *could* add this as a declarative block to the story itself...\n          var variableInitialisation = new Container_1.Container();\n          variableInitialisation.AddContent(ControlCommand_1.ControlCommand.EvalStart());\n          // Global variables are those that are local to the story and marked as global\n          var runtimeLists = [];\n          for (var [key, value] of _this.variableDeclarations) {\n            if (value.isGlobalDeclaration) {\n              if (value.listDefinition) {\n                _this._listDefs.set(key, value.listDefinition);\n                variableInitialisation.AddContent(value.listDefinition.runtimeObject);\n                runtimeLists.push(value.listDefinition.runtimeListDefinition);\n              } else {\n                if (!value.expression) {\n                  throw new Error();\n                }\n                value.expression.GenerateIntoContainer(variableInitialisation);\n              }\n              var runtimeVarAss = new VariableAssignment_1.VariableAssignment(key, true);\n              runtimeVarAss.isGlobal = true;\n              variableInitialisation.AddContent(runtimeVarAss);\n            }\n          }\n          variableInitialisation.AddContent(ControlCommand_1.ControlCommand.EvalEnd());\n          variableInitialisation.AddContent(ControlCommand_1.ControlCommand.End());\n          if (_this.variableDeclarations.size > 0) {\n            variableInitialisation.name = \"global decl\";\n            rootContainer.AddToNamedContentOnly(variableInitialisation);\n          }\n          // Signal that it's safe to exit without error, even if there are no choices generated\n          // (this only happens at the end of top level content that isn't in any particular knot)\n          rootContainer.AddContent(ControlCommand_1.ControlCommand.Done());\n          // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase\n          var runtimeStory = new Story_1.Story(rootContainer, runtimeLists);\n          _this.runtimeObject = runtimeStory;\n          if (_this.hadError) {\n            return null;\n          }\n          // Optimisation step - inline containers that can be\n          _this.FlattenContainersIn(rootContainer);\n          // Now that the story has been fulled parsed into a hierarchy,\n          // and the derived runtime hierarchy has been built, we can\n          // resolve referenced symbols such as variables and paths.\n          // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)\n          // We don't make any assumptions that the INKPath follows the same\n          // conventions as the script format, so we resolve to actual objects before\n          // translating into an INKPath. (This also allows us to choose whether\n          // we want the paths to be absolute)\n          _this.ResolveReferences(_this);\n          if (_this.hadError) {\n            return null;\n          }\n          runtimeStory.ResetState();\n          return runtimeStory;\n        };\n        this.ResolveList = listName => {\n          var list = this._listDefs.get(listName);\n          if (!list) {\n            return null;\n          }\n          return list;\n        };\n        this.ResolveListItem = function (listName, itemName) {\n          var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n          var listDef = null;\n          // Search a specific list if we know its name (i.e. the form listName.itemName)\n          if (listName) {\n            if (!(listDef = _this._listDefs.get(listName))) {\n              return null;\n            }\n            return listDef.ItemNamed(itemName);\n          } else {\n            // Otherwise, try to search all lists\n            var foundItem = null;\n            var originalFoundList = null;\n            for (var [, value] of _this._listDefs.entries()) {\n              var itemInThisList = value.ItemNamed(itemName);\n              if (itemInThisList) {\n                if (foundItem) {\n                  _this.Error(\"Ambiguous item name '\".concat(itemName, \"' found in multiple sets, including \").concat(originalFoundList.identifier, \" and \").concat(value.identifier), source, false);\n                } else {\n                  foundItem = itemInThisList;\n                  originalFoundList = value;\n                }\n              }\n            }\n            return foundItem;\n          }\n        };\n        this.FlattenContainersIn = container => {\n          // Need to create a collection to hold the inner containers\n          // because otherwise we'd end up modifying during iteration\n          var innerContainers = new Set();\n          if (container.content) {\n            for (var c of container.content) {\n              var innerContainer = (0, TypeAssertion_1.asOrNull)(c, Container_1.Container);\n              if (innerContainer) {\n                innerContainers.add(innerContainer);\n              }\n            }\n          }\n          // Can't flatten the named inner containers, but we can at least\n          // iterate through their children\n          if (container.namedContent) {\n            for (var [, value] of container.namedContent) {\n              var namedInnerContainer = (0, TypeAssertion_1.asOrNull)(value, Container_1.Container);\n              if (namedInnerContainer) {\n                innerContainers.add(namedInnerContainer);\n              }\n            }\n          }\n          for (var _innerContainer of innerContainers) {\n            this.TryFlattenContainer(_innerContainer);\n            this.FlattenContainersIn(_innerContainer);\n          }\n        };\n        this.TryFlattenContainer = container => {\n          if (container.namedContent && container.namedContent.size > 0 || container.hasValidName || this._dontFlattenContainers.has(container)) {\n            return;\n          }\n          // Inline all the content in container into the parent\n          var parentContainer = (0, TypeAssertion_1.asOrNull)(container.parent, Container_1.Container);\n          if (parentContainer) {\n            var contentIdx = parentContainer.content.indexOf(container);\n            parentContainer.content.splice(contentIdx, 1);\n            var dm = container.ownDebugMetadata;\n            if (container.content) {\n              for (var innerContent of container.content) {\n                innerContent.parent = null;\n                if (dm !== null && innerContent.ownDebugMetadata === null) {\n                  innerContent.debugMetadata = dm;\n                }\n                parentContainer.InsertContent(innerContent, contentIdx);\n                contentIdx += 1;\n              }\n            }\n          }\n        };\n        this.Error = (message, source, isWarning) => {\n          var errorType = isWarning ? ErrorType_1.ErrorType.Warning : ErrorType_1.ErrorType.Error;\n          var sb = \"\";\n          if (source instanceof AuthorWarning_1.AuthorWarning) {\n            sb += \"TODO: \";\n            errorType = ErrorType_1.ErrorType.Author;\n          } else if (isWarning) {\n            sb += \"WARNING: \";\n          } else {\n            sb += \"ERROR: \";\n          }\n          if (source && source.debugMetadata !== null && source.debugMetadata.startLineNumber >= 1) {\n            if (source.debugMetadata.fileName != null) {\n              sb += \"'\".concat(source.debugMetadata.fileName, \"' \");\n            }\n            sb += \"line \".concat(source.debugMetadata.startLineNumber, \": \");\n          }\n          sb += message;\n          message = sb;\n          if (this._errorHandler !== null) {\n            this._errorHandler(message, errorType);\n          } else {\n            throw new Error(message);\n          }\n          this._hadError = errorType === ErrorType_1.ErrorType.Error;\n          this._hadWarning = errorType === ErrorType_1.ErrorType.Warning;\n        };\n        this.ResetError = () => {\n          this._hadError = false;\n          this._hadWarning = false;\n        };\n        this.IsExternal = namedFuncTarget => this.externals.has(namedFuncTarget);\n        this.AddExternal = decl => {\n          if (this.externals.has(decl.name)) {\n            this.Error(\"Duplicate EXTERNAL definition of '\".concat(decl.name, \"'\"), decl, false);\n          } else if (decl.name) {\n            this.externals.set(decl.name, decl);\n          }\n        };\n        this.DontFlattenContainer = container => {\n          this._dontFlattenContainers.add(container);\n        };\n        this.NameConflictError = (obj, name, existingObj, typeNameToPrint) => {\n          obj.Error(\"\".concat(typeNameToPrint, \" '\").concat(name, \"': name has already been used for a \").concat(existingObj.typeName.toLowerCase(), \" on \").concat(existingObj.debugMetadata));\n        };\n        // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).\n        // When the given symbol type level is reached, we early-out / return.\n        this.CheckForNamingCollisions = function (obj, identifier, symbolType) {\n          var typeNameOverride = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n          var _a;\n          var typeNameToPrint = typeNameOverride || obj.typeName;\n          if (Story.IsReservedKeyword(identifier === null || identifier === void 0 ? void 0 : identifier.name)) {\n            obj.Error(\"'\".concat(identifier, \"' cannot be used for the name of a \").concat(typeNameToPrint.toLowerCase(), \" because it's a reserved keyword\"));\n            return;\n          } else if (FunctionCall_1.FunctionCall.IsBuiltIn((identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\")) {\n            obj.Error(\"'\".concat(identifier, \"' cannot be used for the name of a \").concat(typeNameToPrint.toLowerCase(), \" because it's a built in function\"));\n            return;\n          }\n          // Top level knots\n          var maybeKnotOrFunction = _this.ContentWithNameAtLevel((identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", FlowLevel_1.FlowLevel.Knot);\n          var knotOrFunction = (0, TypeAssertion_1.asOrNull)(maybeKnotOrFunction, FlowBase_1.FlowBase);\n          if (knotOrFunction && (knotOrFunction !== obj || symbolType === SymbolType_1.SymbolType.Arg)) {\n            _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", knotOrFunction, typeNameToPrint);\n            return;\n          }\n          if (symbolType < SymbolType_1.SymbolType.List) {\n            return;\n          }\n          // Lists\n          for (var [key, value] of _this._listDefs) {\n            if ((identifier === null || identifier === void 0 ? void 0 : identifier.name) === key && obj !== value && value.variableAssignment !== obj) {\n              _this.NameConflictError(obj, identifier === null || identifier === void 0 ? void 0 : identifier.name, value, typeNameToPrint);\n            }\n            // We don't check for conflicts between individual elements in\n            // different lists because they are namespaced.\n            if (!(obj instanceof ListElementDefinition_1.ListElementDefinition)) {\n              for (var item of value.itemDefinitions) {\n                if ((identifier === null || identifier === void 0 ? void 0 : identifier.name) === item.name) {\n                  _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", item, typeNameToPrint);\n                }\n              }\n            }\n          }\n          // Don't check for VAR->VAR conflicts because that's handled separately\n          // (necessary since checking looks up in a dictionary)\n          if (symbolType <= SymbolType_1.SymbolType.Var) {\n            return;\n          }\n          // Global variable collision\n          var varDecl = (identifier === null || identifier === void 0 ? void 0 : identifier.name) && _this.variableDeclarations.get(identifier === null || identifier === void 0 ? void 0 : identifier.name) || null;\n          if (varDecl && varDecl !== obj && varDecl.isGlobalDeclaration && varDecl.listDefinition == null) {\n            _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", varDecl, typeNameToPrint);\n          }\n          if (symbolType < SymbolType_1.SymbolType.SubFlowAndWeave) {\n            return;\n          }\n          // Stitches, Choices and Gathers\n          var path = new Path_1.Path(identifier);\n          var targetContent = path.ResolveFromContext(obj);\n          if (targetContent && targetContent !== obj) {\n            _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", targetContent, typeNameToPrint);\n            return;\n          }\n          if (symbolType < SymbolType_1.SymbolType.Arg) {\n            return;\n          }\n          // Arguments to the current flow\n          if (symbolType !== SymbolType_1.SymbolType.Arg) {\n            var flow = (0, TypeAssertion_1.asOrNull)(obj, FlowBase_1.FlowBase);\n            if (!flow) {\n              flow = (0, ClosestFlowBase_1.ClosestFlowBase)(obj);\n            }\n            if (flow && flow.hasParameters && flow.args) {\n              for (var arg of flow.args) {\n                if (((_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name) === (identifier === null || identifier === void 0 ? void 0 : identifier.name)) {\n                  obj.Error(\"\".concat(typeNameToPrint, \" '\").concat(identifier, \"': name has already been used for a argument to \").concat(flow.identifier, \" on \").concat(flow.debugMetadata));\n                  return;\n                }\n              }\n            }\n          }\n        };\n      }\n      get typeName() {\n        return \"Story\";\n      }\n      // Before this function is called, we have IncludedFile objects interspersed\n      // in our content wherever an include statement was.\n      // So that the include statement can be added in a sensible place (e.g. the\n      // top of the file) without side-effects of jumping into a knot that was\n      // defined in that include, we separate knots and stitches from anything\n      // else defined at the top scope of the included file.\n      //\n      // Algorithm: For each IncludedFile we find, split its contents into\n      // knots/stiches and any other content. Insert the normal content wherever\n      // the include statement was, and append the knots/stitches to the very\n      // end of the main story.\n      PreProcessTopLevelObjects(topLevelContent) {\n        super.PreProcessTopLevelObjects(topLevelContent);\n        var flowsFromOtherFiles = [];\n        // Inject included files\n        for (var obj of topLevelContent) {\n          if (obj instanceof IncludedFile_1.IncludedFile) {\n            var file = obj;\n            // Remove the IncludedFile itself\n            var posOfObj = topLevelContent.indexOf(obj);\n            topLevelContent.splice(posOfObj, 1);\n            // When an included story fails to load, the include\n            // line itself is still valid, so we have to handle it here\n            if (file.includedStory) {\n              var nonFlowContent = [];\n              var subStory = file.includedStory;\n              // Allow empty file\n              if (subStory.content != null) {\n                for (var subStoryObj of subStory.content) {\n                  if (subStoryObj instanceof FlowBase_1.FlowBase) {\n                    flowsFromOtherFiles.push(subStoryObj);\n                  } else {\n                    nonFlowContent.push(subStoryObj);\n                  }\n                }\n                // Add newline on the end of the include\n                nonFlowContent.push(new Text_1.Text(\"\\n\"));\n                // Add contents of the file in its place\n                topLevelContent.splice(posOfObj, 0, ...nonFlowContent);\n                // Skip past the content of this sub story\n                // (since it will already have recursively included\n                //  any lines from other files)\n              }\n            }\n            // Include object has been removed, with possible content inserted,\n            // and position of 'i' will have been determined already.\n            continue;\n          }\n        }\n        // Add the flows we collected from the included files to the\n        // end of our list of our content\n        topLevelContent.splice(0, 0, ...flowsFromOtherFiles);\n      }\n    }\n    Story$1.Story = Story;\n    Story.IsReservedKeyword = name => {\n      switch (name) {\n        case \"true\":\n        case \"false\":\n        case \"not\":\n        case \"return\":\n        case \"else\":\n        case \"VAR\":\n        case \"CONST\":\n        case \"temp\":\n        case \"LIST\":\n        case \"function\":\n          return true;\n      }\n      return false;\n    };\n    return Story$1;\n  }\n\n  var StringExpression = {};\n\n  var hasRequiredStringExpression;\n  function requireStringExpression() {\n    if (hasRequiredStringExpression) return StringExpression;\n    hasRequiredStringExpression = 1;\n    Object.defineProperty(StringExpression, \"__esModule\", {\n      value: true\n    });\n    StringExpression.StringExpression = void 0;\n    var ControlCommand_1 = requireControlCommand();\n    var Expression_1 = requireExpression();\n    var Text_1 = requireText();\n    var TypeAssertion_1 = requireTypeAssertion();\n    let StringExpression$1 = class StringExpression extends Expression_1.Expression {\n      get isSingleString() {\n        if (this.content.length !== 1) {\n          return false;\n        }\n        var c = this.content[0];\n        if (!(c instanceof Text_1.Text)) {\n          return false;\n        }\n        return true;\n      }\n      constructor(content) {\n        super();\n        this.GenerateIntoContainer = container => {\n          container.AddContent(ControlCommand_1.ControlCommand.BeginString());\n          for (var c of this.content) {\n            container.AddContent(c.runtimeObject);\n          }\n          container.AddContent(ControlCommand_1.ControlCommand.EndString());\n        };\n        this.toString = () => {\n          var sb = \"\";\n          for (var c of this.content) {\n            sb += c;\n          }\n          return sb;\n        };\n        this.AddContent(content);\n      }\n      get typeName() {\n        return \"String\";\n      }\n      // Equals override necessary in order to check for CONST multiple definition equality\n      Equals(obj) {\n        var otherStr = (0, TypeAssertion_1.asOrNull)(obj, StringExpression);\n        if (otherStr === null) {\n          return false;\n        }\n        // Can only compare direct equality on single strings rather than\n        // complex string expressions that contain dynamic logic\n        if (!this.isSingleString || !otherStr.isSingleString) {\n          return false;\n        }\n        var thisTxt = this.toString();\n        var otherTxt = otherStr.toString();\n        return thisTxt === otherTxt;\n      }\n    };\n    StringExpression.StringExpression = StringExpression$1;\n    return StringExpression;\n  }\n\n  var Tag = {};\n\n  var hasRequiredTag;\n  function requireTag() {\n    if (hasRequiredTag) return Tag;\n    hasRequiredTag = 1;\n    Object.defineProperty(Tag, \"__esModule\", {\n      value: true\n    });\n    Tag.LegacyTag = Tag.Tag = void 0;\n    var Object_1 = require_Object();\n    var ControlCommand_1 = requireControlCommand();\n    let Tag$1 = class Tag extends Object_1.ParsedObject {\n      constructor(isStart) {\n        var inChoice = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        super();\n        this.GenerateRuntimeObject = () => {\n          if (this.isStart) {\n            return ControlCommand_1.ControlCommand.BeginTag();\n          } else {\n            return ControlCommand_1.ControlCommand.EndTag();\n          }\n        };\n        this.toString = () => {\n          if (this.isStart) {\n            return \"#StartTag\";\n          } else {\n            return \"#EndTag\";\n          }\n        };\n        this.isStart = isStart;\n        this.inChoice = inChoice;\n      }\n      get typeName() {\n        return \"Tag\";\n      }\n    };\n    Tag.Tag = Tag$1;\n    var Wrap_1 = requireWrap();\n    class LegacyTag extends Wrap_1.Wrap {\n      constructor(tag) {\n        super(tag);\n      }\n      get typeName() {\n        return \"Tag\";\n      }\n    }\n    Tag.LegacyTag = LegacyTag;\n    return Tag;\n  }\n\n  var DefaultFileHandler = {};\n\n  var hasRequiredDefaultFileHandler;\n  function requireDefaultFileHandler() {\n    if (hasRequiredDefaultFileHandler) return DefaultFileHandler;\n    hasRequiredDefaultFileHandler = 1;\n    Object.defineProperty(DefaultFileHandler, \"__esModule\", {\n      value: true\n    });\n    DefaultFileHandler.DefaultFileHandler = void 0;\n    // This class replaces upstream's DefaultFileHandler. It doesn't perform any\n    // resolution and warns the user about providing a proper file handler when\n    // INCLUDE statements are parsed. Since the JavaScript parser can be executed in\n    // different environments, we let the user decide which FileHandler is best for\n    // their use-case. See PosixFileHandler and JsonFileHandler.\n    let DefaultFileHandler$1 = class DefaultFileHandler {\n      constructor(rootPath) {\n        this.rootPath = rootPath;\n        this.ResolveInkFilename = () => {\n          throw Error(\"Can't resolve filename because no FileHandler was provided when instantiating the parser / compiler.\");\n        };\n        this.LoadInkFileContents = () => {\n          throw Error(\"Can't load ink content because no FileHandler was provided when instantiating the parser / compiler.\");\n        };\n      }\n    };\n    DefaultFileHandler.DefaultFileHandler = DefaultFileHandler$1;\n    return DefaultFileHandler;\n  }\n\n  var hasRequiredInkParser;\n  function requireInkParser() {\n    if (hasRequiredInkParser) return InkParser;\n    hasRequiredInkParser = 1;\n    Object.defineProperty(InkParser, \"__esModule\", {\n      value: true\n    });\n    InkParser.InkParser = void 0;\n    var Argument_1 = requireArgument();\n    var AuthorWarning_1 = requireAuthorWarning();\n    var BinaryExpression_1 = requireBinaryExpression();\n    var CharacterRange_1 = requireCharacterRange();\n    var CharacterSet_1 = requireCharacterSet();\n    var Choice_1 = requireChoice();\n    var CommentEliminator_1 = requireCommentEliminator();\n    var Conditional_1 = requireConditional();\n    var ConditionalSingleBranch_1 = requireConditionalSingleBranch();\n    var ContentList_1 = requireContentList();\n    var ConstantDeclaration_1 = requireConstantDeclaration();\n    var CustomFlags_1 = requireCustomFlags();\n    var DebugMetadata_1 = requireDebugMetadata();\n    var Divert_1 = requireDivert();\n    var DivertTarget_1 = requireDivertTarget();\n    var Expression_1 = requireExpression();\n    var ExternalDeclaration_1 = requireExternalDeclaration();\n    var FlowDecl_1 = requireFlowDecl();\n    var FunctionCall_1 = requireFunctionCall();\n    var Gather_1 = requireGather();\n    var Glue_1 = requireGlue();\n    var Glue_2 = requireGlue$1();\n    var IncDecExpression_1 = requireIncDecExpression();\n    var IncludedFile_1 = requireIncludedFile();\n    var InfixOperator_1 = requireInfixOperator();\n    var Knot_1 = requireKnot();\n    var List_1 = requireList();\n    var ListDefinition_1 = requireListDefinition();\n    var ListElementDefinition_1 = requireListElementDefinition();\n    var MultipleConditionExpression_1 = requireMultipleConditionExpression();\n    var Object_1 = require_Object();\n    var Path_1 = requirePath();\n    var ReturnType_1 = requireReturnType();\n    var Sequence_1 = requireSequence();\n    var SequenceType_1 = requireSequenceType();\n    var StatementLevel_1 = requireStatementLevel();\n    var Stitch_1 = requireStitch();\n    var Story_1 = requireStory();\n    var StringExpression_1 = requireStringExpression();\n    var StringParser_1 = requireStringParser();\n    var Tag_1 = requireTag();\n    var Text_1 = requireText();\n    var TunnelOnwards_1 = requireTunnelOnwards();\n    var VariableAssignment_1 = requireVariableAssignment();\n    var VariableReference_1 = requireVariableReference();\n    var UnaryExpression_1 = requireUnaryExpression();\n    var TypeAssertion_1 = requireTypeAssertion();\n    var Identifier_1 = requireIdentifier();\n    var NumberExpression_1 = requireNumberExpression();\n    var ErrorType_1 = requireErrorType();\n    var DefaultFileHandler_1 = requireDefaultFileHandler();\n    let InkParser$1 = class InkParser extends StringParser_1.StringParser {\n      /**\n       * Begin base InkParser section.\n       */\n      get fileHandler() {\n        if (!this._fileHandler) {\n          throw new Error(\"No FileHandler defined\");\n        }\n        return this._fileHandler;\n      }\n      set fileHandler(value) {\n        this._fileHandler = value;\n      }\n      constructor(str) {\n        var _this;\n        var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var externalErrorHandler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var rootParser = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var fileHandler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        // Main entry point\n        // NOTE: This method is named Parse() in upstream.\n        super(str);\n        _this = this;\n        this.ParseStory = () => {\n          var topLevelContent = this.StatementsAtLevel(StatementLevel_1.StatementLevel.Top);\n          // Note we used to return null if there were any errors, but this would mean\n          // that include files would return completely empty rather than attempting to\n          // continue with errors. Returning an empty include files meant that anything\n          // that *did* compile successfully would otherwise be ignored, generating way\n          // more errors than necessary.\n          return new Story_1.Story(topLevelContent, this._rootParser !== this);\n        };\n        this.SeparatedList = (mainRule, separatorRule) => {\n          var firstElement = this.Parse(mainRule);\n          if (firstElement === null) {\n            return null;\n          }\n          var allElements = [];\n          allElements.push(firstElement);\n          do {\n            var nextElementRuleId = this.BeginRule();\n            var sep = separatorRule();\n            if (sep === null) {\n              this.FailRule(nextElementRuleId);\n              break;\n            }\n            var nextElement = this.Parse(mainRule);\n            if (nextElement === null) {\n              this.FailRule(nextElementRuleId);\n              break;\n            }\n            this.SucceedRule(nextElementRuleId);\n            allElements.push(nextElement);\n          } while (true);\n          return allElements;\n        };\n        this.CreateDebugMetadata = (stateAtStart, stateAtEnd) => {\n          var md = new DebugMetadata_1.DebugMetadata();\n          md.startLineNumber = ((stateAtStart === null || stateAtStart === void 0 ? void 0 : stateAtStart.lineIndex) || 0) + 1;\n          md.endLineNumber = stateAtEnd.lineIndex + 1;\n          md.startCharacterNumber = ((stateAtStart === null || stateAtStart === void 0 ? void 0 : stateAtStart.characterInLineIndex) || 0) + 1;\n          md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;\n          md.fileName = this._filename;\n          return md;\n        };\n        this.RuleDidSucceed = (result, stateAtStart, stateAtEnd) => {\n          // Apply DebugMetadata based on the state at the start of the rule\n          // (i.e. use line number as it was at the start of the rule)\n          var parsedObj = (0, TypeAssertion_1.asOrNull)(result, Object_1.ParsedObject);\n          if (parsedObj) {\n            parsedObj.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n          }\n          // A list of objects that doesn't already have metadata?\n          var parsedListObjs = Array.isArray(result) ? result : null;\n          if (parsedListObjs !== null) {\n            for (var parsedListObj of parsedListObjs) {\n              var singleObj = (0, TypeAssertion_1.asOrNull)(parsedListObj, Object_1.ParsedObject);\n              if (!singleObj) continue;\n              if (!parsedListObj.hasOwnDebugMetadata) {\n                parsedListObj.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n              }\n            }\n          }\n          var id = (0, TypeAssertion_1.asOrNull)(result, Identifier_1.Identifier);\n          if (id != null) {\n            id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n          }\n        };\n        this.OnStringParserError = function (message, index) {\n          var lineIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var isWarning = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n          var warningType = isWarning ? \"WARNING:\" : \"ERROR:\";\n          var fullMessage = warningType;\n          if (_this._filename !== null) {\n            fullMessage += \" '\".concat(_this._filename, \"'\");\n          }\n          fullMessage += \" line \".concat(lineIndex + 1, \": \").concat(message);\n          if (_this._externalErrorHandler !== null) {\n            _this._externalErrorHandler(fullMessage, isWarning ? ErrorType_1.ErrorType.Warning : ErrorType_1.ErrorType.Error);\n          } else {\n            throw new Error(fullMessage);\n          }\n        };\n        this.AuthorWarning = () => {\n          this.Whitespace();\n          var identifier = this.Parse(this.IdentifierWithMetadata);\n          if (identifier === null || identifier.name !== \"TODO\") {\n            return null;\n          }\n          this.Whitespace();\n          this.ParseString(\":\");\n          this.Whitespace();\n          var message = this.ParseUntilCharactersFromString(\"\\n\\r\");\n          if (message) {\n            return new AuthorWarning_1.AuthorWarning(message);\n          }\n          return null;\n        };\n        this.ExtendIdentifierCharacterRanges = identifierCharSet => {\n          var characterRanges = InkParser.ListAllCharacterRanges();\n          for (var charRange of characterRanges) {\n            identifierCharSet.AddCharacters(charRange.ToCharacterSet());\n          }\n        };\n        /**\n         * End CharacterRanges section.\n         */\n        /**\n         * Begin Choices section.\n         */\n        this._parsingChoice = false;\n        this.Choice = () => {\n          var onceOnlyChoice = true;\n          var bullets = this.Interleave(this.OptionalExclude(this.Whitespace), this.String(\"*\"));\n          if (!bullets) {\n            bullets = this.Interleave(this.OptionalExclude(this.Whitespace), this.String(\"+\"));\n            if (bullets === null) {\n              return null;\n            }\n            onceOnlyChoice = false;\n          }\n          // Optional name for the choice\n          var optionalName = this.Parse(this.BracketedName);\n          this.Whitespace();\n          // Allow optional newline right after a choice name\n          if (optionalName != null) this.Newline();\n          // Optional condition for whether the choice should be shown to the player\n          var conditionExpr = this.Parse(this.ChoiceCondition);\n          this.Whitespace();\n          // Ordinarily we avoid parser state variables like these, since\n          // nesting would require us to store them in a stack. But since you should\n          // never be able to nest choices within choice content, it's fine here.\n          if (this._parsingChoice) {\n            throw new Error(\"Already parsing a choice - shouldn't have nested choices\");\n          }\n          this._parsingChoice = true;\n          var startContent = null;\n          var startTextAndLogic = this.Parse(this.MixedTextAndLogic);\n          if (startTextAndLogic) {\n            startContent = new ContentList_1.ContentList(startTextAndLogic);\n          }\n          var optionOnlyContent = null;\n          var innerContent = null;\n          // Check for a the weave style format:\n          //   * \"Hello[.\"],\" he said.\n          var hasWeaveStyleInlineBrackets = this.ParseString(\"[\") !== null;\n          if (hasWeaveStyleInlineBrackets) {\n            this.EndTagIfNecessary(startContent);\n            var optionOnlyTextAndLogic = this.Parse(this.MixedTextAndLogic);\n            if (optionOnlyTextAndLogic !== null) {\n              optionOnlyContent = new ContentList_1.ContentList(optionOnlyTextAndLogic);\n            }\n            this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");\n            this.EndTagIfNecessary(optionOnlyContent);\n            var innerTextAndLogic = this.Parse(this.MixedTextAndLogic);\n            if (innerTextAndLogic !== null) {\n              innerContent = new ContentList_1.ContentList(innerTextAndLogic);\n            }\n          }\n          this.Whitespace();\n          this.EndTagIfNecessary(innerContent !== null && innerContent !== void 0 ? innerContent : startContent);\n          // Finally, now we know we're at the end of the main choice body, parse\n          // any diverts separately.\n          var diverts = this.Parse(this.MultiDivert);\n          this._parsingChoice = false;\n          this.Whitespace();\n          // Completely empty choice without even an empty divert?\n          var emptyContent = !startContent && !innerContent && !optionOnlyContent;\n          if (emptyContent && diverts === null) {\n            this.Warning(\"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\");\n          }\n          if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {\n            // * [] some text\n            this.Warning(\"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\");\n          }\n          if (!innerContent) {\n            innerContent = new ContentList_1.ContentList();\n          }\n          this.EndTagIfNecessary(innerContent);\n          // Normal diverts on the end of a choice - simply add to the normal content\n          if (diverts !== null) {\n            for (var divObj of diverts) {\n              // may be TunnelOnwards\n              var div = (0, TypeAssertion_1.asOrNull)(divObj, Divert_1.Divert);\n              // Empty divert serves no purpose other than to say\n              // \"this choice is intentionally left blank\"\n              // (as an invisible default choice)\n              if (div && div.isEmpty) {\n                continue;\n              }\n              innerContent.AddContent(divObj);\n            }\n          }\n          // Terminate main content with a newline since this is the end of the line\n          // Note that this will be redundant if the diverts above definitely take\n          // the flow away permanently.\n          innerContent.AddContent(new Text_1.Text(\"\\n\"));\n          var choice = new Choice_1.Choice(startContent, optionOnlyContent, innerContent);\n          if (optionalName) choice.identifier = optionalName;\n          choice.indentationDepth = bullets.length;\n          choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;\n          choice.condition = conditionExpr;\n          choice.onceOnly = onceOnlyChoice;\n          choice.isInvisibleDefault = emptyContent;\n          return choice;\n        };\n        this.ChoiceCondition = () => {\n          var conditions = this.Interleave(this.ChoiceSingleCondition, this.ChoiceConditionsSpace);\n          if (conditions === null) {\n            return null;\n          } else if (conditions.length === 1) {\n            return conditions[0];\n          }\n          return new MultipleConditionExpression_1.MultipleConditionExpression(conditions);\n        };\n        this.ChoiceConditionsSpace = () => {\n          // Both optional\n          // Newline includes initial end of line whitespace\n          this.Newline();\n          this.Whitespace();\n          return StringParser_1.ParseSuccess;\n        };\n        this.ChoiceSingleCondition = () => {\n          if (this.ParseString(\"{\") === null) {\n            return null;\n          }\n          var condExpr = this.Expect(this.Expression, \"choice condition inside { }\");\n          this.DisallowIncrement(condExpr);\n          this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");\n          return condExpr;\n        };\n        this.Gather = () => {\n          var gatherDashCountObj = this.Parse(this.GatherDashes);\n          if (gatherDashCountObj === null) {\n            return null;\n          }\n          var gatherDashCount = Number(gatherDashCountObj);\n          // Optional name for the gather\n          var optionalName = this.Parse(this.BracketedName);\n          var gather = new Gather_1.Gather(optionalName, gatherDashCount);\n          // Optional newline before gather's content begins\n          this.Newline();\n          return gather;\n        };\n        this.GatherDashes = () => {\n          this.Whitespace();\n          var gatherDashCount = 0;\n          while (this.ParseDashNotArrow() !== null) {\n            gatherDashCount += 1;\n            this.Whitespace();\n          }\n          if (gatherDashCount === 0) {\n            return null;\n          }\n          return gatherDashCount;\n        };\n        this.ParseDashNotArrow = () => {\n          var ruleId = this.BeginRule();\n          if (this.ParseString(\"->\") === null && this.ParseSingleCharacter() === \"-\") {\n            return this.SucceedRule(ruleId);\n          }\n          return this.FailRule(ruleId);\n        };\n        this.BracketedName = () => {\n          if (this.ParseString(\"(\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          var name = this.Parse(this.IdentifierWithMetadata);\n          if (name === null) {\n            return null;\n          }\n          this.Whitespace();\n          this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");\n          return name;\n        };\n        /**\n         * End Choices section.\n         */\n        /**\n         * Begin Conditional section.\n         */\n        this.InnerConditionalContent = initialQueryExpression => {\n          if (initialQueryExpression === undefined) {\n            var _initialQueryExpression = this.Parse(this.ConditionExpression);\n            var conditional = this.Parse(() => this.InnerConditionalContent(_initialQueryExpression));\n            if (conditional === null) {\n              return null;\n            }\n            return conditional;\n          }\n          var alternatives;\n          var canBeInline = initialQueryExpression !== null;\n          var isInline = this.Parse(this.Newline) === null;\n          if (isInline && !canBeInline) {\n            return null;\n          }\n          if (isInline) {\n            // Inline innards\n            alternatives = this.InlineConditionalBranches();\n          } else {\n            // Multiline innards\n            alternatives = this.MultilineConditionalBranches();\n            if (alternatives === null) {\n              // Allow single piece of content within multi-line expression, e.g.:\n              // { true:\n              //    Some content that isn't preceded by '-'\n              // }\n              if (initialQueryExpression) {\n                var soleContent = this.StatementsAtLevel(StatementLevel_1.StatementLevel.InnerBlock);\n                if (soleContent !== null) {\n                  var soleBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(soleContent);\n                  alternatives = [soleBranch];\n                  // Also allow a final \"- else:\" clause\n                  var elseBranch = this.Parse(this.SingleMultilineCondition);\n                  if (elseBranch) {\n                    if (!elseBranch.isElse) {\n                      this.ErrorWithParsedObject(\"Expected an '- else:' clause here rather than an extra condition\", elseBranch);\n                      elseBranch.isElse = true;\n                    }\n                    alternatives.push(elseBranch);\n                  }\n                }\n              }\n              // Still null?\n              if (alternatives === null) {\n                return null;\n              }\n            } else if (alternatives.length === 1 && alternatives[0].isElse && initialQueryExpression) {\n              // Empty true branch - didn't get parsed, but should insert one for semantic correctness,\n              // and to make sure that any evaluation stack values get tidied up correctly.\n              var emptyTrueBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(null);\n              emptyTrueBranch.isTrueBranch = true;\n              alternatives.unshift(emptyTrueBranch);\n            }\n            // Like a switch statement\n            // { initialQueryExpression:\n            //    ... match the expression\n            // }\n            if (initialQueryExpression) {\n              var earlierBranchesHaveOwnExpression = false;\n              for (var ii = 0; ii < alternatives.length; ++ii) {\n                var branch = alternatives[ii];\n                var isLast = ii === alternatives.length - 1;\n                // Matching equality with initial query expression\n                // We set this flag even for the \"else\" clause so that\n                // it knows to tidy up the evaluation stack at the end\n                // Match query\n                if (branch.ownExpression) {\n                  branch.matchingEquality = true;\n                  earlierBranchesHaveOwnExpression = true;\n                } else if (earlierBranchesHaveOwnExpression && isLast) {\n                  // Else (final branch)\n                  branch.matchingEquality = true;\n                  branch.isElse = true;\n                } else {\n                  // Binary condition:\n                  // { trueOrFalse:\n                  //    - when true\n                  //    - when false\n                  // }\n                  if (!isLast && alternatives.length > 2) {\n                    this.ErrorWithParsedObject(\"Only final branch can be an 'else'. Did you miss a ':'?\", branch);\n                  } else {\n                    if (ii === 0) {\n                      branch.isTrueBranch = true;\n                    } else {\n                      branch.isElse = true;\n                    }\n                  }\n                }\n              }\n            } else {\n              // No initial query, so just a multi-line conditional. e.g.:\n              // {\n              //   - x > 3:  greater than three\n              //   - x == 3: equal to three\n              //   - x < 3:  less than three\n              // }\n              for (var _ii = 0; _ii < alternatives.length; ++_ii) {\n                var alt = alternatives[_ii];\n                var _isLast = _ii === alternatives.length - 1;\n                if (alt.ownExpression === null) {\n                  if (_isLast) {\n                    alt.isElse = true;\n                  } else {\n                    if (alt.isElse) {\n                      // Do we ALSO have a valid \"else\" at the end? Let's report the error there.\n                      var finalClause = alternatives[alternatives.length - 1];\n                      if (finalClause.isElse) {\n                        this.ErrorWithParsedObject(\"Multiple 'else' cases. Can have a maximum of one, at the end.\", finalClause);\n                      } else {\n                        this.ErrorWithParsedObject(\"'else' case in conditional should always be the final one\", alt);\n                      }\n                    } else {\n                      this.ErrorWithParsedObject(\"Branch doesn't have condition. Are you missing a ':'? \", alt);\n                    }\n                  }\n                }\n              }\n              if (alternatives.length === 1 && alternatives[0].ownExpression === null) {\n                this.ErrorWithParsedObject(\"Condition block with no conditions\", alternatives[0]);\n              }\n            }\n          }\n          // TODO: Come up with water-tight error conditions... it's quite a flexible system!\n          // e.g.\n          //   - inline conditionals must have exactly 1 or 2 alternatives\n          //   - multiline expression shouldn't have mixed existence of branch-conditions?\n          if (alternatives === null) {\n            return null;\n          }\n          for (var _branch of alternatives) {\n            _branch.isInline = isInline;\n          }\n          var cond = new Conditional_1.Conditional(initialQueryExpression, alternatives);\n          return cond;\n        };\n        this.InlineConditionalBranches = () => {\n          var listOfLists = this.Interleave(this.MixedTextAndLogic, this.Exclude(this.String(\"|\")), null, false);\n          if (listOfLists === null || listOfLists.length === 0) {\n            return null;\n          }\n          var result = [];\n          if (listOfLists.length > 2) {\n            this.Error(\"Expected one or two alternatives separated by '|' in inline conditional\");\n          } else {\n            var trueBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(listOfLists[0]);\n            trueBranch.isTrueBranch = true;\n            result.push(trueBranch);\n            if (listOfLists.length > 1) {\n              var elseBranch = new ConditionalSingleBranch_1.ConditionalSingleBranch(listOfLists[1]);\n              elseBranch.isElse = true;\n              result.push(elseBranch);\n            }\n          }\n          return result;\n        };\n        this.MultilineConditionalBranches = () => {\n          this.MultilineWhitespace();\n          var multipleConditions = this.OneOrMore(this.SingleMultilineCondition);\n          if (multipleConditions === null) {\n            return null;\n          }\n          this.MultilineWhitespace();\n          return multipleConditions;\n        };\n        this.SingleMultilineCondition = () => {\n          this.Whitespace();\n          if (\n          // Make sure we're not accidentally parsing a divert\n          this.ParseString(\"->\") !== null || this.ParseString(\"-\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          var expr = null;\n          var isElse = this.Parse(this.ElseExpression) !== null;\n          if (!isElse) {\n            expr = this.Parse(this.ConditionExpression);\n          }\n          var content = this.StatementsAtLevel(StatementLevel_1.StatementLevel.InnerBlock);\n          if (expr === null && content === null) {\n            this.Error(\"expected content for the conditional branch following '-'\");\n            // Recover\n            content = [new Text_1.Text(\"\")];\n          }\n          // Allow additional multiline whitespace, if the statements were empty (valid)\n          // then their surrounding multiline whitespacce needs to be handled manually.\n          // e.g.\n          // { x:\n          //   - 1:    // intentionally left blank, but newline needs to be parsed\n          //   - 2: etc\n          // }\n          this.MultilineWhitespace();\n          var branch = new ConditionalSingleBranch_1.ConditionalSingleBranch(content);\n          branch.ownExpression = expr;\n          branch.isElse = isElse;\n          return branch;\n        };\n        this.ConditionExpression = () => {\n          var expr = this.Parse(this.Expression);\n          if (expr === null) {\n            return null;\n          }\n          this.DisallowIncrement(expr);\n          this.Whitespace();\n          if (this.ParseString(\":\") === null) {\n            return null;\n          }\n          return expr;\n        };\n        this.ElseExpression = () => {\n          if (this.ParseString(\"else\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          if (this.ParseString(\":\") === null) {\n            return null;\n          }\n          return StringParser_1.ParseSuccess;\n        };\n        /**\n         * End Conditional section.\n         */\n        /**\n         * Begin Content section.\n         */\n        this._nonTextPauseCharacters = null;\n        this._nonTextEndCharacters = null;\n        this._notTextEndCharactersChoice = null;\n        this._notTextEndCharactersString = null;\n        this.TrimEndWhitespace = (mixedTextAndLogicResults, terminateWithSpace) => {\n          // Trim whitespace from end\n          if (mixedTextAndLogicResults.length > 0) {\n            var lastObjIdx = mixedTextAndLogicResults.length - 1;\n            var lastObj = mixedTextAndLogicResults[lastObjIdx];\n            if (lastObj instanceof Text_1.Text) {\n              var textObj = lastObj;\n              textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");\n              if (terminateWithSpace) {\n                textObj.text += \" \";\n              } else if (textObj.text.length === 0) {\n                // No content left at all? trim the whole object\n                mixedTextAndLogicResults.splice(lastObjIdx, 1);\n                // Recurse in case there's more whitespace\n                this.TrimEndWhitespace(mixedTextAndLogicResults, false);\n              }\n            }\n          }\n        };\n        this.LineOfMixedTextAndLogic = () => {\n          // Consume any whitespace at the start of the line\n          // (Except for escaped whitespace)\n          this.Parse(this.Whitespace);\n          var result = this.Parse(this.MixedTextAndLogic);\n          if (!result || !result.length) {\n            return null;\n          }\n          // Warn about accidentally writing \"return\" without \"~\"\n          var firstText = result[0];\n          if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {\n            this.Warning(\"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\");\n          }\n          if (result.length === 0) {\n            return null;\n          }\n          var lastObj = result[result.length - 1];\n          if (!(lastObj instanceof Divert_1.Divert)) {\n            this.TrimEndWhitespace(result, false);\n          }\n          this.EndTagIfNecessary(result);\n          // If the line doens't actually contain any normal text content\n          // but is in fact entirely a tag, then let's not append\n          // a newline, since we want the tag (or tags) to be associated\n          // with the line below rather than being completely independent.\n          var lineIsPureTag = result.length > 0 && result[0] instanceof Tag_1.Tag && result[0].isStart;\n          if (!lineIsPureTag) {\n            result.push(new Text_1.Text(\"\\n\"));\n          }\n          this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n          return result;\n        };\n        this.MixedTextAndLogic = () => {\n          // Check for disallowed \"~\" within this context\n          var disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));\n          if (disallowedTilde !== null) {\n            this.Error(\"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\");\n          }\n          // Either, or both interleaved\n          var results = this.Interleave(this.Optional(this.ContentText), this.Optional(this.InlineLogicOrGlueOrStartTag));\n          // Terminating divert?\n          // (When parsing content for the text of a choice, diverts aren't allowed.\n          //  The divert on the end of the body of a choice is handled specially.)\n          if (!this._parsingChoice) {\n            var diverts = this.Parse(this.MultiDivert);\n            if (diverts !== null) {\n              // May not have had any results at all if there's *only* a divert!\n              if (results === null) {\n                results = [];\n              }\n              // End previously active tag if necessary\n              this.EndTagIfNecessary(results);\n              this.TrimEndWhitespace(results, true);\n              results.push(...diverts);\n            }\n          }\n          if (!results) {\n            return null;\n          }\n          return results;\n        };\n        this.ContentText = () => {\n          return this.ContentTextAllowingEscapeChar();\n        };\n        this.ContentTextAllowingEscapeChar = () => {\n          var sb = null;\n          do {\n            var _str = this.Parse(this.ContentTextNoEscape);\n            var gotEscapeChar = this.ParseString(\"\\\\\") !== null;\n            if (gotEscapeChar || _str !== null) {\n              if (sb === null) {\n                sb = \"\";\n              }\n              if (_str !== null) {\n                sb += String(_str);\n              }\n              if (gotEscapeChar) {\n                var c = this.ParseSingleCharacter();\n                sb += c;\n              }\n            } else {\n              break;\n            }\n          } while (true);\n          if (sb !== null) {\n            return new Text_1.Text(sb);\n          }\n          return null;\n        };\n        // Content text is an unusual parse rule compared with most since it's\n        // less about saying \"this is is the small selection of stuff that we parse\"\n        // and more \"we parse ANYTHING except this small selection of stuff\".\n        this.ContentTextNoEscape = () => {\n          // Eat through text, pausing at the following characters, and\n          // attempt to parse the nonTextRule.\n          // \"-\": possible start of divert or start of gather\n          // \"<\": possible start of glue\n          if (this._nonTextPauseCharacters === null) {\n            this._nonTextPauseCharacters = new CharacterSet_1.CharacterSet(\"-<\");\n          }\n          // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule\n          // \"{\" for start of logic\n          // \"|\" for mid logic branch\n          if (this._nonTextEndCharacters === null) {\n            this._nonTextEndCharacters = new CharacterSet_1.CharacterSet(\"{}|\\n\\r\\\\#\");\n            this._notTextEndCharactersChoice = new CharacterSet_1.CharacterSet(this._nonTextEndCharacters);\n            this._notTextEndCharactersChoice.AddCharacters(\"[]\");\n            this._notTextEndCharactersString = new CharacterSet_1.CharacterSet(this._nonTextEndCharacters);\n            this._notTextEndCharactersString.AddCharacters('\"');\n          }\n          // When the ParseUntil pauses, check these rules in case they evaluate successfully\n          var nonTextRule = () => this.OneOf([this.ParseDivertArrow, this.ParseThreadArrow, this.EndOfLine, this.Glue]);\n          var endChars = null;\n          if (this.parsingStringExpression) {\n            endChars = this._notTextEndCharactersString;\n          } else if (this._parsingChoice) {\n            endChars = this._notTextEndCharactersChoice;\n          } else {\n            endChars = this._nonTextEndCharacters;\n          }\n          var pureTextContent = this.ParseUntil(nonTextRule, this._nonTextPauseCharacters, endChars);\n          if (pureTextContent !== null) {\n            return pureTextContent;\n          }\n          return null;\n        };\n        /**\n         * End Content section.\n         */\n        /**\n         * Begin Divert section.\n         */\n        this.MultiDivert = () => {\n          this.Whitespace();\n          var diverts = [];\n          // Try single thread first\n          var threadDivert = this.Parse(this.StartThread);\n          if (threadDivert) {\n            diverts = [threadDivert];\n            return diverts;\n          }\n          // Normal diverts and tunnels\n          var arrowsAndDiverts = this.Interleave(this.ParseDivertArrowOrTunnelOnwards, this.DivertIdentifierWithArguments);\n          if (!arrowsAndDiverts) {\n            return null;\n          }\n          diverts = [];\n          this.EndTagIfNecessary(diverts);\n          // Possible patterns:\n          //  ->                   -- explicit gather\n          //  ->->                 -- tunnel onwards\n          //  -> div               -- normal divert\n          //  ->-> div             -- tunnel onwards, followed by override divert\n          //  -> div ->            -- normal tunnel\n          //  -> div ->->          -- tunnel then tunnel continue\n          //  -> div -> div        -- tunnel then divert\n          //  -> div -> div ->     -- tunnel then tunnel\n          //  -> div -> div ->->\n          //  -> div -> div ->-> div    (etc)\n          // Look at the arrows and diverts\n          for (var ii = 0; ii < arrowsAndDiverts.length; ++ii) {\n            var isArrow = ii % 2 === 0;\n            // Arrow string\n            if (isArrow) {\n              // Tunnel onwards\n              if (arrowsAndDiverts[ii] === \"->->\") {\n                var tunnelOnwardsPlacementValid = ii === 0 || ii === arrowsAndDiverts.length - 1 || ii === arrowsAndDiverts.length - 2;\n                if (!tunnelOnwardsPlacementValid) {\n                  this.Error(\"Tunnel onwards '->->' must only come at the begining or the start of a divert\");\n                }\n                var tunnelOnwards = new TunnelOnwards_1.TunnelOnwards();\n                if (ii < arrowsAndDiverts.length - 1) {\n                  var tunnelOnwardDivert = (0, TypeAssertion_1.asOrNull)(arrowsAndDiverts[ii + 1], Divert_1.Divert);\n                  tunnelOnwards.divertAfter = tunnelOnwardDivert;\n                }\n                diverts.push(tunnelOnwards);\n                // Not allowed to do anything after a tunnel onwards.\n                // If we had anything left it would be caused in the above Error for\n                // the positioning of a ->->\n                break;\n              }\n            } else {\n              // Divert\n              var divert = arrowsAndDiverts[ii];\n              // More to come? (further arrows) Must be tunnelling.\n              if (ii < arrowsAndDiverts.length - 1) {\n                divert.isTunnel = true;\n              }\n              diverts.push(divert);\n            }\n          }\n          // Single -> (used for default choices)\n          if (diverts.length === 0 && arrowsAndDiverts.length === 1) {\n            var gatherDivert = new Divert_1.Divert(null);\n            gatherDivert.isEmpty = true;\n            diverts.push(gatherDivert);\n            if (!this._parsingChoice) {\n              this.Error(\"Empty diverts (->) are only valid on choices\");\n            }\n          }\n          return diverts;\n        };\n        this.StartThread = () => {\n          this.Whitespace();\n          if (this.ParseThreadArrow() === null) {\n            return null;\n          }\n          this.Whitespace();\n          var divert = this.Expect(this.DivertIdentifierWithArguments, \"target for new thread\", () => new Divert_1.Divert(null));\n          divert.isThread = true;\n          return divert;\n        };\n        this.DivertIdentifierWithArguments = () => {\n          this.Whitespace();\n          var targetComponents = this.Parse(this.DotSeparatedDivertPathComponents);\n          if (!targetComponents) {\n            return null;\n          }\n          this.Whitespace();\n          var optionalArguments = this.Parse(this.ExpressionFunctionCallArguments);\n          this.Whitespace();\n          var targetPath = new Path_1.Path(targetComponents);\n          return new Divert_1.Divert(targetPath, optionalArguments);\n        };\n        this.SingleDivert = () => {\n          var diverts = this.Parse(this.MultiDivert);\n          if (!diverts) {\n            return null;\n          }\n          // Ideally we'd report errors if we get the\n          // wrong kind of divert, but unfortunately we\n          // have to hack around the fact that sequences use\n          // a very similar syntax.\n          // i.e. if you have a multi-divert at the start\n          // of a sequence, it initially tries to parse it\n          // as a divert target (part of an expression of\n          // a conditional) and gives errors. So instead\n          // we just have to blindly reject it as a single\n          // divert, and give a slightly less nice error\n          // when you DO use a multi divert as a divert taret.\n          if (diverts.length !== 1) {\n            return null;\n          }\n          var singleDivert = diverts[0];\n          if (singleDivert instanceof TunnelOnwards_1.TunnelOnwards) {\n            return null;\n          }\n          var divert = diverts[0];\n          if (divert.isTunnel) {\n            return null;\n          }\n          return divert;\n        };\n        this.DotSeparatedDivertPathComponents = () => this.Interleave(this.Spaced(this.IdentifierWithMetadata), this.Exclude(this.String(\".\")));\n        this.ParseDivertArrowOrTunnelOnwards = () => {\n          var numArrows = 0;\n          while (this.ParseString(\"->\") !== null) {\n            numArrows += 1;\n          }\n          if (numArrows === 0) {\n            return null;\n          } else if (numArrows === 1) {\n            return \"->\";\n          } else if (numArrows === 2) {\n            return \"->->\";\n          }\n          this.Error(\"Unexpected number of arrows in divert. Should only have '->' or '->->'\");\n          return \"->->\";\n        };\n        this.ParseDivertArrow = () => this.ParseString(\"->\");\n        this.ParseThreadArrow = () => this.ParseString(\"<-\");\n        /**\n         * End Divert section.\n         */\n        /**\n         * Begin Expressions section.\n         */\n        this._binaryOperators = [];\n        this._maxBinaryOpLength = 0;\n        this.TempDeclarationOrAssignment = () => {\n          this.Whitespace();\n          var isNewDeclaration = this.ParseTempKeyword();\n          this.Whitespace();\n          var varIdentifier = null;\n          if (isNewDeclaration) {\n            varIdentifier = this.Expect(this.IdentifierWithMetadata, \"variable name\");\n          } else {\n            varIdentifier = this.Parse(this.IdentifierWithMetadata);\n          }\n          if (varIdentifier === null) {\n            return null;\n          }\n          this.Whitespace();\n          // += -=\n          var isIncrement = this.ParseString(\"+\") !== null;\n          var isDecrement = this.ParseString(\"-\") !== null;\n          if (isIncrement && isDecrement) {\n            this.Error(\"Unexpected sequence '+-'\");\n          }\n          if (this.ParseString(\"=\") === null) {\n            // Definitely in an assignment expression?\n            if (isNewDeclaration) {\n              this.Error(\"Expected '='\");\n            }\n            return null;\n          }\n          var assignedExpression = this.Expect(this.Expression, \"value expression to be assigned\");\n          if (isIncrement || isDecrement) {\n            var _result = new IncDecExpression_1.IncDecExpression(varIdentifier, assignedExpression, isIncrement);\n            return _result;\n          }\n          var result = new VariableAssignment_1.VariableAssignment({\n            variableIdentifier: varIdentifier,\n            assignedExpression,\n            isTemporaryNewDeclaration: isNewDeclaration\n          });\n          return result;\n        };\n        this.DisallowIncrement = expr => {\n          if (expr instanceof IncDecExpression_1.IncDecExpression) {\n            this.Error(\"Can't use increment/decrement here. It can only be used on a ~ line\");\n          }\n        };\n        this.ParseTempKeyword = () => {\n          var ruleId = this.BeginRule();\n          if (this.Parse(this.Identifier) === \"temp\") {\n            this.SucceedRule(ruleId);\n            return true;\n          }\n          this.FailRule(ruleId);\n          return false;\n        };\n        this.ReturnStatement = () => {\n          this.Whitespace();\n          var returnOrDone = this.Parse(this.Identifier);\n          if (returnOrDone !== \"return\") {\n            return null;\n          }\n          this.Whitespace();\n          var expr = this.Parse(this.Expression);\n          var returnObj = new ReturnType_1.ReturnType(expr);\n          return returnObj;\n        };\n        // Pratt Parser\n        // aka \"Top down operator precedence parser\"\n        // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n        // Algorithm overview:\n        // The two types of precedence are handled in two different ways:\n        //   ((((a . b) . c) . d) . e)\t\t\t#1\n        //   (a . (b . (c . (d . e))))\t\t\t#2\n        // Where #1 is automatically handled by successive loops within the main 'while' in this function,\n        // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.\n        // ...and #2 is handled by recursion of the right hand term in the binary expression parser.\n        // (see link for advice on how to extend for postfix and mixfix operators)\n        this.Expression = function () {\n          var minimumPrecedence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          _this.Whitespace();\n          // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"\n          var expr = _this.ExpressionUnary();\n          if (expr === null) {\n            return null;\n          }\n          _this.Whitespace();\n          // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)\n          var _loop = function _loop() {\n              var ruleId = _this.BeginRule();\n              // Operator\n              var infixOp = _this.ParseInfixOperator();\n              if (infixOp !== null && infixOp.precedence > minimumPrecedence) {\n                // Expect right hand side of operator\n                var expectationMessage = \"right side of '\".concat(infixOp.type, \"' expression\");\n                var multiaryExpr = _this.Expect(() => _this.ExpressionInfixRight(expr, infixOp), expectationMessage);\n                if (multiaryExpr === null) {\n                  // Fail for operator and right-hand side of multiary expression\n                  _this.FailRule(ruleId);\n                  return {\n                    v: null\n                  };\n                }\n                expr = _this.SucceedRule(ruleId, multiaryExpr);\n                return 0; // continue\n              }\n              _this.FailRule(ruleId);\n              return 1; // break\n            },\n            _ret;\n          while (true) {\n            _ret = _loop();\n            if (_ret === 0) continue;\n            if (_ret === 1) break;\n            if (_ret) return _ret.v;\n          }\n          _this.Whitespace();\n          return expr;\n        };\n        this.ExpressionUnary = () => {\n          // Divert target is a special case - it can't have any other operators\n          // applied to it, and we also want to check for it first so that we don't\n          // confuse \"->\" for subtraction.\n          var divertTarget = this.Parse(this.ExpressionDivertTarget);\n          if (divertTarget !== null) {\n            return divertTarget;\n          }\n          var prefixOp = this.OneOf([this.String(\"-\"), this.String(\"!\")]);\n          // Don't parse like the string rules above, in case its actually\n          // a variable that simply starts with \"not\", e.g. \"notable\".\n          // This rule uses the Identifier rule, which will scan as much text\n          // as possible before returning.\n          if (prefixOp === null) {\n            prefixOp = this.Parse(this.ExpressionNot);\n          }\n          this.Whitespace();\n          // - Since we allow numbers at the start of variable names, variable names are checked before literals\n          // - Function calls before variable names in case we see parentheses\n          var expr = this.OneOf([this.ExpressionList, this.ExpressionParen, this.ExpressionFunctionCall, this.ExpressionVariableName, this.ExpressionLiteral]);\n          // Only recurse immediately if we have one of the (usually optional) unary ops\n          if (expr === null && prefixOp !== null) {\n            expr = this.ExpressionUnary();\n          }\n          if (expr === null) {\n            return null;\n          } else if (prefixOp !== null) {\n            expr = UnaryExpression_1.UnaryExpression.WithInner(expr, prefixOp);\n          }\n          this.Whitespace();\n          var postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);\n          if (postfixOp !== null) {\n            var isInc = postfixOp === \"++\";\n            if (!(expr instanceof VariableReference_1.VariableReference)) {\n              this.Error(\"can only increment and decrement variables, but saw '\".concat(expr, \"'.\"));\n              // Drop down and succeed without the increment after reporting error\n            } else {\n              var varRef = expr;\n              expr = new IncDecExpression_1.IncDecExpression(varRef.identifier, isInc);\n            }\n          }\n          return expr;\n        };\n        this.ExpressionNot = () => {\n          var id = this.Identifier();\n          if (id === \"not\") {\n            return id;\n          }\n          return null;\n        };\n        this.ExpressionLiteral = () => this.OneOf([this.ExpressionFloat, this.ExpressionInt, this.ExpressionBool, this.ExpressionString]);\n        this.ExpressionDivertTarget = () => {\n          this.Whitespace();\n          var divert = this.Parse(this.SingleDivert);\n          if (!divert || divert && divert.isThread) {\n            return null;\n          }\n          this.Whitespace();\n          return new DivertTarget_1.DivertTarget(divert);\n        };\n        this.ExpressionInt = () => {\n          var intOrNull = this.ParseInt();\n          if (intOrNull === null) {\n            return null;\n          }\n          return new NumberExpression_1.NumberExpression(intOrNull, \"int\");\n        };\n        this.ExpressionFloat = () => {\n          var floatOrNull = this.ParseFloat();\n          if (floatOrNull === null) {\n            return null;\n          }\n          return new NumberExpression_1.NumberExpression(floatOrNull, \"float\");\n        };\n        this.ExpressionString = () => {\n          var openQuote = this.ParseString('\"');\n          if (openQuote === null) {\n            return null;\n          }\n          // Set custom parser state flag so that within the text parser,\n          // it knows to treat the quote character (\") as an end character\n          this.parsingStringExpression = true;\n          var textAndLogic = this.Parse(this.MixedTextAndLogic);\n          this.Expect(this.String('\"'), \"close quote for string expression\");\n          this.parsingStringExpression = false;\n          if (textAndLogic === null) {\n            textAndLogic = [new Text_1.Text(\"\")];\n          } else if (textAndLogic.find(c => c instanceof Divert_1.Divert)) {\n            this.Error(\"String expressions cannot contain diverts (->)\");\n          }\n          return new StringExpression_1.StringExpression(textAndLogic);\n        };\n        this.ExpressionBool = () => {\n          var id = this.Parse(this.Identifier);\n          if (id === \"true\") {\n            return new NumberExpression_1.NumberExpression(true, \"bool\");\n          } else if (id === \"false\") {\n            return new NumberExpression_1.NumberExpression(false, \"bool\");\n          }\n          return null;\n        };\n        this.ExpressionFunctionCall = () => {\n          var iden = this.Parse(this.IdentifierWithMetadata);\n          if (iden === null) {\n            return null;\n          }\n          this.Whitespace();\n          var args = this.Parse(this.ExpressionFunctionCallArguments);\n          if (args === null) {\n            return null;\n          }\n          return new FunctionCall_1.FunctionCall(iden, args);\n        };\n        this.ExpressionFunctionCallArguments = () => {\n          if (this.ParseString(\"(\") === null) {\n            return null;\n          }\n          // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results\n          var commas = this.Exclude(this.String(\",\"));\n          var args = this.Interleave(this.Expression, commas);\n          if (args === null) {\n            args = [];\n          }\n          this.Whitespace();\n          this.Expect(this.String(\")\"), \"closing ')' for function call\");\n          return args;\n        };\n        this.ExpressionVariableName = () => {\n          var path = this.Interleave(this.IdentifierWithMetadata, this.Exclude(this.Spaced(this.String(\".\"))));\n          if (path === null || Story_1.Story.IsReservedKeyword(path[0].name)) {\n            return null;\n          }\n          return new VariableReference_1.VariableReference(path);\n        };\n        this.ExpressionParen = () => {\n          if (this.ParseString(\"(\") === null) {\n            return null;\n          }\n          var innerExpr = this.Parse(this.Expression);\n          if (innerExpr === null) {\n            return null;\n          }\n          this.Whitespace();\n          this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");\n          return innerExpr;\n        };\n        this.ExpressionInfixRight = (left, op) => {\n          if (!left) {\n            return null;\n          }\n          this.Whitespace();\n          var right = this.Parse(() => this.Expression(op.precedence));\n          if (right) {\n            // We assume that the character we use for the operator's type is the same\n            // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc\n            var expr = new BinaryExpression_1.BinaryExpression(left, right, op.type);\n            return expr;\n          }\n          return null;\n        };\n        this.ParseInfixOperator = () => {\n          for (var op of this._binaryOperators) {\n            var ruleId = this.BeginRule();\n            if (this.ParseString(op.type) !== null) {\n              if (op.requireWhitespace) {\n                if (this.Whitespace() === null) {\n                  this.FailRule(ruleId);\n                  continue;\n                }\n              }\n              return this.SucceedRule(ruleId, op);\n            }\n            this.FailRule(ruleId);\n          }\n          return null;\n        };\n        this.ExpressionList = () => {\n          this.Whitespace();\n          if (this.ParseString(\"(\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          // When list has:\n          //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"\n          //  - 1 element - it could be confused for a single non-list related\n          //    identifier expression in brackets, but this is a useless thing\n          //    to do, so we reserve that syntax for a list with one item.\n          //  - 2 or more elements - normal!\n          var memberNames = this.SeparatedList(this.ListMember, this.Spaced(this.String(\",\")));\n          this.Whitespace();\n          // May have failed to parse the inner list - the parentheses may\n          // be for a normal expression\n          if (this.ParseString(\")\") === null) {\n            return null;\n          }\n          return new List_1.List(memberNames);\n        };\n        this.ListMember = () => {\n          this.Whitespace();\n          var identifier = this.Parse(this.IdentifierWithMetadata);\n          if (identifier === null) {\n            return null;\n          }\n          var dot = this.ParseString(\".\");\n          if (dot !== null) {\n            var identifier2 = this.Expect(this.IdentifierWithMetadata, \"element name within the set \".concat(identifier));\n            identifier.name += \".\".concat(identifier2 === null || identifier2 === void 0 ? void 0 : identifier2.name);\n          }\n          this.Whitespace();\n          return identifier;\n        };\n        this.RegisterExpressionOperators = () => {\n          // These will be tried in order, so we need \"<=\" before \"<\"\n          // for correctness\n          this.RegisterBinaryOperator(\"&&\", 1);\n          this.RegisterBinaryOperator(\"||\", 1);\n          this.RegisterBinaryOperator(\"and\", 1, true);\n          this.RegisterBinaryOperator(\"or\", 1, true);\n          this.RegisterBinaryOperator(\"==\", 2);\n          this.RegisterBinaryOperator(\">=\", 2);\n          this.RegisterBinaryOperator(\"<=\", 2);\n          this.RegisterBinaryOperator(\"<\", 2);\n          this.RegisterBinaryOperator(\">\", 2);\n          this.RegisterBinaryOperator(\"!=\", 2);\n          // (apples, oranges) + cabbages has (oranges, cabbages) === true\n          this.RegisterBinaryOperator(\"?\", 3);\n          this.RegisterBinaryOperator(\"has\", 3, true);\n          this.RegisterBinaryOperator(\"!?\", 3);\n          this.RegisterBinaryOperator(\"hasnt\", 3, true);\n          this.RegisterBinaryOperator(\"^\", 3);\n          this.RegisterBinaryOperator(\"+\", 4);\n          this.RegisterBinaryOperator(\"-\", 5);\n          this.RegisterBinaryOperator(\"*\", 6);\n          this.RegisterBinaryOperator(\"/\", 7);\n          this.RegisterBinaryOperator(\"%\", 8);\n          this.RegisterBinaryOperator(\"mod\", 8, true);\n        };\n        this.RegisterBinaryOperator = function (op, precedence) {\n          var requireWhitespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          var infix = new InfixOperator_1.InfixOperator(op, precedence, requireWhitespace);\n          _this._binaryOperators.push(infix);\n          _this._maxBinaryOpLength = Math.max(_this._maxBinaryOpLength, op.length);\n        };\n        this._openFilenames = [];\n        this.IncludeStatement = () => {\n          this.Whitespace();\n          if (this.ParseString(\"INCLUDE\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          var filename = this.Expect(() => this.ParseUntilCharactersFromString(\"\\n\\r\"), \"filename for include statement\");\n          filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");\n          // Working directory should already have been set up relative to the root ink file.\n          var fullFilename = this.fileHandler.ResolveInkFilename(filename);\n          if (this.FilenameIsAlreadyOpen(fullFilename)) {\n            this.Error(\"Recursive INCLUDE detected: '\".concat(fullFilename, \"' is already open.\"));\n            this.ParseUntilCharactersFromString(\"\\r\\n\");\n            return new IncludedFile_1.IncludedFile(null);\n          } else {\n            this.AddOpenFilename(fullFilename);\n          }\n          var includedStory = null;\n          var includedString = \"\";\n          try {\n            includedString = this._rootParser.fileHandler.LoadInkFileContents(fullFilename);\n          } catch (err) {\n            this.Error(\"Failed to load: '\".concat(filename, \"'.\\nError:\").concat(err));\n          }\n          if (includedString != null) {\n            var parser = new InkParser(includedString, filename, this._externalErrorHandler, this._rootParser, this.fileHandler);\n            includedStory = parser.ParseStory();\n          }\n          this.RemoveOpenFilename(fullFilename);\n          // Return valid IncludedFile object even if there were errors when parsing.\n          // We don't want to attempt to re-parse the include line as something else,\n          // and we want to include the bits that *are* valid, so we don't generate\n          // more errors than necessary.\n          return new IncludedFile_1.IncludedFile(includedStory);\n        };\n        this.FilenameIsAlreadyOpen = fullFilename => this._rootParser._openFilenames.includes(fullFilename);\n        this.AddOpenFilename = fullFilename => {\n          this._rootParser._openFilenames.push(fullFilename);\n        };\n        this.RemoveOpenFilename = fullFilename => {\n          this._rootParser._openFilenames.splice(this._rootParser._openFilenames.indexOf(fullFilename), 1);\n        };\n        /**\n         * End Include section.\n         */\n        /**\n         * Begin Knot section.\n         */\n        this.KnotDefinition = () => {\n          var knotDecl = this.Parse(this.KnotDeclaration);\n          if (knotDecl === null) {\n            return null;\n          }\n          this.Expect(this.EndOfLine, \"end of line after knot name definition\", this.SkipToNextLine);\n          var innerKnotStatements = () => this.StatementsAtLevel(StatementLevel_1.StatementLevel.Knot);\n          var content = this.Expect(innerKnotStatements, \"at least one line within the knot\", this.KnotStitchNoContentRecoveryRule);\n          return new Knot_1.Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);\n        };\n        this.KnotDeclaration = () => {\n          this.Whitespace();\n          if (this.KnotTitleEquals() === null) {\n            return null;\n          }\n          this.Whitespace();\n          var identifier = this.Parse(this.IdentifierWithMetadata);\n          var knotName;\n          var isFunc = (identifier === null || identifier === void 0 ? void 0 : identifier.name) === \"function\";\n          if (isFunc) {\n            this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");\n            knotName = this.Parse(this.IdentifierWithMetadata);\n          } else {\n            knotName = identifier;\n          }\n          if (knotName === null) {\n            this.Error(\"Expected the name of the \".concat(isFunc ? \"function\" : \"knot\"));\n            knotName = new Identifier_1.Identifier(\"\"); // prevent later null ref\n          }\n          this.Whitespace();\n          var parameterNames = this.Parse(this.BracketedKnotDeclArguments);\n          this.Whitespace();\n          // Optional equals after name\n          this.Parse(this.KnotTitleEquals);\n          return new FlowDecl_1.FlowDecl(knotName, parameterNames, isFunc);\n        };\n        this.KnotTitleEquals = () => {\n          // 2+ \"=\" starts a knot\n          var multiEquals = this.ParseCharactersFromString(\"=\");\n          if (multiEquals === null || multiEquals.length <= 1) {\n            return null;\n          }\n          return multiEquals;\n        };\n        this.StitchDefinition = () => {\n          var decl = this.Parse(this.StitchDeclaration);\n          if (decl === null) {\n            return null;\n          }\n          this.Expect(this.EndOfLine, \"end of line after stitch name\", this.SkipToNextLine);\n          var innerStitchStatements = () => this.StatementsAtLevel(StatementLevel_1.StatementLevel.Stitch);\n          var content = this.Expect(innerStitchStatements, \"at least one line within the stitch\", this.KnotStitchNoContentRecoveryRule);\n          return new Stitch_1.Stitch(decl.name, content, decl.args, decl.isFunction);\n        };\n        this.StitchDeclaration = () => {\n          this.Whitespace();\n          // Single \"=\" to define a stitch\n          if (this.ParseString(\"=\") === null) {\n            return null;\n          }\n          // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail\n          if (this.ParseString(\"=\") !== null) {\n            return null;\n          }\n          this.Whitespace();\n          // Stitches aren't allowed to be functions, but we parse it anyway and report the error later\n          var isFunc = this.ParseString(\"function\") !== null;\n          if (isFunc) {\n            this.Whitespace();\n          }\n          var stitchName = this.Parse(this.IdentifierWithMetadata);\n          if (stitchName === null) {\n            return null;\n          }\n          this.Whitespace();\n          var flowArgs = this.Parse(this.BracketedKnotDeclArguments);\n          this.Whitespace();\n          return new FlowDecl_1.FlowDecl(stitchName, flowArgs, isFunc);\n        };\n        this.KnotStitchNoContentRecoveryRule = () => {\n          // Jump ahead to the next knot or the end of the file\n          this.ParseUntil(this.KnotDeclaration, new CharacterSet_1.CharacterSet(\"=\"), null);\n          var recoveredFlowContent = [new Text_1.Text(\"<ERROR IN FLOW>\")];\n          return recoveredFlowContent;\n        };\n        this.BracketedKnotDeclArguments = () => {\n          if (this.ParseString(\"(\") === null) {\n            return null;\n          }\n          var flowArguments = this.Interleave(this.Spaced(this.FlowDeclArgument), this.Exclude(this.String(\",\")));\n          this.Expect(this.String(\")\"), \"closing ')' for parameter list\");\n          // If no parameters, create an empty list so that this method is type safe and\n          // doesn't attempt to return the ParseSuccess object\n          if (flowArguments === null) {\n            flowArguments = [];\n          }\n          return flowArguments;\n        };\n        this.FlowDeclArgument = () => {\n          // Possible forms:\n          //  name\n          //  -> name      (variable divert target argument\n          //  ref name\n          //  ref -> name  (variable divert target by reference)\n          var firstIden = this.Parse(this.IdentifierWithMetadata);\n          this.Whitespace();\n          var divertArrow = this.ParseDivertArrow();\n          this.Whitespace();\n          var secondIden = this.Parse(this.IdentifierWithMetadata);\n          if (firstIden == null && secondIden === null) {\n            return null;\n          }\n          var flowArg = new Argument_1.Argument();\n          if (divertArrow !== null) {\n            flowArg.isDivertTarget = true;\n          }\n          // Passing by reference\n          if (firstIden !== null && firstIden.name === \"ref\") {\n            if (secondIden === null) {\n              this.Error(\"Expected an parameter name after 'ref'\");\n            }\n            flowArg.identifier = secondIden;\n            flowArg.isByReference = true;\n          } else {\n            // Simple argument name\n            if (flowArg.isDivertTarget) {\n              flowArg.identifier = secondIden;\n            } else {\n              flowArg.identifier = firstIden;\n            }\n            if (flowArg.identifier === null) {\n              this.Error(\"Expected an parameter name\");\n            }\n            flowArg.isByReference = false;\n          }\n          return flowArg;\n        };\n        this.ExternalDeclaration = () => {\n          this.Whitespace();\n          var external = this.Parse(this.IdentifierWithMetadata);\n          if (external === null || external.name != \"EXTERNAL\") {\n            return null;\n          }\n          this.Whitespace();\n          var funcIdentifier = this.Expect(this.IdentifierWithMetadata, \"name of external function\") || new Identifier_1.Identifier(\"\");\n          this.Whitespace();\n          var parameterNames = this.Expect(this.BracketedKnotDeclArguments, \"declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL \".concat(funcIdentifier, \"()'\"));\n          if (parameterNames === null) {\n            parameterNames = [];\n          }\n          var argNames = parameterNames.map(arg => {\n            var _a;\n            return (_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name;\n          }).filter(TypeAssertion_1.filterUndef);\n          return new ExternalDeclaration_1.ExternalDeclaration(funcIdentifier, argNames);\n        };\n        /**\n         * End Knot section.\n         */\n        /**\n         * Start Logic section.\n         */\n        this._identifierCharSet = null;\n        this.LogicLine = () => {\n          this.Whitespace();\n          if (this.ParseString(\"~\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          // Some example lines we need to be able to distinguish between:\n          // ~ temp x = 5  -- var decl + assign\n          // ~ temp x      -- var decl\n          // ~ x = 5       -- var assign\n          // ~ x           -- expr (not var decl or assign)\n          // ~ f()         -- expr\n          // We don't treat variable decl/assign as an expression since we don't want an assignment\n          // to have a return value, or to be used in compound expressions.\n          var afterTilde = () => this.OneOf([this.ReturnStatement, this.TempDeclarationOrAssignment, this.Expression]);\n          var result = this.Expect(afterTilde, \"expression after '~'\", this.SkipToNextLine);\n          // Prevent further errors, already reported expected expression and have skipped to next line.\n          if (result === null) {\n            return new ContentList_1.ContentList();\n          }\n          // Parse all expressions, but tell the writer off if they did something useless like:\n          //  ~ 5 + 4\n          // And even:\n          //  ~ false && myFunction()\n          // ...since it's bad practice, and won't do what they expect if\n          // they're expecting C's lazy evaluation.\n          if (result instanceof Expression_1.Expression && !(result instanceof FunctionCall_1.FunctionCall || result instanceof IncDecExpression_1.IncDecExpression)) {\n            this.Error(\"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\");\n          }\n          // Line is pure function call? e.g.\n          //  ~ f()\n          // Add extra pop to make sure we tidy up after ourselves.\n          // We no longer need anything on the evaluation stack.\n          var funCall = (0, TypeAssertion_1.asOrNull)(result, FunctionCall_1.FunctionCall);\n          if (funCall) {\n            funCall.shouldPopReturnedValue = true;\n          }\n          // If the expression contains a function call, then it could produce a text side effect,\n          // in which case it needs a newline on the end. e.g.\n          //  ~ printMyName()\n          //  ~ x = 1 + returnAValueAndAlsoPrintStuff()\n          // If no text gets printed, then the extra newline will have to be culled later.\n          // Multiple newlines on the output will be removed, so there will be no \"leak\" for\n          // long running calculations. It's disappointingly messy though :-/\n          if (result.Find(FunctionCall_1.FunctionCall)() !== null) {\n            result = new ContentList_1.ContentList(result, new Text_1.Text(\"\\n\"));\n          }\n          this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n          return result;\n        };\n        this.VariableDeclaration = () => {\n          this.Whitespace();\n          var id = this.Parse(this.Identifier);\n          if (id !== \"VAR\") {\n            return null;\n          }\n          this.Whitespace();\n          var varName = this.Expect(this.IdentifierWithMetadata, \"variable name\");\n          this.Whitespace();\n          this.Expect(this.String(\"=\"), \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\");\n          this.Whitespace();\n          var definition = this.Expect(this.Expression, \"initial value for \");\n          var expr = definition;\n          if (expr) {\n            var check = expr instanceof NumberExpression_1.NumberExpression || expr instanceof StringExpression_1.StringExpression || expr instanceof DivertTarget_1.DivertTarget || expr instanceof VariableReference_1.VariableReference || expr instanceof List_1.List;\n            if (!check) {\n              this.Error(\"initial value for a variable must be a number, constant, list or divert target\");\n            }\n            if (this.Parse(this.ListElementDefinitionSeparator) !== null) {\n              this.Error(\"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\");\n            } else if (expr instanceof StringExpression_1.StringExpression) {\n              // Ensure string expressions are simple\n              var strExpr = expr;\n              if (!strExpr.isSingleString) {\n                this.Error(\"Constant strings cannot contain any logic.\");\n              }\n            }\n            var result = new VariableAssignment_1.VariableAssignment({\n              assignedExpression: expr,\n              isGlobalDeclaration: true,\n              variableIdentifier: varName\n            });\n            return result;\n          }\n          return null;\n        };\n        this.ListDeclaration = () => {\n          this.Whitespace();\n          var id = this.Parse(this.Identifier);\n          if (id != \"LIST\") {\n            return null;\n          }\n          this.Whitespace();\n          var varName = this.Expect(this.IdentifierWithMetadata, \"list name\");\n          this.Whitespace();\n          this.Expect(this.String(\"=\"), \"the '=' for an assignment of the list definition\");\n          this.Whitespace();\n          var definition = this.Expect(this.ListDefinition, \"list item names\");\n          if (definition) {\n            definition.identifier = new Identifier_1.Identifier(varName.name);\n            return new VariableAssignment_1.VariableAssignment({\n              variableIdentifier: varName,\n              listDef: definition\n            });\n          }\n          return null;\n        };\n        this.ListDefinition = () => {\n          this.AnyWhitespace();\n          var allElements = this.SeparatedList(this.ListElementDefinition, this.ListElementDefinitionSeparator);\n          if (allElements === null) {\n            return null;\n          }\n          return new ListDefinition_1.ListDefinition(allElements);\n        };\n        this.ListElementDefinitionSeparator = () => {\n          this.AnyWhitespace();\n          if (this.ParseString(\",\") === null) {\n            return null;\n          }\n          this.AnyWhitespace();\n          return \",\";\n        };\n        this.ListElementDefinition = () => {\n          var inInitialList = this.ParseString(\"(\") !== null;\n          var needsToCloseParen = inInitialList;\n          this.Whitespace();\n          var name = this.Parse(this.IdentifierWithMetadata);\n          if (name === null) {\n            return null;\n          }\n          this.Whitespace();\n          if (inInitialList) {\n            if (this.ParseString(\")\") != null) {\n              needsToCloseParen = false;\n              this.Whitespace();\n            }\n          }\n          var elementValue = null;\n          if (this.ParseString(\"=\") !== null) {\n            this.Whitespace();\n            var elementValueNum = this.Expect(this.ExpressionInt, \"value to be assigned to list item\");\n            if (elementValueNum !== null) {\n              elementValue = elementValueNum.value;\n            }\n            if (needsToCloseParen) {\n              this.Whitespace();\n              if (this.ParseString(\")\") !== null) {\n                needsToCloseParen = false;\n              }\n            }\n          }\n          if (needsToCloseParen) {\n            this.Error(\"Expected closing ')'\");\n          }\n          return new ListElementDefinition_1.ListElementDefinition(name, inInitialList, elementValue);\n        };\n        this.ConstDeclaration = () => {\n          this.Whitespace();\n          var id = this.Parse(this.Identifier);\n          if (id !== \"CONST\") {\n            return null;\n          }\n          this.Whitespace();\n          var varName = this.Expect(this.IdentifierWithMetadata, \"constant name\");\n          this.Whitespace();\n          this.Expect(this.String(\"=\"), \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\");\n          this.Whitespace();\n          var expr = this.Expect(this.Expression, \"initial value for \");\n          var check = expr instanceof NumberExpression_1.NumberExpression || expr instanceof DivertTarget_1.DivertTarget || expr instanceof StringExpression_1.StringExpression;\n          if (!check) {\n            this.Error(\"initial value for a constant must be a number or divert target\");\n          } else if (expr instanceof StringExpression_1.StringExpression) {\n            // Ensure string expressions are simple\n            var strExpr = expr;\n            if (!strExpr.isSingleString) {\n              this.Error(\"Constant strings cannot contain any logic.\");\n            }\n          }\n          var result = new ConstantDeclaration_1.ConstantDeclaration(varName, expr);\n          return result;\n        };\n        this.InlineLogicOrGlueOrStartTag = () => this.OneOf([this.InlineLogic, this.Glue, this.StartTag]);\n        this.Glue = () => {\n          // Don't want to parse whitespace, since it might be important\n          // surrounding the glue.\n          var glueStr = this.ParseString(\"<>\");\n          if (glueStr !== null) {\n            return new Glue_1.Glue(new Glue_2.Glue());\n          }\n          return null;\n        };\n        this.InlineLogic = () => {\n          if (this.ParseString(\"{\") === null) {\n            return null;\n          }\n          var wasParsingString = this.parsingStringExpression;\n          var wasTagActive = this.tagActive;\n          this.Whitespace();\n          var logic = this.Expect(this.InnerLogic, \"some kind of logic, conditional or sequence within braces: { ... }\");\n          if (logic === null) {\n            this.parsingStringExpression = wasParsingString;\n            return null;\n          }\n          this.DisallowIncrement(logic);\n          var contentList = (0, TypeAssertion_1.asOrNull)(logic, ContentList_1.ContentList);\n          if (!contentList) {\n            contentList = new ContentList_1.ContentList(logic);\n          }\n          this.Whitespace();\n          this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");\n          // Allow nested strings and logic\n          this.parsingStringExpression = wasParsingString;\n          // Difference between:\n          //\n          //     1) A thing # {image}.jpg\n          //     2) A {red #red|blue #blue} sequence.\n          //\n          //  When logic ends in (1) we still want tag to continue.\n          //  When logic ends in (2) we want to auto-end the tag.\n          //  Side note: we simply disallow tags within strings.\n          if (!wasTagActive) this.EndTagIfNecessary(contentList);\n          return contentList;\n        };\n        this.InnerLogic = () => {\n          this.Whitespace();\n          // Explicitly try the combinations of inner logic\n          // that could potentially have conflicts first.\n          // Explicit sequence annotation?\n          var explicitSeqType = this.ParseObject(this.SequenceTypeAnnotation);\n          if (explicitSeqType !== null) {\n            var contentLists = this.Expect(this.InnerSequenceObjects, \"sequence elements (for cycle/stoping etc)\");\n            if (contentLists === null) {\n              return null;\n            }\n            return new Sequence_1.Sequence(contentLists, explicitSeqType);\n          }\n          // Conditional with expression?\n          var initialQueryExpression = this.Parse(this.ConditionExpression);\n          if (initialQueryExpression) {\n            var conditional = this.Expect(() => this.InnerConditionalContent(initialQueryExpression), \"conditional content following query\");\n            return conditional;\n          }\n          // Now try to evaluate each of the \"full\" rules in turn\n          var rules = [\n          // Conditional still necessary, since you can have a multi-line conditional\n          // without an initial query expression:\n          // {\n          //   - true:  this is true\n          //   - false: this is false\n          // }\n          this.InnerConditionalContent, this.InnerSequence, this.InnerExpression];\n          //let wasTagActiveAtStartOfScope = this.tagActive;\n          // Adapted from \"OneOf\" structuring rule except that in\n          // order for the rule to succeed, it has to maximally\n          // cover the entire string within the { }. Used to\n          // differentiate between:\n          //  {myVar}                 -- Expression (try first)\n          //  {my content is jolly}   -- sequence with single element\n          for (var rule of rules) {\n            var ruleId = this.BeginRule();\n            var result = this.ParseObject(rule);\n            if (result) {\n              // Not yet at end?\n              if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {\n                this.FailRule(ruleId);\n              } else {\n                // Full parse of content within braces\n                return this.SucceedRule(ruleId, result);\n              }\n            } else {\n              this.FailRule(ruleId);\n            }\n          }\n          return null;\n        };\n        this.InnerExpression = () => {\n          var expr = this.Parse(this.Expression);\n          if (expr) {\n            expr.outputWhenComplete = true;\n          }\n          return expr;\n        };\n        this.IdentifierWithMetadata = () => {\n          var id = this.Identifier();\n          if (id === null) {\n            return null;\n          }\n          return new Identifier_1.Identifier(id);\n        };\n        // Note: we allow identifiers that start with a number,\n        // but not if they *only* comprise numbers\n        this.Identifier = () => {\n          // Parse remaining characters (if any)\n          var name = this.ParseCharactersFromCharSet(this.identifierCharSet);\n          if (name === null) {\n            return null;\n          }\n          // Reject if it's just a number\n          var isNumberCharsOnly = true;\n          for (var c of name) {\n            if (!(c >= \"0\" && c <= \"9\")) {\n              isNumberCharsOnly = false;\n              break;\n            }\n          }\n          if (isNumberCharsOnly) {\n            return null;\n          }\n          return name;\n        };\n        /**\n         * End Logic section.\n         */\n        /**\n         * Begin Sequences section.\n         */\n        this._sequenceTypeSymbols = new CharacterSet_1.CharacterSet(\"!&~$\");\n        this.InnerSequence = () => {\n          this.Whitespace();\n          // Default sequence type\n          var seqType = SequenceType_1.SequenceType.Stopping;\n          // Optional explicit sequence type\n          var parsedSeqType = this.Parse(this.SequenceTypeAnnotation);\n          if (parsedSeqType !== null) {\n            seqType = parsedSeqType;\n          }\n          var contentLists = this.Parse(this.InnerSequenceObjects);\n          if (contentLists === null || contentLists.length <= 1) {\n            return null;\n          }\n          return new Sequence_1.Sequence(contentLists, seqType);\n        };\n        this.SequenceTypeAnnotation = () => {\n          var annotation = this.Parse(this.SequenceTypeSymbolAnnotation);\n          if (annotation === null) {\n            annotation = this.Parse(this.SequenceTypeWordAnnotation);\n          }\n          if (annotation === null) {\n            return null;\n          }\n          switch (annotation) {\n            case SequenceType_1.SequenceType.Once:\n            case SequenceType_1.SequenceType.Cycle:\n            case SequenceType_1.SequenceType.Stopping:\n            case SequenceType_1.SequenceType.Shuffle:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            case SequenceType_1.SequenceType.Shuffle | SequenceType_1.SequenceType.Stopping:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            case SequenceType_1.SequenceType.Shuffle | SequenceType_1.SequenceType.Once:\n              break;\n            default:\n              this.Error(\"Sequence type combination not supported: \".concat(annotation));\n              return SequenceType_1.SequenceType.Stopping;\n          }\n          return annotation;\n        };\n        this.SequenceTypeSymbolAnnotation = () => {\n          if (this._sequenceTypeSymbols === null) {\n            this._sequenceTypeSymbols = new CharacterSet_1.CharacterSet(\"!&~$ \");\n          }\n          var sequenceType = 0;\n          var sequenceAnnotations = this.ParseCharactersFromCharSet(this._sequenceTypeSymbols);\n          if (sequenceAnnotations === null) {\n            return null;\n          }\n          for (var symbolChar of sequenceAnnotations) {\n            switch (symbolChar) {\n              case \"!\":\n                sequenceType |= SequenceType_1.SequenceType.Once;\n                break;\n              case \"&\":\n                sequenceType |= SequenceType_1.SequenceType.Cycle;\n                break;\n              case \"~\":\n                sequenceType |= SequenceType_1.SequenceType.Shuffle;\n                break;\n              case \"$\":\n                sequenceType |= SequenceType_1.SequenceType.Stopping;\n                break;\n            }\n          }\n          if (sequenceType === 0) {\n            return null;\n          }\n          return sequenceType;\n        };\n        this.SequenceTypeWordAnnotation = () => {\n          var sequenceTypes = this.Interleave(this.SequenceTypeSingleWord, this.Exclude(this.Whitespace));\n          if (sequenceTypes === null || sequenceTypes.length === 0) {\n            return null;\n          }\n          if (this.ParseString(\":\") === null) {\n            return null;\n          }\n          var combinedSequenceType = 0;\n          for (var seqType of sequenceTypes) {\n            combinedSequenceType |= seqType;\n          }\n          return combinedSequenceType;\n        };\n        this.SequenceTypeSingleWord = () => {\n          var seqType = null;\n          var word = this.Parse(this.IdentifierWithMetadata);\n          if (word !== null) {\n            switch (word.name) {\n              case \"once\":\n                seqType = SequenceType_1.SequenceType.Once;\n                break;\n              case \"cycle\":\n                seqType = SequenceType_1.SequenceType.Cycle;\n                break;\n              case \"shuffle\":\n                seqType = SequenceType_1.SequenceType.Shuffle;\n                break;\n              case \"stopping\":\n                seqType = SequenceType_1.SequenceType.Stopping;\n                break;\n            }\n          }\n          if (seqType === null) {\n            return null;\n          }\n          return seqType;\n        };\n        this.InnerSequenceObjects = () => {\n          var multiline = this.Parse(this.Newline) !== null;\n          var result = null;\n          if (multiline) {\n            result = this.Parse(this.InnerMultilineSequenceObjects);\n          } else {\n            result = this.Parse(this.InnerInlineSequenceObjects);\n          }\n          return result;\n        };\n        this.InnerInlineSequenceObjects = () => {\n          var interleavedContentAndPipes = this.Interleave(this.Optional(this.MixedTextAndLogic), this.String(\"|\"), null, false);\n          if (interleavedContentAndPipes === null) {\n            return null;\n          }\n          var result = [];\n          // The content and pipes won't necessarily be perfectly interleaved in the sense that\n          // the content can be missing, but in that case it's intended that there's blank content.\n          var justHadContent = false;\n          for (var contentOrPipe of interleavedContentAndPipes) {\n            // Pipe/separator\n            if (contentOrPipe === \"|\") {\n              // Expected content, saw pipe - need blank content now\n              if (!justHadContent) {\n                // Add blank content\n                result.push(new ContentList_1.ContentList());\n              }\n              justHadContent = false;\n            } else {\n              // Real content\n              var content = contentOrPipe;\n              if (content === null) {\n                this.Error(\"Expected content, but got \".concat(contentOrPipe, \" (this is an ink compiler bug!)\"));\n              } else {\n                result.push(new ContentList_1.ContentList(content));\n              }\n              justHadContent = true;\n            }\n          }\n          // Ended in a pipe? Need to insert final blank content\n          if (!justHadContent) {\n            result.push(new ContentList_1.ContentList());\n          }\n          return result;\n        };\n        this.InnerMultilineSequenceObjects = () => {\n          this.MultilineWhitespace();\n          var contentLists = this.OneOrMore(this.SingleMultilineSequenceElement);\n          if (contentLists === null) {\n            return null;\n          }\n          return contentLists;\n        };\n        this.SingleMultilineSequenceElement = () => {\n          this.Whitespace();\n          // Make sure we're not accidentally parsing a divert\n          if (this.ParseString(\"->\") !== null) {\n            return null;\n          }\n          if (this.ParseString(\"-\") === null) {\n            return null;\n          }\n          this.Whitespace();\n          var content = this.StatementsAtLevel(StatementLevel_1.StatementLevel.InnerBlock);\n          if (content === null) {\n            this.MultilineWhitespace();\n          } else {\n            // Add newline at the start of each branch\n            content.unshift(new Text_1.Text(\"\\n\"));\n          }\n          return new ContentList_1.ContentList(content);\n        };\n        /**\n         * End Sequences section.\n         */\n        /**\n         * Begin Statements section.\n         */\n        this._statementRulesAtLevel = [];\n        this._statementBreakRulesAtLevel = [];\n        this.StatementsAtLevel = level => {\n          // Check for error: Should not be allowed gather dashes within an inner block\n          if (level === StatementLevel_1.StatementLevel.InnerBlock) {\n            var badGatherDashCount = this.Parse(this.GatherDashes);\n            if (badGatherDashCount !== null) {\n              this.Error(\"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\");\n            }\n          }\n          return this.Interleave(this.Optional(this.MultilineWhitespace), () => this.StatementAtLevel(level), () => this.StatementsBreakForLevel(level));\n        };\n        this.StatementAtLevel = level => {\n          var rulesAtLevel = this._statementRulesAtLevel[level];\n          var statement = this.OneOf(rulesAtLevel);\n          // For some statements, allow them to parse, but create errors, since\n          // writers may think they can use the statement, so it's useful to have\n          // the error message.\n          if (level === StatementLevel_1.StatementLevel.Top) {\n            if (statement instanceof ReturnType_1.ReturnType) {\n              this.Error(\"should not have return statement outside of a knot\");\n            }\n          }\n          return statement;\n        };\n        this.StatementsBreakForLevel = level => {\n          this.Whitespace();\n          var breakRules = this._statementBreakRulesAtLevel[level];\n          var breakRuleResult = this.OneOf(breakRules);\n          if (breakRuleResult === null) {\n            return null;\n          }\n          return breakRuleResult;\n        };\n        this.GenerateStatementLevelRules = () => {\n          var levels = Object.values(StatementLevel_1.StatementLevel);\n          this._statementRulesAtLevel = \"f\".repeat(levels.length).split(\"f\").map(() => []);\n          this._statementBreakRulesAtLevel = \"f\".repeat(levels.length).split(\"f\").map(() => []);\n          for (var level of levels) {\n            var rulesAtLevel = [];\n            var breakingRules = [];\n            // Diverts can go anywhere\n            rulesAtLevel.push(this.Line(this.MultiDivert));\n            // Knots can only be parsed at Top/Global scope\n            if (level >= StatementLevel_1.StatementLevel.Top) {\n              rulesAtLevel.push(this.KnotDefinition);\n            }\n            rulesAtLevel.push(this.Line(this.Choice));\n            rulesAtLevel.push(this.Line(this.AuthorWarning));\n            // Gather lines would be confused with multi-line block separators, like\n            // within a multi-line if statement\n            if (level > StatementLevel_1.StatementLevel.InnerBlock) {\n              rulesAtLevel.push(this.Gather);\n            }\n            // Stitches (and gathers) can (currently) only go in Knots and top level\n            if (level >= StatementLevel_1.StatementLevel.Knot) {\n              rulesAtLevel.push(this.StitchDefinition);\n            }\n            // Global variable declarations can go anywhere\n            rulesAtLevel.push(this.Line(this.ListDeclaration));\n            rulesAtLevel.push(this.Line(this.VariableDeclaration));\n            rulesAtLevel.push(this.Line(this.ConstDeclaration));\n            rulesAtLevel.push(this.Line(this.ExternalDeclaration));\n            // Global include can go anywhere\n            rulesAtLevel.push(this.Line(this.IncludeStatement));\n            // Normal logic / text can go anywhere\n            rulesAtLevel.push(this.LogicLine);\n            rulesAtLevel.push(this.LineOfMixedTextAndLogic);\n            // --------\n            // Breaking rules\n            // Break current knot with a new knot\n            if (level <= StatementLevel_1.StatementLevel.Knot) {\n              breakingRules.push(this.KnotDeclaration);\n            }\n            // Break current stitch with a new stitch\n            if (level <= StatementLevel_1.StatementLevel.Stitch) {\n              breakingRules.push(this.StitchDeclaration);\n            }\n            // Breaking an inner block (like a multi-line condition statement)\n            if (level <= StatementLevel_1.StatementLevel.InnerBlock) {\n              breakingRules.push(this.ParseDashNotArrow);\n              breakingRules.push(this.String(\"}\"));\n            }\n            this._statementRulesAtLevel[level] = rulesAtLevel;\n            this._statementBreakRulesAtLevel[level] = breakingRules;\n          }\n        };\n        this.SkipToNextLine = () => {\n          this.ParseUntilCharactersFromString(\"\\n\\r\");\n          this.ParseNewline();\n          return StringParser_1.ParseSuccess;\n        };\n        // Modifier to turn a rule into one that expects a newline on the end.\n        // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use\n        // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.\n        this.Line = inlineRule => () => {\n          var result = this.ParseObject(inlineRule);\n          if (result === null) {\n            return null;\n          }\n          this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n          return result;\n        };\n        /**\n         * End Statements section.\n         */\n        /**\n         * Begin Tags section.\n         */\n        this.StartTag = () => {\n          this.Whitespace();\n          if (this.ParseString(\"#\") === null) {\n            return null;\n          }\n          if (this.parsingStringExpression) {\n            this.Error(\"Tags aren't allowed inside of strings. Please use \\\\# if you want a hash symbol.\");\n          }\n          var result = null;\n          if (this.tagActive) {\n            var contentList = new ContentList_1.ContentList();\n            contentList.AddContent(new Tag_1.Tag(/*isStart:*/false));\n            contentList.AddContent(new Tag_1.Tag(/*isStart:*/true));\n            result = contentList;\n          } else {\n            result = new Tag_1.Tag(/*isStart:*/true);\n          }\n          this.tagActive = true;\n          this.Whitespace();\n          return result;\n        };\n        /**\n         * End Tags section.\n         */\n        /**\n         * Begin Whitespace section.\n         */\n        this._inlineWhitespaceChars = new CharacterSet_1.CharacterSet(\" \\t\");\n        // Handles both newline and endOfFile\n        this.EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);\n        // Allow whitespace before the actual newline\n        this.Newline = () => {\n          this.Whitespace();\n          var gotNewline = this.ParseNewline() !== null;\n          // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n          if (!gotNewline) {\n            return null;\n          }\n          return StringParser_1.ParseSuccess;\n        };\n        this.EndOfFile = () => {\n          this.Whitespace();\n          if (!this.endOfInput) return null;\n          return StringParser_1.ParseSuccess;\n        };\n        // General purpose space, returns N-count newlines (fails if no newlines)\n        this.MultilineWhitespace = () => {\n          var newlines = this.OneOrMore(this.Newline);\n          if (newlines === null) {\n            return null;\n          }\n          // Use content field of Token to say how many newlines there were\n          // (in most circumstances it's unimportant)\n          var numNewlines = newlines.length;\n          if (numNewlines >= 1) {\n            return StringParser_1.ParseSuccess;\n          }\n          return null;\n        };\n        this.Whitespace = () => {\n          var doneParsed = this.ParseCharactersFromCharSet(this._inlineWhitespaceChars);\n          if (doneParsed !== null) {\n            return StringParser_1.ParseSuccess;\n          }\n          return null;\n        };\n        this.Spaced = rule => () => {\n          this.Whitespace();\n          var result = this.ParseObject(rule);\n          if (result === null) {\n            return null;\n          }\n          this.Whitespace();\n          return result;\n        };\n        this.AnyWhitespace = () => {\n          var anyWhitespace = false;\n          while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {\n            anyWhitespace = true;\n          }\n          return anyWhitespace ? StringParser_1.ParseSuccess : null;\n        };\n        this.MultiSpaced = rule => () => {\n          this.AnyWhitespace();\n          var result = this.ParseObject(rule);\n          if (result === null) {\n            return null;\n          }\n          this.AnyWhitespace();\n          return result;\n        };\n        this._filename = null;\n        this._externalErrorHandler = null;\n        this._fileHandler = null;\n        this._filename = filename;\n        this.RegisterExpressionOperators();\n        this.GenerateStatementLevelRules();\n        this.errorHandler = this.OnStringParserError;\n        this._externalErrorHandler = externalErrorHandler;\n        if (fileHandler === null) {\n          this._fileHandler = new DefaultFileHandler_1.DefaultFileHandler();\n        } else {\n          this._fileHandler = fileHandler;\n        }\n        if (rootParser === null) {\n          this._rootParser = this;\n          this._openFilenames = [];\n          if (this._filename !== null) {\n            var fullRootInkPath = this.fileHandler.ResolveInkFilename(this._filename);\n            this._openFilenames.push(fullRootInkPath);\n          }\n        } else {\n          this._rootParser = rootParser;\n        }\n      }\n      PreProcessInputString(str) {\n        var commentEliminator = new CommentEliminator_1.CommentEliminator(str);\n        return commentEliminator.Process();\n      }\n      get parsingStringExpression() {\n        return this.GetFlag(Number(CustomFlags_1.CustomFlags.ParsingString));\n      }\n      set parsingStringExpression(value) {\n        this.SetFlag(Number(CustomFlags_1.CustomFlags.ParsingString), value);\n      }\n      get tagActive() {\n        return this.GetFlag(Number(CustomFlags_1.CustomFlags.TagActive));\n      }\n      set tagActive(value) {\n        this.SetFlag(Number(CustomFlags_1.CustomFlags.TagActive), value);\n      }\n      get identifierCharSet() {\n        if (this._identifierCharSet === null) {\n          (this._identifierCharSet = new CharacterSet_1.CharacterSet()).AddRange(\"A\", \"Z\").AddRange(\"a\", \"z\").AddRange(\"0\", \"9\").Add(\"_\");\n          // Enable non-ASCII characters for story identifiers.\n          this.ExtendIdentifierCharacterRanges(this._identifierCharSet);\n        }\n        return this._identifierCharSet;\n      }\n      EndTagIfNecessary(outputContentList) {\n        if (this.tagActive) {\n          if (outputContentList != null) {\n            if (outputContentList instanceof ContentList_1.ContentList) {\n              outputContentList.AddContent(new Tag_1.Tag(/*isStart:*/false));\n            } else {\n              outputContentList.push(new Tag_1.Tag(/*isStart:*/false));\n            }\n          }\n          this.tagActive = false;\n        }\n      }\n    };\n    InkParser.InkParser = InkParser$1;\n    /**\n     * End base InkParser section.\n     */\n    /**\n     * Begin CharacterRanges section.\n     */\n    InkParser$1.LatinBasic = CharacterRange_1.CharacterRange.Define(\"\\u0041\", \"\\u007A\", new CharacterSet_1.CharacterSet().AddRange(\"\\u005B\", \"\\u0060\"));\n    InkParser$1.LatinExtendedA = CharacterRange_1.CharacterRange.Define(\"\\u0100\", \"\\u017F\"\n    // no excludes here\n    );\n    InkParser$1.LatinExtendedB = CharacterRange_1.CharacterRange.Define(\"\\u0180\", \"\\u024F\"\n    // no excludes here\n    );\n    InkParser$1.Greek = CharacterRange_1.CharacterRange.Define(\"\\u0370\", \"\\u03FF\", new CharacterSet_1.CharacterSet().AddRange(\"\\u0378\", \"\\u0385\").AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\"));\n    InkParser$1.Cyrillic = CharacterRange_1.CharacterRange.Define(\"\\u0400\", \"\\u04FF\", new CharacterSet_1.CharacterSet().AddRange(\"\\u0482\", \"\\u0489\"));\n    InkParser$1.Armenian = CharacterRange_1.CharacterRange.Define(\"\\u0530\", \"\\u058F\", new CharacterSet_1.CharacterSet().AddCharacters(\"\\u0530\").AddRange(\"\\u0557\", \"\\u0560\").AddRange(\"\\u0588\", \"\\u058E\"));\n    InkParser$1.Hebrew = CharacterRange_1.CharacterRange.Define(\"\\u0590\", \"\\u05FF\", new CharacterSet_1.CharacterSet());\n    InkParser$1.Arabic = CharacterRange_1.CharacterRange.Define(\"\\u0600\", \"\\u06FF\", new CharacterSet_1.CharacterSet());\n    InkParser$1.Korean = CharacterRange_1.CharacterRange.Define(\"\\uAC00\", \"\\uD7AF\", new CharacterSet_1.CharacterSet());\n    InkParser$1.Latin1Supplement = CharacterRange_1.CharacterRange.Define(\"\\u0080\", \"\\u00FF\", new CharacterSet_1.CharacterSet());\n    InkParser$1.Chinese = CharacterRange_1.CharacterRange.Define(\"\\u4E00\", \"\\u9FFF\", new CharacterSet_1.CharacterSet());\n    /// <summary>\n    /// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n    /// non-ASCII character ranges that can be used in identifier names.\n    /// </summary>\n    /// <returns>\n    /// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n    /// non-ASCII character ranges that can be used in identifier names.\n    /// </returns>\n    InkParser$1.ListAllCharacterRanges = () => [InkParser$1.LatinBasic, InkParser$1.LatinExtendedA, InkParser$1.LatinExtendedB, InkParser$1.Arabic, InkParser$1.Armenian, InkParser$1.Cyrillic, InkParser$1.Greek, InkParser$1.Hebrew, InkParser$1.Korean, InkParser$1.Latin1Supplement, InkParser$1.Chinese];\n    return InkParser;\n  }\n\n  var Stats = {};\n\n  var hasRequiredStats;\n  function requireStats() {\n    if (hasRequiredStats) return Stats;\n    hasRequiredStats = 1;\n    Object.defineProperty(Stats, \"__esModule\", {\n      value: true\n    });\n    Stats.GenerateStoryStats = void 0;\n    var Choice_1 = requireChoice();\n    var Divert_1 = requireDivert();\n    var Gather_1 = requireGather();\n    var Knot_1 = requireKnot();\n    var Stitch_1 = requireStitch();\n    var Text_1 = requireText();\n    function GenerateStoryStats(story) {\n      var allText = story.FindAll(Text_1.Text)();\n      var words = 0;\n      for (var text of allText) {\n        var wordsInThisStr = 0;\n        var wasWhiteSpace = true;\n        for (var c of text.text) {\n          if (c == \" \" || c == \"\\t\" || c == \"\\n\" || c == \"\\r\") {\n            wasWhiteSpace = true;\n          } else if (wasWhiteSpace) {\n            wordsInThisStr++;\n            wasWhiteSpace = false;\n          }\n        }\n        words += wordsInThisStr;\n      }\n      var knots = story.FindAll(Knot_1.Knot)();\n      var stitches = story.FindAll(Stitch_1.Stitch)();\n      var choices = story.FindAll(Choice_1.Choice)();\n      var gathers = story.FindAll(Gather_1.Gather)(g => g.debugMetadata != null);\n      var diverts = story.FindAll(Divert_1.Divert)();\n      return {\n        words,\n        knots: knots.length,\n        functions: knots.filter(k => k.isFunction).length,\n        stitches: stitches.length,\n        gathers: gathers.length,\n        diverts: diverts.length - 1,\n        choices: choices.length\n      };\n    }\n    Stats.GenerateStoryStats = GenerateStoryStats;\n    return Stats;\n  }\n\n  var JsonFileHandler = {};\n\n  var hasRequiredJsonFileHandler;\n  function requireJsonFileHandler() {\n    if (hasRequiredJsonFileHandler) return JsonFileHandler;\n    hasRequiredJsonFileHandler = 1;\n    Object.defineProperty(JsonFileHandler, \"__esModule\", {\n      value: true\n    });\n    JsonFileHandler.JsonFileHandler = void 0;\n    let JsonFileHandler$1 = class JsonFileHandler {\n      constructor(fileHierarchy) {\n        this.fileHierarchy = fileHierarchy;\n        this.ResolveInkFilename = filename => {\n          if (Object.keys(this.fileHierarchy).includes(filename)) return filename;\n          throw new Error(\"Cannot locate \".concat(filename, \". Are you trying a relative import ? This is not yet implemented.\"));\n        };\n        this.LoadInkFileContents = filename => {\n          if (Object.keys(this.fileHierarchy).includes(filename)) {\n            return this.fileHierarchy[filename];\n          } else {\n            throw new Error(\"Cannot open \".concat(filename, \".\"));\n          }\n        };\n      }\n    };\n    JsonFileHandler.JsonFileHandler = JsonFileHandler$1;\n    return JsonFileHandler;\n  }\n\n  var hasRequiredCompiler;\n  function requireCompiler() {\n    if (hasRequiredCompiler) return Compiler;\n    hasRequiredCompiler = 1;\n    (function (exports) {\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.Compiler = exports.Story = exports.InkList = exports.JsonFileHandler = exports.StatementLevel = exports.InkParser = exports.CompilerOptions = void 0;\n      var CompilerOptions_1 = requireCompilerOptions();\n      var DebugSourceRange_1 = requireDebugSourceRange();\n      var ErrorType_1 = requireErrorType();\n      var InkParser_1 = requireInkParser();\n      var Value_1 = requireValue();\n      var TypeAssertion_1 = requireTypeAssertion();\n      var Stats_1 = requireStats();\n      var CompilerOptions_2 = requireCompilerOptions();\n      Object.defineProperty(exports, \"CompilerOptions\", {\n        enumerable: true,\n        get: function get() {\n          return CompilerOptions_2.CompilerOptions;\n        }\n      });\n      var InkParser_2 = requireInkParser();\n      Object.defineProperty(exports, \"InkParser\", {\n        enumerable: true,\n        get: function get() {\n          return InkParser_2.InkParser;\n        }\n      });\n      var StatementLevel_1 = requireStatementLevel();\n      Object.defineProperty(exports, \"StatementLevel\", {\n        enumerable: true,\n        get: function get() {\n          return StatementLevel_1.StatementLevel;\n        }\n      });\n      var JsonFileHandler_1 = requireJsonFileHandler();\n      Object.defineProperty(exports, \"JsonFileHandler\", {\n        enumerable: true,\n        get: function get() {\n          return JsonFileHandler_1.JsonFileHandler;\n        }\n      });\n      var Story_1 = requireStory$1();\n      Object.defineProperty(exports, \"InkList\", {\n        enumerable: true,\n        get: function get() {\n          return Story_1.InkList;\n        }\n      });\n      Object.defineProperty(exports, \"Story\", {\n        enumerable: true,\n        get: function get() {\n          return Story_1.Story;\n        }\n      });\n      class Compiler {\n        get errors() {\n          return this._errors;\n        }\n        get warnings() {\n          return this._warnings;\n        }\n        get authorMessages() {\n          return this._authorMessages;\n        }\n        get inputString() {\n          return this._inputString;\n        }\n        get options() {\n          return this._options;\n        }\n        get parsedStory() {\n          if (!this._parsedStory) {\n            throw new Error();\n          }\n          return this._parsedStory;\n        }\n        get runtimeStory() {\n          if (!this._runtimeStory) {\n            throw new Error(\"Compilation failed.\");\n          }\n          return this._runtimeStory;\n        }\n        get parser() {\n          if (!this._parser) {\n            throw new Error();\n          }\n          return this._parser;\n        }\n        get debugSourceRanges() {\n          return this._debugSourceRanges;\n        }\n        constructor(inkSource) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          this._errors = [];\n          this._warnings = [];\n          this._authorMessages = [];\n          this._parsedStory = null;\n          this._runtimeStory = null;\n          this._parser = null;\n          this._debugSourceRanges = [];\n          this.Compile = () => {\n            this._parser = new InkParser_1.InkParser(this.inputString, this.options.sourceFilename || null, this.OnError, null, this.options.fileHandler);\n            this._parsedStory = this.parser.ParseStory();\n            if (this.errors.length === 0) {\n              this.parsedStory.countAllVisits = this.options.countAllVisits;\n              this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);\n            } else {\n              this._runtimeStory = null;\n            }\n            return this.runtimeStory;\n          };\n          this.RetrieveDebugSourceForLatestContent = () => {\n            var _a;\n            for (var outputObj of this.runtimeStory.state.outputStream) {\n              var textContent = (0, TypeAssertion_1.asOrNull)(outputObj, Value_1.StringValue);\n              if (textContent !== null) {\n                var range = new DebugSourceRange_1.DebugSourceRange(((_a = textContent.value) === null || _a === void 0 ? void 0 : _a.length) || 0, textContent.debugMetadata, textContent.value || \"unknown\");\n                this.debugSourceRanges.push(range);\n              }\n            }\n          };\n          this.GenerateStats = () => {\n            if (this._parsedStory === null) {\n              return null;\n            }\n            return (0, Stats_1.GenerateStoryStats)(this._parsedStory);\n          };\n          this.DebugMetadataForContentAtOffset = offset => {\n            var currOffset = 0;\n            var lastValidMetadata = null;\n            for (var range of this.debugSourceRanges) {\n              if (range.debugMetadata !== null) {\n                lastValidMetadata = range.debugMetadata;\n              }\n              if (offset >= currOffset && offset < currOffset + range.length) {\n                return lastValidMetadata;\n              }\n              currOffset += range.length;\n            }\n            return null;\n          };\n          this.OnError = (message, errorType) => {\n            switch (errorType) {\n              case ErrorType_1.ErrorType.Author:\n                this._authorMessages.push(message);\n                break;\n              case ErrorType_1.ErrorType.Warning:\n                this._warnings.push(message);\n                break;\n              case ErrorType_1.ErrorType.Error:\n                this._errors.push(message);\n                break;\n            }\n            if (this.options.errorHandler !== null) {\n              this.options.errorHandler(message, errorType);\n            }\n          };\n          this._inputString = inkSource;\n          this._options = options || new CompilerOptions_1.CompilerOptions();\n        }\n      }\n      exports.Compiler = Compiler;\n    })(Compiler);\n    return Compiler;\n  }\n\n  var PosixFileHandler = {};\n\n  var hasRequiredPosixFileHandler;\n  function requirePosixFileHandler() {\n    if (hasRequiredPosixFileHandler) return PosixFileHandler;\n    hasRequiredPosixFileHandler = 1;\n    Object.defineProperty(PosixFileHandler, \"__esModule\", {\n      value: true\n    });\n    PosixFileHandler.PosixFileHandler = void 0;\n    var path = require$$0;\n    var fs = require$$1;\n    // This class replaces upstream's DefaultFileHandler.\n    let PosixFileHandler$1 = class PosixFileHandler {\n      constructor() {\n        var rootPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        this.rootPath = rootPath;\n        this.ResolveInkFilename = filename => {\n          return path.resolve(process.cwd(), this.rootPath, filename);\n        };\n        this.LoadInkFileContents = filename => {\n          return fs.readFileSync(filename, \"utf-8\");\n        };\n      }\n    };\n    PosixFileHandler.PosixFileHandler = PosixFileHandler$1;\n    return PosixFileHandler;\n  }\n\n  var hasRequiredInk;\n  function requireInk() {\n    if (hasRequiredInk) return ink;\n    hasRequiredInk = 1;\n    (function (exports) {\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.JsonFileHandler = exports.PosixFileHandler = exports.CompilerOptions = exports.Compiler = exports.InkList = exports.Story = void 0;\n      var Story_1 = requireStory$1();\n      Object.defineProperty(exports, \"Story\", {\n        enumerable: true,\n        get: function get() {\n          return Story_1.Story;\n        }\n      });\n      Object.defineProperty(exports, \"InkList\", {\n        enumerable: true,\n        get: function get() {\n          return Story_1.InkList;\n        }\n      });\n      var Compiler_1 = requireCompiler();\n      Object.defineProperty(exports, \"Compiler\", {\n        enumerable: true,\n        get: function get() {\n          return Compiler_1.Compiler;\n        }\n      });\n      Object.defineProperty(exports, \"CompilerOptions\", {\n        enumerable: true,\n        get: function get() {\n          return Compiler_1.CompilerOptions;\n        }\n      });\n      var PosixFileHandler_1 = requirePosixFileHandler();\n      Object.defineProperty(exports, \"PosixFileHandler\", {\n        enumerable: true,\n        get: function get() {\n          return PosixFileHandler_1.PosixFileHandler;\n        }\n      });\n      var JsonFileHandler_1 = requireJsonFileHandler();\n      Object.defineProperty(exports, \"JsonFileHandler\", {\n        enumerable: true,\n        get: function get() {\n          return JsonFileHandler_1.JsonFileHandler;\n        }\n      });\n    })(ink);\n    return ink;\n  }\n\n  var inkExports = requireInk();\n\n  var Story = (function () {\n      function Story() {\n          var _this = this;\n          var storydataElement = document.querySelector('tw-storydata');\n          if (storydataElement === null) {\n              throw new Error(\"Could not find '<tw-storydata>' element!\");\n          }\n          this.storyData = storydataElement;\n          this.name = this.storyData.getAttribute('name');\n          this.passages = [];\n          this.storyData.querySelectorAll('tw-passagedata').forEach(function (element) {\n              var tagsValue = element.getAttribute('tags');\n              var tags;\n              if (tagsValue !== '' && tagsValue) {\n                  tags = tagsValue.split(' ');\n              }\n              else {\n                  tags = [];\n              }\n              _this.passages.push(new Passage(element.getAttribute('name'), tags, element.innerHTML));\n          });\n          var workingPassage;\n          if (!(workingPassage = document.querySelector('tw-passage'))) {\n              throw new Error(\"Unable to locate <tw-passage>!\");\n          }\n          this.workingPassage = workingPassage;\n          this.currentPassage = null;\n          this.currentInkStory = null;\n          this.inkBlock = null;\n      }\n      Story.prototype.start = function () {\n          var _this = this;\n          var passageIDStr = this.storyData.getAttribute('startnode');\n          if (!passageIDStr) {\n              throw new Error('Unable to fetch startnode value!');\n          }\n          var startingPassageID = parseInt(passageIDStr);\n          var startingPassage;\n          var startPassageName;\n          if (!(startingPassage = document.querySelector(\"[pid=\\\"\".concat(startingPassageID, \"\\\"]\")))\n              || !(startPassageName = startingPassage.getAttribute('name'))) {\n              throw new Error('Unable to fetch starting passage name!');\n          }\n          var passage = this.getPassageByName(startPassageName);\n          if (passage === null) {\n              throw new Error('Starting passage does not exist!');\n          }\n          this.currentPassage = passage;\n          this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n          var passageTemplate = this.include(passage.name);\n          this.workingPassage.innerHTML = \"\";\n          this.workingPassage.appendChild(passageTemplate.content.cloneNode(true));\n          if (passage.inkSource.length > 0) {\n              this.currentInkStory = new inkExports.Compiler(passage.inkSource).Compile();\n              this.inkBlock = document.querySelector(\"#ink_block\");\n              console.log(this.currentInkStory);\n              this.updateInk();\n          }\n          else {\n              this.currentInkStory = null;\n          }\n          Utils.addEventListener('click', function (event) {\n              if (event.target instanceof Element) {\n                  var passageName = event.target.getAttribute('data-passage');\n                  _this.show(passageName);\n              }\n          }, 'tw-link[data-passage]');\n          Utils.addEventListener('click', function () {\n              console.log(\"ink content clicked\");\n              if (_this.currentInkStory) {\n                  _this.updateInk();\n              }\n          }, 'div#ink_content,div#tap_reminder');\n          Utils.addEventListener('click', function (event) {\n              console.log(\"ink choice clicked\");\n              if (event.target instanceof HTMLAnchorElement) {\n                  var choiceIndex = event.target.getAttribute('choiceIndex');\n                  _this.updateInk(parseInt(choiceIndex));\n              }\n          }, 'a.ink_choice');\n          if (this.currentInkStory) {\n              this.updateInk();\n          }\n      };\n      Story.prototype.getPassagesByTag = function (tag) {\n          return this.passages.filter(function (p) {\n              return p.tags.includes(tag);\n          });\n      };\n      Story.prototype.getPassageByName = function (name) {\n          var passage = null;\n          var result = this.passages.filter(function (p) { return p.name === name; });\n          if (result.length !== 0) {\n              passage = result[0];\n          }\n          return passage;\n      };\n      Story.prototype.show = function (name) {\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error(\"There is no passage with the name \".concat(name));\n          }\n          this.currentPassage = passage;\n          this.workingPassage.setAttribute('tags', passage.tags.join(\" \"));\n          var passageTemplate = this.include(passage.name);\n          this.workingPassage.innerHTML = \"\";\n          this.workingPassage.appendChild(passageTemplate.content.cloneNode(true));\n          if (passage.inkSource.length > 0) {\n              this.currentInkStory = new inkExports.Compiler(passage.inkSource).Compile();\n              this.inkBlock = document.querySelector(\"#ink_block\");\n              console.log(this.currentInkStory);\n              this.updateInk();\n          }\n          else {\n              this.currentInkStory = null;\n          }\n      };\n      Story.prototype.update = function () {\n      };\n      Story.prototype.updateInk = function (choiceIndex) {\n          if (choiceIndex === void 0) { choiceIndex = -1; }\n          if (this.currentInkStory === null || !this.inkBlock === null) {\n              return;\n          }\n          var inkContent = this.inkBlock.querySelector(\"div#ink_content\");\n          var inkChoices = this.inkBlock.querySelector(\"div#ink_choices\");\n          var tapReminder = this.inkBlock.querySelector(\"div#tap_reminder\");\n          var changeMade = false;\n          if (inkContent === null) {\n              inkContent = document.createElement(\"div\");\n              inkContent.id = \"ink_content\";\n              this.inkBlock.appendChild(inkContent);\n              changeMade = true;\n          }\n          if (inkChoices === null) {\n              inkChoices = document.createElement(\"div\");\n              inkChoices.id = \"ink_choices\";\n              inkChoices.setAttribute(\"hidden\", \"hidden\");\n              this.inkBlock.appendChild(inkChoices);\n              changeMade = true;\n          }\n          if (tapReminder === null) {\n              tapReminder = document.createElement(\"div\");\n              tapReminder.id = \"tap_reminder\";\n              tapReminder.textContent = \"(Tap the screen to continue)\";\n              tapReminder.setAttribute(\"hidden\", \"hidden\");\n              this.inkBlock.appendChild(tapReminder);\n              changeMade = true;\n          }\n          if (choiceIndex >= 0) {\n              if (inkChoices.getAttribute(\"hidden\")) {\n                  throw new Error(\"#ink_choices element should not be hidden!\");\n              }\n              this.currentInkStory.ChooseChoiceIndex(choiceIndex);\n              inkChoices.setAttribute(\"hidden\", \"hidden\");\n              inkChoices.innerHTML = \"\";\n              changeMade = true;\n          }\n          if (this.currentInkStory.canContinue) {\n              var element = document.createElement(\"p\");\n              element.innerHTML = this.currentInkStory.Continue();\n              inkContent.appendChild(element);\n              changeMade = true;\n          }\n          if (this.currentInkStory.canContinue) {\n              tapReminder.removeAttribute(\"hidden\");\n          }\n          else {\n              tapReminder.setAttribute(\"hidden\", \"hidden\");\n          }\n          if (inkChoices.getAttribute(\"hidden\") && this.currentInkStory.currentChoices.length > 0) {\n              this.currentInkStory.currentChoices.forEach(function (choice, index) {\n                  var choiceElement = document.createElement(\"a\");\n                  choiceElement.setAttribute(\"class\", \"ink_choice\");\n                  choiceElement.setAttribute(\"choiceIndex\", \"\".concat(index));\n                  choiceElement.href = \"javascript:void(0)\";\n                  choiceElement.innerText = \"\".concat(index, \". \").concat(choice.text);\n                  inkChoices.appendChild(choiceElement);\n                  inkChoices.appendChild(document.createElement(\"br\"));\n              });\n              inkChoices.removeAttribute(\"hidden\");\n              changeMade = true;\n          }\n          if (changeMade) {\n              this.inkBlock.scroll(0, this.inkBlock.scrollHeight);\n          }\n      };\n      Story.prototype.include = function (name) {\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error('There is no passage with name ' + name);\n          }\n          var passageSource = passage.renderStaticElements();\n          return passageSource;\n      };\n      Story.prototype.renderPassageToSelector = function (passageName, selector) {\n          var passageTemplate = this.include(passageName);\n          var element = document.querySelector(selector);\n          if (element) {\n              element.innerHTML = \"\";\n              element.appendChild(passageTemplate.content.cloneNode(true));\n          }\n      };\n      Story.prototype.addPassage = function (name, tags, source) {\n          if (name === void 0) { name = ''; }\n          if (tags === void 0) { tags = []; }\n          if (source === void 0) { source = ''; }\n          var nameSearch = this.getPassageByName(name);\n          if (nameSearch !== null) {\n              throw new Error('Cannot add two passages with the same name!');\n          }\n          if (!Array.isArray(tags)) {\n              tags = [];\n          }\n          if (Object.prototype.toString.call(source) !== '[object String]') {\n              source = '';\n          }\n          this.passages.push(new Passage(name, tags, source));\n      };\n      Story.prototype.removePassage = function (name) {\n          if (name === void 0) { name = ''; }\n          this.passages = this.passages.filter(function (passage) {\n              return passage.name !== name;\n          });\n      };\n      Story.prototype.goto = function (name) {\n          if (name === void 0) { name = ''; }\n          var passage = this.getPassageByName(name);\n          if (passage === null) {\n              throw new Error(\"There is no passage with the name \".concat(name));\n          }\n          this.show(name);\n      };\n      return Story;\n  }());\n\n  window._story = new Story();\n  window._story.start();\n\n}));\n       </script>\n    \n</body></html>"});