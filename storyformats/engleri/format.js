window.storyFormat({"name":"Engleri","version":"0.1.0","description":"A Twine story format that uses Inkle's Ink language","proofing":false,"license":"MIT","setup":"","source":"<!DOCTYPE html><html><head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta charset=\"utf-8\">\n        <title>{{STORY_NAME}}</title>\n    </head>\n    <body>\n        {{STORY_DATA}}\n\t\t<tw-story>\n\t\t\t<tw-passage class=\"passage\"></tw-passage>\n\t\t</tw-story>\n        <script>\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.engleri = factory());\n})(this, (function () { 'use strict';\n\n\tfunction getDefaultExportFromCjs (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tvar main$1 = {};\n\n\t/**\n\t * An object representing a passage. The current passage will be `window.passage`.\n\t * @class Passage\n\t */\n\n\tvar Passage_1;\n\tvar hasRequiredPassage;\n\n\tfunction requirePassage () {\n\t\tif (hasRequiredPassage) return Passage_1;\n\t\thasRequiredPassage = 1;\n\t\tclass Passage {\n\t\t  constructor (name = 'Default', tags = [], source = '') {\n\t\t    /**\n\t\t     * @property {string} name - The name of passage\n\t\t     * @type {string}\n\t\t     */\n\n\t\t    this.name = name;\n\n\t\t    /**\n\t\t     * @property {Array} tags - The tags of the passage.\n\t\t     * @type {Array}\n\t\t     */\n\n\t\t    this.tags = tags;\n\n\t\t    /**\n\t\t     * @property {string} source - The passage source code.\n\t\t     * @type {string}\n\t\t     */\n\n\t\t    this.source = source;\n\t\t  }\n\n\t\t  /**\n\t\t   * Replaces Twine link syntax (ex: '[[link->passage]]') in this passage's source with a <tw-link>,\n\t\t   * and returns the result.\n\t\t   */\n\t\t  renderLinks() {\n\t\t    const rules = [\n\t\t      // [[link_name|target_passage]]\n\t\t      // [[link_name->target_passage]]\n\t\t      [/\\[\\[(.+)(\\||-\\&gt;)(.+)\\]\\]/g, '<tw-link data-passage=\"$3\">$1</tw-link>'],\n\t\t      // [[link_name<-target_passage]]\n\t\t      [/\\[\\[(.+)\\&lt;-(.+)?\\]\\]/g, '<tw-link data-passage=\"$1\">$2</tw-link>']\n\t\t    ];\n\n\t\t    let text = this.source;\n\n\t\t    rules.forEach(([rule, template]) => {\n\t\t      text = text.replaceAll(rule, template);\n\t\t    });\n\n\t\t    return text;\n\t\t  }\n\t\t}\n\n\t\tPassage_1 = Passage;\n\t\treturn Passage_1;\n\t}\n\n\tvar Utils_1;\n\tvar hasRequiredUtils;\n\n\tfunction requireUtils () {\n\t\tif (hasRequiredUtils) return Utils_1;\n\t\thasRequiredUtils = 1;\n\t\tclass Utils {\n\t\t    static generateElements(html) {\n\t\t        const template = document.createElement('template');\n\t\t        template.innerHTML = html.trim();\n\t\t        return template.content.children;\n\t\t    }\n\n\t\t    static addEventListener(eventName, eventHandler, selector) {\n\t\t        const wrappedHandler = (e) => {\n\t\t            if (!e.target) return;\n\t\t            const el = e.target.closest(selector);\n\t\t            if (el) {\n\t\t                eventHandler.call(el, e);\n\t\t            }\n\t\t        };\n\t\t        document.addEventListener(eventName, wrappedHandler);\n\t\t        return wrappedHandler;\n\t\t    }\n\t\t}\n\n\t\tUtils_1 = Utils;\n\t\treturn Utils_1;\n\t}\n\n\t/**\n\t * @external Element\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Element}\n\t */\n\n\tvar Story_1;\n\tvar hasRequiredStory;\n\n\tfunction requireStory () {\n\t\tif (hasRequiredStory) return Story_1;\n\t\thasRequiredStory = 1;\n\t\tconst Passage = requirePassage();\n\t\tconst Utils = requireUtils();\n\n\t\t/**\n\t\t * An object representing the entire story. After the document has completed\n\t\t * loading, an instance of this class will be available at `window.Story`.\n\t\t * @class Story\n\t\t */\n\t\tclass Story {\n\t\t  constructor () {\n\t\t    /**\n\t\t     * @property {string} name - The name of the story.\n\t\t     * @type {string}\n\t\t     * @readonly\n\t\t     */\n\t\t    this.name = document.querySelector('tw-storydata').getAttribute('name');\n\n\t\t    /**\n\t\t     * An array of all passages.\n\t\t     * @property {Array} passages - Passages array.\n\t\t     * @type {Array}\n\t\t     */\n\t\t    this.passages = [];\n\n\t\t    // For each child element of the `<tw-storydata>` element,\n\t\t    //  create a new Passage object based on its attributes.\n\t\t    document.querySelector('tw-storydata').querySelectorAll('tw-passagedata').forEach((element) => {\n\t\t      const elementReference = element;\n\t\t      // Access any potential tags.\n\t\t      let tags = elementReference.getAttribute('tags');\n\n\t\t      // Does the 'tags' attribute exist?\n\t\t      if (tags !== '' && tags !== undefined) {\n\t\t        // Attempt to split by space.\n\t\t        tags = tags.split(' ');\n\t\t      } else {\n\t\t        // It did not exist, so we create it as an empty array.\n\t\t        tags = [];\n\t\t      }\n\n\t\t      // Push the new passage.\n\t\t      this.passages.push(new Passage(\n\t\t        elementReference.getAttribute('name'),\n\t\t        tags,\n\t\t        elementReference.innerHTML,\n\t\t      ));\n\t\t    });\n\n\t\t    /**\n\t\t     * Passage element.\n\t\t     * @property {Element} passageElement Passage element.\n\t\t     * @type {Element}\n\t\t     */\n\t\t    this.passageElement = document.querySelector('tw-passage');\n\n\t\t    /**\n\t\t     * The current passage.\n\t\t     * @property {Passage|null} currentPassage Currently showing passage, if any.\n\t\t     * @type {Passage|null}\n\t\t     */\n\t\t    this.currentPassage = null;\n\n\t\t  }\n\t\t  // end constructor.\n\n\t\t  /**\n\t\t   * Begins playing this story based on data from tw-storydata.\n\t\t   * 1. Apply all user styles\n\t\t   * 2. Run all user scripts\n\t\t   * 3. Find starting passage\n\t\t   // Excised //* 4. Add to starting passage to History.history\n\t\t   * 5. Show starting passage\n\t\t   // Excised // * 6. Trigger 'start' event\n\t\t   * @function start\n\t\t   */\n\t\t  start () {\n\n\t\t    // For each Twine style, add them to the body as extra style elements.\n\t\t    /*\n\t\t    document.querySelectorAll('*[type=\"text/twine-css\"]').forEach((element) => {\n\t\t      const twineStyleElement = element;\n\t\t      // Append a new `<style>` with text from old.\n\t\t      document.body.append(\n\t\t        Utils.generateElements(`<style>${twineStyleElement.textContent}</style>`));\n\t\t    });\n\t\t    */\n\n\t\t    /**\n\t\t     * Note: Browsers prevent error catching from scripts\n\t\t     *  added after the initial loading.\n\t\t     *\n\t\t     * window.onerror will have error, but it cannot\n\t\t     *  be caught.\n\t\t     */\n\t\t    /*\n\t\t    document.querySelectorAll('*[type=\"text/twine-javascript\"]').forEach((element) => {\n\t\t      // Convert Element into jQuery Element.\n\t\t      const twineScriptElement = element;\n\t\t      // Create a new `<script>`.\n\t\t      const newScriptElement = Utils.generateElements(\"<script>\");\n\t\t      // Set the text of new from old.\n\t\t      newScriptElement.textContent = twineScriptElement.textContent;\n\t\t      // Append the new `<script>` with text to document body.\n\t\t      document.body.append(newScriptElement);\n\t\t    });\n\t\t    */\n\n\t\t    // Get the startnode value (which is a number).\n\t\t    const startingPassageID = parseInt(document.querySelector('tw-storydata').getAttribute('startnode'));\n\t\t    // Use the PID to find the name of the starting passage based on elements.\n\t\t    const startPassageName = document.querySelector(`[pid=\"${startingPassageID}\"]`).getAttribute('name');\n\t\t    // Search for the starting passage.\n\t\t    const passage = this.getPassageByName(startPassageName);\n\n\t\t    // Does the starting passage exist?\n\t\t    if (passage === null) {\n\t\t      // It does not exist.\n\t\t      // Throw an error.\n\t\t      throw new Error('Starting passage does not exist!');\n\t\t    }\n\n\t\t    // Set the global passage to the one about to be shown.\n\t\t    this.currentPassage = passage;\n\n\t\t    // Overwrite current tags\n\t\t    this.passageElement.setAttribute('tags', passage.tags);\n\n\t\t    // Get passage source.\n\t\t    const passageSource = this.include(passage.name);\n\n\t\t    // Overwrite the parsed with the rendered.\n\t\t    this.passageElement.innerHTML = passageSource;\n\n\t\t    // Listen for any reader clicking on `<tw-link>`.\n\t\t    Utils.addEventListener(\n\t\t        'click', \n\t\t        (event) => { \n\t\t          // Retrieve data-passage value.  \n\t\t          const passageName = event.target.getAttribute('data-passage');\n\t\t          // Show the passage by name.\n\t\t          this.show(passageName); \n\t\t        },\n\t\t        'tw-link[data-passage]'\n\t\t      );\n\t\t  }\n\n\t\t  /**\n\t\t   * Returns an array of none, one, or many passages matching a specific tag.\n\t\t   * @function getPassagesByTag\n\t\t   * @param {string} tag - Tag to search for.\n\t\t   * @returns {Array} Array containing none, one, or many passage objects.\n\t\t   */\n\t\t  getPassagesByTag (tag) {\n\t\t    // Search internal passages\n\t\t    return this.passages.filter((p) => {\n\t\t      return p.tags.includes(tag);\n\t\t    });\n\t\t  }\n\n\t\t  /**\n\t\t   * Returns a Passage object by name from internal collection. If none exists, returns null.\n\t\t   * The Twine editor prevents multiple passages from having the same name, so\n\t\t   * this always returns the first search result.\n\t\t   * @function getPassageByName\n\t\t   * @param {string} name - name of the passage\n\t\t   * @returns {Passage|null} Passage object or null\n\t\t   */\n\t\t  getPassageByName (name) {\n\t\t    // Create default value\n\t\t    let passage = null;\n\n\t\t    // Search for any passages with the name\n\t\t    const result = this.passages.filter((p) => p.name === name);\n\n\t\t    // Were any found?\n\t\t    if (result.length !== 0) {\n\t\t      // Grab the first result.\n\t\t      passage = result[0];\n\t\t    }\n\n\t\t    // Return either null or first result found.\n\t\t    return passage;\n\t\t  }\n\n\t\t  /**\n\t\t   * Replaces current passage shown to reader with rendered source of named passage.\n\t\t   * If the named passage does not exist, an error is thrown.\n\t\t   * @function show\n\t\t   * @param {string} name name of the passage.\n\t\t   */\n\t\t  show (name) {\n\t\t    // Look for passage by name.\n\t\t    const passage = this.getPassageByName(name);\n\n\t\t    // passage will be null if it was not found.\n\t\t    if (passage === null) {\n\t\t      // Passage was not found.\n\t\t      // Throw error.\n\t\t      throw new Error(`There is no passage with the name ${name}`);\n\t\t    }\n\n\t\t    // Set currentPassage to the one about to be shown.\n\t\t    this.currentPassage = passage;\n\n\t\t    // Overwrite current tags.\n\t\t    this.passageElement.getAttribute('tags', passage.tags);\n\n\t\t    // Get passage source by name.\n\t\t    const passageSource = this.include(passage.name);\n\n\t\t    // Overwrite any existing HTML.\n\t\t    this.passageElement.innerHTML = passageSource;\n\n\t\t    // Listen for any reader clicking on `<tw-link>`.\n\t\t    Utils.addEventListener(      \n\t\t      'click', \n\t\t      (event) => {\n\t\t        // Retrieve data-passage value.\n\t\t        const passageName = event.target.getAttribute('data-passage');\n\t\t        // Show the passage by name.\n\t\t        this.show(passageName); \n\t\t      },\n\t\t      'tw-link[data-passage]', \n\t\t    );\n\t\t  }\n\n\t\t  /**\n\t\t   * Returns the rendered source of a passage by name.\n\t\t   * @function include\n\t\t   * @param {string} name - name of the passage.\n\t\t   * @returns {string} Rendered passage source.\n\t\t   */\n\t\t  include (name) {\n\t\t    // Search for passage by name.\n\t\t    const passage = this.getPassageByName(name);\n\n\t\t    // Does this passage exist?\n\t\t    if (passage === null) {\n\t\t      // It does not exist.\n\t\t      // Throw error.\n\t\t      throw new Error('There is no passage with name ' + name);\n\t\t    }\n\n\t\t    // Get passage source.\n\t\t    let passageSource = passage.renderLinks();\n\n\t\t    // Return the passage source.\n\t\t    return passageSource;\n\t\t  }\n\n\t\t  /**\n\t\t   * Render a passage to any/all element(s) matching query selector\n\t\t   * @function renderPassageToSelector\n\t\t   * @param {object} passageName - The passage to render\n\t\t   * @param {string} selector - jQuery selector\n\t\t   */\n\t\t  renderPassageToSelector (passageName, selector) {\n\t\t    // Get passage source\n\t\t    const passageSource = this.include(passageName);\n\n\t\t    // Replace the HTML of the selector (if valid).\n\t\t    document.query(selector).innerHTML = passageSource;\n\t\t  }\n\n\t\t  /**\n\t\t   * Add a new passage to the story.\n\t\t   * @function addPassage\n\t\t   * @param {string} name name\n\t\t   * @param {Array} tags tags\n\t\t   * @param {string} source source\n\t\t   */\n\t\t  addPassage (name = '', tags = [], source = '') {\n\t\t    // Look for name.\n\t\t    const nameSearch = this.getPassageByName(name);\n\n\t\t    // Confirm name does not already exist.\n\t\t    if (nameSearch !== null) {\n\t\t      throw new Error('Cannot add two passages with the same name!');\n\t\t    }\n\n\t\t    // Confirm tags is an array.\n\t\t    if (!Array.isArray(tags)) {\n\t\t      // Ignore and set to empty array.\n\t\t      tags = [];\n\t\t    }\n\n\t\t    // Confirm if source is string.\n\t\t    if (Object.prototype.toString.call(source) !== '[object String]') {\n\t\t      // Ignore and set to empty string.\n\t\t      source = '';\n\t\t    }\n\n\t\t    // Add to the existing passages.\n\t\t    this.passages.push(new Passage(\n\t\t      name,\n\t\t      tags,\n\t\t      source,\n\t\t    ));\n\t\t  }\n\n\t\t  /**\n\t\t   * Remove a passage from the story internal collection.\n\t\t   * Removing a passage and then attempting to visit the passage will\n\t\t   * throw an error.\n\t\t   *\n\t\t   * Note: Does not affect HTML elements.\n\t\t   * @function removePassage\n\t\t   * @param {string} name name\n\t\t   */\n\t\t  removePassage (name = '') {\n\t\t    this.passages = this.passages.filter(passage => {\n\t\t      return passage.name !== name;\n\t\t    });\n\t\t  }\n\n\t\t  /**\n\t\t   * Go to an existing passage in the story. Unlike `Story.show()`, this will add to the history.\n\t\t   *\n\t\t   * Throws error if passage does not exist.\n\t\t   * @function goto\n\t\t   * @param {string} name name of passage\n\t\t   */\n\t\t  goto (name = '') {\n\t\t    // Look for passage.\n\t\t    const passage = this.getPassageByName(name);\n\n\t\t    // Does passage exist?\n\t\t    if (passage === null) {\n\t\t      // Throw error.\n\t\t      throw new Error(`There is no passage with the name ${name}`);\n\t\t    }\n\n\t\t    // Show the passage by name.\n\t\t    this.show(name);\n\t\t  }\n\t\t}\n\n\t\tStory_1 = Story;\n\t\treturn Story_1;\n\t}\n\n\tvar hasRequiredMain;\n\n\tfunction requireMain () {\n\t\tif (hasRequiredMain) return main$1;\n\t\thasRequiredMain = 1;\n\t\t// Require Story.\n\t\tconst Story = requireStory();\n\t\t// Create new Story instance.\n\t\twindow.Story = new Story();\n\t\t// Create global store shortcut.\n\t\twindow.s = window.Story.store;\n\t\t// Start story.\n\t\twindow.Story.start();\n\t\treturn main$1;\n\t}\n\n\tvar mainExports = requireMain();\n\tvar main = /*@__PURE__*/getDefaultExportFromCjs(mainExports);\n\n\treturn main;\n\n}));\n       </script>\n    \n</body></html>"});